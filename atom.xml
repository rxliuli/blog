<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rxliuli blog</title>
  
  
  <link href="https://blog.rxliuli.com/atom.xml" rel="self"/>
  
  <link href="https://blog.rxliuli.com/"/>
  <updated>2022-11-04T16:00:11.468Z</updated>
  <id>https://blog.rxliuli.com/</id>
  
  <author>
    <name>rxliuli</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mami 一个跨工具文档转换器</title>
    <link href="https://blog.rxliuli.com/p/a657a02fccca4f788fb864f2ec8ebfa0/"/>
    <id>https://blog.rxliuli.com/p/a657a02fccca4f788fb864f2ec8ebfa0/</id>
    <published>2022-10-11T15:51:55.884Z</published>
    <updated>2022-11-04T16:00:11.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在写的一个工具，用以连接不同的工具，使它们的数据能够相互转换，主要用例是多平台发布和跨应用迁移，例如从 joplin/obsidian 笔记中选择一部分通过 hexo/hugo 渲染为 blog 共享给别人，事实上，现在你看到这个 blog 就是这样生成出来的。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>mami 是一个转换工具，可以连接不同的基于 markdown 框架和工具，能将一种工具的数据转换到另一种工具，这对于跨应用迁移以及多平台发布很有帮助，目前已已知 <code>joplin/obsidian/hexo/hugo/raw</code>，计划将支持 <code>docsify/vuepress</code>。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>前置条件</p><ul><li>你需要安装 <a href="https://nodejs.org/en/download/">nodejs 18</a></li></ul></blockquote><h3 id="步骤-1：创建新项目"><a href="#步骤-1：创建新项目" class="headerlink" title="步骤 1：创建新项目"></a>步骤 1：创建新项目</h3><blockquote><p>下面使用 pnpm 作为包管理器，但你可以替换它为 npm</p></blockquote><p>创建新目录并进入</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir mami-starter &amp;&amp; cd mami-starter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>然后使用喜欢的包管理器初始化</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pnpm init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="步骤-2：安装-mami"><a href="#步骤-2：安装-mami" class="headerlink" title="步骤 2：安装 mami"></a>步骤 2：安装 mami</h3><p>添加 @mami/cli 和 typescript 作为项目的开发依赖项</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pnpm i -D @mami/cli typescript<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>添加一些脚本到 <code>package.json</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">{  ...  "scripts": {    "gen": "mami"  },  ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>创建你的配置文件 <code>mami.config.ts</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { defineConfig } from '@mami/cli'export default defineConfig({  input: [],  output: [],})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>然后运行</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pnpm run gen&gt; joplin2obsidian-demo@1.0.0 gen&gt; mamistartend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>嗯，什么也没有发生，因为你没有定义输入或输出插件。继续看下一步。</p><h3 id="步骤-3：安装需要的插件"><a href="#步骤-3：安装需要的插件" class="headerlink" title="步骤 3：安装需要的插件"></a>步骤 3：安装需要的插件</h3><p>安装需要的插件，用来连接需要的工具，这里使用 joplin =&gt; obsidian 来举例</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">pnpm i -D @mami/plugin-joplin @mami/plugin-obsidian<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>修改你的配置文件 <code>mami.config.ts</code></p><blockquote><p>这里的 joplin 插件需要的 token 来自 <a href="https://joplinapp.org/clipper/#troubleshooting-the-web-clipper-service">web clipper service</a></p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { defineConfig } from '@mami/cli'import * as joplin from '@mami/plugin-joplin'import * as obsidian from '@mami/plugin-obsidian'import path from 'path'export default defineConfig({  input: [    joplin.input({      baseUrl: 'http://127.0.0.1:41184',      token:        '5bcfa49330788dd68efea27a0a133d2df24df68c3fd78731eaa9914ef34811a34a782233025ed8a651677ec303de6a04e54b57a27d48898ff043fd812d8e0b31',      tag: '',    }),  ],  output: [    obsidian.output({      root: path.resolve(__dirname, 'dist'),    }),  ],})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="步骤-4：执行转换"><a href="#步骤-4：执行转换" class="headerlink" title="步骤 4：执行转换"></a>步骤 4：执行转换</h3><p>然后，你可以重新运行以下命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pnpm run gen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>现在，你将能在 dist 中看到转换的 obsidian 文件</p><blockquote><p><a href="https://github.com/rxliuli/mami/tree/master/demos/joplin2obsidian-demo">示例</a></p></blockquote><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><blockquote><p><a href="https://paka.dev/npm/@mami/cli@latest/api">API 文档</a></p></blockquote><p>大致上，插件分为输入和输出插件，输入插件会返回一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncGenerator">AsyncGenerator</a>，而输出插件则会则 <code>handle hook</code> 函数中消费它。</p><p><img src="/resources/3a914293ca6f46f79d0cac4b57046533.svg" alt="design.drawio.svg"></p><p>中间格式</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">{  "id": "0e2510c9272449dbafe3e0f3fba12d74",  "title": "Welcome to Joplin!",  "content": "content body",  "createAt": 1666288266591,  "updateAt": 1666288266591,  "path": ["Welcome! (Desktop)"],  "tags": [    {      "id": "04dfa5cf19e4435f9f3f09a73a7edfb2",      "title": "blog"    }  ],  "resources": [    {      "id": "63b83e548b7b4adfae18544b7038b0bc",      "title": "AllClients.png",      "raw": "&lt;nodejs buffer&gt;"    }  ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>编写插件涉及到一些 markdown ast 操作，例如你可能需要转换 markdown 中的链接，建议使用 <a href="https://github.com/syntax-tree/mdast">mdast</a> 来处理。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><blockquote><p>如果你不知道 joplin-blog 是什么，那我简要介绍一下：它是一个将 joplin 笔记转换为其他形式的内容的 cli 工具，支持了 hexo、vuepress、docsify、jeykll 这些 blog/wiki 框架。ref: <a href="https://discourse.joplinapp.org/t/joplin-note-sharing-tool/13480">https://discourse.joplinapp.org/t/joplin-note-sharing-tool/13480</a></p></blockquote><p>为什么开始了这次重写？</p><p>主要原因是目前支持了一些框架，但实际上仍然不够，就吾辈而言，目前接触到了 vitepress 文档生成器，吾辈打算用它替代 vuepress，但这需要对 joplin-blog 做一些修改，实际上这并不太方便。之前也有人提到如何更有定制性的生成文件，例如在生成的 markdown 添加额外的 yaml meta 信息（ref: <a href="https://github.com/rxliuli/joplin-utils/issues/55">https://github.com/rxliuli/joplin-utils/issues/55</a>），这实际上在没有扩展点的情况下有点麻烦，那时给出的临时解决方案是以 lib 的形式使用 joplin-blog，并插入自定义的一些逻辑来完成。也有人提到了支持 hugo，但全部在 joplin-blog 中实现是不显示的。</p><p>后来，吾辈意识到支持生成任意框架的文件需要插件系统，进一步而言，吾辈甚至可以将输入源（例如 joplin）也作为插件，就像 pandoc 一样，连接不同的笔记、博客和 wiki 工具。目前做的一个尝试就是 mami，打算通过 markdown 作为中间格式进行转换。<br>目前这个项目才刚刚创建，并且仅支持 joplin 作为输入源、hexo/hugo/obsidian 作为输出源，但吾辈已经在自己的 blog 中使用了，参考：<a href="https://github.com/rxliuli/blog/blob/master/mami.config.ts">https://github.com/rxliuli/blog/blob/master/mami.config.ts</a></p><blockquote><p>PS：mami 这个名字的来源是 Puella Magi Madoka Magica 中的 <a href="https://en.wikipedia.org/wiki/Mami_Tomoe">Mami Tomoe</a>，她的魔法是<strong>缎带</strong>，可以连接各种不同的事物，甚至能组成火枪（笑）。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="开源" scheme="https://blog.rxliuli.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>vite-不仅仅是一个构建工具</title>
    <link href="https://blog.rxliuli.com/p/0987a1de82694970851755d02920bc6e/"/>
    <id>https://blog.rxliuli.com/p/0987a1de82694970851755d02920bc6e/</id>
    <published>2022-10-09T01:02:30.296Z</published>
    <updated>2022-10-13T04:34:11.390Z</updated>
    
    <content type="html"><![CDATA[<p>自 vite 发布第一个版本（2020-04）以来，已经过去了两年，最近它发布了 3.0，不过没有太多 break change 的变化。或许有人已经在使用它了，但也有许多人看到是 vue 作者创建的工具就绕道走过去，因为 vue 生态里的工具历来是 vue 锁定，无法在其他生态中使用，像是 vuex/pinia 之类的，而 redux/mobx 却可以在 vue 中使用。尽管 vite 1.0 默认仅支持 vue，但在 2.0 中改变了一切，默认不再支持任何框架（好吧，由于 esbuild 的原因，其实是默认支持 react 的），而是通过插件完成对框架的支持。</p><p>目前已默认支持的 ui 框架</p><ul><li>vanilla</li><li>vue</li><li>react</li><li>preact</li><li>lit</li><li>svelte</li></ul><p>一些非官方的支持</p><ul><li>solid.js</li><li>qwik</li></ul><h2 id="依赖于-vite-的有名工具"><a href="#依赖于-vite-的有名工具" class="headerlink" title="依赖于 vite 的有名工具"></a>依赖于 vite 的有名工具</h2><ul><li><a href="https://vitest.dev/">vitest</a>: 一个单元测试工具，它很快，默认支持 esm，兼容 jest api，可以被视为更好的 jest</li><li><a href="https://github.com/vuejs/vitepress">vitepress</a>: 一个非常快的文档生成器，在文档数量非常大的情况下（例如 1k+），与其他工具会有数量级的性能差距</li><li><a href="https://github.com/tauri-apps">tauri</a>: 一个跨端应用开发工具</li><li><a href="https://astro.build/">astro</a>: 基于 vite 的构建工具</li></ul><p>事实上，目前 npm 中统计有 1k+ 的包直接依赖于 vite，参考：<a href="https://www.npmjs.com/package/vite?activeTab=dependents">https://www.npmjs.com/package/vite?activeTab=dependents</a></p><h2 id="vitest"><a href="#vitest" class="headerlink" title="vitest"></a>vitest</h2><p>在默认情况下，它支持以下吾辈关注的功能</p><ul><li>很快</li><li>支持 esm</li><li>支持 ts</li><li>兼容 jest api</li><li>支持 vite 的功能</li><li>支持多框架 react/vue</li></ul><p>目前，吾辈主要维护的几个社区 monorepo 项目都已经迁移到了 esm，测试工具全部由 jest =&gt; vitest，毕竟它真的太好用了。</p><blockquote><p>ref: <a href="https://vitest.dev/">https://vitest.dev/</a></p></blockquote><h2 id="vitepress"><a href="#vitepress" class="headerlink" title="vitepress"></a>vitepress</h2><p>性能</p><table><thead><tr><th>类型</th><th>vitepress</th><th>vuepress</th><th>docusaurus</th></tr></thead><tbody><tr><td>real</td><td>0m9.861s</td><td>0m18.649s</td><td>0m42.794s</td></tr><tr><td>user</td><td>0m0.015s</td><td>0m0.076s</td><td>0m0.077s</td></tr><tr><td>sys</td><td>0m0.151s</td><td>0m0.091s</td><td>0m0.106s</td></tr></tbody></table><p>站点基本信息</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cloc books/      83 text files.      83 unique files.      15 files ignored.github.com/AlDanial/cloc v 1.94  T=0.52 s (158.4 files/s, 112091.4 lines/s)-----------------------------------------------------Language   files      blank      comment         code-----------------------------------------------------Markdown      83      29090            0        29645-----------------------------------------------------SUM:          83      29090            0        29645-----------------------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>字数</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ find books/ -name '*.md' | xargs wc -m | tail -l5071073 total<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>在文档数量上升之后，vitepress 和其他生成器之间似乎有数量级的性能差异。在下面这个例子中，1000 个 md 文档的构建时间大约是 20 倍的差异</p><p>ref: <a href="https://github.com/vuepress/vuepress-next/issues/994">https://github.com/vuepress/vuepress-next/issues/994</a></p><p>在更大型的文档项目上实际测试</p><table><thead><tr><th>框架</th><th>时间</th></tr></thead><tbody><tr><td>vitepress</td><td>1m56.019s</td></tr><tr><td>vuepress</td><td>14m18.764s</td></tr><tr><td>docusaurus</td><td>36m39.857s</td></tr></tbody></table><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cloc docs/     914 text files.     914 unique files.       0 files ignored.github.com/AlDanial/cloc v 1.94  T=2.60 s (351.5 files/s, 319491.6 lines/s)-------------------------------------------------------------------------------Language                     files          blank        comment           code-------------------------------------------------------------------------------Markdown                       914         371604              0         459249-------------------------------------------------------------------------------SUM:                           914         371604              0         459249-------------------------------------------------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这 nodejs，真香！<br><img src="/resources/a83fcba3cb9b4e89979fa9c51cae86ab.png" alt="1665283372624.png"></p><blockquote><p>ref: <a href="https://vitepress.vuejs.org/">https://vitepress.vuejs.org/</a></p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>vite 的前身 snowpack 虽然已经死了，但它留下的遗产却被 vite 发扬光大，并且在扩展成为更大的社区，成为前端开发工具链的基础设施。</p><blockquote><p>ps1: 实际上，工作的生产项目已经全面使用 vite，虽然也遇到了一些边缘问题，例如 dev 过慢、build 超出内存限制之类的问题，但总体上仍然是目前 DX 最好的 web 构建工具。<br>ps2: 有趣的是，之前的前端工具分散而零碎，例如 webpack 负责 bundle、typescript/babel 负责转译、各种 loader 处理自定义的资源，一通配置与调试之后，你才可能将项目运行起来。更别说多个框架之间的配置和工具还往往不同，在跨框架共用方面实在糟糕。但 vite 却与之相反，默认支持所有常见功能，多框架只需要引入对应框架的插件即可，在需要时才需要深入研究插件和配置。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="工具" scheme="https://blog.rxliuli.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="vite" scheme="https://blog.rxliuli.com/tags/vite/"/>
    
  </entry>
  
  <entry>
    <title>闲谈网站的 Google 索引问题</title>
    <link href="https://blog.rxliuli.com/p/cb752f65aeee4661bf4f31fa7d2a2729/"/>
    <id>https://blog.rxliuli.com/p/cb752f65aeee4661bf4f31fa7d2a2729/</id>
    <published>2022-10-07T08:15:23.865Z</published>
    <updated>2022-10-07T08:55:06.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>从今年 2 月份以来，吾辈创建了一个 <a href="https://github.com/liuli-moe/to-the-stars">魔法少女小圆-飞向星空</a> 同人小说翻译的 GitHub 项目，并一直维护至今。最初，这个项目只是将目前几位作者的翻译打包为 epub 以便在手机和电子阅读器上阅读，同时避免国内网站删除、下架或不再维护网站而创建存档。后来，也使用工具从 markdown 中生成了网站。</p><blockquote><p>魔法少女小圆-飞向星空 的作品简介<br><img src="https://user-images.githubusercontent.com/24560368/156177284-33456fc7-53fc-4515-a4bd-48683ca88277.png" alt="cover"><br>在经历了几个世纪的动荡之后，一个乌托邦式的 AI— 人类政府治理着地球，预示着后稀缺社会的来临和太空殖民的新时代。一次意外的接触却让科技更先进的敌对外星种族打破了和平，这迫使魔法少女们走出幕后，拯救人类文明。在这一切之中，志筑良子，一个普通的女孩，仰望着星空，好奇着她在宇宙中的归所。</p><p>“丘比承诺说人类总有一天也能到达那遥远的星空。但它们很明智地没有说出来，人类将会在那里遇到什么。”—— 引言</p></blockquote><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>之前，该网站使用 vuepress 生成，因为它看起来相当友好和简单，吾辈之前也在其他地方使用过它。但最近吾辈尝试为网站<a href="https://github.com/liuli-moe/to-the-stars/issues/22">添加搜索功能</a>，在调研中了解到 <a href="https://www.google.com/cse/">Google Custom Search Engine</a>，但实际测试中发现无法搜索有效内容。进一步调查中发现了是 Google 未正确索引网站，所以导致无法正常搜索。</p><p><img src="https://user-images.githubusercontent.com/24560368/192085971-f23a5fcb-6741-4367-be43-5072c80e158f.png" alt="index"></p><p>吾辈也观察了 vuepress 生成的内容，它会在 dist/ 下生成 index.html 和 404.html，而在使用 github pages 部署后，如果访问一个不存在的路径，会被自动导航到 404.html，然后通过 vue-router 渲染具体的页面内容（本质上还是 spa 网站），这就导致了 Google 搜索报告问题 <a href="https://support.google.com/webmasters/answer/7440203#not_found_404">未找到 (404)</a>，而这似乎在 vuepress 中没人关注。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">├── 404.html├── assets├── CNAME├── index.html├── local-search.json├── logo.png├── logoDark.png└── sitemap.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>于是，不得已之下，吾辈尝试寻找了 vuepress 的替代品，最终使用了 <a href="https://docusaurus.io/">docusaurus</a>。它与 vuepress 的基本目标相同，只是使用了不同的技术栈，吾辈在 <a href="https://github.com/liuli-moe/to-the-stars/issues/23">issue feat: 考虑迁移至 docusaurus</a> 中说明了它们的一些差异，但最关键的还是它生成的 bundle 中指向了实际的 .html 文件，这让 Google 索引很开心。</p><p><img src="/resources/c1231e694b074c4f84bf02c89193cd9d.png" alt="1665132275042.png"></p><p>同时，吾辈也将 sitemap 提交到了 bing，这让国内用户也可以搜索了。</p><p><img src="https://user-images.githubusercontent.com/24560368/194464064-c1097f9e-3ab4-4fd8-b660-7d2db1928a38.jpg" alt="google"><br><img src="https://user-images.githubusercontent.com/24560368/194463665-57c4e566-9712-4737-9596-df22705b258a.jpg" alt="bing"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>只是现有的搜索引擎都有一个问题，对于大量没有使用标题分割的内容效果并不好。例如小说网站，大量的内容是以 <code>&lt;p&gt;&lt;/p&gt;</code> 标签分割。这确实是一个烦人的问题，不过还是留到下一次再解决吧。</p><blockquote><p>其实在 vuepress 中尝试解决过，ref: <a href="https://github.com/liuli-moe/to-the-stars/issues/22#issuecomment-1253240061">https://github.com/liuli-moe/to-the-stars/issues/22#issuecomment-1253240061</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="开源" scheme="https://blog.rxliuli.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>代码生成-从环境变量生成类型定义</title>
    <link href="https://blog.rxliuli.com/p/d867b35e62454483ae697185d93617ab/"/>
    <id>https://blog.rxliuli.com/p/d867b35e62454483ae697185d93617ab/</id>
    <published>2022-09-29T12:18:51.145Z</published>
    <updated>2022-10-09T00:56:48.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>既之前的 <a href="/p/b8e8ce8bccff49d191480a40a18a7fc8">代码生成-从 module css 生成 dts</a> 之后，这篇来实现从环境变量生成接口，便于开发时能够有正确的类型提示。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>在前端日常开发中，环境变量经常用于区分不同环境的配置，最常见的像是服务端地址。但在使用时，往往不能得到提示，或是一个环境变量没有。</p><p>我们通常使用以下两种方式访问环境变量</p><p>在 vite 中使用 <code>import.meta.env</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import.meta.env.NODE_ENV<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>在 vite importMeta.d.ts 中的类型定义为</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface ImportMeta {  // 其他属性。。。  readonly env: ImportMetaEnv}interface ImportMetaEnv {  [key: string]: any  BASE_URL: string  MODE: string  DEV: boolean  PROD: boolean  SSR: boolean}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>或者在普通 nodejs 项目中使用 <code>process.env</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">process.env.NODE_ENV<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>在 nodejs process.d.ts 中的类型定义为</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Dict&lt;T&gt; {  [key: string]: T | undefined}interface ProcessEnv extends Dict&lt;string&gt; {  /**   * Can be used to change the default timezone at runtime   */  TZ?: string}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>但无论如何，它们都不能定义一些项目中定制的环境变量，这需要我们手动完成。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>这里使用 vite 举例，如果需要在代码中使用 <code>import.meta.env</code> 时能够提示自定义的环境变量的话，需要在 <em>vite-env.d.ts</em> 中添加 <code>ImportMetaEnv</code>。<br>例如添加环境变量 VITE_PORT/VITE_AUTH_TOKEN 的类型定义</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface ImportMetaEnv {  VITE_PORT?: string  VITE_AUTH_TOKEN?: string}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>现在，使用环境变量的流程变成：<strong>在 .env 中添加环境变量</strong> =&gt; <strong>在 vite-env.d.ts 中添加类型定义</strong> =&gt; <strong>在代码中使用环境变量</strong>，可以看到，我们基本上重复添加了两次环境变量，只是使用了不同的语法，这正是我们要解决的问题，从环境变量自动生成类型定义。</p><p><img src="/resources/3f4cd03fa7564d6a99abab7d2c11d826.svg" alt="从环境变量生成类型定义.drawio.svg"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>获取环境变量的路径（vite 的环境变量类型定义文件发生过一次变化，需要做下兼容）</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">async function getEnvPath(cwd: string) {  let envPath = path.resolve(cwd, 'src/vite-env.d.ts')  if (await pathExists(envPath)) {    return envPath  }  envPath = path.resolve(cwd, 'src/env.d.ts')  if (await pathExists(envPath)) {    return envPath  }  throw new Error('未找到环境变量配置文件')}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>扫描所有的环境变量</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export async function scan(dir: string): Promise&lt;string[]&gt; {  const files = await FastGlob('.env*', {    cwd: path.resolve(dir),  })  const configs = await Promise.all(    files.map((file) =&gt; readFile(path.resolve(dir, file), 'utf-8')),  )  return uniqueBy(configs.map((s) =&gt; Object.keys(parse(s))).flat())}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>对比环境变量与类型定义</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function eq(a: string[], b: string[]): boolean {  const f = (a: string, b: string) =&gt; a.localeCompare(b)  return JSON.stringify([...a].sort(f)) === JSON.stringify([...b].sort(f))}export function getEnvs(ast: n.ASTNode): string[] {  return CodeUtil.iterator(ast, n.TSInterfaceDeclaration)    .filter((item) =&gt; (item.id as n.Identifier).name === 'ImportMetaEnv')    .flatMap((ast) =&gt; CodeUtil.iterator(ast, n.TSPropertySignature))    .flatMap((ast) =&gt; CodeUtil.iterator(ast, n.Identifier))    .map((item) =&gt; item.name)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>修改类型定义</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function convert(ast: n.ASTNode, envs: string[]): n.ASTNode {  let envInterface = CodeUtil.iterator(ast, n.TSInterfaceDeclaration).find(    (item) =&gt; (item.id as n.Identifier).name === 'ImportMetaEnv',  )  if (!envInterface) {    envInterface = b.tsInterfaceDeclaration(      b.identifier('ImportMetaEnv'),      b.tsInterfaceBody([]),    )    ;(ast as n.File).program.body.push(envInterface)  }  envInterface.body.body = envs.map((name) =&gt;    b.tsPropertySignature.from({      key: b.identifier(name),      typeAnnotation: b.tsTypeAnnotation(b.tsStringKeyword()),      readonly: true,    }),  )  return ast}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最后，将它们连接起来</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export async function gen(cwd: string): Promise&lt;void&gt; {  const envPath = await getEnvPath(cwd)  const code = await readFile(envPath, 'utf-8')  const ast = CodeUtil.parse(code)  const envNames = await scan(cwd)  if (eq(envNames, getEnvs(ast))) {    return  }  await writeFile(envPath, CodeUtil.print(convert(ast, envNames)))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>实现 vite 插件</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { Plugin } from 'vite'import { gen } from './gen'import * as path from 'path'export function envDtsGen(): Plugin {  let rootPath: string  return {    name: 'vite-plugin-env-dts-gen',    configResolved(resolveConfig) {      rootPath = resolveConfig.root    },    configureServer(server) {      server.watcher.add('.env*')      const listener = async (filePath: string) =&gt; {        const relative = path.relative(rootPath, filePath)        // console.log('filePath: ', relative)        if (relative.startsWith('.env')) {          await gen(rootPath)        }      }      server.watcher.on('change', listener)      server.watcher.on('add', listener)    },    async buildStart() {      await gen(rootPath)    },  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><blockquote><p>完整代码 ref: <a href="https://github.com/rxliuli/liuli-tools/blob/master/libs/vite-plugin-env-dts-gen">https://github.com/rxliuli/liuli-tools/blob/master/libs/vite-plugin-env-dts-gen</a></p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { defineConfig } from 'vite'import { envDtsGen } from '@liuli-util/vite-plugin-env-dts-gen'export default defineConfig({  plugins: [envDtsGen()],})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>现在，每当修改环境变量文件时，都会自动修改对应的类型定义，编写代码时也会有提示和校验了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>之后，将演示两个现有的代码生成的实例。</p><ul><li>从 graphql 生成代码</li><li>从 open api schema 生成类型定义</li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="typescript" scheme="https://blog.rxliuli.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>代码生成-从 module css 生成 dts</title>
    <link href="https://blog.rxliuli.com/p/b8e8ce8bccff49d191480a40a18a7fc8/"/>
    <id>https://blog.rxliuli.com/p/b8e8ce8bccff49d191480a40a18a7fc8/</id>
    <published>2022-09-28T14:30:47.951Z</published>
    <updated>2022-10-18T11:27:14.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代码生成对于很多开发者都不是陌生的概念，从使用脚手架（create-react-app）生成项目，到使用 ide 生成代码、或是从后端 api schema 生成代码，几乎不可能避免使用它。它可以解决各种各样的问题</p><ul><li>从同一个来源生成项目，避免千人千面的项目整体结构</li><li>减少编写样板代码</li><li>避免在多个地方重复编写代码导致的不一致性</li></ul><p>但在使用 TypeScript 时，它还可以做到一些其他有趣的事情，包括</p><ul><li>生成类型提高开发者体验，例如为 env、module css、i18n config 生成类型定义</li><li>支持原本不支持引入的文件，例如为 graphql 生成代码音变引入它</li></ul><p>或许有人会认为代码生成需要处理 ast（即抽象语法树），而处理 ast 是一件复杂的事情，因而不去尝试做类似的事情。吾辈要说的是，ast 的实际结构确实可能会很复杂，例如 TypeScript 官方解析器解析 ts 得到的那个，但其核心却相当简单，这个领域仅仅只是门槛稍微有点高。如果你选择了一个合适的语法树操作工具，再加上现有的各种 代码 &lt;=&gt; ast 可视化工具，那事情会变得简单许多。</p><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>想要生成代码，基本上就像将一只大象放进冰箱里面一样需要三步</p><ol><li>得到某种类型的元数据，例如从 css 得到它的 ast</li><li>转换元数据得到生成目标代码的 ast</li><li>将 ast 转换成代码</li></ol><p><img src="/resources/0a85923724f64322b272f96ba09f0982.svg" alt="代码生成步骤.drawio.svg"></p><p>正如标题所言，在这里主要的目标代码是 TypeScript，相应的，元数据的来源多种多样，从 json 数据、到其他语言的 ast、到远端的接口，这实际上没有什么限制，只要你能够将之转换为目标 ast 即可。</p><p>下面我们将来尝试第一个，也是最简单的一个，从 module css 文件生成类型定义</p><h2 id="从-css-生成类型定义"><a href="#从-css-生成类型定义" class="headerlink" title="从 css 生成类型定义"></a>从 css 生成类型定义</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>为什么要这样做？</p><p>在使用 css module 时，我们通常使用构建工具，例如 rollup/vite/webpack 来解析 *.module.css 文件，并使得最终 bundle 中的结果符合预期。但在开发阶段，它并没有太多提示，例如定义了一个 css class，但你在 ts 中使用时，并不会有什么提示。当你将一个 css class 删除后，也不会有任何代码提示。<br>例如下面这个示例</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* App.module.css */</span><span class="token selector">.hide</span> <span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">// App.tsximport { useReducer } from 'react'import css from './App.module.css'export function App() {  const [hide, toggle] = useReducer((s) =&gt; !s, false)  return (    &lt;div&gt;      &lt;button onClick={toggle}&gt;toggle&lt;/button&gt;      &lt;p className={hide ? css.hide : ''}&gt;test&lt;/p&gt;    &lt;/div&gt;  )}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如果我们在 App.module.css 旁边放一个 App.module.css.d.ts 文件，那么在 ts 中使用时就会很快乐</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const css: {  hide: string}export default css<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>当然，在 ide 中也可以完成这个功能，但每个 ide 都需要实现一遍这个功能，这正是问题所在，插件无法跨 ide 使用，但基于 TypeScript 的代码提示可以做到跨 ide 使用，包括 vscode、jetbrains ide、vim 等等。</p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>正如上面所言，想要生成代码，在这里需要得到 css ast 和转换 css ast 为 ts ast，而这就需要选择一个合适的解析器来解析 css 得到 ast 以及生成 ts ast 并转换为代码了。</p><p><img src="/resources/736d1e022d374f79be616675e6a616a6.svg" alt="从 css 生成接口基本流程.drawio.svg"></p><p>我们使用以下两个库</p><ul><li>css-tree: 解析 css 代码为 cssom</li><li>ast-types: 一个通用的 ts/js ast 高层次抽象</li><li>recast: 基于 ast-types 的一个 ast 解析生成器</li></ul><blockquote><p>Tip: 代码的 ast 可以在 <a href="https://astexplorer.net/">https://astexplorer.net/</a> 以可视化的方式检查<br><img src="/resources/bef3bb2bf40f43dd87c724d4cfc70bdc.png" alt="1664382002113.png"></p></blockquote><h3 id="解析-css"><a href="#解析-css" class="headerlink" title="解析 css"></a>解析 css</h3><p>首先，解析 css 得到 ast，并从中过滤出所有 class 选择器类名</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function parse(code: string): string[] {  const ast = csstree.parse(code)  const r: string[] = []  csstree.walk(ast, (node) =&gt; {    if (node.type === 'ClassSelector') {      r.push(node.name)    }  })  return r}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>然后将 css 类名列表转换为 ast</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function convert(classes: string[]): n.Program {  return b.program([    b.variableDeclaration('const', [      b.variableDeclarator(        b.identifier.from({          name: 'css',          typeAnnotation: b.tsTypeAnnotation(            b.tsTypeLiteral(              classes.map((s) =&gt;                b.tsPropertySignature(                  b.identifier(s),                  b.tsTypeAnnotation(b.tsStringKeyword()),                ),              ),            ),          ),        }),      ),    ]),    b.exportDefaultDeclaration(b.identifier('css')),  ])}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最后，将 ast 转换为 ts 代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function format(ast: n.ASTNode): string {  return prettyPrint(ast).code}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>结合一下 3 个方法</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function generate(cssCode: string): string {  const classes = parse(cssCode)  const ast = convert(classes)  return format(ast)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>做个最简单的测试</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">console.log(  generate(`/* App.module.css */.hide {  display: none;}`),)// 会得到以下代码// const css: {//     hide: string// };// export default css;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>看起来我们完成了基本的从 css 到 dts 的代码生成，但如果希望实用，它还需要一些额外的步骤</p><ol><li>更好的使用方式封装，例如封装为 cli 自动扫描指定目录下的所有 *.module.css 文件并生成对应的 dts 文件，或者是通过插件直接集成到开发工具的流程中，例如 vite 插件</li><li>发布为 npm 包，或者使用某种形式的 monorepo 便于在多个项目复用</li></ol><p>下面使用 vite 插件作为演示</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { defineConfig, Plugin, ResolvedConfig } from 'vite'import react from '@vitejs/plugin-react'import { globby } from 'globby'import path from 'path'import * as csstree from 'css-tree'import { namedTypes as n, builders as b } from 'ast-types'import { prettyPrint } from 'recast'import fsExtra from 'fs-extra'import { watch } from 'chokidar'// 上面的代码。。。const { pathExists, readFile, remove, writeFile } = fsExtrafunction cssdts(): Plugin {  let config: ResolvedConfig  async function generateByPath(item: string) {    const cssPath = path.resolve(config.root, item)    const code = await readFile(cssPath, 'utf-8')    await writeFile(cssPath + '.d.ts', generate(code))  }  return {    name: 'vite-plugin-cssdts',    configResolved(_config) {      config = _config    },    async buildStart() {      const list = await globby('src/**/*.module.css', {        cwd: config.root,      })      await Promise.all(        list.map(async (item) =&gt; {          const cssPath = path.resolve(config.root, item)          await generateByPath(cssPath)        }),      )    },    configureServer(server) {      watch('src/**/*.module.css', { cwd: config.root })        .on('add', generateByPath)        .on('change', generateByPath)        .on('unlink', async (cssPath) =&gt; {          if (cssPath.endsWith('.module.css')) {            const dtsPath = cssPath + '.d.ts'            if (await pathExists(dtsPath)) {              await remove(dtsPath)            }          }        })    },  }}export default defineConfig({  plugins: [react(), cssdts()],})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>现在，每当启动 vite 时都会自动扫描所有的 *.module.css 生成对应的类型定义，在开发模式下还会持续监听文件的变化。</p><p><img src="/resources/13cdf71f96e549c9bb21188dd051a81b.gif" alt="代码提示.gif"></p><h3 id="sourcemap"><a href="#sourcemap" class="headerlink" title="sourcemap"></a>sourcemap</h3><p>目前已经实现了代码提示和校验的功能，但跳转尚未生效，我们可以使用 source-map 来实现它。这是另一个有趣的技术，在之后将详细介绍，这里仅说明一下工作方式。sourcemap 将一个文件的内容与一或多个源文件的内容映射，chrome 或 vscode 均支持根据 sourcemap 自动查找对应的源文件，利用这个功能我们可以让生成的 dts 指向 css 文件。</p><p>效果</p><p><img src="/resources/07d7086ae24e496ca1dcd291668a36ac.gif" alt="跳转.gif"></p><p>完整代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { SourceMapGenerator, SourceNode } from 'source-map'import { defineConfig, Plugin, ResolvedConfig } from 'vite'import react from '@vitejs/plugin-react'import { globby } from 'globby'import path from 'path'import * as csstree from 'css-tree'import { namedTypes as n, builders as b } from 'ast-types'import * as recast from 'recast'import fsExtra from 'fs-extra'import { watch } from 'chokidar'import { keyBy } from 'lodash-es'import tsParser from 'recast/parsers/typescript.js'function parse(code: string): csstree.ClassSelector[] {  const ast = csstree.parse(code, { positions: true })  const r: csstree.ClassSelector[] = []  csstree.walk(ast, (node) =&gt; {    if (node.type === 'ClassSelector') {      r.push(node)    }  })  return r}function convert(classes: csstree.ClassSelector[]): n.Program {  const r = b.variableDeclaration('const', [    b.variableDeclarator(      b.identifier.from({        name: 'css',        typeAnnotation: b.tsTypeAnnotation(          b.tsTypeLiteral(            classes.map((s) =&gt;              b.tsPropertySignature(                b.identifier(s.name),                b.tsTypeAnnotation(b.tsStringKeyword()),              ),            ),          ),        ),      }),    ),  ])  ;(r as unknown as n.TSTypeAliasDeclaration).declare = true  return b.program([r, b.exportDefaultDeclaration(b.identifier('css'))])}function format(ast: n.ASTNode): string {  return recast.prettyPrint(ast).code}function sourcemap({  code,  classes,  source,  target,}: {  code: string  classes: csstree.ClassSelector[]  source: string  target: string}) {  const root = recast.parse(code, { parser: tsParser })  const cssSelectorsMap = keyBy(classes, (item) =&gt; item.name)  const map = new SourceMapGenerator({    file: target,  })  recast.visit(root, {    visitTSPropertySignature(path) {      const name = (path.node.key as n.Identifier).name      console.log((path.node.key as n.Identifier).name)      const css = cssSelectorsMap[name]      interface Pos {        line: number        column: number      }      function add(original: Pos, generated: Pos) {        map.addMapping({          source: source,          original: {            line: original.line,            column: original.column,          },          generated: {            line: generated.line,            column: generated.column,          },        })      }      add(css.loc!.start, path.node!.key.loc!.start)      add(css.loc!.end, path.node!.key.loc!.end)      return false    },  })  return map.toString()}export function generate(  cssCode: string,  source: string,  target: string,): string {  const classes = parse(cssCode)  const ast = convert(classes)  const code = format(ast)  const mapCode = sourcemap({ code, classes, source, target })  return (    code +    '\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,' +    btoa(mapCode)  )}const { pathExists, readFile, remove, writeFile } = fsExtrafunction cssdts(): Plugin {  let config: ResolvedConfig  async function generateByPath(item: string) {    const cssPath = path.resolve(config.root, item)    const code = await readFile(cssPath, 'utf-8')    const dtsPath = cssPath + '.d.ts'    await writeFile(dtsPath, generate(code, cssPath, dtsPath))  }  return {    name: 'vite-plugin-cssdts',    configResolved(_config) {      config = _config    },    async buildStart() {      const list = await globby('src/**/*.module.css', {        cwd: config.root,      })      await Promise.all(        list.map(async (item) =&gt; {          const cssPath = path.resolve(config.root, item)          await generateByPath(cssPath)        }),      )    },    configureServer(server) {      watch('src/**/*.module.css', { cwd: config.root })        .on('add', generateByPath)        .on('change', generateByPath)        .on('unlink', async (cssPath) =&gt; {          if (cssPath.endsWith('.module.css')) {            const dtsPath = cssPath + '.d.ts'            if (await pathExists(dtsPath)) {              await remove(dtsPath)            }          }        })    },  }}export default defineConfig({  plugins: [react(), cssdts()],  build: {    sourcemap: 'inline',    minify: false,  },})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在之后的几篇文章中，吾辈将演示代码生成的实际用途，并实现一些简单的例子，也会给出现有的更完善的的工具（如果有的话）。</p><ul><li><a href="/p/d867b35e62454483ae697185d93617ab">代码生成-从环境变量生成类型定义</a></li><li><a href="/p/7fc05ef7c1274b168504c216a6774ea6">代码生成-从 i18n config 生成类型定义</a></li><li>从 graphql 生成代码</li><li>从 open api schema 生成类型定义</li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="typescript" scheme="https://blog.rxliuli.com/tags/typescript/"/>
    
    <category term="vite" scheme="https://blog.rxliuli.com/tags/vite/"/>
    
    <category term="工程化" scheme="https://blog.rxliuli.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript ESM 很好，但它现在也许没那么好</title>
    <link href="https://blog.rxliuli.com/p/73331967c1814df480811eee598e714b/"/>
    <id>https://blog.rxliuli.com/p/73331967c1814df480811eee598e714b/</id>
    <published>2022-08-10T09:47:00.363Z</published>
    <updated>2022-10-01T17:47:14.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>可能许多前端开发者都知道，自从去年 sindresorhus 发表 <a href="https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c">esm only 的宣言</a> 一年多以来，许多项目开始转向了 esm only，即仅支持 esm 而不支持 cjs，以此来迫使整个生态更快的迁移到 esm only。</p><p>一些流行的项目已经这样做了</p><ul><li>sindresorhus 维护的上千个 npm 包</li><li>node-fetch</li><li>remark 系列</li><li>更多。。。</li></ul><p>它们声称：你可以仍然使用现有版本而不升级到最新版，大版本更新不会影响到你。事实如何？</p><p>吾辈之前碰到过几次无法使用 esm only 包的问题，每当吾辈想尝试 esm only 时，总是还有一些问题，最痛苦的是，一些包是 esm only，而另一些是 cjs only，总要选择放弃一边，fuck esm only。主要问题一些是 cjs only 的包，以及必须兼容的包 typescript/jest/ts-jest/wallaby 未能正确支持 esm。当然，吾辈可以选择寻找 esm only 包的替代品，例如 globby =&gt; fast-glob、remark =&gt; markdown-it、node-fetch =&gt; node-fetch@2，lodash-es =&gt; lodash，但这终究不是一个长久的选择，更何况有些包很难真正找到替代品，例如 remark 系列。</p><p>那么，使用旧版本的包有什么问题呢？<br>主要问题是很难找到正确的版本，当然，如果使用的是相对独立的包，例如 node-fetch 这个，就可以直接使用 v2 版本即可。但如果使用的是 vuepress/remark 这种 monorepo 中包含许多小型包的项目，你很难找到每个子项目正确的版本。</p><p>吾辈最近在做 epub 生成器的时候需要从 markdown 并操作 ast 做一些转换，最后转换为 html，因此再次使用 remark，也决定真正尝试使用 esm，下面是一些尝试的过程。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>使用 esm 必须解决以下几个问题，否则在生产环境中使用是不可能的</p><ul><li><input checked="" disabled="" type="checkbox"> typescript 支持 – 基本上全部的 web 项目都使用了 ts，不支持的话是不可接受的</li><li><input checked="" disabled="" type="checkbox"> jest 支持 – 同样大量使用的测试工具<ul><li><input checked="" disabled="" type="checkbox"> wallaby 支持 – 一个付费的所见即所得的测试工具</li></ul></li><li><input checked="" disabled="" type="checkbox"> 允许引用 cjs 模块 – 需要支持现有包</li><li><input checked="" disabled="" type="checkbox"> 双模块包仍然能支持两种 esm/cjs 的项目 – 需要支持 cjs 项目引用</li><li><input checked="" disabled="" type="checkbox"> 支持不打包的模块 – monorepo 中有些私有模块不会 bundle</li><li><input checked="" disabled="" type="checkbox"> esbuild 支持 – esbuild 正在成为 lib bundle 标准</li></ul><h2 id="修改-package-声明"><a href="#修改-package-声明" class="headerlink" title="修改 package 声明"></a>修改 package 声明</h2><p>第一步是修改包的模块类型，修改 <code>"type": "module"</code> 即可将包声明为 esm，所有 js 代码将默认以 esm 模块运行。</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">{  "type": "module"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="TypeScript-支持"><a href="#TypeScript-支持" class="headerlink" title="TypeScript 支持"></a>TypeScript 支持</h2><p>从 ts4.7 开始支持 NodeNext，所以需要更改 tsconfig.json</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">{  "compilerOptions": {    "module": "ESNext",    "moduleResolution": "NodeNext"  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>另外，在 ts 文件中导入其他 ts 文件必须使用 .js 后缀</p><p>这是一个奇怪的限制，参考 <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#type-in-packagejson-and-new-extensions">ts 4.7 发布文档</a></p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { helper } from './foo.js' // works in ESM &amp; CJShelper()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>看起来是否会很奇怪，但现在只能这样写，typescript 甚至会这样提示</p><h2 id="jest-x2F-wallaby-支持"><a href="#jest-x2F-wallaby-支持" class="headerlink" title="jest/wallaby 支持"></a>jest/wallaby 支持</h2><p>例如使用 <code>pnpm jest src/__tests__/lodash.test.ts</code> 命令运行以下代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { uniq } from 'lodash-es'it('uniq', () =&gt; {  console.log(uniq([1, 2, 1]))})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>出现错误</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Jest encountered an unexpected token<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>从 jest 28 开始支持实验性的 esm 支持，wallaby/ts-jest 也都可以通过配置支持，按照以下步骤即可处理</p><ol><li><p>配置 ts-jest</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">{  "jest": {    "preset": "ts-jest/presets/default-esm",    "globals": {      "ts-jest": {        "useESM": true      }    },    "moduleNameMapper": {      "^(\\.{1,2}/.*)\\.js$": "$1"    },    "testMatch": ["&lt;rootDir&gt;/src/**/__tests__/*.test.ts"]  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li><li><p>修改命令为 <code>node --experimental-vm-modules node_modules/jest/bin/jest.js src/__tests__/lodash.test.ts</code></p></li><li><p>配置 wallaby</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">{  "wallaby": {    "env": {      "params": {        "runner": "--experimental-vm-modules"      }    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li><li><p>由于 esm 的导入是静态的，所以还需要卸载 <code>@types/jest</code> 使用 <code>@jest/globals</code> 包导入测试需要的函数，例如 <code>it/expect/describe/beforeEach</code> 等等</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { it, expect } from '@jest/globals'it('basic', () =&gt; {  expect(1 + 2).toBe(3)})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li></ol><h2 id="nodejs-支持"><a href="#nodejs-支持" class="headerlink" title="nodejs 支持"></a>nodejs 支持</h2><p>nodejs 自从 14 就开始支持 esm，但直到目前 18 为止迁移仍然不是平滑的，主要遇到了以下问题。</p><h3 id="导入-cjs-only-模块"><a href="#导入-cjs-only-模块" class="headerlink" title="导入 cjs only 模块"></a>导入 cjs only 模块</h3><p>遗憾的是，现存的大量包都是 cjs only 模块的，不可能短时间迁移，而 nodejs 中 esm 与 cjs 的互操作性并不太好，所以需要处理一下。下面以 fs-extra 为例：</p><p>之前一般会这样写</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { readdir } from 'fs-extra'import path from 'path'console.log(await readdir(path.resolve()))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>使用 tsx 运行时会出现错误 <code>SyntaxError: The requested module 'fs-extra' does not provide an export named 'readdir'</code>，这似乎是一个已知错误，参考：<a href="https://github.com/esbuild-kit/tsx/issues/38">https://github.com/esbuild-kit/tsx/issues/38</a></p><p>现在需要修改为</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import fsExtra from 'fs-extra'import path from 'path'console.log(await fsExtra.readdir(path.resolve()))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>或者修改为以下代码使用 <code>ts-node --esm &lt;file&gt;</code> 运行（tsx 不支持这种方式）</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import fsExtra = require('fs-extra')import path from 'path'console.log(await fsExtra.readdir(path.resolve()))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="使用-dirname"><a href="#使用-dirname" class="headerlink" title="使用 __dirname"></a>使用 <code>__dirname</code></h3><p>是的，你没看错，在 esm 模块下 <code>__dirname</code> 不可用了，取而代之的是 <code>import.meta.url</code>，总而言之，现在的使用方式是</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import path from 'path'import { fileURLToPath } from 'url'const __filename = fileURLToPath(import.meta.url)const __dirname = path.dirname(__filename)console.log(__dirname)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>参考文章 <a href="https://flaviocopes.com/fix-dirname-not-defined-es-module-scope/">https://flaviocopes.com/fix-dirname-not-defined-es-module-scope/</a>，之后在谈到 esbuild 时再说打包 cjs bundle 如何处理 <code>import.meta.url</code>（在 cjs 中不支持，又是二选一）。</p><h2 id="lib-维护与使用"><a href="#lib-维护与使用" class="headerlink" title="lib 维护与使用"></a>lib 维护与使用</h2><h3 id="新的-esm-与-cjs-双包支持配置"><a href="#新的-esm-与-cjs-双包支持配置" class="headerlink" title="新的 esm 与 cjs 双包支持配置"></a>新的 esm 与 cjs 双包支持配置</h3><p>之前，我们通过 main/module 字段区分模块</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">{  "main": "dist/index.js",  "module": "dist/index.esm.js",  "types": "dist/index.d.ts"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>但在 esm 项目中引用会报错</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SyntaxError: The requested module 'cjs-and-esm-lib' does not provide an export named 'hello'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>esm 项目不认这个，它新定义了 exports 字段，所以需要增加（注意 main 字段仍需保留兼容旧版本 node）exports 字段</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">{  "exports": {    ".": {      "import": "./dist/index.esm.js",      "require": "./dist/index.js",      "types": "./dist/index.d.ts"    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>参考该回答：<a href="https://stackoverflow.com/a/70020984">https://stackoverflow.com/a/70020984</a></p><h2 id="esbuild-支持"><a href="#esbuild-支持" class="headerlink" title="esbuild 支持"></a>esbuild 支持</h2><p>原以为 esbuild 天生支持 esm 所以应该会很简单，但实际上也遇到了相当多的问题。</p><p>捆绑以下代码为 cjs 会出现错误</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import path from 'path'import { fileURLToPath } from 'url'import fsExtra from 'fs-extra'const { readdir } = fsExtraconst __filename = fileURLToPath(import.meta.url)const __dirname = path.dirname(__filename)console.log(__dirname)console.log(await readdir(__dirname))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">esbuild src/bin.ts --platform=node --outfile=dist/bin.esm.js --bundle --sourcemap --format=esmesbuild src/bin.ts --platform=node --outfile=dist/bin.js --bundle --sourcemap --format=cjs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>错误</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[ERROR] Top-level await is currently not supported with the "cjs" output format<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这里是因为 cjs 不能包含顶级 await，修改为</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import path from 'path'import { fileURLToPath } from 'url'import fsExtra from 'fs-extra'const { readdir } = fsExtra;(async () =&gt; {  const __filename = fileURLToPath(import.meta.url)  const __dirname = path.dirname(__filename)  console.log(__dirname)  console.log(await readdir(__dirname))})()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>捆绑没有问题，但运行会出错</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node dist/bin.js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>首先是第一个错误</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var import_path = __toESM(require("path"), 1);                  ^ReferenceError: require is not defined in ES module scope, you can use import insteadThis file is being treated as an ES module because it has a '.js' file extension and 'esm-demo\packages\esm-include-cjs-lib\package.json' contains "type": "module". Totreat it as a CommonJS script, rename it to use the '.cjs' file extension.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>它说这是一个 esm 包，默认代码是 esm 模块，如果希望是以 cjs 模块执行，需要修改为 cjs 后缀。</p><p>修改命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">esbuild src/bin.ts --platform=node --outfile=dist/bin.cjs --bundle --sourcemap --format=cjs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>然后出现了第二个错误</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">TypeError [ERR_INVALID_ARG_TYPE]: The "path" argument must be of type string or an instance of URL. Received undefined<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>相关代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// src/bin.ts</span><span class="token keyword">var</span> import_path <span class="token operator">=</span> <span class="token function">__toESM</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">var</span> import_url <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">)</span><span class="token keyword">var</span> import_fs_extra <span class="token operator">=</span> <span class="token function">__toESM</span><span class="token punctuation">(</span><span class="token function">require_lib</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">var</span> import_meta <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> <span class="token punctuation">{</span> readdir <span class="token punctuation">}</span> <span class="token operator">=</span> import_fs_extra<span class="token punctuation">.</span>default<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> __filename <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> import_url<span class="token punctuation">.</span>fileURLToPath<span class="token punctuation">)</span><span class="token punctuation">(</span>import_meta<span class="token punctuation">.</span>url<span class="token punctuation">)</span> <span class="token comment">// 这里是关键，因为 import.meta.url 在 cjs 代码中是空的</span>  <span class="token keyword">const</span> __dirname <span class="token operator">=</span> import_path<span class="token punctuation">.</span>default<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span>__filename<span class="token punctuation">)</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">)</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> <span class="token function">readdir</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>根据<a href="https://github.com/evanw/esbuild/issues/1492#issuecomment-893144483">这个 issue 中作者的回答</a>，修改命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">esbuild src/bin.ts --platform=node --outfile=dist/bin.cjs --inject:./import-meta-url.js --define:import.meta.url=import_meta_url --bundle --sourcemap --format=cjs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>遗憾的是，这不再生效，bundle 的代码如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// import-meta-url.js</span><span class="token keyword">var</span> import_meta_url2 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pathToFileURL</span><span class="token punctuation">(</span>__filename<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>import_meta_url2<span class="token punctuation">)</span><span class="token comment">// src/bin.ts</span><span class="token keyword">var</span> import_path <span class="token operator">=</span> <span class="token function">__toESM</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">var</span> import_url <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> __filename2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> import_url<span class="token punctuation">.</span>fileURLToPath<span class="token punctuation">)</span><span class="token punctuation">(</span>import_meta_url<span class="token punctuation">)</span>  <span class="token keyword">const</span> __dirname <span class="token operator">=</span> import_path<span class="token punctuation">.</span>default<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span>__filename2<span class="token punctuation">)</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以明显看到，注入的脚本的变量名被修改了，从 <code>import_meta_url</code> =&gt; <code>import_meta_url2</code>，这是奇怪的问题。。。</p><p>或许可以替换 <code>--inject</code> =&gt; <code>--banner</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">esbuild src/bin.ts --platform=node --outfile=dist/bin.cjs --define:import.meta.url=import_meta_url --bundle --sourcemap --banner:js="var import_meta_url = require('url').pathToFileURL(__filename)" --format=cjs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这样就生效了</p><hr><p>那么，运行 esm bundle 呢？<br>也会出现错误</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">throw new Error('Dynamic require of "' + x + '" is not supported')Error: Dynamic require of "fs" is not supported<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>按照<a href="https://github.com/evanw/esbuild/issues/1921#issuecomment-1152991694">这里</a>的解决方法修改命令</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">esbuild src/bin.ts --platform=node --outfile=dist/bin.esm.js --bundle --sourcemap --banner:js="import { createRequire } from 'module';const require = createRequire(import.meta.url);" --format=esm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>现在，bundle 后的代码可以终于运行了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>或许 esm only 看起来很好，也有 tree shaking 看起来很棒的想法，但现在，它都还没有真正在生产中可用。包括一系列重要的项目都没有迁移，包括 react/vscode/electron/vite 等等。实际上，在此之前，许多人（吾辈亦然）也都使用 esm 模块来编写代码，只是最终的 bundle 产物可能不是 esm，例如在浏览器中可能是 iife，在 nodejs 中是 cjs，但绝大多数的应用层开发者并不关心这些，只有 lib 的维护者才会关心，esm only 则将包的复杂度也转移给了使用者，而且在 cjs 中引用 esm only 的包并没有真正可用的方案。相比于 esbuild/vite 这种解决实际问题的项目而言，esm only 运动更像是一场 web 前端圈内的狂欢。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="javascript" scheme="https://blog.rxliuli.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>新视点</title>
    <link href="https://blog.rxliuli.com/p/002e2156c7de4d7189c30e6af1eb76ee/"/>
    <id>https://blog.rxliuli.com/p/002e2156c7de4d7189c30e6af1eb76ee/</id>
    <published>2022-07-31T10:34:57.640Z</published>
    <updated>2022-08-01T13:38:45.518Z</updated>
    
    <content type="html"><![CDATA[<p>这周请了 5 天的年假，回去了一趟老家，虽然很多事物没有什么变化，但认知世界的眼睛发生了变化，便看到了一些不曾留意过的东西。</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEUbjwYBQkklYjA0npQ5lPuG5CY5w1TrycauJp-2mfqaDs4Fd5I727g8e0dlFTLBDyOu6IhZc5pgrQch-5RJtnFDW2TLNRPVO0Uf2M8sBDzsW59_noS-35qt9qbbalYk7O4u-zHM3_lh2cUVI2geI1v5=w1783-h1337-no" alt="爷爷的旧居被农田围上了"></p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEW3hKIshgwnBj1J8gF8_DxSYN4vqkH-9-YwW5rex0AhMC83CeIgBaZnvQrq5-CQpFoQUGd0-xXyGtOeawv1JDlZqEUWnoF6azruPZc25r-vt1oSIWrkPMh4X3OfmPZr_-m8EM165Q60jQGvYn0SYDTj=w1003-h1337-no" alt="高高的树"></p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEVEK4F8jbciGUedC-b6brnPPrg2ZTudwnhZtDhY-f_mgMStgc0jLgCeTyiGyZU00MRDVdkhn-8Aaw_pb7AQIHRLZwTPLGxUmDQMkgdsmuYK-31ahC067FEiwphbyvQRqHL2l_U3c0kOawTdpc2syupK=w1783-h1337-no" alt="家里的木头小板凳（真-实木）"></p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEWQycXqGJ3lAEw_0U4Y45_0TrUxzfyfv4Hi-Xy9lpVk6i5hFPS3FdtrfWiN8Um4lRWFDj5af96nRMsxs2Qqh1tkNuLIQ0pGy7BKH3QoYZjUu9ylKdUUPuyzUunK4YonIM_ym84GZCZEnqDTvfeKFvJo=w1003-h1337-no" alt="绿叶与树荫"></p><p>そら</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEWcA7J-vNw02TDt81Yp78AHcKwfiVTKtql18HYX3JuxTR7eP3Acpg228pew2MLDq9ReaLVnFYac3Mp5c9K3lgmNt8sKeQiJQa3F85_UTOa5rWYGOpKfjEChpADeLG2HMhVbI79PWsjZRl0x9m2EhJEY=w1783-h1337-no" alt="天空 1"><br><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEVmQHOoTfUnt4QH64OkGfIezcJwM-OtAaE1oa4FKCPUiyGk7er8CF18TdokuwliI0wrT45ieKSstwRwkS310wvuhAxnStZV0Rk8x0Bj-3jbOISt3NdvFfLLLfEBaFQ30V1pA-J7uhYL7uveinI881EK=w1783-h1337-no" alt="天空 2"><br><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEV2nr7K97amspV-Mld2XuzuiKFRBSidqvgEWk96AJz6A8JDV5zgOzkAlFr8xsXRB9hpQ6bHNAxwlsNCMFmLcyt9KcM6nSV6zp1ZL7_UuNAMSXH6SGCk-Cl8LhJynKpnPCWP3y9fRR7IZZtlArZCVcTD=w1783-h1337-no" alt="天空 3"><br><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEV3aJOP24N1Umagfr_h7WTPmWDkpKXeixB03Y2Tp8zTq-jTJbuuE2T_q4zfNZOU7FUfRWtqDv2QsF2rNAfFIK7fI3RS-wXKFmi-Y34i816_yJROeYSM0ift8Snpsdn8NvT-f27gRSPEQtPLS99pm0Lo=w1783-h1337-no" alt="天空 4"></p><p>用树叶吹出来的声音，和吾辈想象中的差别有一点点大 ಡ ͜ ʖ ಡ</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEWeDljN4jFTG5zQ_pmASmE0VcnHOhwQ50Lh5YHOGUBrqFX9dlr6x2jZvzcso0lLtU68OL_psC_1yLJGk2DxX2xx7OfEA2ninK9qed68xi5xTzLaUPL9bk9QejSoCVYfWp2kHGH1gwspZFH_DM-t55TY=w1003-h1337-no" alt="树叶"></p><p>声音: <a href="https://1drv.ms/u/s!AqTwKbfzs-vyiocZXo9hbDbp7h7P2g">https://1drv.ms/u/s!AqTwKbfzs-vyiocZXo9hbDbp7h7P2g</a></p><p>魔幻现实，退林返耕（小时候玩的空地前几年被挖了个大坑（卖地），现在居然种上农作物了，一边是楼房，一边是农田，确实很可以。。。</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEWVlhEiCajamNxy6ILPC_dxFUZU6i5urH-6K7OH9HtyvWIiWAqjSlVnRicVHy6pdoRGcb5I2t-V39vcK1IgOnEPzACxQtl6WYhU-cvjl6AtJrwOi93_hDYFzJl4pXSxnlAGYPxKoccbhW2xokX5h25O=w1783-h1337-no" alt="退林返耕"></p><p>有一点空地就会被糟蹋，之前的小树林变成了养牛养鸭的地方</p><p><img src="https://pbs.twimg.com/media/FYaWY2nUYAAUW_J?format=jpg&amp;name=large" alt="被毁灭的小树林"></p><p>就算在石头中，也无法阻挡生长（这个照片是楼顶上长出的一颗草（生命会自己找到出路 #逃</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEXamFpVGGVIMkOEnP-cVQt4ypVGvdu5X08cZblmkCMCsD0NRF8_x9xBctONhta84i0YJqpCRdUONT2MWpKN6ZtweAqPNww34neFI3n5iK6YEeFRXbI_aMyBGn4pNgSbf7r66N8-iV8pe06RZTdh885v=w1003-h1337-no" alt="石头中长出的草"></p><p>あさひ</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEV2sIra0Ti4nkWvbNgufzLEWVnrHcBrMKd31vctz6D9jvzFUi5TjZxrla1mFkMT8B4zrh2HE8y7YuGUanPwdxwqex6hJNbE6kNnaI9wSCXDf_5aVdjBcBT6eU6vz7UbYieX05ECoYETU6woVGlVxmDO=w1783-h1337-no" alt="热"></p><p>雨后，木头上长出了蘑菇</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEWL7Sg_ejmjQTSHjRAL-pWS71ZLlDaaWg1gN0SlAISnlA6TvE09jYguQdgi8OqG9s2BFHtL6lbw_MK3SeIhBu2sBCusfn331rv1JQ99iLQHup43GnLtRfVMKn8YJeYIouZGW-P2ye28ij_VoeMAcen-=w1003-h1337-no" alt="蘑菇 1"><br><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEVKWE7deSWE_l0faErNQROTp_Y5HBRnlpjV3Qmxaxr_-6pMVDhgLiDYaFedkBcwGz6HS4neAegODYozIO8NxmocoXro4FVhFV5t5kBnGPddVGR6ru1DNSRrLPdH_XGIdrL7s0XtCegxZjTv2Z3Bogtl=w1783-h1337-no" alt="蘑菇 2"></p><p>还未来得及成长的树叶</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEUKPipICU7gEA4W9vzt2qQ5YmcDpbi6eDJCLGA0Sn58VtwofDLuU6Quqsy-8P3bbOzkQN4tkZH3zFqwEcoYfHhQdRuZ61siwiphHX4iq-Pa0XDRVaPEbpMldtcdXna9WIKHoW1L7TMwyAFmduNtKJoG=w1003-h1337-no" alt="树芽"></p><p>在城市举目四望都是高楼，而在村庄，则大多数都是穿破天空的杨树，这也是为什么吾辈对天空拍照时总能拍到树的原因</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEVQBp1i4QG6aOhufPJUAam-Qb61KehmUktOyGjgWSGtVQSPTJaaIRMcIWSKqFImTa5c1byxBTJ7V1n0PMFeZRJPoacnUaGPvfbFqsETpQYd0odUWA3kPi_LFNUM1I2l14SV65OmzRdVNgmt_k8pZkwe=w1003-h1337-no" alt="远方只有树"></p><p>一个封闭的旧房间是如何飞进来了 4 只鸟儿</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEWdit-bbWs8Axt5GG8Yzd5oeohTkXYtzfkJEBSppQQZc-Mv2oBJp3Xg3Xn4UpQThwm5G9RXy4uH_VmMYqVZB0mWnBE9_bvt-m78TKnaDVEV24nIKoeQbtLVq8mi97KHfv3wr1SeMrev1YV4Cfm7F97X=w1003-h1337-no" alt="远摄"><br><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEX5hkVhtW-DIfXhoDvtN6cNCz8nBEZiwvDdcWX9Bh3bSUBBnWC5A6R5w2O_xUjQI0bs1te1CgH96oVbO0OAxobeIjjPFlgG8-IaO_uCVjijxASb9UTFWJ9DTSyUcoE2hXywkdkYJxFZYJUiYP_qtV_P=w1003-h1337-no" alt="近摄"></p><p>蝉</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEWfki45Nw0Sf1OFRln3yNfrX4EylP-UqBo6bo9EJ2uey6wFYqN6nuL2g0umdmbcYXGTwgXQvmbnxOxyhx12fWJF4Zgu57fTbMR2VzchXyOBHEpWks9qk7QXwmYJFkiXvWo5H_SUiLo80j5d5cEBSti7=w1003-h1337-no" alt="蝉 1"><br><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEUrhz_eXrL_-SlCMfWIrZJ2mL5vzD1JUJ-KfxbCtN6cslcPoVGzKG1t15g0ChM7xvhlAb6HxGVLMOn6ByBMIxrcoqnRZHy_eha0Grn2v8d6kIiDSE9J-GUPlXCIDPC2nkQi-TD-maoA57Ei1xD4cIcu=w1783-h1337-no" alt="蝉 2"></p><p>雨过天晴，藏身于瓦砾之中的蜗牛</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEXw0ivAzpg1RvfgAN52iHUxEbidSvE06GbYY0VJ5I0ZhPRGkkJ_oUwGgoR0SOTvxRPcHn6a7UvddT8Tlf3Ko8Vq84r4Ezawo25WqF9J3Uqnf6kw3K4xAhE1ofo2d6qBnRrpBTC8NwPfR401Hian_zDD=w1003-h1337-no" alt="蜗牛 1"><br><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEXWuXuRv1zFFTKLVtOCMMGdV4XtS5my_zVS8QieQU0CC4gAdk7omxeMxWh-nkTVi1BW_nrC6sMlfxlJ3G47CAo3ZkUI0P8D3kb8qK8bhnRja3lukio74DkNl7I9Ed3nwz_3ERoxn2lVcmTX-VD1uqJo=w1003-h1337-no" alt="蜗牛 2"><br><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEWj3w5dJ6xBqf03kuocff0Dag1ejVUCuDQn02uWazi-d-lpw65Dz9VA3T9d7fb5qIJKpohehJYygoKTloZeEzE70CA7JA-6vX-XUTnoEbNW_b_vXRIKwJicPlUIttEplUgLxzzYdAxvS2K6E3_DjLDk=w1003-h1337-no" alt="蜗牛 3"></p><p>死去的蝉（上图中是昨天遇到的一只活的蝉，今天早上就碰到一只死的</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEWABaINBKHI--vkncMp7VzMimo7P5zS0rrCvcG426ilfXiYnkOgLsq7Ge4zJ7ed9CfxZns83dOGh_-bOve_lR6n45fcsfbUA69w2ZE51Lg24BRipEgcY-RJx7309yHdbiW2VWSsL5uIOS4AjR3xtjXM=w1003-h1337-no" alt="死去的蝉 1"><br><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEVWO5YaiXM7JHE-FwjUU6TikFZa0oQ2WDhEhikyYdmVIOms_VxyEXnjhn1nI5Hbh8H-QILYjvLCIn4FmzQgHg85DgBgNlcs-B1--ci5Lg9-6koWtXfOfkZ8CL8Qw6AmlSEbnL4vRfi7VKAoaoqWugJf=w1003-h1337-no" alt="死去的蝉 2"><br><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEX3Er4MoEmXxG5HRj-bftsWbfj-Om_cixRZ-nhcw5HsY5Ip-EkC2zD_2KYAZg3R2n-WxTJkB6sjLwDg--kma96_vduMp-wObS1GNDJXS4yCAGX9rl26B8NMHvTeqeuhAG20OMEllbFWRAnVeLMCycw9=w1003-h1337-no" alt="死去的蝉 3"></p><p>天空确实感觉不错，又拍了几张</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEXBVQey0YwzB2hM5f_Ffs6X-mrRwjjxypJ3FhEE33vIxidrXk1eSnKGYddvkrSvvQj5Zy1PF2CNVbt1g-nOefKin4t5XNOZOnuDo-782mjsSs8pMDOWXh0d2IzYmdepK18upJAeHwyex2-qufzXAn4z=w1783-h1337-no" alt="天空 1"><br><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEUx6z0TMn6WegAknHxa8qQ7uwHMqBxGsyPbDZKb_rrfVgCwrDkac-7g-kx6OBdVDL3GQuXvsZGdUFOF-BRwbPlRfQ3_kcofnw4d0uMflhcO6BLjy-VLO0DROot6xFEEIAEVPE5ARyyLsZft9VmfY-7N=w1783-h1337-no" alt="天空 2"><br><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEWz4K0RHTkhowf3BlqIx6ThTktRpOhcCdCY2IKXyukX2Q92Ed-k1xmWG-VYbdRTZhW8S43l4NmVHg4sHfxRQqb-nkRQjBIsiAnWIqifPcVejM8fUfJgeeSWwIxD4RMDFRWwBZKSc23VQlOShiimbXLj=w1783-h1337-no" alt="天空 3"></p><p>夕阳</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEUVfq4-6jTzSsm8ca_6oVzBYuKZDfWmOhd5TvicErnE5IzvbCimPl9kR7MJzGCulmaMvUuqB34_JFScXRIFf6U--cQd0ynuzPUS_5MeRSn52BEe3ktMonS99rvHEoI-TiiLR-O8YeTnryalX8L-VjXu=w1783-h1337-no" alt="夕阳 2"></p><p>あめ ☔</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEW5MZJTl1G7c3jywXNmamyk8C7ooR_z9pWw2wAaeCfkSQKo9wY4S89ldfdfX1vSpqq8jBvIzOCaO6leisV4QsbjJ10HT7cLSTJh2s3NtD46mc-nFgLd7Q2Jt6z6JqjS84M0fG8PVPda27uB_ofeXPhA=w1003-h1337-no" alt="あめ"></p><p>雨中的云。。。是灰的？</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEX3opFAmhwzUskuulmfyGJ1-i4vLi3DMRFrXlkUJz2v7fuXQqNP5zKteR-v7aKnsJ6OXCRG3xmPKObkD2eolc2TKV6dcdOrQnntIE_-jVP4WminSTDwSJ_goxDjOum9U6vXILaHACblYmPQRjG0QWsg=w1882-h1337-no" alt="雨中的云"></p><p>蜗牛的世界，是二维的</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEVLZ6FSdDtgbFg-OzVEA9fo9iTVlBs5G4mke_yrzcJ14CLuc2HYOQHfchkKnzlNp3zPCb5L46oGasJI9bf0dK_iT08zwhMyieJpKcPiwrE0xxNoQW6cOnCwvcB4XI3jrBui36PvbIKTKAF30oaUQaDC=w1003-h1337-no" alt="蜗牛 1"><br><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEWGdVVFVZDH3p1Gtb6gG0eROfuill6rtLb7Y0g5hIFSUApSeVvdjqj0LR9IvMCkspdDb2ZcuW0VjRkbuaon6d_naka-VLd7OxgeJrqYQ67R9TuLvTTIayXlZQp3u92VSQGWT-F4b6ihHeOkFo4_bXhV=w1003-h1337-no" alt="蜗牛 2"><br><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEVrWKUe22SKcplrt0rLEwfXyxNnCfgt9P6nqgw3BnqvKfQ99jm8-ItHNUE5fWKnliLMd9cSt6xmtssSBCA12vAcmF25ezBpVb2QdHhNIVA3L79aXcTwzDMP88lfWpJeIji2N1WoFz74g8a6KpunhDRm=w1003-h1337-no" alt="蜗牛 3"></p><p>雨后真的有很多蜗牛出来</p><p><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEU4nqisIfb96Xu-YnP3SO27JOu2TKiEDR8iCnFl5aRXSDjOMRHLnzxnCc8khjeJcIwL92ywi45OvioRjvSAuD7g6x4vdbskZIxA9HTY_6o05O_yZNHEmZftYaJeHHvR9jKxexgjL5YFbTpO9A4vDWaB=w1003-h1337-no" alt="蜗牛 4"><br><img src="https://images.weserv.nl/?url=https://lh3.googleusercontent.com/pw/AL9nZEV2rSDwfngA00LiBn52oSoZ7fzUjqaessP42i-k_PuqErzmmoNBKAiRpYae2SihP7MpA5pTRGlDAorp3aEj7q_-J2B6ubujZA62PnOxhdFl-hwIyv4qDoXzOdff9qsOQiIzs9KWhTRZXgdO-IwptgJe=w1003-h1337-no" alt="蜗牛 5"></p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="个人" scheme="https://blog.rxliuli.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>使用 jscodeshift 做重构</title>
    <link href="https://blog.rxliuli.com/p/e124cb73d5864c24bb5547cd3431e338/"/>
    <id>https://blog.rxliuli.com/p/e124cb73d5864c24bb5547cd3431e338/</id>
    <published>2022-07-14T13:45:05.338Z</published>
    <updated>2022-08-07T10:36:38.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最近迁移了一些 API，因为所有前端项目都在同一个 monorepo 中，所以作为 lib 维护者吾辈还需要帮助迁移其他使用的模块。由于项目数量较多（大约有 30 多个），手动迁移非常麻烦而且难以测试。所以在调研了一些现有的大规模重构的方法后，吾辈选择了 jscodeshift 作为主要工具来做自动化迁移。<br>那么，它相比于使用 ide 的重构功能、使用字符串搜索替换亦或是手工一个个替换有什么不同呢？</p><ul><li>ide（vscode）的重构大多数时候不太好用，尤其在 monorepo 中以及包含 vue 文件时，它基本上无效的。</li><li>字符串替换我们经常使用，它只能处理简单的情况，并不能处理一些更复杂的情况，例如替换导入的变量并修改下面对应的值。</li><li>手工一个个替换最大的问题是浪费时间，并且难以形成积累以供后续复用，处理大量文件时是不现实的。</li></ul><p><img src="/resources/911c2de3c0244a2bafca13e8c32d2f0f.svg" alt="codemod.drawio.svg"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>jscodeshift 支持多种解析器，包括常见的 babel、ts、tsx，也提供链式调用 API，类似于 jquery。在调研的过程中，吾辈还发现了一个非常好的工具 <a href="https://astexplorer.net/">astexplorer</a>，它可以非常方便的浏览一段代码的 ast，便于确认如何找到想要处理的 ast 节点。</p><p><img src="/resources/cffe2a8a0f69452bbaca26977e4a9ade.png" alt="1658135431847"></p><p>jscodeshift 同时提供了 cli/lib 的使用方式，下面是基本的使用命令，它会在匹配的 ts 文件上运行转换脚本 transform.ts，<code>-d</code> 表示尝试运行并确定影响范围。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jscodeshift -t=./transform.ts --parser=ts ./*.ts -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="替换-import-导入的变量并替换所有使用到的-API"><a href="#替换-import-导入的变量并替换所有使用到的-API" class="headerlink" title="替换 import 导入的变量并替换所有使用到的 API"></a>替换 import 导入的变量并替换所有使用到的 API</h3><p>一种需求是将命名空间导入重构为命名导入，例如将 <code>import * as _ from 'lodash'</code> 转换为 <code>import { uniq } from 'lodash'</code> 便于构建工具能正确的 tree shaking。</p><p>转换前</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import * as _ from 'lodash'console.log(_.sort(_.uniq([1, 2, 1])))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>转换后</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { sort, uniq } from 'lodash'console.log(sort(uniq([1, 2, 1])))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>这里只需要找到引用命名空间的所有调用，并分别替换<strong>导入</strong>与<strong>命名空间方法调用</strong>即可，以下是实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import {  Identifier,  ImportDeclaration,  MemberExpression,  Transform,} from 'jscodeshift'const replaceImport: Transform = (fileInfo, api) =&gt; {  const j = api.j  const root = j(fileInfo.source)  const importNames = root    .find(j.ImportDeclaration)    .find(j.ImportNamespaceSpecifier)    .find(j.Identifier)    .nodes()    .map((node) =&gt; (node as Identifier).name)  console.log(importNames)  const list = importNames.map((name) =&gt; ({    name,    list: root      .find(j.MemberExpression, {        object: { name },      })      .nodes()      .map((node) =&gt; ((node as MemberExpression).property as Identifier).name),  }))  console.log(list)  list.forEach(({ name, list }) =&gt; {    root      .find(j.ImportDeclaration, {        specifiers: [{ type: 'ImportNamespaceSpecifier', local: { name } }],      })      .replaceWith((path) =&gt; {        const node = path.node as ImportDeclaration        node.specifiers = list.map((name) =&gt;          j.importSpecifier(j.identifier(name)),        )        return node      })    list.forEach((p) =&gt; {      root        .find(j.MemberExpression, { object: { name }, property: { name: p } })        .replaceWith(j.identifier(p))    })  })  return root.toSource()}export default replaceImport<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="将废弃的-API-替换为新的-API-调用"><a href="#将废弃的-API-替换为新的-API-调用" class="headerlink" title="将废弃的 API 替换为新的 API 调用"></a>将废弃的 API 替换为新的 API 调用</h3><p>还有一些时候我们废弃了一些 API，但目前仍然有引用，为了避免堆叠兼容式的代码，需要将使用旧 API 的代码转换为使用新 API 的代码。<br>例如我们希望替换以下代码</p><p>转换前</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { RendererApiFactory } from 'ipc-renderer'export const { vmBasicMessageChannel } = RendererApiFactory.createAll()export const { systemApi } = RendererApiFactory.createAllIpcMainApi(  vmBasicMessageChannel,)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>转换后</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { ApiFactory } from 'app-utils'export const { basicMessageChannel, systemApi } =  ApiFactory.createAll(basicMessageChannel)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这里替换稍微复杂一点，涉及到以下几个操作</p><ul><li>删除 import 的指定导入</li><li>创建新的导入</li><li>删除变量</li><li>创建新的导出</li><li>清理空的导入、导出</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { Identifier, ObjectProperty, Transform } from 'jscodeshift'const depretedApi: Transform = (fileInfo, api) =&gt; {  const j = api.j  const root = j(fileInfo.source)  const findImport = root    .find(j.ImportDeclaration, { source: { value: 'ipc-renderer' } })    .filter(      (path) =&gt;        j(path.node).find(j.ImportSpecifier, {          imported: { name: 'RendererApiFactory' },        }).length !== 0,    )  if (findImport.length === 0) {    return  }  findImport    .find(j.ImportSpecifier, { imported: { name: 'RendererApiFactory' } })    .remove()  findImport.insertAfter(    j.importDeclaration(      [j.importSpecifier(j.identifier('ApiFactory'))],      j.literal('app-utils'),    ),  )  if (findImport.find(j.ImportSpecifier).length === 0) {    findImport.remove()  }  root    .find(j.ExportNamedDeclaration)    .filter(      (path) =&gt;        j(path.node).find(j.MemberExpression, {          object: { name: 'RendererApiFactory' },          property: { name: 'createAll' },        }).length !== 0,    )    .remove()  const createAllIpcMainApi = root.find(j.ExportNamedDeclaration).filter(    (path) =&gt;      j(path.node).find(j.MemberExpression, {        object: { name: 'RendererApiFactory' },        property: { name: 'createAllIpcMainApi' },      }).length !== 0,  )  const keys = createAllIpcMainApi    .find(j.ObjectPattern)    .find(j.ObjectProperty)    .nodes()    .map((node) =&gt; ((node as ObjectProperty).key as Identifier).name)  console.log(keys)  createAllIpcMainApi.insertAfter(    j(      `export const { ${['basicMessageChannel', ...keys].join(        ', ',      )} } = ApiFactory.createAll()`,    )      .find(j.ExportNamedDeclaration)      .nodes()[0],  )  createAllIpcMainApi.remove()  console.log(root.toSource())  return root.toSource()}export default depretedApi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这里可以看到，吾辈并未使用 jscodeshift 构建 ast 的 api，而是直接使用了字符串拼接的方法。主要是使用 jscodeshift 的 api 构建过于繁琐，所以直接拼接字符串然后解析可能更简单一点。</p><h3 id="替换方法调用到多个参数与对象参数"><a href="#替换方法调用到多个参数与对象参数" class="headerlink" title="替换方法调用到多个参数与对象参数"></a>替换方法调用到多个参数与对象参数</h3><p>除此之外，我们还能变换方法调用的参数，例如将多个参数转换为对象参数（这在 ide 中是现成的功能）</p><p>转换前</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">show('liuli', 17, false)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>转换后</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">show({ name: 'liuli', age: 17, sex: false })<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>这里我们仅需要找到需要处理的函数调用，然后转换其参数即可。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { CallExpression, Identifier, Transform } from 'jscodeshift'const replaceParams: Transform = (fileInfo, api) =&gt; {  const j = api.j  const root = j(fileInfo.source)  const names = ['name', 'age', 'sex']  root    .find(j.CallExpression, { callee: { type: 'Identifier', name: 'show' } })    .replaceWith((path) =&gt; {      const node = path.node as CallExpression      const args = node.arguments      node.arguments = [        j.objectExpression(          names.map((name, i) =&gt;            j.objectProperty(j.identifier(name), args[i] as Identifier),          ),        ),      ]      return node    })  return root.toSource()}export default replaceParams<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="踩到的一些坑"><a href="#踩到的一些坑" class="headerlink" title="踩到的一些坑"></a>踩到的一些坑</h2><h3 id="使用-ts-解析器得到的结果与-jscodeshift-的-API-差距很大"><a href="#使用-ts-解析器得到的结果与-jscodeshift-的-API-差距很大" class="headerlink" title="使用 ts 解析器得到的结果与 jscodeshift 的 API 差距很大"></a>使用 ts 解析器得到的结果与 jscodeshift 的 API 差距很大</h3><p>ts 的 ast 非常特立独行，可以在 <a href="https://astexplorer.net/">astexplorer</a> 看到。吾辈一般会选择使用 @typescript-eslint/parser，它既能解析 js/ts/tsx，又能与 jscodeshift 的 api 相结合判断如何检索节点。</p><h3 id="无法直接按类型找到泛型参数"><a href="#无法直接按类型找到泛型参数" class="headerlink" title="无法直接按类型找到泛型参数"></a>无法直接按类型找到泛型参数</h3><p>例如可以在 ast viewer 中看到节点 TSTypeParameterInstantiation</p><p><img src="/resources/48b7b59c126142358065492d2935f1cb.png" alt="1658133727745"></p><p>但却无法使用 jscodeshift 找到</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const root = j(`wrap&lt;IHelloApi&gt;()`)expect(root.find(j.TSTypeParameterInstantiation).length).toBe(0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h3 id="string-prototype-replace-替换包含-的字符串时会出现奇怪的现象"><a href="#string-prototype-replace-替换包含-的字符串时会出现奇怪的现象" class="headerlink" title="string.prototype.replace 替换包含 $ 的字符串时会出现奇怪的现象"></a>string.prototype.replace 替换包含 $ 的字符串时会出现奇怪的现象</h3><p>运行下面这段代码，可能会得到让你意外的结果</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const s = 'hell$$ w$$rld'console.log(s.replaceAll(s, s)) // hell$ w$rld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>这与 string.prototype.replace 的一些奇怪实现有关，具体参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">mdn</a>，目前 StackOverflow 上的推荐方法是先处理一次要替换的值</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">console.log(s.replaceAll(s, s.replaceAll('$', '$$$$')))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="glob-模式依赖于-bash"><a href="#glob-模式依赖于-bash" class="headerlink" title="glob 模式依赖于 bash"></a>glob 模式依赖于 bash</h3><p>这点很烦人，它并未使用 node-glob 之类的包来实现文件匹配，而是直接依赖于 shell 本身的 glob 匹配，而默认情况下并不支持 <code>**</code>。某种变通的方法是使用 <code>find + xargs</code> 来绕过</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">find ./*/src -iname '*.vue' -o -iname '*.ts' | xargs jscodeshift -t "./convertAppApi.ts" -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.toptal.com/javascript/write-code-to-rewrite-your-code">https://www.toptal.com/javascript/write-code-to-rewrite-your-code</a></li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="typescript" scheme="https://blog.rxliuli.com/tags/typescript/"/>
    
    <category term="工程化" scheme="https://blog.rxliuli.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>实现一个玩具 lisp 运行时与解析器</title>
    <link href="https://blog.rxliuli.com/p/76673453498244cfbe34027678d75f67/"/>
    <id>https://blog.rxliuli.com/p/76673453498244cfbe34027678d75f67/</id>
    <published>2022-06-16T04:52:45.846Z</published>
    <updated>2022-06-21T04:50:17.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前看元循环求值器一节中使用 lisp 实现了一个 lisp 的运行时，吾辈也尝试使用 ts 来实现它。首先，这里展示一张曾经在书中出现过的图，表示一个运行时的基本组成是由 eval 和 apply 组成（看起来很像太极就是了）。eval 负责执行一个表达式，在 lisp 中，所有的代码都是表达式，这没什么问题。apply 则负责执行一个函数，将计算实参列表，并创建一个新的闭包环境绑定到形参上。</p><p><img src="/resources/45a7e01048f34e16911b58813165c1db.svg" alt="循环求值器.excalidraw.svg"></p><p>环境是一个有趣的话题，最初，吾辈了解到的是代换模型，即 <code>(+ (+ 1 2) 3)</code> 也可以被替换为 <code>(+ 1 2 3)</code>。后来，接触到修改变量后，每个函数就会绑定环境，然后动态获取某些值。</p><p>例如执行代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-lisp" data-language="lisp"><code class="language-lisp">(define (add x y)  (+ x y))(add 1 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p><img src="/resources/67194e14b93744cdac9f62a68531cd80.svg" alt="环境模型.excalidraw.svg"></p><h2 id="实现运行时"><a href="#实现运行时" class="headerlink" title="实现运行时"></a>实现运行时</h2><p>最初，吾辈也尝试使用 cons 实现，但后来发现面向对象更适合做这种事情（抽象语法树有不同的类型）。</p><p>考虑到复杂度的问题，目前实现了以下几种 ast</p><ul><li>primitive: 原始值，例如 number/boolean/string</li><li>variable: 变量，从当前环境中获取值</li><li>define: 在当前环境中定义新的值</li><li>set: 修改当前环境中指定的值</li><li>if: 条件判断，类似于三元表达式</li><li>cond: 条件判断，类似于 if/else-if/else</li><li>begin: 一系列表达式，结果为最后一个表达式的值</li><li>lambda: 函数，包含参数、函数体与定义时的环境，可以被 apply 执行</li><li>procedure: 一个需要执行的函数+参数</li></ul><p>先定义基础的 ast 接口，其中 eval 是每种 ast 都必须实现的方法，apply 则仅在 lambda ast 中存在。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type AstType =  | 'primitive'  | 'variable'  | 'define'  | 'set'  | 'if'  | 'cond'  | 'begin'  | 'lambda'  | 'procedure'export interface IAst {  readonly type: AstType  eval(env: Env): any}export interface IApplyAst {  apply(args: any[]): any}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>然后实现 Env 环境变量，应该能够获取、新增、修改以及扩展为一个新的环境</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export class Env {  private readonly map = new Map&lt;string, any&gt;()  constructor(private readonly prototype: Env | null = null) {}  get(k: string): any {    return this.map.has(k)      ? this.map.get(k)      : this.prototype !== null      ? this.prototype.get(k)      : null  }  define(k: string, v: any) {    if (this.map.has(k)) {      throw new Error(`变量 ${k} 已定义`)    }    this.map.set(k, v)  }  set(k: string, v: any): any {    if (this.map.has(k)) {      this.map.set(k, v)      return    }    if (this.prototype === null) {      throw new Error(`当前环境没有定义 ${k}`)    }    this.prototype.set(k, v)  }  extend(args: Record&lt;string, any&gt;) {    const env = new Env(this)    Object.entries(args).forEach(([k, v]) =&gt; {      env.map.set(k, v)    })    return env  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>接下来我们分别实现每一个</p><h3 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h3><p>原始值很简单，例如 1,2,3,4,5… 这样的数字，或 true/false 布尔值，亦或是 “hello world” 这种字符串，它们都是原始值，可以直接声明和使用，所以 ast 也仅仅是保存值，并且执行的时候返回而已。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export class PrimitiveAst implements IAst {  readonly type: AstType = 'primitive'  readonly value  constructor(value: any) {}  eval() {    if (this.value === null) {      return null    }    if (!['string', 'number', 'boolean'].includes(typeof this.value)) {      throw new Error('不支持的类型 ' + typeof this.value)    }    return this.value  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="variable-x2F-define-x2F-set-环境"><a href="#variable-x2F-define-x2F-set-环境" class="headerlink" title="variable/define/set 环境"></a>variable/define/set 环境</h3><p>variable/define/set 都是在操作环境，分别是获取、新增和修改。</p><p>有两点需要注意的地方</p><ul><li>variable 有点特殊，因为某些函数预先定义在语言中，例如 <code>+ - * / cons car cdr</code>，它们不需要定义就可以使用（类似于浏览器的 <code>native function</code>），所以这里有一个仅在内部使用的 <code>PrimitiveLambdaAst</code> 类型，可以看到其中实现了 <code>+ &gt; &lt; =</code> 这几个原生函数。</li><li>环境应该保存指向上一个环境的索引，这里为了简单实现使用了引用复制。</li></ul><p><img src="/resources/4748cad3d3c241b6a41520a25f9a1bcb.svg" alt="env.excalidraw.svg"></p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class PrimitiveLambdaAst implements IAst, IApplyAst {  readonly type: AstType = 'lambda'  constructor(readonly name: string) {}  eval(env: Env) {    return this  }  static readonly symbols = ['+', '&gt;', '&lt;', '=']  apply(args: any[]) {    if (this.name === '+') {      return args.reduce((r, i) =&gt; r + i, 0)    }    if (this.name === '&gt;') {      return args[0] &gt; args[1]    }    if (this.name === '&lt;') {      return args[0] &lt; args[1]    }    if (this.name === '=') {      return args[0] === args[1]    }    throw new Error('不支持的 api ' + this.name)  }}export class VariableAst implements IAst {  readonly type: AstType = 'variable'  constructor(readonly name: string) {}  eval(env: Env) {    const res = env.get(this.name)    if (res === null) {      if (PrimitiveLambdaAst.symbols.includes(this.name)) {        return new PrimitiveLambdaAst(this.name).eval(env)      }      throw new Error('变量未定义 ' + this.name)    }    return res  }}export class DefineAst implements IAst {  readonly type: AstType = 'define'  constructor(readonly name: string, readonly value: IAst) {}  eval(env: Env) {    if (env.get(this.name)) {      throw new Error(`变量 ${this.name} 已存在，不能重复定义`)    }    return env.define(this.name, this.value.eval(env))  }}export class SetAst implements IAst {  readonly type: AstType = 'set'  constructor(readonly name: string, readonly value: IAst) {}  eval(env: Env) {    if (env.get(this.name) === null) {      throw new Error(`变量 ${this.name} 不存在，不能设置值`)    }    return env.set(this.name, this.value.eval(env))  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="if-x2F-cond-条件判断"><a href="#if-x2F-cond-条件判断" class="headerlink" title="if/cond 条件判断"></a>if/cond 条件判断</h3><p>条件分支的 ast 很简单，许多语言中都有这种功能。</p><p><img src="/resources/a6428fc40e00466dae10b0e23072e4a6.svg" alt="条件判断.excalidraw.svg"></p><blockquote><p>if/cond 可以相互替代，所以可以仅实现一种，然后替换另一种即可，这里由于比较简单所以实现了两种。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export class IfAst implements IAst {  readonly type: AstType = 'if'  constructor(    readonly predict: IAst,    readonly left: IAst,    readonly right: IAst,  ) {}  eval(env: Env) {    return this.predict.eval(env) ? this.left.eval(env) : this.right.eval(env)  }}export class CondAst implements IAst {  readonly type: AstType = 'cond'  constructor(    readonly clauses: [predict: IAst, value: IAst][],    readonly defaultValue: IAst | null,  ) {}  eval(env: Env) {    const findClause = this.clauses.find((item) =&gt; item[0].eval(env))    return findClause      ? findClause[1].eval(env)      : this.defaultValue      ? this.defaultValue.eval(env)      : null  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="sequence-x2F-procedure"><a href="#sequence-x2F-procedure" class="headerlink" title="sequence/procedure"></a>sequence/procedure</h3><p>sequence 表示一系列表达式，全部执行并返回最后一个的结果。例如以下代码应该返回 3</p><figure><div class="code-wrapper"><pre class="line-numbers language-lisp" data-language="lisp"><code class="language-lisp">(begin  (define (add x y) (+ x y))  (define a 1)  (define b 2)  (add a b))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export class SequenceAst implements IAst {  readonly type: AstType = 'begin'  constructor(readonly exps: IAst[]) {}  eval(env: Env) {    return this.exps.reduce((_, exp) =&gt; exp.eval(env), null)  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="lambda-x2F-procedure"><a href="#lambda-x2F-procedure" class="headerlink" title="lambda/procedure"></a>lambda/procedure</h3><p>procedure/lambda 是最有趣的一部分，前者负责定义一个函数，后者则负责具体的调用。lambda ast 执行仅绑定了环境，并未真的执行。apply 则才会开辟一个新的环境，并将参数绑定新的环境上，然后执行函数体的代码。procedure 则计算一个表达式，表达式包含函数部分与参数部分，它会分别计算两者并最后应用 lambda ast 的 apply 方法。</p><p>考虑以下代码如何执行</p><figure><div class="code-wrapper"><pre class="line-numbers language-lisp" data-language="lisp"><code class="language-lisp">(((lambda (x) (lambda (y) (+ x y))) 1) 2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>分为几步看</p><ol><li><code>(lambda (x) (lambda (y) (+ x y)))</code> 创建一个函数，它返回一个新的函数</li><li><code>((lambda (x) (lambda (y) (+ x y))) 1)</code> 应用了上面的函数，创建了一个新的环境，x 被绑定为 1，返回了一个新的函数，可以被认为转换为了表达式 <code>(lambda (y) (+ 1 y))</code></li><li>应用返回的函数，创建新的环境，将 y 绑定到 2</li><li>是一个原生函数 <code>+</code>，直接得到结果 3</li></ol><p><img src="/resources/650bca017a5140f194af7ed764b0b5dc.svg" alt="函数.excalidraw.svg"></p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export class LambdaAst implements IAst, IApplyAst {  readonly type: AstType = 'lambda'  constructor(    readonly args: string[],    readonly body: IAst,    readonly restArgs: boolean,  ) {}  env!: Env  eval(env: Env) {    // 绑定环境，然后什么都不做    this.env = env    return this  }  apply(args: any[]) {    return this.body.eval(this.env.extend(this.pairArgs(this.args, args)))  }  private pairArgs(argNames: string[], args: any[]): Record&lt;string, any&gt; {    return argNames.reduce((r, k, i) =&gt; {      if (i === argNames.length - 1 &amp;&amp; this.restArgs) {        r[k] = args.slice(i)      } else {        r[k] = args[i]      }      return r    }, {} as Record&lt;string, any&gt;)  }}export class ProcedureAst implements IAst {  readonly type: AstType = 'procedure'  constructor(readonly operator: IAst, readonly operands: IAst[]) {}  eval(env: Env) {    return applyLisp(      this.operator.eval(env),      this.operands.map((ast) =&gt; ast.eval(env)),    )  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="统一入口"><a href="#统一入口" class="headerlink" title="统一入口"></a>统一入口</h3><p>然后，统一的入口 <code>evalLisp/applyLisp</code> 就很简单了</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">/** * 计算 lisp 表达式 */export function evalLisp(ast: IAst, env: Env = new Env()): any {  return ast.eval(env)}/** * 执行一个 lisp 函数 */export function applyLisp(ast: IAst &amp; IApplyAst, args: any[]): any {  return ast.apply(args)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>验证一下</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">describe('basic', () =&gt; {  const primitiveAdd = new VariableAst('+')  const primitiveMore = new VariableAst('&gt;')  const primitiveLess = new VariableAst('&lt;')  const primitiveEq = new VariableAst('=')  it('primitive', () =&gt; {    expect(evalLisp(new PrimitiveAst(1))).toBe(1)    expect(evalLisp(new PrimitiveAst(false))).toBe(false)    expect(evalLisp(new PrimitiveAst('hello'))).toBe('hello')    expect(() =&gt; evalLisp(new PrimitiveAst([1, 2]))).toThrowError()  })  it('variable', () =&gt; {    expect(      evalLisp(new VariableAst('name'), new Env().extend({ name: 'liuli' })),    ).toBe('liuli')    expect(() =&gt; evalLisp(new VariableAst('name'))).toThrowError()  })  describe('if', () =&gt; {    it('basic', () =&gt; {      expect(        evalLisp(          new IfAst(            new PrimitiveAst(true),            new PrimitiveAst(true),            new PrimitiveAst(false),          ),        ),      ).toBe(true)      expect(        evalLisp(          new IfAst(            new PrimitiveAst(false),            new PrimitiveAst(true),            new PrimitiveAst(false),          ),        ),      ).toBe(false)    })    it('variable', () =&gt; {      expect(        evalLisp(          new IfAst(            new VariableAst('hasName'),            new PrimitiveAst(true),            new PrimitiveAst(false),          ),          new Env().extend({            hasName: true,          }),        ),      ).toBe(true)    })    it('expression', () =&gt; {})  })  it('cond', () =&gt; {    const cond = new CondAst(      [        [new PrimitiveAst(false), new PrimitiveAst(1)],        [new VariableAst('x'), new PrimitiveAst(2)],        [          new ProcedureAst(primitiveEq, [            new VariableAst('y'),            new PrimitiveAst(3),          ]),          new PrimitiveAst(3),        ],      ],      new PrimitiveAst(0),    )    expect(evalLisp(cond, new Env().extend({ x: true, y: 3 }))).toBe(2)    expect(evalLisp(cond, new Env().extend({ x: false, y: 3 }))).toBe(3)    expect(evalLisp(cond, new Env().extend({ x: false, y: 0 }))).toBe(0)  })  describe('define', () =&gt; {    it('basic', () =&gt; {      const env = new Env()      evalLisp(new DefineAst('name', new PrimitiveAst('liuli')), env)      expect(evalLisp(new VariableAst('name'), env)).toBe('liuli')    })    it('repeated define', () =&gt; {      expect(() =&gt;        evalLisp(          new SequenceAst([            new DefineAst('name', new PrimitiveAst('liuli')),            new DefineAst('name', new PrimitiveAst('liuli')),          ]),        ),      ).toThrowError()    })  })  describe('set', () =&gt; {    it('basic', () =&gt; {      const res = evalLisp(        new SequenceAst([          new DefineAst('name', new PrimitiveAst('liuli')),          new SetAst('name', new PrimitiveAst('li')),          new VariableAst('name'),        ]),      )      expect(res).toBe('li')    })    it('error set', () =&gt; {      expect(() =&gt;        evalLisp(new SetAst('name', new PrimitiveAst('li'))),      ).toThrowError()    })  })  it('sequence', () =&gt; {    const res = evalLisp(      new SequenceAst([        new DefineAst('name', new PrimitiveAst('liuli')),        new VariableAst('name'),      ]),    )    expect(res).toBe('liuli')  })  it('lambda', () =&gt; {    const fn = new LambdaAst([], new PrimitiveAst(1), false)    expect(applyLisp(evalLisp(fn), [])).toBe(1)    expect(evalLisp(new ProcedureAst(fn, []))).toBe(1)  })  describe('procedure', () =&gt; {    it('primitive', () =&gt; {      expect(applyLisp(evalLisp(primitiveAdd), [1, 2])).toBe(3)      expect(applyLisp(evalLisp(primitiveMore), [1, 2])).toBe(false)      expect(applyLisp(evalLisp(primitiveLess), [1, 2])).toBe(true)    })    it('wrap', () =&gt; {      const add = new LambdaAst(        ['x', 'y'],        new ProcedureAst(primitiveAdd, [          new VariableAst('x'),          new VariableAst('y'),        ]),        false,      )      expect(applyLisp(evalLisp(add), [1, 2])).toBe(3)      expect(        evalLisp(          new ProcedureAst(add, [new PrimitiveAst(1), new PrimitiveAst(2)]),        ),      ).toBe(3)    })    it('close', () =&gt; {      const closeFn = new LambdaAst(        ['x'],        new ProcedureAst(primitiveAdd, [          new VariableAst('x'),          new VariableAst('y'),        ]),        false,      )      expect(        applyLisp(evalLisp(closeFn, new Env().extend({ y: 1 })), [1]),      ).toBe(2)      const ast = new SequenceAst([        new DefineAst('x', new PrimitiveAst(1)),        new DefineAst('y', new VariableAst('x')),        new ProcedureAst(closeFn, [new PrimitiveAst(2)]),      ])      expect(evalLisp(ast)).toBe(3)    })    it('basic', () =&gt; {      const returnSelf = new LambdaAst(['x'], new VariableAst('x'), false)      expect(applyLisp(evalLisp(returnSelf), [1])).toBe(1)    })    it('restArgs', () =&gt; {      const lambda = new LambdaAst(        ['numbers'],        new VariableAst('numbers'),        true,      )      console.log(applyLisp(evalLisp(lambda), [1, 2]))      // expect(applyLisp(evalLisp(lambda, {}), [1, 2])).toBe(1)    })    describe('cons', () =&gt; {      const cons = new LambdaAst(        ['car', 'cdr'],        new LambdaAst(          ['action'],          new CondAst(            [              [                new ProcedureAst(primitiveEq, [                  new VariableAst('action'),                  new PrimitiveAst('car'),                ]),                new VariableAst('car'),              ],              [                new ProcedureAst(primitiveEq, [                  new VariableAst('action'),                  new PrimitiveAst('cdr'),                ]),                new VariableAst('cdr'),              ],              [                new ProcedureAst(primitiveEq, [                  new VariableAst('action'),                  new PrimitiveAst('setCar'),                ]),                new LambdaAst(                  ['val'],                  new SetAst('car', new VariableAst('val')),                  false,                ),              ],              [                new ProcedureAst(primitiveEq, [                  new VariableAst('action'),                  new PrimitiveAst('setCdr'),                ]),                new LambdaAst(                  ['val'],                  new SetAst('cdr', new VariableAst('val')),                  false,                ),              ],            ],            new PrimitiveAst('error'),          ),          false,        ),        false,      )      it('basic', () =&gt; {        const numbers = applyLisp(evalLisp(cons), [1, 2])        expect(applyLisp(numbers, ['car'])).toBe(1)        expect(applyLisp(numbers, ['cdr'])).toBe(2)      })      const car = new LambdaAst(        ['cons'],        new ProcedureAst(new VariableAst('cons'), [new PrimitiveAst('car')]),        false,      )      const cdr = new LambdaAst(        ['cons'],        new ProcedureAst(new VariableAst('cons'), [new PrimitiveAst('cdr')]),        false,      )      it('car/cdr', () =&gt; {        const numbers = applyLisp(evalLisp(cons), [1, 2])        expect(applyLisp(evalLisp(car), [numbers])).toBe(1)        expect(applyLisp(evalLisp(cdr), [numbers])).toBe(2)      })      const setCar = new LambdaAst(        ['cons', 'val'],        new ProcedureAst(          new ProcedureAst(new VariableAst('cons'), [            new PrimitiveAst('setCar'),          ]),          [new VariableAst('val')],        ),        false,      )      const setCdr = new LambdaAst(        ['cons', 'val'],        new ProcedureAst(          new ProcedureAst(new VariableAst('cons'), [            new PrimitiveAst('setCdr'),          ]),          [new VariableAst('val')],        ),        false,      )      it('set', () =&gt; {        const numbers = applyLisp(evalLisp(cons), [1, 2])        applyLisp(evalLisp(setCar), [numbers, 11])        expect(applyLisp(evalLisp(car), [numbers])).toBe(11)        applyLisp(evalLisp(setCdr), [numbers, 12])        expect(applyLisp(evalLisp(cdr), [numbers])).toBe(12)      })    })  })})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="解析代码为-ast"><a href="#解析代码为-ast" class="headerlink" title="解析代码为 ast"></a>解析代码为 ast</h2><p>上面实现了执行 lisp ast 的功能，但如何将 lisp 代码解析为这种 ast 还没有实现，下面就来完成这一步。</p><h3 id="解析代码为字符流"><a href="#解析代码为字符流" class="headerlink" title="解析代码为字符流"></a>解析代码为字符流</h3><p>简单的处理为一个 token 数组很简单</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">/** * 解析代码为 token 数组（一维） * @param code * @returns */export function tokenize(code: string): string[] {  return code    .replaceAll('(', ' ( ')    .replaceAll(')', ' ) ')    .split(' ')    .map((i) =&gt; i.trim())    .filter((i) =&gt; i.length !== 0)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="将字符流结构化"><a href="#将字符流结构化" class="headerlink" title="将字符流结构化"></a>将字符流结构化</h3><p>但我们需要结构化的，所以还需要做一次转换</p><p>基本思路是每次处理一个字符</p><ol><li>如果是 <code>(</code>，则添加一个临时数组存储之后的值，直到遇到 <code>)</code> 为止</li><li>如果是 <code>)</code>，则将当前的临时数组合并到上一个临时数组</li><li>如果是其他字符，则将之追加到当前临时数组中</li><li>如果到了结尾，则返回当前的数组</li><li>初始数组是 <code>[[]]</code>，最后返回 <code>res[0][0]</code></li></ol><p>这是一个基本的流程图</p><p><img src="/resources/8f1eb6d8868d4976b2c5d1dc54c1fb02.jpg" alt="image.jpg"></p><p>下面是解析代码 <code>(begin (define x 1) (define y 2) (+ x y))</code> 的 tokens 流程中数组的状态</p><table><thead><tr><th>step</th><th>code</th><th>arr</th></tr></thead><tbody><tr><td>init</td><td></td><td><code>[[]]</code></td></tr><tr><td>1</td><td><code>(</code></td><td><code>[[], []]</code></td></tr><tr><td>2</td><td><code>begin</code></td><td><code>[[], [begin]]</code></td></tr><tr><td>3</td><td><code>(</code></td><td><code>[[], [begin], []]</code></td></tr><tr><td>4</td><td><code>define</code></td><td><code>[[], [begin], [define]]</code></td></tr><tr><td>5</td><td><code>define</code></td><td><code>[[], [begin], [define]]</code></td></tr><tr><td>6</td><td><code>x</code></td><td><code>[[], [begin], [define, x]]</code></td></tr><tr><td>7</td><td><code>1</code></td><td><code>[[], [begin], [define, x, 1]]</code></td></tr><tr><td>8</td><td><code>)</code></td><td><code>[[], [begin, [define, x, 1]]]</code></td></tr><tr><td>9</td><td><code>(</code></td><td><code>[[], [begin, [define, x, 1]], []]</code></td></tr><tr><td>10</td><td><code>define</code></td><td><code>[[], [begin, [define, x, 1]], [define]]</code></td></tr><tr><td>11</td><td><code>y</code></td><td><code>[[], [begin, [define, x, 1]], [define, y]]</code></td></tr><tr><td>12</td><td><code>2</code></td><td><code>[[], [begin, [define, x, 1]], [define, y, 2]]</code></td></tr><tr><td>13</td><td><code>)</code></td><td><code>[[], [begin, [define, x, 1], [define, y, 2]]]</code></td></tr><tr><td>14</td><td><code>(</code></td><td><code>[[], [begin, [define, x, 1], [define, y, 2]], []]</code></td></tr><tr><td>15</td><td><code>+</code></td><td><code>[[], [begin, [define, x, 1], [define, y, 2]], [+]]</code></td></tr><tr><td>16</td><td><code>x</code></td><td><code>[[], [begin, [define, x, 1], [define, y, 2]], [+, x]]</code></td></tr><tr><td>17</td><td><code>y</code></td><td><code>[[], [begin, [define, x, 1], [define, y, 2]], [+, x, y]]</code></td></tr><tr><td>18</td><td><code>)</code></td><td><code>[[], [begin, [define, x, 1], [define, y, 2], [+, x, y]]]</code></td></tr><tr><td>19</td><td><code>)</code></td><td><code>[[[begin, [define, x, 1], [define, y, 2], [+, x, y]]]]</code></td></tr></tbody></table><p>具体实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">/** * 解析代码为 token 数组（一维） * @param code * @returns */export function tokenize(code: string): string[] {  return code    .replaceAll('(', ' ( ')    .replaceAll(')', ' ) ')    .split(' ')    .map((i) =&gt; i.trim())    .filter((i) =&gt; i.length !== 0)}type DeepArray&lt;T&gt; = (T | DeepArray&lt;T&gt;)[]/** * 将平铺的 tokens 结构化，包含层次关系（使用多维数组） * @param tokens * @returns */export function structTokens(tokens: string[]): DeepArray&lt;string&gt; {  function iter(i: number, curr: DeepArray&lt;string&gt;): DeepArray&lt;string&gt; {    if (i === tokens.length) {      return curr    }    if (tokens[i] === '(') {      curr.push([])      return iter(i + 1, curr)    }    if (tokens[i] === ')') {      const sub = curr.pop()!      ;(curr[curr.length - 1] as DeepArray&lt;string&gt;).push(sub)      return iter(i + 1, curr)    }    ;(curr[curr.length - 1] as DeepArray&lt;string&gt;).push(tokens[i])    return iter(i + 1, curr)  }  return iter(0, [[]])[0][0] as DeepArray&lt;string&gt;}/** * 解析 lisp 代码为 ast * @param code */export function parseLisp(code: string): IAst {  const map: Partial&lt;Record&lt;AstType, (token: string[]) =&gt; IAst&gt;&gt; = {    define(token) {      const name = token[1]      if (Array.isArray(name)) {        return new DefineAst(          name[0],          new LambdaAst(            name.slice(1) as unknown as string[],            readFromToken(token[2]),            false,          ),        )      }      return new DefineAst(name, readFromToken(token[2]))    },    set(token) {      const name = token[1]      return new SetAst(name, readFromToken(token[2]))    },    begin(token) {      return new SequenceAst(token.slice(1).map(readFromToken))    },    if(token) {      return new IfAst(        readFromToken(token[1]),        readFromToken(token[2]),        readFromToken(token[3]),      )    },    cond(token) {      if (token[token.length - 1][0] === 'else') {        return new CondAst(          token            .slice(1, token.length - 1)            .map(([p, v]) =&gt; [readFromToken(p), readFromToken(v)]),          readFromToken(token[token.length - 1][1]),        )      } else {        return new CondAst(          token.slice(1).map(([p, v]) =&gt; [readFromToken(p), readFromToken(v)]),          null,        )      }    },    lambda(token) {      return new LambdaAst(        token[1] as unknown as string[],        readFromToken(token[2]),        false,      )    },  }  function readFromToken(token: string | string[]): IAst {    if (Array.isArray(token)) {      const op = token[0]      const parse = map[op as AstType]      return parse        ? parse(token)        : new ProcedureAst(            readFromToken(token[0]),            token.slice(1).map(readFromToken),          )    }    if (typeof token !== 'string') {      throw new Error('不支持的 token 类型 ' + typeof token)    }    return atom(token)  }  function atom(token: string): IAst {    if (/^\d$/.test(token)) {      return new PrimitiveAst(Number.parseInt(token))    }    if (/^([0-9]{1,}[.][0-9]*)$/.test(token)) {      return new PrimitiveAst(Number.parseFloat(token))    }    if (/^".*"$/.test(token)) {      return new PrimitiveAst(token.slice(1, token.length - 1))    }    if (['true', 'false'].includes(token)) {      return new PrimitiveAst(token === 'true')    }    return new VariableAst(token)  }  return readFromToken(structTokens(tokenize(code)) as any)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="转换为-ast"><a href="#转换为-ast" class="headerlink" title="转换为 ast"></a>转换为 ast</h3><p>最终，我们将结构化的 token 转换为 ast</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">/** * 解析 lisp 代码为 ast * @param code */export function parseLisp(code: string): IAst {  const map: Partial&lt;Record&lt;AstType, (token: string[]) =&gt; IAst&gt;&gt; = {    define(token) {      const name = token[1]      if (Array.isArray(name)) {        return new DefineAst(          name[0],          new LambdaAst(            name.slice(1) as unknown as string[],            readFromToken(token[2]),            false,          ),        )      }      return new DefineAst(name, readFromToken(token[2]))    },    set(token) {      const name = token[1]      return new SetAst(name, readFromToken(token[2]))    },    begin(token) {      return new SequenceAst(token.slice(1).map(readFromToken))    },    if(token) {      return new IfAst(        readFromToken(token[1]),        readFromToken(token[2]),        readFromToken(token[3]),      )    },    cond(token) {      if (token[token.length - 1][0] === 'else') {        return new CondAst(          token            .slice(1, token.length - 1)            .map(([p, v]) =&gt; [readFromToken(p), readFromToken(v)]),          readFromToken(token[token.length - 1][1]),        )      } else {        return new CondAst(          token.slice(1).map(([p, v]) =&gt; [readFromToken(p), readFromToken(v)]),          null,        )      }    },    lambda(token) {      return new LambdaAst(        token[1] as unknown as string[],        readFromToken(token[2]),        false,      )    },  }  function readFromToken(token: string | string[]): IAst {    if (Array.isArray(token)) {      const op = token[0]      const parse = map[op as AstType]      return parse        ? parse(token)        : new ProcedureAst(            readFromToken(token[0]),            token.slice(1).map(readFromToken),          )    }    if (typeof token !== 'string') {      throw new Error('不支持的 token 类型 ' + typeof token)    }    return atom(token)  }  function atom(token: string): IAst {    if (/^\d$/.test(token)) {      return new PrimitiveAst(Number.parseInt(token))    }    if (/^([0-9]{1,}[.][0-9]*)$/.test(token)) {      return new PrimitiveAst(Number.parseFloat(token))    }    if (/^".*"$/.test(token)) {      return new PrimitiveAst(token.slice(1, token.length - 1))    }    if (['true', 'false'].includes(token)) {      return new PrimitiveAst(token === 'true')    }    return new VariableAst(token)  }  return readFromToken(structTokens(tokenize(code)) as any)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们可以验证它的正确性</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">expect(evalLisp(parseLisp('"liuli"'))).toBe('liuli')expect(evalLisp(parseLisp('(+ 1 2)'))).toBe(3)expect(evalLisp(parseLisp('(+ 1.1 3.3)'))).toBe(4.4)expect(evalLisp(parseLisp('true'))).toBe(true)expect(evalLisp(parseLisp('(begin (define x 1) (define y 2) (+ x y))'))).toBe(3)expect(evalLisp(parseLisp('(if true 0 1)'))).toBe(0)expect(evalLisp(parseLisp('(if false 0 1)'))).toBe(1)expect(evalLisp(parseLisp('(cond (false 0) (false 1))'))).toBe(null)expect(evalLisp(parseLisp('(cond (false 0) (false 1) (else 2))'))).toBe(2)expect(evalLisp(parseLisp('(cond (false 0) (true 1) (else 2))'))).toBe(1)expect(evalLisp(parseLisp('((lambda (x y) (+ x y)) 1 2)'))).toBe(3)expect(  evalLisp(parseLisp('(begin (define (add x y) (+ x y)) (add 1 2))')),).toBe(3)expect(evalLisp(parseLisp('(begin 1 2)'))).toBe(2)expect(evalLisp(parseLisp('(begin (define x 1) (set x 2) x)'))).toBe(2)expect(  evalLisp(    parseLisp(`      (        begin        (define (cons a b) (          lambda (action) (            cond            ((= action "car") a)            ((= action "cdr") b)          )        ))        (define (car cons) (cons "car"))        (define (cdr cons) (cons "cdr"))        (define v (cons 1 2))        (+ (car v) (cdr v))      )    `),  ),).toBe(3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在上面，吾辈实现了 lisp 的玩具运行时和解析器，虽然还不支持许多 lisp 的功能（例如 <code>'</code> 引用功能），但核心的功能已经实现了，它可以完成一些基本的数值逻辑运算了。另一种有趣的思路是编译器，它不直接运行 lisp 代码，而是将 lisp 代码编译为一种其他可以运行的代码，例如将 lisp 代码编译为汇编代码执行，或者更有趣的方法是 – 编译为 js，就像 ts 做的一样，那样它就可以与 js 互操作了。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="算法" scheme="https://blog.rxliuli.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>流与延迟计算</title>
    <link href="https://blog.rxliuli.com/p/74ee9e8c552b421680a9cd967e2638ad/"/>
    <id>https://blog.rxliuli.com/p/74ee9e8c552b421680a9cd967e2638ad/</id>
    <published>2022-06-09T13:42:23.930Z</published>
    <updated>2022-06-20T04:55:52.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在此之前，吾辈介绍了如何 <a href="/p/a8027393b93445909aeed32a179086dd">从函数中<strong>无中生有</strong>的构造数据结构</a>。现在，吾辈将使用它构造一个更强大的数据结构：Stream（流）。</p><p>或许你曾经见过这张图</p><p><img src="/resources/06db2fe633f446e08a9074e792073ee0.svg" alt="stream.drawio.svg"></p><p>一些数据经过一系列的处理，然后得到结果，而只需要迭代每个元素一次，就像魔法一样。</p><h2 id="之前的想法"><a href="#之前的想法" class="headerlink" title="之前的想法"></a>之前的想法</h2><p>最初，吾辈的想法是让操作保存起来，只有等待某个显式调用的时候才真正执行。</p><p>即调用 map/filter/reduce 时将 action 与参数保存起来，等到调用 value 方法的时候才真正执行，像是 lodash 的 <code>_.chain</code> api 就是这种形式的。</p><p>形如</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">_.chain([1, 2, 3, 4])  .filter((i) =&gt; i % 2 === 0)  .map((i) =&gt; i * 2)  .value()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>于是最初吾辈也是按照这种 api 实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Stream&lt;T&gt; {  private flags: [action: string, ...args: any[]][] = []  constructor(private readonly arr: T[]) {}  map&lt;R&gt;(f: (item: T) =&gt; R): Stream&lt;R&gt; {    this.flags.push(['map', f])    return this as any  }  filter(f: (item: T) =&gt; boolean): Stream&lt;T&gt; {    this.flags.push(['filter', f])    return this  }  reduce&lt;R&gt;(f: (r: R, item: T) =&gt; R, init: R): R {    this.flags.push(['reduce', f, init])    return this.value() as any  }  value() {    const res: any[] = []    for (const item of this.arr) {      outer: {        let temp = item        for (const [action, ...args] of this.flags) {          switch (action) {            case 'map':              temp = args[0](temp)              break            case 'filter':              if (!args[0](temp)) {                break outer              }              break          }        }        res.push(temp)      }    }    return res  }}it('basic', () =&gt; {  const r = new Stream([1, 2, 3, 4])    .filter((i) =&gt; i % 2 === 0)    .map((i) =&gt; i * 2)    .value()  expect(r).toEqual([4, 8])})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>看起来 map/filter 工作的还不错，但 reduce 却存在问题，因为在两层 for 循环中 map 是依赖于临时变量替换，filter 则是依赖于 break label 实现，这种方式显然很难在 value 函数中兼容所有的功能。</p><p>不过实际上的解决方案也是延迟执行，只需要转换一下思路即可。下面将使用 cons 来构造流。</p><h2 id="延迟计算"><a href="#延迟计算" class="headerlink" title="延迟计算"></a>延迟计算</h2><p>首先，可以将流可以看作一系列的值，而且只能顺序依次获取，那么，我们仅需要实现一种在需要的时候能拿到值的数据结构就可以了。</p><p>下面将流的每个节点分为两部分，head 部分是一个具体的值，而 tail 部分则是一个产生下一个节点的函数，它可能是空的。</p><p><img src="/resources/d3826159559041f2aedb2bb21a1566c9.svg" alt="流节点.excalidraw.svg"></p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Stream&lt;T&gt; = Cons&lt;T, () =&gt; Stream&lt;T&gt;&gt; | nullfunction makeStream&lt;T&gt;(head: T, tail: () =&gt; Stream&lt;T&gt; = () =&gt; null) {  return cons(head, tail)}function head&lt;T&gt;(s: Stream&lt;T&gt;): T | null {  return s ? car(s) : null}function tail&lt;T&gt;(s: Stream&lt;T&gt;): Stream&lt;T&gt; {  return s ? cdr(s)() : null}function isEmpty(s: Stream&lt;any&gt;): boolean {  return s === null}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>现在有了基本的流的构造函数，可以使用最原始的方法构造了一个流了</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">makeStream(1, () =&gt; makeStream(2, () =&gt; makeStream(3)))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>看起来好像没什么用？这是因为我们还没有动态去构造。例如，我们可以从数组构造一个流，也可以转换回去</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function ofArray&lt;T&gt;(arr: T[]): Stream&lt;T&gt; {  return arr.length === 0    ? null    : makeStream(arr[0], () =&gt; ofArray(arr.slice(1)))}function toArray&lt;T&gt;(s: Stream&lt;T&gt;): T[] {  return isEmpty(s) ? [] : [head(s)!, ...toArray(tail(s))]}const arr = [1, 2, 3, 4]expect(toArray(ofArray(arr))).toEqual(arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="map-x2F-filter-x2F-reduce"><a href="#map-x2F-filter-x2F-reduce" class="headerlink" title="map/filter/reduce"></a>map/filter/reduce</h2><p>当然，我们也可以为它们编写 map/filter/reduce</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function map&lt;T, R&gt;(s: Stream&lt;T&gt;, fn: (item: T) =&gt; R): Stream&lt;R&gt; {  return isEmpty(s) ? null : makeStream(fn(head(s)!), () =&gt; map(tail(s), fn))}function filter&lt;T&gt;(s: Stream&lt;T&gt;, fn: (item: T) =&gt; boolean): Stream&lt;T&gt; {  return isEmpty(s)    ? null    : fn(head(s)!)    ? makeStream(head(s)!, () =&gt; filter(tail(s), fn))    : filter(tail(s), fn)}function reduce&lt;T, R&gt;(s: Stream&lt;T&gt;, fn: (res: R, item: T) =&gt; R, init: R): R {  return isEmpty(s) ? init : reduce(tail(s), fn, fn(init, head(s)!))}const r = reduce(  map(    filter(ofArray([1, 2, 3, 4]), (i) =&gt; i % 2 === 0),    (i) =&gt; i * 2,  ),  (r, i) =&gt; r + i,  0,)expect(r).toBe(12)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>啊咧？奇怪，我们是不是之前在写链表的时候写过类似的代码？像是这样</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function map&lt;T, R&gt;(list: List&lt;T&gt;, f: (i: T) =&gt; R): List&lt;R&gt; {  return list === null ? null : (cons(f(car(list)), map(cdr(list)!, f)) as any)}function filter&lt;T&gt;(list: List&lt;T&gt;, f: (i: T) =&gt; boolean): List&lt;T&gt; {  return list === null    ? null    : f(car(list))    ? cons(car(list), filter(cdr(list), f))    : filter(cdr(list), f)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>是的，它们的代码实现看起来很像，实际上，它们的区别仅在于流的节点的 cdr 部分是一个可以延迟计算的函数，只有<strong>在需要时</strong>才会被真的计算。在嵌套使用 map/filter 时，不再是先将所有元素通过 map 处理一遍形成新的流，再通过 filter 处理一遍形成新的流，而是在真正转换为链表或数组这种非延时的数据结构时才会被真正计算，而且方向是反的。</p><p>我们可以验证它真的是延迟计算的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const genStream = jest  .fn()  .mockImplementation((i) =&gt; makeStream(i, () =&gt; genStream(i + 1)))const s = genStream(1)expect(head(s)).toEqual(1)expect(genStream.mock.calls.length).toBe(1)expect(head(tail(s))).toEqual(2)expect(genStream.mock.calls.length).toBe(2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>在继续下一步之前，我们首先对流做一个简单的性能优化</p><p>继续使用上一个示例，当多次访问 tail 时，每次都会重新计算下一个节点的值，<strong>即便已经计算过了</strong>，这很浪费，而且会引发一些其他的问题，例如 <code>tail(s) === tail(s)</code> 的结果会是 false，因为这里生成了两次。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">it('once before', () =&gt; {  const genStream = jest    .fn()    .mockImplementation((i) =&gt; makeStream(i, () =&gt; genStream(i + 1)))  const s = genStream(1) // 创建流时会立刻计算 head，1 次  tail(s) // 1 次  tail(tail(s)) // 2 次  tail(tail(tail(s))) // 3 次  expect(genStream.mock.calls.length).toBe(7)  expect(tail(s) === tail(s)).toBeFalsy() // 两个值不相等})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>那么，是否有办法解决呢？<br>很简单，只需要做个缓存即可。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function once&lt;T extends () =&gt; any&gt;(f: T): T {  let flag: any = null  return (() =&gt; {    if (flag === null) {      flag = f()    }    return flag  }) as any}function makeStream&lt;T&gt;(head: T, tail: () =&gt; Stream&lt;T&gt; = () =&gt; null) {  return cons(head, once(tail))}it('once after', () =&gt; {  const genStream = jest    .fn()    .mockImplementation((i) =&gt; makeStream(i, () =&gt; genStream(i + 1)))  const s = genStream(1) // 创建流时会立刻计算 head，1 次  tail(tail(tail(s))) // 3 次  tail(tail(s)) // 直接从缓存读取，0 次  tail(s) // 直接从缓存读取，0 次  expect(genStream.mock.calls.length).toBe(4)  expect(tail(s) === tail(s)).toBeTruthy() // 两个值相等})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>现在，所有访问 tail 访问下一个节点都会默认缓存，如果已经计算过，将永远不再重复计算。</p><h2 id="无限流"><a href="#无限流" class="headerlink" title="无限流"></a>无限流</h2><p>流不仅可以表示有限的数据，甚至可以是无限的。</p><p>例如可以使用以下函数生成一个从 n 开始的无限整数流</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function intFrom(n: number): Stream&lt;number&gt; {  return makeStream(n, () =&gt; intFrom(n + 1))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>我们可以使用以下代码验证它</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const ints = intFrom(1)expect(head(ints)).toBe(1)expect(head(tail(ints))).toBe(2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>或者生成一个所有元素都是同一个值的无限流</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function ones&lt;T&gt;(i: T): Stream&lt;T&gt; {  return makeStream(i, () =&gt; ones(i))}let n = ones(1)Array(100)  .fill(0)  .forEach(() =&gt; {    expect(head(n)).toBe(1)    n = tail(n)  })<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>那么，如何截取流的一部分呢？例如截取前 n 个元素（<code>take</code>）或第 n 个之后的所有元素（<code>drop</code>）呢？<br>其实很简单，take 只需要生成新的流并在取到第 n 个元素的时候返回 null，drop 则不断使用 tail 获取下一个节点，直到获取到第 n 个节点就返回，而 slice 则是组合这两个函数。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function take&lt;T&gt;(s: Stream&lt;T&gt;, n: number): Stream&lt;T&gt; {  return n === 0 || isEmpty(s)    ? null    : makeStream(head(s)!, () =&gt; take(tail(s), n - 1))}function drop&lt;T&gt;(s: Stream&lt;T&gt;, n: number): Stream&lt;T&gt; {  return isEmpty(s) || n === 0 ? s : drop(tail(s), n - 1)}function slice&lt;T&gt;(s: Stream&lt;T&gt;, start: number, end: number) {  return take(drop(s, start), end - start)}it('slice', () =&gt; {  const ints = intFrom(1)  expect(toArray(take(ints, 4))).toEqual([1, 2, 3, 4])  expect(head(drop(ints, 4))).toBe(5)  expect(toArray(slice(ints, 2, 4))).toEqual([3, 4])})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>上面的函数并非是链式调用的，在使用起来会感觉有点繁琐，嵌套很多层的话尤其如此，但可以通过简单的包装实现传统的链式调用。</p><p>基本思想是在 Stream 对象中保存当前流，然后每次非终结操作都不断创建新的 Stream 对象，并且在对象的方法中调用之前实现的函数。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class StreamImpl&lt;T&gt; {  constructor(private readonly s: Stream&lt;T&gt;) {}  map&lt;R&gt;(fn: (item: T) =&gt; R): StreamImpl&lt;R&gt; {    return new StreamImpl(map(this.s, fn))  }  filter(fn: (item: T) =&gt; boolean): StreamImpl&lt;T&gt; {    return new StreamImpl(filter(this.s, fn))  }  reduce&lt;R&gt;(fn: (res: R, item: T) =&gt; R, init: R): R {    return reduce(this.s, fn, init)  }  take(n: number): StreamImpl&lt;T&gt; {    return new StreamImpl(take(this.s, n))  }  drop(n: number): StreamImpl&lt;T&gt; {    return new StreamImpl(drop(this.s, n))  }  value() {    return toArray(this.s)  }}function stream&lt;T&gt;(arr: T[]): StreamImpl&lt;T&gt; {  return new StreamImpl(ofArray(arr))}it('stream', () =&gt; {  const s = stream([1, 2, 3, 4, 5, 6, 7, 8, 9])    .filter((i) =&gt; i % 2 === 0)    .map((i) =&gt; i * 2)    .drop(1)    .take(2)  expect(s.value()).toEqual([8, 12])  expect(s.reduce((r, i) =&gt; r + i, 0)).toBe(20)})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以看到，上面的 api 其实已经和 lodash 一样了。</p><h2 id="异步的流"><a href="#异步的流" class="headerlink" title="异步的流"></a>异步的流</h2><p>流不仅可以处理同步的数据，也可以处理异步的数据。但与同步的数据相比，需要更换流节点的基本模型，从 head 立刻计算、tail 延迟计算更换为整个流节点都是延迟计算的。</p><p>一个基本的异步流节点可能是这样的</p><p><img src="/resources/c1113e6a67e84910a162d2b244935f15.svg" alt="异步流节点.excalidraw.svg"></p><p>类型定义</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type AsyncStream&lt;T&gt; = Promise&lt;Cons&lt;T, AsyncStream&lt;T&gt;&gt; | null&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>创建一些基本的辅助函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">/** 从数组中创建异步流 */async function asyncOfArray&lt;T&gt;(arr: T[]): AsyncStream&lt;T&gt; {  return arr.length === 0 ? null : cons(arr[0], asyncOfArray(arr.slice(1)))}/** 将异步流转换为数组 */async function asyncToArray&lt;T&gt;(s: AsyncStream&lt;T&gt;): Promise&lt;T[]&gt; {  const r = await s  return r === null ? [] : [car(r), ...(await asyncToArray(cdr(r)))]}it('basic', async () =&gt; {  const a = [1, 2, 3, 4]  expect(await asyncToArray(asyncOfArray(a))).toEqual(a)})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在此基础上实现 map/filter/reduce</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">async function asyncMap&lt;T, R&gt;(  s: AsyncStream&lt;T&gt;,  f: (i: T) =&gt; Promise&lt;R&gt;,): AsyncStream&lt;R&gt; {  const r = await s  return r === null ? null : cons((await f(car(r))) as R, asyncMap(cdr(r), f))}async function asyncFilter&lt;T&gt;(  s: AsyncStream&lt;T&gt;,  f: (i: T) =&gt; Promise&lt;boolean&gt;,): AsyncStream&lt;T&gt; {  const r = await s  return r === null    ? null    : (await f(car(r)))    ? cons(car(r), asyncFilter(cdr(r), f))    : await asyncFilter(cdr(r), f)}async function asyncReduce&lt;T, R&gt;(  s: AsyncStream&lt;T&gt;,  f: (r: R, i: T) =&gt; Promise&lt;R&gt;,  init: R,): Promise&lt;R&gt; {  const r = await s  return r === null ? init : asyncReduce(cdr(r), f, await f(init, car(r)))}it('map/filter/reduce', async () =&gt; {  const s = asyncOfArray([1, 2, 3, 4])  const r = await asyncReduce(    asyncMap(      asyncFilter(s, async (i) =&gt; i % 2 === 0),      async (i) =&gt; i * 2,    ),    async (r, i) =&gt; r + i,    0,  )  expect(r).toBe(12)})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这里也顺便实现一下 flatMap</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">async function concat&lt;T&gt;(a: AsyncStream&lt;T&gt;, b: AsyncStream&lt;T&gt;): AsyncStream&lt;T&gt; {  const r = await a  return r === null ? b : cons(car(r), concat(cdr(r), b))}async function asyncFlatMap&lt;T, R&gt;(  s: AsyncStream&lt;T&gt;,  f: (i: T) =&gt; AsyncStream&lt;R&gt;,): AsyncStream&lt;R&gt; {  const r = await s  return r === null ? null : concat(f(car(r)), asyncFlatMap(cdr(r), f))}async function int(start: number, end: number): AsyncStream&lt;number&gt; {  return start === end ? null : cons(start, int(start + 1, end))}it('flatMap', async () =&gt; {  expect(await asyncToArray(int(1, 4))).toEqual([1, 2, 3])  const r = asyncFlatMap(int(1, 4), (i) =&gt; int(0, i))  expect(await asyncToArray(r)).toEqual([0, 0, 1, 0, 1, 2])})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以看到，同步与异步的 map/filter/reduce 两者之间实现的差距相当小，是否有办法兼容呢？<br>不知道，或许有办法做到，但类型上感觉会有些复杂。</p><h2 id="异步数组"><a href="#异步数组" class="headerlink" title="异步数组"></a>异步数组</h2><p>下面列出一个真实的例子，在写前端应用时，处理异步操作是一件常见的事情，当需要异步的 map/filter/reduce 时，我们经常会使用 <code>Promise.all</code> 来完成</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">it('promise.all', async () =&gt; {  const r = (await Promise.all([1, 2, 3, 4].map(async (i) =&gt; [i % 2 === 0, i])))    .filter((r) =&gt; r[0])    .map((r) =&gt; r[1])  expect(r).toEqual([2, 4])})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>但是也可以看到，这种代码非常丑陋，因此吾辈之前曾经写过 AsyncArray 这种异步数组工具类，参考 <a href="https://github.com/rxliuli/liuli-tools/blob/master/libs/async/src/AsyncArray.ts">https://github.com/rxliuli/liuli-tools/blob/master/libs/async/src/AsyncArray.ts</a>。</p><p>下面基于 asyncStream 来实现它，可以看到都是直接转发到异步操作上，这没什么复杂的。有一点比较比较有趣的是这里还实现了 <code>PromiseLike</code> 接口，这让我们可以在不使用 <code>.value</code> 这种显式调用的情况下将流转换为 <code>Promise&lt;any[]&gt;</code>，仅使用 await 就像等待一个 Promise 一样执行了 then 方法，这只是个 Promise 的技巧罢了。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class AsyncArray&lt;T&gt; implements PromiseLike&lt;T[]&gt; {  static reduce&lt;T, R&gt;(    arr: T[],    fn: (res: R, item: T) =&gt; Promise&lt;R&gt;,    res: R,  ): Promise&lt;R&gt; {    return asyncReduce(asyncOfArray(arr), fn, res)  }  static map&lt;T, R&gt;(arr: T[], fn: (item: T) =&gt; Promise&lt;R&gt;): Promise&lt;R[]&gt; {    return asyncToArray(asyncMap(asyncOfArray(arr), fn))  }  static filter&lt;T&gt;(arr: T[], fn: (item: T) =&gt; Promise&lt;boolean&gt;): Promise&lt;T[]&gt; {    return asyncToArray(asyncFilter(asyncOfArray(arr), fn))  }  static flatMap&lt;T, R&gt;(arr: T[], fn: (item: T) =&gt; Promise&lt;R[]&gt;): Promise&lt;R[]&gt; {    return asyncToArray(      asyncFlatMap(asyncOfArray(arr), async (i) =&gt; asyncOfArray(await fn(i))),    )  }  static async forEach&lt;T&gt;(    arr: T[],    fn: (item: T) =&gt; Promise&lt;void&gt;,  ): Promise&lt;void&gt; {    await this.map(arr, fn)  }  private s: AsyncStream&lt;T&gt;  constructor(arr: T[]) {    this.s = asyncOfArray(arr)  }  private static of&lt;T&gt;(s: AsyncStream&lt;T&gt;): AsyncArray&lt;T&gt; {    const r = new AsyncArray&lt;T&gt;([])    r.s = s    return r  }  map&lt;R&gt;(fn: (item: T) =&gt; Promise&lt;R&gt;): AsyncArray&lt;R&gt; {    return AsyncArray.of(asyncMap(this.s, fn))  }  flatMap&lt;R&gt;(fn: (item: T) =&gt; Promise&lt;R[]&gt;): AsyncArray&lt;R&gt; {    return AsyncArray.of(      asyncFlatMap(this.s, async (i) =&gt; asyncOfArray(await fn(i))),    )  }  filter(fn: (item: T) =&gt; Promise&lt;boolean&gt;): AsyncArray&lt;T&gt; {    return AsyncArray.of(asyncFilter(this.s, fn))  }  async forEach&lt;R&gt;(fn: (item: T) =&gt; Promise&lt;R&gt;): Promise&lt;void&gt; {    await this.map(fn)  }  reduce&lt;R&gt;(fn: (res: R, item: T) =&gt; Promise&lt;R&gt;, res: R): Promise&lt;R&gt; {    return asyncReduce(this.s, fn, res)  }  then&lt;TResult1 = T[], TResult2 = never&gt;(    onfulfilled?: ((value: T[]) =&gt; TResult1 | PromiseLike&lt;TResult1&gt;) | null,    onrejected?: ((reason: any) =&gt; TResult2 | PromiseLike&lt;TResult2&gt;) | null,  ): PromiseLike&lt;TResult1&gt; {    return asyncToArray(this.s) as any  }}it('AsyncArray', async () =&gt; {  const r = await new AsyncArray([1, 2, 3, 4])    .filter(async (i) =&gt; i % 2 === 0)    .map(async (i) =&gt; i * 2)    .reduce(async (r, i) =&gt; r + i, 0)  expect(r).toBe(12)})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>流是一个很有用的数据抽象，尤其是在处理集合方面，几乎是无可比肩的，之前曾经非常流行的大数据处理框架 Spark 就非常强调 map/filter/reduce，这种数据结构约定了<strong>接口</strong>，然后就可以抽象出各种通用的处理了，延迟计算的想法更是天才，几乎仅仅只修改了 makeStream，就能够实现集合处理的性能优化了。虽然吾辈了解和实现这些知识有些晚，但就像有人说过 <strong>种一棵树最好的时间是十年前，其次是现在</strong>，亡羊补牢，尤未迟也，只要在不断的变得更好，便已然足够了。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="算法" scheme="https://blog.rxliuli.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>cons: 无中生有的数据结构</title>
    <link href="https://blog.rxliuli.com/p/a8027393b93445909aeed32a179086dd/"/>
    <id>https://blog.rxliuli.com/p/a8027393b93445909aeed32a179086dd/</id>
    <published>2022-06-07T05:01:43.129Z</published>
    <updated>2022-06-09T13:38:03.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>lisp 中有一种有趣的数据结构，Cons，它使用函数闭包封装了一个两元组的数据结构，并在此之上构建出其他需要的任何数据结构。在此之前，虽然也知道闭包之类的概念，写过一些高阶函数，但并未想过可以使用函数来构建数据结构，下面吾辈会说明如何在 ts 完成。</p><blockquote><p><a href="https://zh.wikipedia.org/zh-cn/%E5%88%97%E8%A1%A8%E6%A7%8B%E9%80%A0%E5%87%BD%E6%95%B8">lisp cons 的 wiki</a></p></blockquote><p>基本定义如下</p><p>$$<br>c=cons(a,b)\<br>car(c)=a\<br>cdr(c)=b<br>$$</p><h2 id="初始实现"><a href="#初始实现" class="headerlink" title="初始实现"></a>初始实现</h2><p>cons 初始实现很简单，只需要几行代码即可实现。可以看到，仅仅是使用闭包绑定了参数 a 和 b，并在函数执行时返回它们。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function cons(a: number, b: number): (n: number) =&gt; number {  return (n: number) =&gt; (n === 0 ? a : b)}function car(cons: (n: number) =&gt; number) {  return cons(0)}function cdr(cons: (n: number) =&gt; number) {  return cons(1)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以按照以下方式来使用它</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const n = cons(1, 2)console.log(car(n)) // 1console.log(cdr(n)) // 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>为了让它看起来更实用一点，首先使用泛型补充它的类型</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export interface Cons&lt;A, B&gt; {  (s: 0): A  (s: 1): B  _0: A  _1: B}export function cons&lt;A, B&gt;(a: A, b: B): Cons&lt;A, B&gt; {  return ((s: 0 | 1) =&gt; (s === 0 ? a : b)) as any}export function car&lt;T extends Cons&lt;any, any&gt;&gt;(cons: T): T['_0'] {  return cons(0)}export function cdr&lt;T extends Cons&lt;any, any&gt;&gt;(cons: T): T['_1'] {  return cons(1)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>使用以下单元测试验证它</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">it('cons', () =&gt; {  const c = cons('hello', 1)  expect(car(c) as string).toBe('hello')  expect(cdr(c) as number).toBe(1)})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>看起来没什么了不起的，但下面会使用它（最简单的二元结构）组合成链表和树等更复杂的数据结构。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>事实上，只要有了一个二元组，就可以继续组合任意需要的数据结构，链表是一种简单的示例。<br>这里将 cons 的 car 部分存储链表中当前结点的值，cdr 则存储着指向下一个节点的指针。</p><p><img src="/resources/85214de926184bf895c289404a0d8853.png" alt="1654666418817"></p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type List&lt;T&gt; = Cons&lt;T, List&lt;T&gt;&gt; | nullfunction list(): nullfunction list&lt;T&gt;(...args: T[]): Exclude&lt;List&lt;T&gt;, null&gt;function list&lt;T&gt;(...args: T[]): List&lt;T&gt; {  function iter(i: number): List&lt;T&gt; {    return i === args.length ? null : cons(args[i], iter(i + 1))  }  return iter(0)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>下面是一个存储 4 个元素的链表</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">list(1, 2, 3, 4)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>它会是一个 cons 嵌套调用的过程</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">cons(1, cons(2, cons(3, cons(4, null))))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><img src="/resources/fede3624da9245e581f7c06ce5ee557a.png" alt="1654666409802"></p><p>可以为之编写 <code>map/filter/reduce</code> 函数</p><p>map/filter 没什么复杂的，只是递归处理每个节点</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function map&lt;T, R&gt;(list: List&lt;T&gt;, f: (i: T) =&gt; R): List&lt;R&gt; {  return list === null ? null : (cons(f(car(list)), map(cdr(list)!, f)) as any)}function filter&lt;T&gt;(list: List&lt;T&gt;, f: (i: T) =&gt; boolean): List&lt;T&gt; {  return list === null    ? null    : f(car(list))    ? cons(car(list), filter(cdr(list), f))    : filter(cdr(list), f)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>下面使用 map 处理的示意图</p><p><img src="/resources/84dd1713ca704ed8946a142fcb6bf4f5.png" alt="1654667371418"></p><p>reduce 会有一点特殊，它是一个迭代式的递归</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function reduce&lt;T&gt;(list: List&lt;T&gt;, f: (res: T, v: T, i: number) =&gt; T): Tfunction reduce&lt;T, R&gt;(  list: List&lt;T&gt;,  f: (res: R, v: T, i: number) =&gt; R,  init: R,): Rfunction reduce&lt;T, R&gt;(  list: List&lt;T&gt;,  f: (res: R, v: T, i: number) =&gt; R,  init?: R,): R {  function iter(list: List&lt;T&gt;, init: R, i: number): R {    return list === null ? init : iter(cdr(list)!, f(init, car(list), i), i + 1)  }  return init !== undefined    ? iter(list, init, 0)    : iter(cdr(list!), car(list!) as unknown as R, 1)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以使用以下方式来使用它</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const res = reduce(  map(    filter(list(1, 2, 3, 4), (i) =&gt; i % 2 === 0),    (i) =&gt; i * 2,  ),  (a, b) =&gt; a + b,  0,)console.log(res) // 12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>理论上，应该很容易将 map/filter 转换为基于 reduce 的高阶函数，例如下面这段代码是在 js 中基于 reduce 实现 map/filter</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function map&lt;T, R&gt;(list: T[], f: (i: T) =&gt; R): R[] {  return list.reduce((res, i) =&gt; {    res.push(f(i))    return res  }, [] as R[])}function filter&lt;T&gt;(list: T[], f: (i: T) =&gt; boolean): T[] {  return list.reduce((res, i) =&gt; {    if (f(i)) {      res.push(i)    }    return res  }, [] as T[])}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如果希望将这里链表的 map/filter 基于 reduce 实现，则目前是不可能的。请注意，上面的代码使用了 push，这是一个<strong>修改</strong>操作，在函数式编程中更推荐不可变状态。那么，是否有某种方式即不改变状态也能做到呢？吾辈将尝试实现它。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function concat&lt;T&gt;(a: List&lt;T&gt;, b: List&lt;T&gt;): List&lt;T&gt; {  return a === null ? b : cons(car(a), concat(cdr(a), b))}function mapForReduce&lt;T, R&gt;(arr: List&lt;T&gt;, f: (i: T) =&gt; R): List&lt;R&gt; {  return reduce(arr, (res, i) =&gt; concat(res, list(f(i))), null as List&lt;R&gt;)}function filterForReduce&lt;T&gt;(arr: List&lt;T&gt;, f: (i: T) =&gt; boolean): List&lt;T&gt; {  return reduce(    arr,    (res, i) =&gt; (f(i) ? concat(res, list(i)) : res),    null as List&lt;T&gt;,  )}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>当然，或许会有人说：每次迭代一个元素时，都需要连接两个链表，这个效率不是很低么？是的，确实很低，所以可以使用另一种稍微怪异的方法。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function mapForReduce&lt;T, R&gt;(list: List&lt;T&gt;, f: (i: T) =&gt; R): List&lt;R&gt; {  return reduce(    list,    (res, i) =&gt; {      return i === null ? res : (next) =&gt; res(cons(f(i), next))    },    (r: List&lt;R&gt;) =&gt; r,  )(null)}function filterForReduce&lt;T&gt;(list: List&lt;T&gt;, f: (i: T) =&gt; boolean): List&lt;T&gt; {  return reduce(    list,    (res, i) =&gt; (f(i) ? (next) =&gt; res(cons(i, next)) : res),    (r: List&lt;T&gt;) =&gt; r,  )(null)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>诚然，这种方法看起来不会在每次递归时积累栈，但它也会将 res 这个函数不断包裹，最终在 reduce 结束后传入一个参数一次性全部调用，并未解决根本问题，所以下面实现 <code>setCar/setCdr</code></p><h2 id="支持修改-car-x2F-cdr"><a href="#支持修改-car-x2F-cdr" class="headerlink" title="支持修改 car/cdr"></a>支持修改 car/cdr</h2><p>想要实现 set，其实也就是修改闭包绑定的参数。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export interface Cons&lt;A, B&gt; {  (s: 'car'): A  (s: 'cdr'): B  (s: 'setCar'): (v: A) =&gt; void  (s: 'setCdr'): (v: B) =&gt; void  _0: A  _1: B}export function cons&lt;A, B&gt;(a: A, b: B): Cons&lt;A, B&gt; {  return ((s: string) =&gt;    s === 'car'      ? a      : s === 'cdr'      ? b      : s === 'setCar'      ? (v: A) =&gt; (a = v)      : (v: B) =&gt; (b = v)) as any}export function car&lt;T extends Cons&lt;any, any&gt;&gt;(cons: T): T['_0'] {  return cons('car')}export function cdr&lt;T extends Cons&lt;any, any&gt;&gt;(cons: T): T['_1'] {  return cons('cdr')}export function setCar&lt;T extends Cons&lt;any, any&gt;&gt;(cons: T, v: T['_0']): void {  return cons('setCar')(v)}export function setCdr&lt;T extends Cons&lt;any, any&gt;&gt;(cons: T, v: T['_1']): void {  return cons('setCdr')(v)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以使用以下单元测试验证</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">it('cons', () =&gt; {  const c = cons('hello', 1)  expect(car(c) as string).toBe('hello')  expect(cdr(c) as number).toBe(1)  setCar(c, 'liuli')  setCdr(c, 2)  expect(car(c) as string).toBe('liuli')  expect(cdr(c) as number).toBe(2)})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>不过在课程中提出了另一种实现，完全使用高阶函数实现，不在 cons 中使用内部判断。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export interface Cons&lt;A, B&gt; {  (m: (a: A, b: B, setA: (a: A) =&gt; void, setB: (b: B) =&gt; void) =&gt; any): any  _0: A  _1: B}export function cons&lt;A, B&gt;(a: A, b: B): Cons&lt;A, B&gt; {  return ((    m: (a: A, b: B, setA: (a: A) =&gt; void, setB: (b: B) =&gt; void) =&gt; any,  ) =&gt;    m(      a,      b,      (n: A) =&gt; (a = n),      (n: B) =&gt; (b = n),    )) as any}export function car&lt;T extends Cons&lt;any, any&gt;&gt;(cons: T): T['_0'] {  return cons((a) =&gt; a)}export function cdr&lt;T extends Cons&lt;any, any&gt;&gt;(cons: T): T['_1'] {  return cons((_a, b) =&gt; b)}export function setCar&lt;T extends Cons&lt;any, any&gt;&gt;(  cons: T,  value: T['_0'],): void {  cons((_a, _b, setA) =&gt; setA(value))}export function setCdr&lt;T extends Cons&lt;any, any&gt;&gt;(  cons: T,  value: T['_1'],): void {  cons((_a, _b, _setA, setB) =&gt; setB(value))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>现在，重新实现 mapForReduce/filterForReduce</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function mapForReduce&lt;T, R&gt;(list: List&lt;T&gt;, f: (i: T) =&gt; R): List&lt;R&gt; {  const init = cons(null, null) as unknown as List&lt;R&gt;  reduce(    list,    (curr, i) =&gt; {      const next = cons(f(i), null) as List&lt;R&gt;      setCdr(curr!, next)      return next    },    init,  )  return cdr(init!)}function filterForReduce&lt;T&gt;(list: List&lt;T&gt;, f: (i: T) =&gt; boolean): List&lt;T&gt; {  const init = cons(null, null) as unknown as List&lt;T&gt;  reduce(    list,    (curr, i) =&gt; {      if (!f(i)) {        return curr      }      const next = cons(i, null) as List&lt;T&gt;      setCdr(curr!, next)      return next    },    init,  )  return cdr(init!)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>对于代码 <code>mapForReduce(list(1, 2, 3, 4), i =&gt; i)</code> 的迭代过程图</p><table><thead><tr><th>i</th><th>curr</th><th>init</th></tr></thead><tbody><tr><td>1</td><td>(null, null)</td><td>(null, null)</td></tr><tr><td>2</td><td>(1, null)</td><td>(null, (1, null))</td></tr><tr><td>3</td><td>(2, null)</td><td>(null, (1, (2, null)))</td></tr><tr><td>4</td><td>(3, null)</td><td>(null, (1, (2, (3, null))))</td></tr><tr><td>return</td><td></td><td>(null, (1, (2, (3, (4, null)))))</td></tr></tbody></table><p>可以看到，每次都修改上一个节点，并且将当前值使用 cons 构造一个新的节点并作为下一个迭代值，最终遍历完整个列表也就将整个列表复制了一份。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>既然可以通过 cons 构造链表，也自然可以构造树结构，只要定义一个树结构即可。</p><p>一个节点是由一个值和可能存在的子节点组成，所以我们这样定义一个树节点。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">cons(value, list(sub1, sub2, ...subN))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><img src="/resources/a1c112afef614305907391dcf9ee1434.png" alt="1654739911536"></p><p>实现非常简单</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Tree&lt;T&gt; = Cons&lt;T, List&lt;Tree&lt;T&gt;&gt;&gt;function tree&lt;T&gt;(value: T, children: List&lt;Tree&lt;T&gt;&gt; = null) {  return cons(value, children)}const t = tree(1, list(tree(2, list(tree(3))), tree(4)))expect(car(t)).toBe(1)expect(car(car(cdr(t)!))).toBe(2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>也可以实现树结构的 map/filter/reduce，可以看到线面的实现都是简单基于 list 的 map/filter 实现。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function treeReduce&lt;T, R&gt;(tree: Tree&lt;T&gt;, f: (r: R, v: T) =&gt; R, init: R): R {  init = f(init, car(tree))  map(cdr(tree), (i) =&gt; {    init = treeReduce(i, f, init)  })  return init}function treeMap&lt;T, R&gt;(tree: Tree&lt;T&gt;, f: (v: T) =&gt; R): Tree&lt;R&gt; {  return cons(    f(car(tree)),    map(cdr(tree)!, (i) =&gt; treeMap(i, f)),  )}function treeFilter&lt;T&gt;(tree: Tree&lt;T&gt;, f: (v: T) =&gt; boolean): Tree&lt;T&gt; | null {  if (!f(car(tree))) {    return null  }  return cons(    car(tree),    filter(      map(cdr(tree)!, (i) =&gt; treeFilter(i, f)!),      (i) =&gt; i !== null,    ),  )}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>测试一下</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const t = tree(1, list(tree(2, list(tree(3))), tree(4)))it('basic', () =&gt; {  expect(car(t)).toBe(1)  expect(car(car(cdr(t)!))).toBe(2)})it('treeReduce', () =&gt; {  expect(treeReduce(t, (r, i) =&gt; [...r, i], [] as number[])).toEqual([    1, 2, 3, 4,  ])})it('treeMap', () =&gt; {  expect(    treeReduce(      treeMap(t, (i) =&gt; i * 2),      (r, i) =&gt; [...r, i],      [] as number[],    ),  ).toEqual([1, 2, 3, 4].map((i) =&gt; i * 2))})it('treeFilter', () =&gt; {  const res = treeFilter(t, (i) =&gt; i % 2 === 1)  expect(treeReduce(res!, (r, i) =&gt; [...r, i], [] as number[])).toEqual([1])})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>lisp 是一个看起来很简单的语言，因为似乎一切都是表达式，也不像现代语言一样提供多种构造复合数据的方法（像是 object 对象、struct 结构体、class 类等等）。但这里可以看到，只要支持最简单的复合数据，便可以构造任意复杂的数据结构，一切的复合数据的基石是如此简单以至于难以置信。</p><blockquote><p>事实上，使用 ts 编写一个 lisp 玩具解析器和运行时是如此简单，吾辈会在之后演示它。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="算法" scheme="https://blog.rxliuli.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>vite 构建正确内联 svg 资源</title>
    <link href="https://blog.rxliuli.com/p/9eb3b1a6e46a4777b3661ce0bb890d69/"/>
    <id>https://blog.rxliuli.com/p/9eb3b1a6e46a4777b3661ce0bb890d69/</id>
    <published>2022-05-30T13:28:20.859Z</published>
    <updated>2022-05-30T14:12:17.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>目前 vite 构建时内联媒体资源的功能有 bug，从 2020 年底就已经存在一个 <a href="https://github.com/vitejs/vite/issues/1204">github issue</a>，感觉短期不太可能解决，于是吾辈决定自行使用插件恢复这个功能。</p><p>下面是一个使用 vite 构建的 dist，可以看到其中的 svg 并未被正确内联到代码中，而是单独分割为了一个 bundle，而 jpg 图片则被正确内联。</p><p><img src="/resources/96c0e9443b0d476cb48d81a8c0a25f1f.png" alt="1653919149233"></p><h2 id="现有插件"><a href="#现有插件" class="headerlink" title="现有插件"></a>现有插件</h2><p>为什么不使用插件 <a href="https://github.com/rollup/plugins/tree/master/packages/image">@rollup/plugin-image</a></p><ul><li>它没有对 vite 做特殊处理，vite 本身内置插件处理 svg 的时机要早于它，它永远不会有机会处理图片</li><li>它没有处理 monorepo 项目中其他模块的资源</li></ul><p>实现起来并不困难，核心是拦截 .svg 的 load，将之替换为一个 js 文件，其中默认导出 svg dataUri 字符串。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { createFilter, FilterPattern } from '@rollup/pluginutils'import { readFile } from 'fs-extra'import svgToMiniDataURI from 'mini-svg-data-uri'import * as path from 'path'import { optimize, OptimizedSvg } from 'svgo'import { Plugin } from 'vite'const defaults = {  exclude: null,  include: null,}export function svgPatch(opts?: {  include?: FilterPattern  exclude?: FilterPattern}): Plugin {  const options = Object.assign({}, defaults, opts)  const filter = createFilter(options.include, options.exclude)  return {    name: 'vite-plugin-svg-patch',    enforce: 'pre',    resolveId(id: string, importer: string) {      if (this.meta.watchMode) {        return null      }      if (id.endsWith('.svg')) {        return path.resolve(path.dirname(importer), id)      }    },    async load(id) {      if (this.meta.watchMode) {        return null      }      if (!filter(id) || !id.endsWith('.svg')) {        return null      }      const source = optimize(        (await readFile(id, 'utf-8')).replace(/[\r\n]+/gm, ''),      )      if (source.error || source.modernError) {        console.error('svg optimization failed: ', id)      }      const dataUri = svgToMiniDataURI((source as OptimizedSvg).data)      return `export default "${dataUri}";`    },  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>已发布为 npm 包 <a href="https://npmjs.com/@liuli-util/vite-plugin-svg-patch">@liuli-util/vite-plugin-svg-patch</a></p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { defineConfig } from 'vite'import vue from '@vitejs/plugin-vue'import { svgPatch } from '@liuli-util/vite-plugin-svg-patch'export default defineConfig({  plugins: [vue(), svgPatch()],})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>以下是使用插件之后，可以看到 svg 文件没有被单独分割为一个文件了。</p><p><img src="/resources/f71f59c5dc304863928734a1ed0a281c.png" alt="1653919908486"></p><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>目前，没有找到一种钩子去处理 <code>vue style/css</code> 文件中使用 <code>background-image: url("")</code> 的图片资源，可能是只有 vite 内部才可以访问的钩子吧</p><blockquote><p>一种思路是使用 transformHook，但吾辈暂时不想处理 sourcemap 之类的事情，所以暂未尝试。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="vite" scheme="https://blog.rxliuli.com/tags/vite/"/>
    
    <category term="工程化" scheme="https://blog.rxliuli.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>使用 ESBuild 插件机制实现需要的功能</title>
    <link href="https://blog.rxliuli.com/p/ba9b341a8792405fb86d8fe02a18adfc/"/>
    <id>https://blog.rxliuli.com/p/ba9b341a8792405fb86d8fe02a18adfc/</id>
    <published>2022-05-20T12:54:23.400Z</published>
    <updated>2022-05-20T15:03:54.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://esbuild.github.io/">esbuild</a> 是一个通用的代码编译器和构建工具，使用 golang 构建，它非常快，性能上比现有的 js 工具链高 1~2 个数量级。它目前还不是一个开箱即用的构建工具，但通过它的插件系统，我们已经可以做到许多事情。</p><p><img src="/resources/006b4700843a4237a22056b3bd29a742.png" alt="1653052756694"></p><h2 id="自动排除所有依赖项"><a href="#自动排除所有依赖项" class="headerlink" title="自动排除所有依赖项"></a>自动排除所有依赖项</h2><p>在构建 lib 时，我们通常都不希望捆绑依赖的模块，希望能够默认排除掉所有的依赖项，这个插件就是用来实现这个功能的。它会将所有不是以 <code>.</code> 开头的导入模块设置为外部的，避免捆绑到最终构建产物中。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { Plugin } from 'esbuild'/** * 自动排除所有依赖项 * golang 不支持 js 的一些正则表达式语法，参考 https://github.com/evanw/esbuild/issues/1634 */export function autoExternal(): Plugin {  return {    name: 'autoExternal',    setup(build) {      build.onResolve({ filter: /.*/ }, (args) =&gt; {        if (/^\.{1,2}\//.test(args.path)) {          return        }        return {          path: args.path,          external: true,        }      })    },  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们可以这样使用，例如 import esbuild，但它不会被捆绑进来。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { build } from 'esbuild'console.log(build)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>会被编译成</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> build <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'esbuild'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>build<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h2><p>有时候我们会需要针对不同的环境使用环境变量来区分，而使用插件也可以很简单的做到这一点。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { Plugin } from 'esbuild'/** * @param {string} str */function isValidId(str: string) {  try {    new Function(`var ${str};`)  } catch (err) {    return false  }  return true}/** * Create a map of replacements for environment variables. * @return A map of variables. */export function defineProcessEnv() {  /**   * @type {{ [key: string]: string }}   */  const definitions: Record&lt;string, string&gt; = {}  definitions['process.env.NODE_ENV'] = JSON.stringify(    process.env.NODE_ENV || 'development',  )  Object.keys(process.env).forEach((key) =&gt; {    if (isValidId(key)) {      definitions[`process.env.${key}`] = JSON.stringify(process.env[key])    }  })  definitions['process.env'] = '{}'  return definitions}export function defineImportEnv() {  const definitions: Record&lt;string, string&gt; = {}  Object.keys(process.env).forEach((key) =&gt; {    if (isValidId(key)) {      definitions[`import.meta.env.${key}`] = JSON.stringify(process.env[key])    }  })  definitions['import.meta.env'] = '{}'  return definitions}/** * Pass environment variables to esbuild. * @return An esbuild plugin. */export function env(options: { process?: boolean; import?: boolean }): Plugin {  return {    name: 'env',    setup(build) {      const { platform, define = {} } = build.initialOptions      if (platform === 'node') {        return      }      build.initialOptions.define = define      if (options.import) {        Object.assign(build.initialOptions.define, defineImportEnv())      }      if (options.process) {        Object.assign(build.initialOptions.define, defineProcessEnv())      }    },  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>使用插件之后，我们就可以在代码中使用环境变量了</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export const NodeEnv = import.meta.env.NODE_ENV<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>编译结果</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">export</span> <span class="token keyword">const</span> NodeEnv <span class="token operator">=</span> <span class="token string">'test'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="在构建时输出日志"><a href="#在构建时输出日志" class="headerlink" title="在构建时输出日志"></a>在构建时输出日志</h2><p>有时候我们希望以监视模式构建某些东西，但 esbuild 不会在构建后输出消息，我们简单实现一个。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { Plugin, PluginBuild } from 'esbuild'export function log(): Plugin {  return {    name: 'log',    setup(builder: PluginBuild) {      let start: number      builder.onStart(() =&gt; {        start = Date.now()      })      builder.onEnd((result) =&gt; {        if (result.errors.length !== 0) {          console.error('build failed', result.errors)          return        }        console.log(`build complete, time ${Date.now() - start}ms`)      })    },  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们可以测试它是有效的</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const mockLog = jest.fn()jest.spyOn(global.console, 'log').mockImplementation(mockLog)await build({  stdin: {    contents: `export const name = 'liuli'`,  },  plugins: [log()],  write: false,})expect(mockLog.mock.calls.length).toBe(1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="自动排除-node-开头的依赖"><a href="#自动排除-node-开头的依赖" class="headerlink" title="自动排除 node: 开头的依赖"></a>自动排除 node: 开头的依赖</h2><p>有时候某些依赖的模块使用了 nodejs 的原生模块，但是以 <code>node:</code> 开头的的写法，这会导致 esbuild 无法识别，我们使用以下插件处理它</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { Plugin } from 'esbuild'/** * 排除和替换 node 内置模块 */export function nodeExternal(): Plugin {  return {    name: 'nodeExternals',    setup(build) {      build.onResolve({ filter: /(^node:)/ }, (args) =&gt; ({        path: args.path.slice(5),        external: true,      }))    },  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们的以下代码中的 node: 开头的原生模块会被排除</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { path } from 'node:path'console.log(path.resolve(__dirname))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>编译结果</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// &lt;stdin&gt;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> path <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'path'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="通过-raw-捆绑文本文件"><a href="#通过-raw-捆绑文本文件" class="headerlink" title="通过 ?raw 捆绑文本文件"></a>通过 ?raw 捆绑文本文件</h2><p>如果使用过 vite 的话，可能会对它的 <code>?*</code> 功能印象深刻，它提供了各种各样的功能来以不同的方式导入文件，而在 esbuild 中，我们有时候也希望静态捆绑某些内容，例如 readme 文件。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { Plugin } from 'esbuild'import { readFile } from 'fs-extra'import * as path from 'path'/** * 通过 ?raw 将资源作为字符串打包进来 * @returns */export function raw(): Plugin {  return {    name: 'raw',    setup(build) {      build.onResolve({ filter: /\?raw$/ }, (args) =&gt; {        return {          path: path.isAbsolute(args.path)            ? args.path            : path.join(args.resolveDir, args.path),          namespace: 'raw-loader',        }      })      build.onLoad(        { filter: /\?raw$/, namespace: 'raw-loader' },        async (args) =&gt; {          return {            contents: await readFile(args.path.replace(/\?raw$/, '')),            loader: 'text',          }        },      )    },  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>通过以下方式验证</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const res = await build({  stdin: {    contents: `        import readme from '../../README.md?raw'        console.log(readme)      `,    resolveDir: __dirname,  },  plugins: [raw()],  bundle: true,  write: false,})console.log(res.outputFiles[0].text)expect(  res.outputFiles[0].text.includes('@liuli-util/esbuild-plugins'),).toBeTruthy()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="重写一些模块"><a href="#重写一些模块" class="headerlink" title="重写一些模块"></a>重写一些模块</h2><p>有时候我们希望重写一些模块，例如将导入的 lodash 更改为 lodash-es 以实现 tree shaking，这时候我们可以通过以下插件办到这件事</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { build, Plugin } from 'esbuild'import path from 'path'/** * 将指定的 import 重写为另一个 * @param entries * @returns */export function resolve(entries: [from: string, to: string][]): Plugin {  return {    name: 'resolve',    setup(build) {      build.onResolve({ filter: /.*/ }, async (args) =&gt; {        const findEntries = entries.find((item) =&gt; item[0] === args.path)        if (!findEntries) {          return        }        return await build.resolve(findEntries[1])      })    },  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们可以使用以下配置将 lodash 替换为 lodash-es</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">build({  plugins: [resolve([['lodash', 'lodash-es']])],})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>源代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { uniq } from 'lodash'console.log(uniq([1, 2, 1]))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>编译结果</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> uniq <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'lodash-es'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">uniq</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h2 id="强制指定模块没有副作用"><a href="#强制指定模块没有副作用" class="headerlink" title="强制指定模块没有副作用"></a>强制指定模块没有副作用</h2><p>当我们的使用一个第三方的包时，有可能这个包依赖了一些其他的模块，如果这个模块没有声明 <code>sideEffect</code>，那么即便它没有副作用并且导出了 esm 的包，也会将依赖的模块 bundle 进来，但我们可以使用插件 api 强制指定模块没有副作用。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import { Plugin } from 'esbuild'/** * 设置指定模块为没有副作用的包，由于 webpack/esbuild 的配置不兼容，所以先使用插件来完成这件事 * @param packages * @returns */export function sideEffects(packages: string[]): Plugin {  return {    name: 'sideEffects',    setup(build) {      build.onResolve({ filter: /.*/ }, async (args) =&gt; {        if (          args.pluginData || // Ignore this if we called ourselves          !packages.includes(args.path)        ) {          return        }        const { path, ...rest } = args        rest.pluginData = true // Avoid infinite recursion        const result = await build.resolve(path, rest)        result.sideEffects = false        return result      })    },  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>我们以如下方式使用它</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">build({  plugins: [sideEffects(['lib'])],})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>这时候，即便 lib-a 中某些代码依赖了 lib-b，但只要你的代码没有依赖到特定方法，那么它就会被正确的 tree shaking</p><p>例如下面的代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">// main.tsimport { hello } from 'lib-a'console.log(hello('liuli'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">// lib-a/src/index.tsexport * from 'lib-b'export function hello(name: string) {  return `hello ${name}`}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>编译结果</p><figure><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// dist/main.js</span><span class="token keyword">function</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">name</span><span class="token operator">:</span> string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token string">'liuli'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前已经实现了 esbuild 的许多插件，但它作为构建应用的基础构建工具仍然稍显薄弱，目前仅推荐使用它构建一些纯 JavaScript/TypeScript 的代码。如果需要构建完整的 web 应用，那么 vite 可能是目前基于 esbuild 的最成熟的构建工具。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="工程化" scheme="https://blog.rxliuli.com/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    <category term="javascript" scheme="https://blog.rxliuli.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>汉诺塔问题</title>
    <link href="https://blog.rxliuli.com/p/9751355186fd4c5bbad0d041fe85c256/"/>
    <id>https://blog.rxliuli.com/p/9751355186fd4c5bbad0d041fe85c256/</id>
    <published>2022-04-25T00:23:01.599Z</published>
    <updated>2022-07-31T13:03:50.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近两个月一直在看 <a href="https://www.youtube.com/playlist?list=PLkEwH_Z2WOlppy8oUfrGwFVlOuKyo3RO_">SICP 的 Youtube 课程</a>，作为一个半路出家的人，自觉基础欠缺，至今已是工作的第四个年头，正如年初计划所言，仅仅依赖于热情去折腾各种简单的玩具已经不再能有效地提升自己了，需要系统化的学习和组织知识。虽然之前也买过实体书，但由于看起来比较难而且也没有风趣的讲解（看的有点枯燥，看完视频后感觉里面的教授真的太有趣了！），所以一直没能看下去（另外一本《算法》也是同样的命运），但幸运的是，Youtube 上有现有的课程，而且还有人做了翻译的字幕，这对吾辈而言真的是方便太多了。汉诺塔是在 SICP 第二课<strong>计算过程</strong>讲的一个小游戏的例子，由于它真的很有趣，所以吾辈想要写一篇关于它的文章。<br>那么，为了避免有人还不知道汉诺塔是什么，这里引用一段 <a href="https://zh.wikipedia.org/wiki/%E6%B1%89%E8%AF%BA%E5%A1%94">wiki</a> 的简介</p><blockquote><p>汉诺塔（港台：河内塔）（Tower of Hanoi）是根据一个传说形成的数学问题：</p><p>有三根杆子 A，B，C。A 杆上有 N 个 (N&gt;1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：</p><p>每次只能移动一个圆盘；<br>大盘不能叠在小盘上面。<br>提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则。</p><p>问：如何移？最少要移动多少次？</p></blockquote><h2 id="简单情况"><a href="#简单情况" class="headerlink" title="简单情况"></a>简单情况</h2><blockquote><p>这里是递归应用最强大的实证</p></blockquote><p>首先来看最简单的情况，将一个初始状态的汉诺塔的所有圆盘移动到另一个柱子上。</p><p>课程中给出的解法很有趣</p><ol><li>首先，我们如果需要移动 a(n) 柱子上的圆盘到 b</li><li>如果可以直接移动，则直接移动</li><li>否则，我们可以将之分解为以下 3 步<ol><li>移动 a(n-1) 到柱子 c（临时柱）</li><li>然后移动 a(n) 到 b</li><li>最后将 a(n-1) 从移动到 b</li></ol></li></ol><p>然后呢？然后就没有然后了！这个例子真的非常强大，我们使用 4 个圆盘的柱子来演示这一点</p><p>下面这个表格是代表操作与状态的变化，如果无法操作，我们将按照上面的规则转换为 3 个子操作，直到可以直接移动为止</p><table><thead><tr><th>操作</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td><code>init</code></td><td>[1,2,3,4]</td><td>[]</td><td>[]</td></tr><tr><td><code>a4=&gt;b</code></td><td></td><td></td><td></td></tr><tr><td><code>--a3=&gt;c</code></td><td></td><td></td><td></td></tr><tr><td><code>----a2=&gt;b</code></td><td></td><td></td><td></td></tr><tr><td><code>------a1=&gt;c</code></td><td>[2,3,4]</td><td>[]</td><td>[1]</td></tr><tr><td><code>------a2=&gt;b</code></td><td>[3,4]</td><td>[2]</td><td>[1]</td></tr><tr><td><code>------c1=&gt;b</code></td><td>[3,4]</td><td>[1,2]</td><td></td></tr><tr><td><code>----a3=&gt;c</code></td><td>[4]</td><td>[1,2]</td><td>[3]</td></tr><tr><td><code>----b2=&gt;c</code></td><td></td><td></td><td></td></tr><tr><td><code>------b1=&gt;a</code></td><td>[1,4]</td><td>[2]</td><td>[3]</td></tr><tr><td><code>------b2=&gt;c</code></td><td>[1,4]</td><td>[]</td><td>[2,3]</td></tr><tr><td><code>------b1=&gt;c</code></td><td>[4]</td><td>[]</td><td>[1,2,3]</td></tr><tr><td><code>--a4=&gt;b</code></td><td>[]</td><td>[4]</td><td>[1,2,3]</td></tr><tr><td><code>--c3=&gt;b</code></td><td></td><td></td><td></td></tr><tr><td><code>----c2=&gt;a</code></td><td></td><td></td><td></td></tr><tr><td><code>------c1=&gt;b</code></td><td>[]</td><td>[1,4]</td><td>[2,3]</td></tr><tr><td><code>------c2=&gt;a</code></td><td>[2]</td><td>[1,4]</td><td>[3]</td></tr><tr><td><code>------b1=&gt;a</code></td><td>[1,2]</td><td>[4]</td><td>[3]</td></tr><tr><td><code>----c3=&gt;b</code></td><td>[1,2]</td><td>[3,4]</td><td>[]</td></tr><tr><td><code>----a2=&gt;b</code></td><td></td><td></td><td></td></tr><tr><td><code>------a1=&gt;c</code></td><td>[2]</td><td>[3,4]</td><td>[1]</td></tr><tr><td><code>------a2=&gt;b</code></td><td>[]</td><td>[2,3,4]</td><td>[1]</td></tr><tr><td><code>------c1=&gt;b</code></td><td>[]</td><td>[1,2,3,4]</td><td>[]</td></tr></tbody></table><p>可以看到，最终我们成功将圆盘从 a 移动到了 b，这里的关键点是将一个复杂操作分为几步，直到能够执行某些基本操作为止。下面是吾辈使用 ts 实现的最初版本</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function hanoi(n: number) {  const res: [from: string, to: string][] = []  function hanoi(n: number, from: string, to: string, stage: string) {    if (n === 1) {      res.push([from, to])      return    }    hanoi(n - 1, from, stage, to)    hanoi(1, from, to, stage)    hanoi(n - 1, stage, to, from)  }  hanoi(n, 'a', 'b', 'c')  return res}console.log(hanoi(4))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>下面则使用更加函数式的风格来完成</p><blockquote><p>改进：实际上汉诺塔是先移动上层的所有圆盘到临时柱，然后移动最下层的圆盘到目标柱，最终将临时圆盘上的所有圆盘移动到目标柱。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function hanoi(n: number) {  function iter(    n: number,    from: string,    to: string,    stage: string,  ): [string, string][] {    if (n === 1) {      return [[from, to]]    }    return iter(n - 1, from, stage, to)      .concat(iter(1, from, to, stage))      .concat(iter(n - 1, stage, to, from))  }  return hanoi(n, 'a', 'b', 'c')}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="计算步数"><a href="#计算步数" class="headerlink" title="计算步数"></a>计算步数</h2><p>计算步数更加简单，甚至可以写成一个数学函数</p><p>$$<br>f(1)=1 \<br>f(n)=2f(n-1)+1<br>$$</p><p>如果画成图，就是求一棵树的所有叶子节点</p><p><img src="/resources/a08e9f5d95a541f7b016a7cce631662c.png" alt="1654526921100"></p><p>下面使用 ts 非常简单的实现了</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">/** * 计算移动汉诺塔从 a =&gt; b 的步数，本质上公式非常简单 * @param n * @returns */function fn(n: number) {  return n === 1 ? 1 : fn(n - 1) + fn(1) + fn(n - 1)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>如果使用缓存，则效率可以高得多</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const map = new Map&lt;number, number&gt;()function fn(n: number) {  if (!map.has(n)) {    map.set(n, n === 1 ? 1 : fn(n - 1) + fn(1) + fn(n - 1))  }  return map.get(n)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="使用迭代的方式求解"><a href="#使用迭代的方式求解" class="headerlink" title="使用迭代的方式求解"></a>使用迭代的方式求解</h2><p>看起来似乎无法使用迭代的方式去解决这个问题，核心是不知道前面还有多少步，或者说没有办法保存当前的移动信息<br>或许有办法，使用一个对象，通过三个字段的数组保存当前汉诺塔的状态，只要递归函数能<strong>智能</strong>移动一步，就可以以尾递归（迭代）的方式来解决这个问题，就像人的做法一样，能根据上下文做出合理的移动。</p><p>创建一个 HanoiGame 类型</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class HanoiGame {  constructor(public state: { a: number[]; b: number[]; c: number[] }) {}  check(from: string, to: string) {    return (      this.state[from].length !== 0 &amp;&amp;      (this.state[to].length === 0 || this.get(from) &lt; this.get(to))    )  }  move(from: string, to: string) {    if (!this.check(from, to)) {      throw new Error(        `invalid move ${JSON.stringify(this.state)} ${from} ${to}`,      )    }    this.state[to].unshift(this.state[from].shift())  }  get(from: string) {    return this.state[from][0]  }}const game = new HanoiGame({ a: [1, 2, 3, 4], b: [], c: [] })const steps = hanoi(4)steps.forEach((item) =&gt; game.move(...item))console.log(game.state)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="初始想法"><a href="#初始想法" class="headerlink" title="初始想法"></a>初始想法</h3><p>下面是想到的一种迭代式的非最佳走法</p><p>基本思路如下</p><ol><li>从所有操作中过滤出可用的操作，过滤条件为<ul><li>可移动</li><li>上一次移动的不是这个圆盘</li></ul></li><li>从所有可选操作中选择移动来源与目标差距最小的步骤</li><li>移动它</li><li>记录当前步骤</li><li>传递当前状态进行下一次移动</li></ol><p><img src="/resources/00007b59e8bb4315a0defa9d591bb4e8.png" alt="演示的示例"></p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function sortBy&lt;T&gt;(arr: T[], fn: (item: T) =&gt; number): T[] {  return [...arr].sort((a, b) =&gt; fn(a) - fn(b))}function fn(n: number) {  const game = new HanoiGame({    a: Array(n)      .fill(0)      .map((_, i) =&gt; i + 1),    b: [],    c: [],  })  const res: [string, string][] = []  function f(game: HanoiGame, last: number) {    if (      game.state.a.length === 0 &amp;&amp;      (game.state.b.length === 0 || game.state.c.length === 0)    ) {      return    }    const steps = (      [        ['a', 'b'],        ['a', 'c'],        ['c', 'b'],        ['b', 'c'],        ['b', 'a'],        ['c', 'a'],      ] as [string, string][]    ).filter(      ([from, to]) =&gt; game.check(from, to) &amp;&amp; game.state[from][0] !== last,    )    const list = sortBy(steps, (item) =&gt;      Math.abs(game.state[item[0]][0] ?? 0 - game.state[item[1]][0] ?? 0),    )    const step = list[0]    res.push(step)    game.move(...list[0])    f(game, game.state[step[1]][0])  }  f(game, 0)  return res}console.log(fn(1).length)console.log(fn(2).length)console.log(fn(3).length)console.log(fn(4).length)console.log(fn(5).length)console.log(fn(6).length)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><blockquote><p>这个实现有 bug，当 n = 10 时，会无限递归调用导致堆栈溢出</p></blockquote><p>一些观察到的规律</p><ul><li>如果按照最佳走法，那么第一步和汉诺塔的层级决定了最终的 target。具体规则是 <code>n % 2 = 0, target != first step to; n % 2 =1, target = first step to</code></li></ul><h3 id="使用迭代的方式计算步数"><a href="#使用迭代的方式计算步数" class="headerlink" title="使用迭代的方式计算步数"></a>使用迭代的方式计算步数</h3><p>换个思路求解步数也可以简化为尾递归的形式</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function hanoiCountByIter(n: number): number {  function f(i: number, n: number, sum: number) {    return i &gt; n ? sum : f(i + 1, n, sum * 2 + 1)  }  return f(1, n, 0)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="使用迭代的方式计算移动步骤"><a href="#使用迭代的方式计算移动步骤" class="headerlink" title="使用迭代的方式计算移动步骤"></a>使用迭代的方式计算移动步骤</h3><p>下面是一个迭代实现，基本思路</p><ul><li>基本操作，不需要临时柱的操作</li><li>复合操作，需要临时柱的操作，一般而言是需要移动两个以上的圆盘的操作</li><li>使用链表保存所有的操作，每次递归调用时，都替换其中一个复合操作为 3 个基本操作，并且修改当前操作为要替换的 3 个操作的第一个，直到遇到基本操作</li><li>如果还有下一个操作，则继续处理，否则终止迭代</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface LinkNode&lt;T&gt; {  prev?: LinkNode&lt;T&gt;  next?: LinkNode&lt;T&gt;  value: T}class LinkedList&lt;T&gt; {  first: LinkNode&lt;T&gt;  constructor(first: T) {    this.first = { value: first }  }  replace(old: LinkNode&lt;T&gt;, _nodes: T[]) {    const nodes: LinkNode&lt;T&gt;[] = _nodes.map((value) =&gt; ({ value }))    nodes.forEach((item, i) =&gt; {      item.next = nodes[i + 1]      item.prev = nodes[i - 1]    })    nodes[0].prev = old.prev    if (old.prev) {      old.prev.next = nodes[0]    } else {      this.first = nodes[0]    }    const last = nodes[nodes.length - 1]    last.next = old.next    if (old.next) {      old.prev = last    }    return nodes[0]  }  *[Symbol.iterator]() {    let current: LinkNode&lt;T&gt; | undefined = this.first    while (current) {      yield current.value      current = current.next    }  }}interface HanoiItem {  value: number  from: string  to: string  stage: string}function hanoiForIter(n: number) {  const list = new LinkedList&lt;HanoiItem&gt;({    value: n,    from: 'a',    to: 'b',    stage: 'c',  })  function f(node: LinkNode&lt;HanoiItem&gt;) {    const current = node.value    // 如果可以直接移动，则必须返回    if (current.value === 1) {      // 如果没有处理到最后一个节点，则继续处理下一个      if (node.next) {        f(node.next)      }      return    }    // 替换当前复合操作为 3 个子操作    const newNode = list.replace(node, [      {        value: current.value - 1,        from: current.from,        to: current.stage,        stage: current.to,      },      {        value: 1,        from: current.from,        to: current.to,        stage: current.stage,      },      {        value: current.value - 1,        from: current.stage,        to: current.to,        stage: current.from,      },    ])    f(newNode)  }  f(list.first)  return [...list].map((item) =&gt; [item.from, item.to] as [string, string])}console.log(hanoiForIter(4))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最终，吾辈也是用迭代的方式计算得到了结果（虽然这种方式看起来非常不优雅）</p><h2 id="处理任意状态的汉诺塔"><a href="#处理任意状态的汉诺塔" class="headerlink" title="处理任意状态的汉诺塔"></a>处理任意状态的汉诺塔</h2><p>以上都在处理从零开始移动汉诺塔，但实际上我们也可以处理任意状态的汉诺塔，以下是吾辈想到的一些处理任意汉诺塔的思路</p><ol><li>优先考虑如何将最大的圆盘移动到合适的位置，必须要考虑无法移动的情况（在无法移动的情况下应该尝试合并两外两个柱子）</li><li>优先移动小的圆盘，合并为连续的便于视为一个复合操作，最终一定能合并到一个柱子上，但不是最优步骤</li><li>穷举所有可能的步骤，得到最佳的走法（或许可以改进为动态规划）– 性能存在问题，无法排除掉大量无效解</li><li>还有一种有趣的方法是算出一个汉诺塔从 0 开始移动到另一个柱子上的所有状态，然后匹配特定状态，进而得到后续所有的步骤 – 复杂度应该是 <code>3*2^n-1</code>，这种方式需要证明一点就是某个状态一定被包含在从初始到结束的所有状态中</li></ol><p>本质上汉诺塔的最佳走法可以转换为一棵树，然后按照深度优先的方式遍历获取所有的叶子节点即可。或者以任意方式获取所有的节点及其路径（包含所有 order 的数组），然后排除所有的非叶子节点，最后以 path 排序即可（path 的排序指的是从顶级依次往下比较，有点类似于字符串的左侧优先快速比较）</p><p>有什么简单的迭代方式去处理树结构么？</p><h3 id="2-优先移动小的圆盘，合并为连续的便于视为一个复合操作，最终一定能合并到一个柱子上，但不是最优步骤"><a href="#2-优先移动小的圆盘，合并为连续的便于视为一个复合操作，最终一定能合并到一个柱子上，但不是最优步骤" class="headerlink" title="2. 优先移动小的圆盘，合并为连续的便于视为一个复合操作，最终一定能合并到一个柱子上，但不是最优步骤"></a>2. 优先移动小的圆盘，合并为连续的便于视为一个复合操作，最终一定能合并到一个柱子上，但不是最优步骤</h3><p>下面是使用第二种方式实现处理任意状态的汉诺塔</p><p>这种方式最大的优点是比较简单，因为它可以像处理一个初始的汉诺塔一样处理任意状态的汉诺塔，只需要将一些有序的圆盘移动到另一个柱子上，而不需要考虑另一个柱子的状态。</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">/** * 处理任意状态下的汉诺塔 * @param state * @returns */function hanoiAny(state: Record&lt;HanoiPos, number[]&gt;): [HanoiPos, HanoiPos][] {  function findPos(state: Record&lt;HanoiPos, number[]&gt;, value: number): HanoiPos {    const arr: HanoiPos[] = ['a', 'b', 'c']    const res = arr.map((i) =&gt; state[i][0])    return arr[res.indexOf(value)]  }  function findContinuousCount(arr: number[]): number {    function f(i: number, last: number): number {      return arr[i] !== last + 1 ? i : f(i + 1, arr[i])    }    return f(1, arr[0])  }  function calcSteps(    n: number,    from: HanoiPos,    to: HanoiPos,    stage: HanoiPos,  ): [HanoiPos, HanoiPos][] {    if (n === 1) {      return [[from, to]]    }    return calcSteps(n - 1, from, stage, to)      .concat(calcSteps(1, from, to, stage))      .concat(calcSteps(n - 1, stage, to, from))  }  function findStage(from: HanoiPos, to: HanoiPos): HanoiPos {    const arr: HanoiPos[] = ['a', 'b', 'c']    return arr.find((i) =&gt; i !== from &amp;&amp; i !== to)!  }  function move(    state: Record&lt;HanoiPos, number[]&gt;,    n: number,    from: HanoiPos,    to: HanoiPos,    stage: HanoiPos,  ): Record&lt;HanoiPos, number[]&gt; {    return {      [to]: state[from].slice(0, n).concat(state[to]),      [from]: state[from].slice(n),      [stage]: state[stage],    } as Record&lt;HanoiPos, number[]&gt;  }  function count(state: Record&lt;HanoiPos, number[]&gt;): number {    const arr: HanoiPos[] = ['a', 'b', 'c']    return arr.map((i) =&gt; state[i].length).reduce((a, b) =&gt; a + b)  }  function iter(state: Record&lt;HanoiPos, number[]&gt;): [HanoiPos, HanoiPos][] {    // 寻找小的连续圆盘    const from = findPos(state, 1)    const n = findContinuousCount(state[from])    // 判断是否到最终状态了    // 返回所有步骤    if (n === count(state)) {      return []    }    // 否则移动所有连续的圆盘到另一个柱子    // 找到移动的目标    const to = findPos(state, state[from][n - 1] + 1)    const stage = findStage(from, to)    // 移动    return calcSteps(n, from, to, stage).concat(      iter(move(state, n, from, to, stage)),    )  }  return iter(state)}const state = { a: [1, 4], b: [2], c: [3, 5] }const game = new HanoiGame(state)const steps = hanoiAny(state)steps.forEach((item) =&gt; game.move(...item))console.log(game.state) // { a: [], b: [], c: [ 1, 2, 3, 4, 5 ] }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>以上方法都是指数增长 <code>2^n-1</code>，或许有某种线性增长的方法？</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function hanoiCount(n: number): number {  return n === 1 ? 1 : hanoiCount(n - 1) * 2 + 1}console.log(  Array(64)    .fill(0)    .map((_, i) =&gt; hanoiCount(i + 1)),)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><img src="/resources/f6ee862e41844284a6ca0bbb1513ccdc.png" alt="汉诺塔层级-移动次数关系"></p><h3 id="3-穷举所有可能的步骤，得到最佳的走法（或许可以改进为动态规划）–-性能存在问题，无法排除掉大量无效解"><a href="#3-穷举所有可能的步骤，得到最佳的走法（或许可以改进为动态规划）–-性能存在问题，无法排除掉大量无效解" class="headerlink" title="3. 穷举所有可能的步骤，得到最佳的走法（或许可以改进为动态规划）– 性能存在问题，无法排除掉大量无效解"></a>3. 穷举所有可能的步骤，得到最佳的走法（或许可以改进为动态规划）– 性能存在问题，无法排除掉大量无效解</h3><p>使用穷举法实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">/** * 使用穷举的方式尝试所有可能的走法，找出最优解 * 深度优先递归的问题是前期会做大量浪费的计算，实际上最优解可能并不在前面，或许应该尝试一下广度优先递归 * @param state * @returns */export function hanoiAnyByReduce(  state: Record&lt;HanoiPos, number[]&gt;,): [HanoiPos, HanoiPos][] {  let min = hanoiAny(state)  function isComplete(state: Record&lt;HanoiPos, number[]&gt;): boolean {    return Object.values(state).filter((v) =&gt; v.length !== 0).length === 1  }  const steps: [HanoiPos, HanoiPos][] = [    ['a', 'b'],    ['a', 'c'],    ['b', 'a'],    ['b', 'c'],    ['c', 'a'],    ['c', 'b'],  ]  function calcSteps(    state: Record&lt;HanoiPos, number[]&gt;,    prev: [HanoiPos, HanoiPos][],  ): [HanoiPos, HanoiPos][] {    const game = new HanoiGame(state)    return steps.filter((step) =&gt; game.check(...step))  }  function move(    state: Record&lt;HanoiPos, number[]&gt;,    from: HanoiPos,    to: HanoiPos,  ): Record&lt;HanoiPos, number[]&gt; {    return {      ...state,      [to]: state[from].slice(0, 1).concat(state[to]),      [from]: state[from].slice(1),    }  }  function isSuccess(steps: [HanoiPos, HanoiPos][]): boolean {    if (steps.length &lt; 2) {      return true    }    const last = steps[steps.length - 1]    const prev = steps[steps.length - 2]    if (prev[0] === last[1] &amp;&amp; prev[1] === last[0]) {      return false    }    return true  }  const arr: string[] = []  function iter(    state: Record&lt;HanoiPos, number[]&gt;,    prev: [HanoiPos, HanoiPos][],  ) {    // 判断当前是否出现了环    if (!isSuccess(prev)) {      return    }    const prevString = JSON.stringify(prev)    arr.push(prevString)    // 判断当前步数是否已经超过了最佳步数（或者之后可以使用 map 判断相同状态是否已经有更好的走法了）    if (prev.length &gt;= min.length) {      return    }    if (isComplete(state)) {      if (prev.length &lt; min.length) {        min = prev      }      return    }    // 否则找到所有可行步骤，执行它们    calcSteps(state, prev).forEach((step) =&gt; {      iter(move(state, ...step), [...prev, step])    })  }  iter(state, [])  // writeFileSync(path.resolve(__dirname, 'test.json'), JSON.stringify(arr))  return min}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="1-优先考虑如何将最大的圆盘移动到合适的位置，必须要考虑无法移动的情况（在无法移动的情况下应该尝试合并两外两个柱子）"><a href="#1-优先考虑如何将最大的圆盘移动到合适的位置，必须要考虑无法移动的情况（在无法移动的情况下应该尝试合并两外两个柱子）" class="headerlink" title="1. 优先考虑如何将最大的圆盘移动到合适的位置，必须要考虑无法移动的情况（在无法移动的情况下应该尝试合并两外两个柱子）"></a>1. 优先考虑如何将最大的圆盘移动到合适的位置，必须要考虑无法移动的情况（在无法移动的情况下应该尝试合并两外两个柱子）</h3><p>使用第一种方法实现，但最终结果和穷举法相同，似乎这就是最优解</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">/** * 处理任意状态下的汉诺塔 * 优先考虑如何将最大的圆盘移动到合适的位置，必须要考虑无法移动的情况（在无法移动的情况下应该尝试合并两外两个柱子） */export function hanoiAnyByDepth(  state: Record&lt;HanoiPos, number[]&gt;,  to: HanoiPos,): [HanoiPos, HanoiPos][] {  function findPosByNumber(    state: Record&lt;HanoiPos, number[]&gt;,    n: number,  ): HanoiPos {    return Object.entries(state).find(([_k, v]) =&gt;      v.includes(n),    )?.[0] as HanoiPos  }  function isMove(    state: Record&lt;HanoiPos, number[]&gt;,    from: HanoiPos,    to: HanoiPos,    n: number,  ) {    const game = new HanoiGame(state)    return game.get(from) === n &amp;&amp; game.check(from, to)  }  function move(    state: Record&lt;HanoiPos, number[]&gt;,    steps: [HanoiPos, HanoiPos][],  ): Record&lt;HanoiPos, number[]&gt; {    const game = new HanoiGame(JSON.parse(JSON.stringify(state)))    steps.forEach((step) =&gt; game.move(...step))    return game.state  }  function findStage(from: HanoiPos, to: HanoiPos): HanoiPos {    const arr: HanoiPos[] = ['a', 'b', 'c']    return arr.find((i) =&gt; i !== from &amp;&amp; i !== to)!  }  function iter(    state: Record&lt;HanoiPos, number[]&gt;,    from: HanoiPos,    to: HanoiPos,    stage: HanoiPos,    n: number,  ): [HanoiPos, HanoiPos][] {    if (from === to) {      const nextFrom = findPosByNumber(state, n - 1)      return iter(state, nextFrom, to, findStage(nextFrom, to), n - 1)    }    // 移动 from =&gt; to 的一个指定值    // 如果可以直接移动，则直接移动    if (isMove(state, from, to, n)) {      return [[from, to]]    }    // 否则找到上面影响移动的最大圆盘到临时柱，递归调用该方法    const values = [...state[from], ...state[to]].sort((a, b) =&gt; a - b)    const nextN = values[values.indexOf(n) - 1]    const nextForm = findPosByNumber(state, nextN)    // 应用上面的移动步骤，然后递归调用该方法    // 移动上面阻碍它移动的圆盘到临时柱    const before = iter(      state,      nextForm,      stage,      findStage(nextForm, stage),      nextN,    )    let nextState = move(state, before)    // 移动当前圆盘    const current = iter(nextState, from, to, stage, n)    nextState = move(nextState, current)    const next = findPosByNumber(nextState, n - 1)    // 继续下一次迭代移动上面的一个圆盘    const after = iter(nextState, next, to, findStage(next, to), n - 1)    return [...before, ...current, ...after]  }  const initN = Object.values(state).flat().length  const initForm = findPosByNumber(state, initN)  return iter(state, initForm, to, findStage(initForm, to), initN)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>使用基本的单元测试验证它是有效的</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">describe('hanoiAnyByDepth', () =&gt; {  it('basic', () =&gt; {    const state: Record&lt;HanoiPos, number[]&gt; = {      a: [1, 3, 5],      b: [],      c: [2, 4, 6],    }    console.log(hanoiAnyByDepth(state, 'c').length)    console.log(hanoiAny(state).length)    const game = new HanoiGame(state)    hanoiAnyByDepth(state, 'b').forEach((step) =&gt; game.move(...step))    expect(game.state['b'].length).toBe(6)  })})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>大多数情况下，它计算得到的步数要比使用方法 2 得到的步骤少得多，我们可以验证这一点</p><blockquote><p><code>upset</code> 是一个将汉诺塔状态随机打乱的函数</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function findMax(state: Record&lt;HanoiPos, number[]&gt;) {  const pos: HanoiPos[] = ['a', 'b', 'c']  return sortBy(    pos.map((k) =&gt; ({      k,      v: state[k][state[k].length - 1] ?? 0,    })),    (item) =&gt; -item.v,  )[0].k}it('findMax', () =&gt; {  console.log(findMax({ a: [1, 3], b: [], c: [2, 4] }))  console.log(findMax({ a: [1, 2, 3, 4], b: [], c: [] }))})it('perf', async () =&gt; {  const list = Array(100)    .fill(0)    .map(() =&gt; {      const state = upset(10)      return {        first: hanoiAny(state).length,        second: hanoiAnyByDepth(state, findMax(state)).length,      }    })  await mkdirp(path.resolve(__dirname, '.temp/'))  await writeJson(path.resolve(__dirname, '.temp/test.json'), [    {      name: 'hanoiAny',      type: 'line',      data: list.map((item) =&gt; item.first),    },    {      name: 'hanoiAnyByDepth',      type: 'line',      data: list.map((item) =&gt; item.second),    },  ])})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>下面是测试用例的结果的可视化图表</p><p><img src="/resources/77f4b3628080446a99c703301062bec2.png" alt="1654530232450"></p><h3 id="4-算出一个汉诺塔从-0-开始移动到另一个柱子上最佳步骤的所有状态，然后匹配特定状态，进而得到后续所有的步骤"><a href="#4-算出一个汉诺塔从-0-开始移动到另一个柱子上最佳步骤的所有状态，然后匹配特定状态，进而得到后续所有的步骤" class="headerlink" title="4. 算出一个汉诺塔从 0 开始移动到另一个柱子上最佳步骤的所有状态，然后匹配特定状态，进而得到后续所有的步骤"></a>4. 算出一个汉诺塔从 0 开始移动到另一个柱子上最佳步骤的所有状态，然后匹配特定状态，进而得到后续所有的步骤</h3><p>实际上不可能，事实上可以找到反例，例如以下状态就不会在最佳走法的任意一步状态中</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const state: Record&lt;HanoiPos, number[]&gt; = {  a: [1, 3],  b: [],  c: [2, 4],}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>验证它也很简单</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function eq(  a: Record&lt;HanoiPos, number[]&gt;,  b: Record&lt;HanoiPos, number[]&gt;,): Record&lt;HanoiPos, HanoiPos&gt; | false {  const arr: HanoiPos[] = ['a', 'b', 'c']  const bs = arr.reduce((res, i) =&gt; {    res[JSON.stringify(b[i])] = i    return res  }, {} as Record&lt;string, HanoiPos&gt;)  const res: (HanoiPos | null)[] = arr.map(    (i) =&gt; bs[JSON.stringify(a[i])] ?? null,  )  if (res.includes(null)) {    return false  }  return res.reduce((res, v, i) =&gt; {    res[arr[i]] = v!    return res  }, {} as Record&lt;HanoiPos, HanoiPos&gt;)}it('eq', () =&gt; {  expect(    eq({ a: [1, 3], b: [2, 4], c: [] }, { a: [1, 3], b: [2, 4], c: [] }),  ).toBeTruthy()  expect(    eq({ a: [1, 3], b: [2, 4], c: [] }, { a: [], b: [2, 4], c: [1, 3] }),  ).toBeTruthy()  expect(    eq({ a: [1, 3], b: [2, 4], c: [] }, { a: [2, 4], b: [], c: [1, 3] }),  ).toBeTruthy()  expect(    eq({ a: [1, 3], b: [2, 4], c: [] }, { a: [2], b: [], c: [1, 3] }),  ).toBeFalsy()})it('hanoiByStream', () =&gt; {  const state: Record&lt;HanoiPos, number[]&gt; = {    a: [1, 3],    b: [],    c: [2, 4],  }  const game = new HanoiGame({    a: [1, 2, 3, 4],    b: [],    c: [],  })  const i = hanoi(4).findIndex((step) =&gt; {    const res = eq(game.state, state)    game.move(...step)    return res  })  console.log(i)})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>吾辈最终也实现了一个汉诺塔的在线小游戏，参考：<a href="https://rxliuli.github.io/hanoi/">https://rxliuli.github.io/hanoi/</a></p><blockquote><p>后续还会写几篇吾辈觉得有意思的技术点，包括 cons 如何无中生有的构造数据结构、流与延迟计算、lisp 的解释器和运行时等。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="算法" scheme="https://blog.rxliuli.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>浅评漫画《指尖奶茶》</title>
    <link href="https://blog.rxliuli.com/p/325808f141be4eca927d9a02cd0e3997/"/>
    <id>https://blog.rxliuli.com/p/325808f141be4eca927d9a02cd0e3997/</id>
    <published>2022-04-23T13:59:15.226Z</published>
    <updated>2022-04-23T16:19:41.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>早前在看网络小说《腹黑三无少女日记》时，提到了漫画《指尖奶茶》这部漫画。虽然一直想看，但由于作品型式（漫画）的原因难以收集存储到本地，所以真正一口气看完也是趁着今天周六休息的时候。与之前的 galgame《近月少女的礼仪》的小仓朝日、动画《放浪男孩》的小鸟修一相比，由纪并没有那么善良，却有着相同程度的可爱，但这就足够了，男孩纸什么的只要萌就好啦！不是么？</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%B0%91%E5%B9%B4%E7%BE%8E%E7%9C%89">wiki</a></p></blockquote><p>里面大致上讲述了一个由纪在一次偶然的女装后，迷上了自己这种可爱的姿态，之后与青梅竹马和学校里的班上同学之间复杂的感情故事，里面包含了大量的奇怪的元素。借用书籍简介：“《指尖奶茶》又名《少年美眉》，是一部包含女装癖、幼驯染、校园恋、百合、伪百合、萝莉控、御姐、姐弟不纯、邻家大叔、还有锁骨控等诸多题材的另类漫画”。</p><p><img src="/resources/274324aef0ed4bb0aac8f27e93a151be.png" alt="1650725976160"></p><h2 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h2><ul><li>由纪：喜欢女装的男孩子，想到什么就去做，但想法有些极端。与贾宝玉一样有“女孩子都是水做的，男孩子都是泥做的”同类思想，认为女孩子纯净无暇，并基于女装的形象创造了小雪这个女孩子的人格。但自始至终，他并不是 mtf，而是一个喜欢上了女装的自己的男孩子。</li><li>小雪：理想化的女性形象，没有人会讨厌她，有点类似于男性心中的 <strong>阿尼玛</strong> 形象</li><li>小左：小两岁的青梅竹马，一开始与由纪之间更像是父女之间的关系，但随后逐渐成长（各种意义上）与独立，与由纪的主动关系反转，最终与由纪结合在一起。在目睹到最亲的两个人由纪（与水面）与父亲（与未纪）都抛弃自己后曾经想过自杀，幸被加贺见救下，那个时候，少女一下子就长大了。</li><li>水面：由于女装主动交往，她对由纪打开了心结，随后陷入了与他的感情之中，甚至有些斯德哥尔摩情结。在两次情感崩坏后，最终与由纪分离。</li><li>加贺见：小左的同班同学，对小左抱有爱恋，但没有真正的到过回应。有点像是魔卡少女樱作品中的知世，始终默默地在背后支持她。</li><li>未纪：由纪的姐姐，经常会有一些暧昧的举动，喜欢小左的爸爸，希望替代小左已故的妈妈，不能接受由纪与小左之外的人结合。</li><li>亘：由纪的死党，对小雪一见钟情，即便在知道她的真实身份后，也对其念念不忘，与由纪接吻过。</li><li>由纪的爸爸：小时候出轨导致与由纪母亲分离，基本上不在家照顾孩子，小时候经常将孩子托付给邻居。</li><li>小左的妈妈：小时候亡故，经常照顾小左和由纪，被由纪视为完美的女性。</li><li>摄像店老板：开启由纪女装的元凶祸首</li></ul><p><img src="/resources/a9379010701c481490db6836744f2b72.svg" alt="人物关系图.drawio.svg"></p><h2 id="成长过程-x2F-心路历程"><a href="#成长过程-x2F-心路历程" class="headerlink" title="成长过程/心路历程"></a>成长过程/心路历程</h2><p>小时候父亲出轨与母亲闹掰，对男性有着不好的印象。<br>中学时在一次偶然的情况下替代模特姐姐穿上婚纱拍摄照片，从此喜欢上了这样的自己。– “那就像是魔法”<br>上高中后放弃了足球，因为害怕膝盖和脸受伤导致无法女装。<br>认为水面是美丽的女孩子，所以在无法通过男孩子的身份与之交流的情况下，女装之后与之交流，并被一眼识破，但也让水面对她敞开心扉。<br>在亘对她告白后，他是这样说的：“因为我为了这样放弃了其他事物，所以想要我的话，就放弃其他的东西吧，这样我们才能对等的交往。”<br>随着与水面关系的进展，他希望水面能带上假发替代小雪，因为自己如果与水面在一起的话会让男性的部分变得强烈，便无法再拥有小雪，但结果导致第一次感情崩坏。<br>随着年龄渐增，他长出了喉结，也开始了变声，性欲望也开始变大。他对男性部分的欲望感到讨厌，也害怕自己以后无法女装，于是通过女装来逃避现实，使用相机疯狂摄影，希望留存住小雪的存在。<br>在故事的结尾，当小左说自己以后的五年、十年，还要继续成长时，他却希望小左就这样就好，但小左却无法理解。他很害怕变化，不管是自己逐渐变得不适合女装，还是小左成长之后自己能否配得上她，他都感到害怕。</p><p><img src="/resources/79555060818f498eafe80079edff5fa2.png" alt="1650729899498"></p><h2 id="共鸣"><a href="#共鸣" class="headerlink" title="共鸣"></a>共鸣</h2><p>看这部漫画确实会有一些共鸣，例如在高中时期也曾模仿过女孩子可爱的行为举止，尽管只是网络上的沟通文法。<br>工作之后也有购买和穿着一些女装，尽管也有 kigurumi 这种 cosplay 的服装。<br>在知道 mtf 的存在后也曾考虑过这件事，但后来由于各种现实的原因放弃了。总的来说，在与一些 mtf 接触之后，对其的形象由传统认知中的人妖发生了很大的改变。</p><h2 id="不合理之处"><a href="#不合理之处" class="headerlink" title="不合理之处"></a>不合理之处</h2><p>很难想象，作为最了解由纪内心黑暗面的人，水面居然能一直不离不弃。<br>出于故事性考虑，漫画中有许多次都已经要生孩子的时候却被打断的情况，包括和小左在小左家被水面打断，和水面在由纪家被未纪撞见（并扬言下次再来就杀了她）<br>总览整部漫画，由纪都在纠结是否要为了小左或水面放弃女装，或者说心目中理想的女孩子形象具现化。但前期顶多可以说是优柔寡断，但后面确实有点花心大萝卜了。</p><h2 id="结局"><a href="#结局" class="headerlink" title="结局"></a>结局</h2><p>最终确实很突兀，由纪突然就回心转意，决定与水面了断感情，并在修学旅行时与小左结合。</p><h2 id="有趣的部分"><a href="#有趣的部分" class="headerlink" title="有趣的部分"></a>有趣的部分</h2><p>文化祭上亘看到了由纪的女装之后的发言（但居然没认出来是小雪）</p><p><img src="/resources/c6952f5c6b4d4d7a899d2369fecc932a.png" alt="1650729069831"></p><p>两个人的修学旅行，看到这里真的要笑死了，互相伤害呀</p><p><img src="/resources/ca3b239c2fb34a4e83ba0772bf0fefdc.png" alt="1650727560675"><br><img src="/resources/834ef4a61d0d482f9045318b05278b0d.png" alt="1650727566373"><br><img src="/resources/fe07a7d9404b4ea2bfdb5c0b11bab780.png" alt="1650727572741"></p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="个人" scheme="https://blog.rxliuli.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-低智商社会</title>
    <link href="https://blog.rxliuli.com/p/c987819dbdbf46d48ffbdd0d5c78b80b/"/>
    <id>https://blog.rxliuli.com/p/c987819dbdbf46d48ffbdd0d5c78b80b/</id>
    <published>2022-04-22T14:02:31.427Z</published>
    <updated>2022-04-30T15:16:56.741Z</updated>
    
    <content type="html"><![CDATA[<p>为什么我们的企业家都忌讳向亚洲国家学习，没有人质疑过为什么日本不能借鉴中国好的东西（比如说向民众转让更多的权利等）</p><p>【批注】本质上并非如此，目前更加封闭专制了</p><hr><p>Q：日本股市有什么理由能保持上涨？</p><p>【批注】话虽如此，我也确实不了解股市。但我相信，经济危机会影响全球，不可能有人能独善装身。</p><hr><p>Q：“引进外资有害，所以要维护日本本土企业的利益。”我想这就是现在大家公认的“日本的常识”，那么请从经济全球化的角度来思考一下这种说法有什么问题。</p><p>【批注】如果一味维护本土企业，那世界上就没人愿意投资了，因为风险太高，完全没有市场规律可言。<br>就像现在的中国。。。</p><hr><p>对于那种简单地把外资等同于危害的想法，不管从哪个角度来说都是让人无法理解的。</p><p>【批注】与把美国、日本、台湾、苏联作为假想敌也是一榉，无非是想营造民族主义罢了。</p><hr><p>“智商衰退”导致的“政府无能”<br>经济产业省在月例经济报告中宣布“经济恢复已经达到了一定程度”，这表明他们已经认识到经济不再恢复，这就意味着今后的经济状况还会倒退。</p><p>【批注】真是春秋笔法</p><hr><p>Q：资源匮乏的日本怎样才能变成能源大国？请给个建议。</p><p>【批注】核电，核能是人类目前已知最高效清洁（只要控制的好）的能源，不能因为危险就放弃使用。</p><hr><p>即便没有利息也要把钱继续存进银行<br>Q：你愿意把钱存进利率为 0.1%的银行，还是利率为 5%的银行？</p><p>【批注】毫无疑向是后者。</p><hr><p>偏差值教育</p><p>【批注】似乎是和中国的教育系统中以分数决定一切差不多</p><hr><p>Q：对于未来，你有不安和担心吗？如果回答“有”，那么你有什么具体的对策吗？</p><p>【批注】对于当前状态，有很多不满意的地方，但只有一些模糊的想法，实际的行动却迟迟没有发生，例如想要出国离开这里，但没有切实可行的计划，比如去哪儿？需要做什么？有什么优缺点？</p><hr><p>所谓丧葬费，如果在活着的时候自己规定好标准，那么至少可以节约 1/3，而不会造成不必要的浪费。</p><p>【批注】这确实是一条明确可行的建议，之后了解一下吧，作个计划之类的也好</p><hr><p>Q：海外的投资家是通过何种特殊的渠道买到商业情报的呢？</p><p>【批注】是吾辈的知识盲区了</p><hr><p>和“智商衰退”密切相关的源泉征收制度<br>外国人了解了日本人的生活后，最感到惊奇的就是日本的工薪阶层把工资全数交给妻子，而丈夫只从中获得零花钱的生活方式。</p><p>【批注】这确实非常奇怪，难道不应该是共有储蓄么？两者的义务和权力应该是对等的，而不是由一方”施舍”。<br>Pass: 吾辈的同事就有这种现像，吾辈很难理解</p><hr><p>Q：在 2005 年的众议院选举中投票给自民党的人，在 2007 年的参议院选举中又投票给民主党，他们之所以会这样做，是因为他们什么都不会考虑吗？</p><p>【批注】他们不是坏，而是蠢。在信息来源受限的情况下，舆论被操纵，所以只能看到眼前的利益。</p><hr><p>从理论上来说，一件事情所面临的选择越多，越会引发人们深入的思考。因为要从很多选项中选出一个来，需要综合考虑问题，在此基础上才能作判断。但是，这种情况在心理学上却恰恰相反，心理学上认为面临的选择越多，就越容易引发简单的判断。</p><p>【批注】但是想要深入的了解和尝试，必须将了选项控制在少数几个。例如开发时技术调研，不可能深入尝试每一个技术栈。</p><hr><p>现行的教育体制从不问“为什么”，只会问“〇是正确的还是 X 是正确的”。不管怎样都是在“〇”和“X”中做一个二选一的选择。</p><hr><p>Q：反对小泉将邮政民营化的人（反对势力）就是正确的吗？</p><p>【批注】不，一方是错的，不代表另一方就是对的，这是典型的二极管（非此即彼）的思想。二<br>就像总有人认为别人过的不好自己就能过的相对更好一样，即所谓的“即使自己生活在很底层，但还是有大国子民的感觉”（来自左耳朵耗子）</p><hr><p>Q：需要调査的问题，如果全部能用 Google 搜索到答案，那么人们的思考能力会不会因此而衰退，从而变成笨蛋呢？</p><p>【批注】信息不等于知识，诚然，现代搜索引擎已经非常强大，几乎可以获取到任何信息，但它并不等于你的知识。它只是一件工具，将以前手工查阅变成了网络搜索，提高了信息共享和查阅效率，但也仅此而以。</p><hr><p>Q：在今后的社会中，网络有没有可能彻底消失呢？</p><p>【批注】除非人类毁灭，否则网络不可能消失（或者说顶多换个表现形式，例如从 Web 换成了 App）。</p><hr><p>假如你输入的是垃圾，那么输出的也只能是垃圾</p><p>【批注】经典名言</p><hr><p>如果读一本书需要 1 个小时的时间，那么就应该花大约 5 个小时的时间来认真思考这本书到底写了什么？它对于我自身有什么意义？它对于我们公司有什么意义？</p><p>【批注】确实应该如此，一本接一本的看下去，没有深入思考也是不行的。</p><hr><p>我都会让学生读完一本书后，大家一起来作讨论</p><p>【批注】或许我也欠缺一个可以讨论的社区？或许深圳会有吧</p><hr><p>当然，即便是这样，黑客还是会通过其他方式来袭击网站。如果是这样的话，我就会采取亲自和他见面的方式，问问他本人“为什么要这样做？”</p><p>【批注】具然能够查到黑客的真实身份？怎么可能，这还真的是黑客么？</p><hr><p>必须遵循这样一种方法，那就是在得到一些信息后，首先要进行思考并提出疑问，其次再和自己所拥有的信息进行对比，然后取其精华去其糟粕。如果能有效地进行这个过程，那么就能在自己的脑海中构建一个信息框架。再强调一遍，最重要的是能够将信息进行有效的整理。</p><hr><p>Q：无志向年轻人的增多会对日本经济产生怎样的影响呢？</p><p>【批注】这让吾辈想到了国内的躺平，但这并不是意味着放弃变的更好，而是因为自己改变不了大环境，所以只能不合作的方式来反抗不公平的制度。毕竟一旦结婚生子就要辛苦一生（房子，车子，教育，医疗），还不如一个人轻松快活。</p><hr><p>Q：你认为“偏差值教育”对日本产生了怎样的影响？</p><p>【批注】不太了解，或许和国内的分数绝对论一样？</p><hr><p>全然不同的“手机一代”<br>手机在其他国家虽然也很时兴，但很少有像日本现在的手机那样，具有如此多的特殊功能。</p><p>【批注】这应该是错误的，现代手机都有很多功能，而不仅仅是在日本才这样。</p><hr><p>印度和中国逐渐涌现出了优秀人才<br>Q：日本的现在和未来到底需要什么样的人才？</p><p>【批注】了解现代世界并且能够自主思考解决问题的人</p><hr><p>Q：能够在 21 世纪立足的是“拥有思考能力但专业知识不足的人”，还是“没有思考能力但拥有很多专业知识的人”？</p><p>【批注】可以说必然是前者，因为专业知识一直在变化，所以只有学习能力强才能保证更被社会需要。</p><hr><p>YouTube 上甚至有一段视频称，“到 2015 年，中国讲英语的人数将会超过美国”。</p><p>【批注】现在这个视频可以证伪了。本质上中国的英语或者说所有学科都是为分数服务的，与日本的偏差值教育有异曲同工之妙。</p><hr><p>作为课题解决父母和孩子的交谈问题<br>所以，归根结底，解决这个问题的关键就是必须对父母们进行再教育。</p><p>【批注】所以，根本原因是为人父母者，并不需要考试或者证书之类。</p><hr><p>地方国立大学已经起不到作用了<br>这在世界上很罕见。</p><p>【批注】并不罕见，国内自从计算机行业流行之后，许多人都在大学结束后快速培训（一般是三个月到半年）学习相关技能，然后参加相关工作。</p><hr><p>谁都有“地头力”，而且越锻炼越强<br>为什么我要问高中时候的事呢？因为大学里的时间很充裕，花时间做一些自己感兴趣的或者有意义的事情是理所当然的。可是高中的大部分学生都把时间花在了学习上，大部分学生为了升入一流大学而一味地学习。所以我才问高中时代的事情。</p><p>【批注】吾辈喜欢在面试中向面试人问‘’在闲余时间会做些什么开发相关的事情么？”是一样的。</p><hr><p>即使中国很关注教育，也比不上日本的教育。</p><p>【批注】就像三体中降临派所言：”我们不知道外星人怎么样，但我们知道人类”，这句话在这里也很合适。作者不了解中国教育的现状，但了解日本的，所以才会提出这样的问题。但实际上，中国的教育系统一样是烂透了，更别说现在数学物理教材中都夹杂着乱七八糟政治相关的（洗脑）内容了。</p><hr><p>Q：是不是有人从日本变成“低智商社会”的过程中获益呢？</p><p>【批注】自然如此，愚民政策向来对专制政府和权贵人士有利</p><hr><p>日本人没有原则、没有理念，但是比这些更严重的应该是意识问题。日本人的意识和其他民族的意识有很大差异。</p><p>【批注】整个东亚文化圈都有类似的问题</p><hr><p>不仅“集体智商”低，“集体记忆力”也低</p><p>【批注】国内集体记忆更低，记吃不记打。端起碗来吃饭，搁下筷子骂娘。</p><hr><p>Q：日本政府最终会怎样处理巨额的借款呢？</p><p>【批注】甩锅</p><hr><p>成为“觉醒的个人”、“承担风险的人”！<br>Q：我们怎样才能摆脫“低智商社会的圈套”？</p><p>【批注】提高信息来源质量，永不停止的学习与思考。就实践上而言，设定目标是最好的。</p><hr><p>俄罗斯的普京</p><p>【批注】已经是独裁者了</p><hr><p>Q：集体智商不高的国家，今后将怎样？</p><p>【批注】不过是再次陷入盛衰轮回的怪圈之中罢了</p><hr><p>何谓“没有素质”？<br>Q：听到“素质”这个词，你会联想到什么？</p><p>【批注】文化教养，认知逻辑。</p><hr><p>你甘愿做“低智商社会”中的一员吗？<br>Q：读了这本书，你今后会采取什么样的行动？</p><p>【批注】或许会移民吧？但日本可能不太适合了，但还是想去看一下，然后决定去欧洲或加拿大安度余生吧</p><hr><p>现在是网络万能的时代，所以没必要读书。</p><p>【批注】这是错误的，网络信息的时效性、层次深度与系统化都比不上优秀的书籍</p><hr><p>超级喜欢用搜索引擎寻找一切答案，但如果在 Google 上找不到答案就会马上放弃眼前问题，丝毫不会去主动思考。</p><p>【批注】确实会有这种情况，但也有一些独立思考的内容（笔记）</p><hr><p>虽然对于一些搞笑的肥皂剧和综艺娱乐节目有所鄙视，但还是会随大流准时收看。</p><p>【批注】不看。因为输入是垃圾，输出也不会是垃圾！</p><hr><p>今天赞成这个做法，明天又赞成那个做法，不管怎样，总有做法会正确，所以自己的意见无关紧要。</p><p>【批注】并不是，有自己的认知和观点很重要，因为这需要思考才能得到。</p><hr><p>即使银行的利率为零，也还是会毫不犹豫地将辛苦挣来的薪水存进去，而懒得去寻找其他高收益的投资途径。</p><p>【批注】或许以后会考虑吧，但目前工作收入仍有 50%的年增长，所以暂时这并不太重要。</p><hr><p>忌讳谈论其他国家的繁荣现状，并对这些国家的发展嗤之以鼻。</p><p>【批注】不，假若没有看见光明，我本可以忍受黑暗，比烂是永远没有下限的。</p><hr><p>认为学校老师教给自己子女的东西都是时代所需要的，而作为父母的自己则把子女外包给了学校，从而主动放弃了教育子女的责任。</p><p>【批注】并不是，父母的经验之谈往往是过时的，如果为人父母自己都管不好孩子，凭什么认为交给社会、政府，学校就能管好呢？只管生不管养的父母就不该存在！</p><hr><p>面对自己水平低下的英语、IT、金融知识毫不担心，从没有主动学习这些知识的想法和动力。</p><p>【批注】不，英语决定认知和交流边界，IT 是现代世界必须的工具，而经济（股票，基金）则关乎个人财产的技能。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="读书" scheme="https://blog.rxliuli.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Code Review 漫谈 02</title>
    <link href="https://blog.rxliuli.com/p/f34835c49a8647a6b50ad61c6f08eea5/"/>
    <id>https://blog.rxliuli.com/p/f34835c49a8647a6b50ad61c6f08eea5/</id>
    <published>2022-04-13T02:37:06.552Z</published>
    <updated>2022-04-13T11:43:39.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>继上次的 code review 之后，吾辈这两天在迁移 vpn ip =&gt; domain 的过程中，需要帮忙修改一些之前写死的 vpn ip 地址为动态从后端获取，所以有幸见到了一些有趣的代码，便于此继续分享一下。</p><ul><li>在 vue3 项目中仍然写 vue2 的 options 组件</li><li>完全没有分层的概念，想到哪儿写到哪</li><li>神奇的获取 url 参数的方式及变量命名</li><li>错误处理仅仅只是打印在控制台</li></ul><p><img src="/resources/96422f4f133a4b69abadbd3dc984a615.png" alt="1649819326108"></p><h2 id="在-vue3-项目中仍然写-vue2-的-options-组件"><a href="#在-vue3-项目中仍然写-vue2-的-options-组件" class="headerlink" title="在 vue3 项目中仍然写 vue2 的 options 组件"></a>在 vue3 项目中仍然写 vue2 的 options 组件</h2><blockquote><p>反正 vite 支持，又不是不能跑，反正人和代码有一个能跑就行！</p></blockquote><p>这是一个 3 个月前创建的新项目，使用 vite + vue3，但在某些组件（可能是复制的代码）仍然使用 vue2 的形式。</p><p><img src="/resources/e9257d15a5014c1d87c29d02fa000d21.png" alt="1649818451304"></p><p>甚至完全不遵守一般约定，并且强制忽略 eslint 的检查，真是让人看了就想打人！</p><p><img src="/resources/1c7272988a1340a99c79ff8a055c1bd7.png" alt="1649818512960"></p><h2 id="神奇的获取-url-参数的方式及变量命名"><a href="#神奇的获取-url-参数的方式及变量命名" class="headerlink" title="神奇的获取 url 参数的方式及变量命名"></a>神奇的获取 url 参数的方式及变量命名</h2><blockquote><p>相比于浏览器的代码我更信任自己的，没听过 left-pad 事件么？除了自己写的代码之外，没人的代码是可靠的！</p></blockquote><p>吾辈寻思着，不是已经有 <code>URLSearchParams</code> 这么好用的浏览器原生 api 了么？为什么还要自己使用正则表达式匹配 url 参数，而且还匹配了两次。</p><p><img src="/resources/105a8560c07b48b3b83925d23fd56c30.png" alt="1649817799386"></p><p>而且可以看到，url 参数字段名也使用了单独的变量，并且字段的值与名字仅有一个字符之差。</p><h2 id="完全没有分层的概念，想到哪儿写到哪"><a href="#完全没有分层的概念，想到哪儿写到哪" class="headerlink" title="完全没有分层的概念，想到哪儿写到哪"></a>完全没有分层的概念，想到哪儿写到哪</h2><blockquote><p>你说这里是数据层，不应该放 ui 层的代码？管他是什么层，我司自有代码规范，管它社区规范如何！</p></blockquote><p>不在乎哪些应该放在 ui 层，哪些应该分离到数据层，或者说，根本没有这种概念，就是能 run 就行了。</p><p><img src="/resources/e0d16a41c46442cc9aa210323a5be709.png" alt="1649818834821"></p><p>可以看到，其中有些应该是在 ui 层解析并且传递到数据层，有些是工具函数（如果真的需要）应该放到 utils/ 中以便复用，但都直接一股脑的塞到 <code>dataApi.ts</code> 这单个文件中。</p><h2 id="错误处理仅仅只是打印在控制台"><a href="#错误处理仅仅只是打印在控制台" class="headerlink" title="错误处理仅仅只是打印在控制台"></a>错误处理仅仅只是打印在控制台</h2><blockquote><p>嗯，如果出错了，我应该只需要打印在控制台就好了。都 2202 年了，应该没有用户不会使用控制台查看错误了吧？</p></blockquote><p><img src="/resources/c5847aef9c8a41218fdf0b735ee0f64d.png" alt="1649819664273"></p><p>一般而言，如果出错应该给出 ui 反馈，而非默默的将错误吞下去。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>来自群友</p></blockquote><p>不求前人不留屎<br>但求屎不留後人</p><p>軟體工程就只能做到這樣沒辦法 XD</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="javascript" scheme="https://blog.rxliuli.com/tags/javascript/"/>
    
    <category term="vue" scheme="https://blog.rxliuli.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Code Review 漫谈 01</title>
    <link href="https://blog.rxliuli.com/p/aa0ef1c7a0fe4bfba5f9bce94c0bbfb0/"/>
    <id>https://blog.rxliuli.com/p/aa0ef1c7a0fe4bfba5f9bce94c0bbfb0/</id>
    <published>2022-04-03T07:17:18.168Z</published>
    <updated>2022-04-03T09:11:48.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p>某些言辞可能略微辛辣，请勿对号入座。</p></blockquote><p>最近在帮同事做代码的 code review，发现了一些日常很难见到的奇妙代码，其中有些吾辈可能都不知道可以这样写。所以发布出来，便于其他刚入坑的萌新警戒。</p><p>先发一份快乐源泉</p><p><img src="/resources/a1e4918a0e834fba9d2a9a3b3d116fe4.png" alt="1648974891923"></p><p>下面列一些吾辈发现的问题</p><h2 id="目录结构和命名混乱"><a href="#目录结构和命名混乱" class="headerlink" title="目录结构和命名混乱"></a>目录结构和命名混乱</h2><p>这似乎是多人协作天生就会遇到的问题，但吾辈确实还是想吐槽一番。如果说按照业务分割顶级目录，然后在子目录分割类型，那么 asssets/components 显然不像，反之亦然。</p><p><img src="/resources/161aede761584deebbe48e7be4037b6b.png" alt="1648973811543"></p><p>或许你已经被同时存在驼峰、中划线、强制小写的写法感觉满头疑惑，但实际上这是同一个人写的，你甚至能见到 userInitData/userInitData2 这种神奇的命名，它们有什么不同？或许只有天知道（如何编写不可维护的代码）。</p><h2 id="graphql-拼接-sql-字符串"><a href="#graphql-拼接-sql-字符串" class="headerlink" title="graphql 拼接 sql 字符串"></a>graphql 拼接 sql 字符串</h2><p>老实说，吾辈还没想过 graphql 还能这样用，不确定这种用法和后端传统艺能拼接 sql 语句有什么不同 – 后者已经被各种 orm 框架抨击过许多次了。整体上，吾辈还挺喜欢 graphql 的，它强制后端给出 service schema，前端便可以基于这个 schema 完成代码生成、编辑器支持以及各种周边工具，使用门槛比之原生的 restful 虽然稍显繁重，但仍然在开发体验上要优于 restful。但这种用法完全享受不到优点，甚至比使用 restful 还要糟糕。</p><p><img src="/resources/a7610cd7d8f4497da83ef55951c0afb2.png" alt="1648973635984"></p><h2 id="绝大多数时候应该使用命名导出，因为可以导出多个并更好的做代码提示"><a href="#绝大多数时候应该使用命名导出，因为可以导出多个并更好的做代码提示" class="headerlink" title="绝大多数时候应该使用命名导出，因为可以导出多个并更好的做代码提示"></a>绝大多数时候应该使用命名导出，因为可以导出多个并更好的做代码提示</h2><p>吾辈不确定为什么会有人喜欢用默认导出，它不仅限定一个文件只能导出一个，还导致编辑器在代码提示和重构方面会出现一些细微的问题。</p><p><img src="/resources/3b9aaca8482046c585ecb4f27cb14b6b.png" alt="1648974537284"><br><img src="/resources/6968acf3ffa449738555bda1f72e054a.png" alt="1648974457995"></p><h2 id="操作状态（view-层）应该与请求后端（api-层）分离，更不应该将状态传到-api-层"><a href="#操作状态（view-层）应该与请求后端（api-层）分离，更不应该将状态传到-api-层" class="headerlink" title="操作状态（view 层）应该与请求后端（api 层）分离，更不应该将状态传到 api 层"></a>操作状态（view 层）应该与请求后端（api 层）分离，更不应该将状态传到 api 层</h2><p>分层是一个基本的思想，不管是 java web 后端的 mvc，还是前端的 mvvm，都会将不同的部分分割开来分离关注点，以便于后续维护。前端在实际业务开发中，框架一般处理了 model =&gt; view，但这仍然需要继续分层，现在一个很不好的趋势是重 view 层，什么东西都写到 view 层（指 react、vue 组件），而这让测试和后续维护变得很痛苦（单测有依赖的组件非常麻烦）。</p><p><img src="/resources/365644f6ee564ac9b8a0ddc48ad55582.png" alt="1648976016738"></p><h2 id="绝大多数-async-函数都必须使用-await-等待"><a href="#绝大多数-async-函数都必须使用-await-等待" class="headerlink" title="绝大多数 async 函数都必须使用 await 等待"></a>绝大多数 async 函数都必须使用 await 等待</h2><p>泥萌见过调用 async 函数时不加上 await 的么？吾辈见过了。除了某些特殊情况之外，在绝大多数情况下，调用 async 函数都需要使用 await 等待，而下面这里并没有这样做，甚至还写了虚假的 try/catch 来捕获永远无法捕获到的错误。</p><p><img src="/resources/8607b5d643b6465eb0f32f36fba1325d.png" alt="1648975322020"></p><h2 id="应该使用-reactive-x2F-ref-分离多个状态，而非用-vue2-一个组件一个集中状态的方式"><a href="#应该使用-reactive-x2F-ref-分离多个状态，而非用-vue2-一个组件一个集中状态的方式" class="headerlink" title="应该使用 reactive/ref 分离多个状态，而非用 vue2 一个组件一个集中状态的方式"></a>应该使用 reactive/ref 分离多个状态，而非用 vue2 一个组件一个集中状态的方式</h2><p>或许是因为 vue2 将状态都写到 <code>data</code> 字段中的原因，vue3 也有人在这样写，将所有的状态放到一个对象中，而这虽然能够运行，但完全没有根据业务分割状态和逻辑，硬生生把 vue3 用成了 vue2。</p><p><img src="/resources/7af843a192da4864bc2eed3d9f413ad8.png" alt="1648974707241"></p><h2 id="anyscript"><a href="#anyscript" class="headerlink" title="anyscript"></a>anyscript</h2><p>引入 TypeScript 本是便于项目的开发和可维护性，但实际执行过程中，几乎变成了 anyscript。不知道怎么写类型？那就不写就好了，不是么？</p><p><img src="/resources/82757bba467e473490aac210265ce014.png" alt="1648975542659"><br><img src="/resources/7dfe37881c1140218ebc7c2f1c563dc5.png" alt="1648975628217"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>曾经吾辈刚开始工作时（还在写 java），提升代码细节质量主要依赖于 jetbrains idea 内置的 linter。吾辈认为，大部分时候，如果 idea 认为错了，那么可能就真的错了。个人认为，提高代码质量方法很多，要么去阅读现有好的代码，或者有人帮忙指导，但最重要的还是自己有意识希望将代码写的更好，而不仅仅是抱着<strong>代码和人有一个能跑就行</strong>的心态，将 coding 作为养家糊口的一份手段。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="javascript" scheme="https://blog.rxliuli.com/tags/javascript/"/>
    
    <category term="vue" scheme="https://blog.rxliuli.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>VSCode 扩展 New Project 发布 0.2.0</title>
    <link href="https://blog.rxliuli.com/p/2930fc364bbe42139765efc0c23746f8/"/>
    <id>https://blog.rxliuli.com/p/2930fc364bbe42139765efc0c23746f8/</id>
    <published>2022-03-31T04:37:33.381Z</published>
    <updated>2022-03-31T05:07:39.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前 <a href="/p/605d5f360fc7438dac50148c36610217">VSCode 扩展 New Project 发布 0.1.0</a> 一文中，吾辈实现了基本的扩展功能，也说明在过程中遇到的一些问题。<br>现在，吾辈实现了自定义生成器的功能，然后发布了 0.2.0，这让使用公司内部的 cli 生成器变成了可能。</p><p>具体来说，有以下几步</p><ol><li>公开生成器的 json schema</li><li>从 vscode 配置中获取 json configs</li><li>渲染为创建模板项目的表单</li><li>创建时与内部支持的生成器走同一个流程</li></ol><h2 id="定义-schema"><a href="#定义-schema" class="headerlink" title="定义 schema"></a>定义 schema</h2><p>typescript interface</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export interface BaseConfig {  name: string  label: string  default?: any}export interface SelectConfig extends BaseConfig {  type: 'select'  options: {    label: string    value: string  }[]}export interface CheckboxConfig extends BaseConfig {  type: 'checkbox'}export interface InputConfig extends BaseConfig {  type: 'input'}export type Conifg = SelectConfig | CheckboxConfig | InputConfigexport interface BootstrapConfig {  id: string  title: string  package: string  command: string  configs: Conifg[]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>转换得到的 json schema</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">{  "type": "array",  "description": "List of generators to use",  "items": {    "type": "object",    "properties": {      "id": {        "type": "string",        "description": "The id of the generator"      },      "title": {        "type": "string",        "description": "The title of the generator"      },      "package": {        "type": "string",        "description": "npm package"      },      "command": {        "type": "string",        "description": "command to run"      },      "configs": {        "type": "array",        "description": "configs to pass to the command",        "items": {          "type": "object",          "properties": {            "type": {              "type": "string",              "enum": ["select", "checkbox", "input"],              "description": ""            },            "name": {              "type": "string",              "description": ""            },            "label": {              "type": "string",              "description": ""            },            "default": {},            "options": {              "type": "array",              "items": {                "type": "object",                "properties": {                  "label": {                    "type": "string",                    "description": "option label"                  },                  "value": {                    "type": "string",                    "description": "option value"                  }                },                "required": ["label", "value"]              }            }          },          "required": ["type", "name", "label"]        }      }    },    "required": ["id", "title", "package", "command", "configs"]  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>接着我们就可以在 VSCode 中自定义生成器了</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">{  "newProject.generators": [    {      "id": "@liuli-util/cli",      "title": "liuli-cli",      "package": "@liuli-util/cli",      "command": "liuli-cli generate",      "configs": [        {          "type": "select",          "name": "template",          "label": "Template",          "default": "lib",          "options": [            { "label": "lib", "value": "lib" },            { "label": "cli", "value": "cli" }          ]        },        {          "type": "checkbox",          "name": "init-sync",          "label": "init sync",          "default": false        }      ]    }  ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>然后便可以使用这个生成器创建项目了</p><p><img src="/resources/dec1bb478fb34a83baf03512bf181d42.png" alt="1648703038281"></p><blockquote><p><a href="https://github.com/rxliuli/vscode-plugin-new-project/blob/master/webview-ui/src/assets/generators.json">更多的生成器配置示例</a></p></blockquote><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><ul><li>cli 最好支持非交互式的模式。交互式 cli 虽然对命令行使用较为友好，但这个插件本身的就已经实现了交互部分，所以不需要额外使用 cli 本身的交互行为</li><li>cli 生成项目的命令格式大体上需要满足 <code>cli command name flags</code>。例如 <code>create-vite hello-world --template=preact-ts</code>，幸运的是，commanderjs 和 yargs 都支持这种模式，而且许多 cli 也是如此做的</li></ul><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>目前插件的基本功能已完成，后续已知需要处理的几件事情有</p><ul><li>feat: 国际化支持</li><li>feat: 支持类似于 jetbrains ide 的覆盖模式（目前是清除）</li><li>feat: 支持更多的现有框架</li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="vscode" scheme="https://blog.rxliuli.com/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>VSCode 扩展 New Project 发布 0.1.0</title>
    <link href="https://blog.rxliuli.com/p/605d5f360fc7438dac50148c36610217/"/>
    <id>https://blog.rxliuli.com/p/605d5f360fc7438dac50148c36610217/</id>
    <published>2022-03-29T13:51:20.732Z</published>
    <updated>2022-03-31T04:31:03.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p><a href="https://marketplace.visualstudio.com/items?itemName=rxliuli.new-project">vscode 扩展市场</a></p></blockquote><p>这个 idea 起源于吾辈从 webstorm 切换到 vscode 的几周后，在上个周末，吾辈想到，为什么 Jetbrains IDE 都有 <a href="https://www.jetbrains.com/help/idea/create-new-project-twitter-bootstrap.html">项目创建引导面板</a>，而 vscode 却并不支持，而只能使用命令行工具呢？念及于此，吾辈便打算自行在 vscode 中实现对等插件。</p><blockquote><p>吾辈之前也为 webstorm 开发了一个生成 vite 项目的插件 <a href="https://plugins.jetbrains.com/plugin/16897/">Vite Integrated</a></p></blockquote><p>最终效果</p><p><img src="/resources/6ac71ef7d19d409c8e7cef995c396876.gif" alt="new project.gif"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>基本思路是通过 vscode webview 渲染配置，然后在主线程拼接执行 npx 命令来创建项目。具体来说，从用户的角度而言，分为以下几步</p><ol><li>通过命令或 ui 上的菜单打开项目创建面板</li><li>选择使用的生成器</li><li>选择生成项目的位置</li><li>选择或输入一些生成器需要的配置</li><li>创建项目</li><li>如果是当前项目的子目录，打开目录中的 package.json，否则打开一个新的窗口</li></ol><h2 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h2><ul><li>如何使用 react 开发视图层</li><li>如何保证 webview 的界面风格与 vscode 保持一致</li><li>如何实现渲染层与主线程通信</li><li>使用 npm create 还是 npx</li><li>如何持久化状态</li></ul><h2 id="如何使用-react-开发视图层"><a href="#如何使用-react-开发视图层" class="headerlink" title="如何使用 react 开发视图层"></a>如何使用 react 开发视图层</h2><p>吾辈起初想将 webview 视图层独立开发部署至 github pages 上，而 vscode 插件的部分仅包含 bundle。但 vscode 默认需要使用 html 字符串作为入口，因而让事情变得有些复杂，幸好吾辈找到了官方的示例项目 <a href="https://github.com/microsoft/vscode-webview-ui-toolkit-samples/tree/main/react/hello-world-vite">hello-world-vite</a>，这让集成吾辈熟悉的技术栈变得简单了一些，该项目便是在此模板上修改。</p><h2 id="如何保证-webview-的界面风格与-vscode-保持一致"><a href="#如何保证-webview-的界面风格与-vscode-保持一致" class="headerlink" title="如何保证 webview 的界面风格与 vscode 保持一致"></a>如何保证 webview 的界面风格与 vscode 保持一致</h2><p>这个问题在早前其实会有点复杂，但随着 vscode 官方推出 ui 库 <a href="https://github.com/microsoft/vscode-webview-ui-toolkit">vscode-webview-ui-toolkit</a>，并且在近期推出了默认集成 react 之后，这个问题变得简单多了 – 当然，并不意味着尽善尽美了。</p><p>官方示意图</p><p><img src="/resources/4d90e30cfde74c23bef01991a8ea261b.png" alt="toolkit-artwork"></p><p>它提供一些基本的组件</p><ul><li><code>badge</code></li><li><code>button</code></li><li><code>checkbox</code></li><li><code>data-grid</code></li><li><code>divider</code></li><li><code>dropdown</code></li><li><code>link</code></li><li><code>option</code></li><li><code>panels</code></li><li><code>progress-ring</code></li><li><code>radio</code></li><li><code>radio-group</code></li><li><code>tag</code></li><li><code>text-area</code></li><li><code>text-field</code></li></ul><p>但是，吾辈在实际使用时仍然发现一些问题，主要包括</p><ul><li>组件的类型定义不准确，导致严重需要依赖于 storybook 的文档，梦回 JavaScript</li><li>一些组件不符合直觉，例如 <code>panels/select/text-field</code> 和一般做法存在些许不同，<code>panels</code> tab/panel 要写两次，<code>select</code> 没有分离 <code>value/label</code>，<code>text-field</code> 使用</li><li>ui 库不支持 tree shaking，导致 bundle 比较大，项目占比 <strong>439.98kb/74.79%</strong></li></ul><p>依赖树实在可怕，正因如此，吾辈才没有去替换 react =&gt; preact</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">@vscode/codicons 0.0.29@vscode/webview-ui-toolkit 0.9.3├── @microsoft/fast-element 1.8.0├─┬ @microsoft/fast-foundation 2.37.2│ ├── @microsoft/fast-element 1.8.0│ ├── @microsoft/fast-web-utilities 5.1.0│ ├── tabbable 5.2.1│ └── tslib 1.14.1├─┬ @microsoft/fast-react-wrapper 0.1.43│ ├── @microsoft/fast-element 1.8.0│ ├─┬ @microsoft/fast-foundation 2.37.2│ │ ├── @microsoft/fast-element 1.8.0│ │ ├── @microsoft/fast-web-utilities 5.1.0│ │ ├── tabbable 5.2.1│ │ └── tslib 1.14.1│ └── react 17.0.2 peer└── react 17.0.2 peer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><img src="/resources/8cb9112697704e6699908d0537c647fe.png" alt="Snipaste\_2022-03-29\_22-24-32"></p><h2 id="如何实现渲染层与主线程通信"><a href="#如何实现渲染层与主线程通信" class="headerlink" title="如何实现渲染层与主线程通信"></a>如何实现渲染层与主线程通信</h2><p>由于核心是通过 <code>postMessage/onmessage</code> 实现，所以与 web worker 或 iframe 通信非常相似。由于代码比较简单，所以吾辈并未封装复杂的通信逻辑。</p><ol><li>确定了通信的基础数据结构</li><li>在主线程部分使用 map 保存 <code>channel =&gt; handle</code> 向渲染线程暴露的功能，在接收到渲染现成的消息后执行相应的方法并通过 postMessage 扔到渲染线程</li><li>在渲染线程简单封装，让调用时传入 <code>channel + data</code>，即可调用到主线程暴露的方法并异步获取到结果</li></ol><p>关键代码</p><p>主线程</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const map = new Map&lt;string, (...args: any[]) =&gt; any&gt;()map.set('hello', (name: string) =&gt; `hello ${name}`)webview.onDidReceiveMessage(  async (message: any) =&gt; {    const { command, data = [], callback } = message    if (!map.has(command)) {      throw new Error(`找不到命令 ${command}`)    }    const res = await map.get(command)!(...data)    if (callback) {      console.log('callback: ', callback)      this._panel.webview.postMessage({        command: callback,        data: [res],      })    }  },  undefined,  this._disposables,)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>渲染线程</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import type { WebviewApi } from 'vscode-webview'class VSCodeAPIWrapper {  private readonly vsCodeApi: WebviewApi&lt;unknown&gt; | undefined  constructor() {    if (typeof acquireVsCodeApi === 'function') {      this.vsCodeApi = acquireVsCodeApi()    }  }  public postMessage(message: unknown) {    if (this.vsCodeApi) {      this.vsCodeApi.postMessage(message)    } else {      console.log(message)    }  }  async invoke(options: {    command: string    default?: any    args?: any[]  }): Promise&lt;any&gt; {    return await new Promise&lt;string&gt;((resolve) =&gt; {      if (typeof acquireVsCodeApi !== 'function') {        resolve(options.default)        return      }      const id = Date.now() + '_' + Math.random()      const listener = (message: MessageEvent) =&gt; {        const data = message.data        if (data.command === id) {          resolve(data.data[0])          window.removeEventListener('message', listener)        }      }      window.addEventListener('message', listener)      vscode.postMessage({        command: options.command,        data: options.args,        callback: id,      })    })  }}export const vscode = new VSCodeAPIWrapper()console.log(await vscode.invoke({ command: 'world' })) // hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="使用-npm-create-还是-npx"><a href="#使用-npm-create-还是-npx" class="headerlink" title="使用 npm create 还是 npx"></a>使用 npm create 还是 npx</h2><p>例如使用 vite 创建一个 react 项目的命令是</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx --yes --package create-vite create-vite path --template=react-ts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>使用 create-react-app 创建一个项目的命令是</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx --yes --package create-react-app create-react-app path --template=typescript<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>可能有人会问了：“为什么没有使用类似 <code>npm create</code> 这个命令来创建项目呢？”<br>这背后确有缘由，乍看上去 <code>create</code> 命令已经被主流的包管理器 <code>npm/yarn/pnpm</code> 都支持了，但它有一些局限性</p><ol><li>npm 包名存在限制，不包含组织名的部分必须以 <code>create-</code> 开头，但事实上不是所有 cli 都以 <code>create-</code> 开头，例如 <code>@angular/cli</code></li><li><code>pnpm create</code> 功能和 npm 不对等，需要分别适配每个包管理器</li><li>webstorm 仍然在使用 npx 实现项目创建，这也影响了吾辈的选择</li></ol><p>所以选择 npx 也便理所当然了，后续可能支持全局配置使用 <code>pnpx</code>。</p><h2 id="如何持久化状态"><a href="#如何持久化状态" class="headerlink" title="如何持久化状态"></a>如何持久化状态</h2><p>vscode 其实提供了官方的解决方案，实现 <code>WebviewPanelSerializer</code> 即可让 <code>acquireVsCodeApi()</code> 的 <code>getState/setState</code> 都能被持久化，但它存在一些问题导致吾辈最终没有使用它。</p><ol><li>仅在 webview 第一次渲染时能够恢复状态，但在没有关闭 vscode 之前多次更改都不会持久化，即如果你需要创建两个项目，第一次创建时选择了一些配置项，但第二次创建时配置项没有被缓存，而只有重开 vscode 时才会生效，这实在很奇怪（也有可能是吾辈用错了）</li><li>接口不支持 kv 存储，仅支持获取全量状态或设置全量状态</li></ol><p>因而吾辈选择使用 <code>context.globalState</code> 持久化数据</p><p>主线程</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">// 其他代码。。。map.set('getState', (key: string) =&gt; this.globalState.get(key))map.set('setState', (key: string, value: any) =&gt;  this.globalState.update(key, value),)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>渲染线程</p><figure><div class="code-wrapper"><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import type { WebviewApi } from 'vscode-webview'class VSCodeAPIWrapper {  // 其他代码。。。  async getState(key: string): Promise&lt;unknown | undefined&gt; {    if (this.vsCodeApi) {      return await this.invoke({ command: 'getState', args: [key] })    } else {      const state = localStorage.getItem(key)      return state ? JSON.parse(state) : undefined    }  }  async setState&lt;T extends unknown | undefined&gt;(    key: string,    newState: T,  ): Promise&lt;void&gt; {    if (this.vsCodeApi) {      return await this.invoke({ command: 'setState', args: [key, newState] })    } else {      localStorage.setItem(key, JSON.stringify(newState))    }  }}export const vscode = new VSCodeAPIWrapper()const store = (await vscode.getState(props.id)) as { location: string }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>现在可以支持选择的生成器和配置项在下次使用时仍然会被缓存，这对于需要使用相同的生成器创建项目确实很方便，尤其是生成器选项比较多的情况下。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>vscode 目前在一些方面仍然比不上 webstorm，但其流行趋势简直势不可挡，许多前端项目甚至官方仅支持 vscode 编辑器，这让在某些时候变得没有选择（例如 vue3、nx）。所以与其抱怨，还不如尝试让它变得更好。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="vscode" scheme="https://blog.rxliuli.com/tags/vscode/"/>
    
  </entry>
  
</feed>
