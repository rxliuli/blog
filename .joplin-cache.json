{"note":[{"id":"53784162ade2454498a210a59796fae6","title":"基于 IEventEmitter 封装更上层的 api","body":"## 场景\r\n\r\n> 已经有许许多多类似的封装了，例如最流行的可能是 ChromeLab 的 [comlink](https://github.com/GoogleChromeLabs/comlink/blob/main/src/node-adapter.ts)。\r\n\r\n之前虽然通过 IEventEmitter 声明了子应用与系统之间的通信，但实际使用时可能不够简单，所以基于它封装更上层的 api `MessageChannel`，希望它能够有以下功能。\r\n\r\n## 基础实现\r\n\r\n- 在一边通过 `on` 方法注册后应该可以直接返回值并自动发回至调用者\r\n- 默认对参数及返回值做一些处理以提高性能，主要是通过 `JSON.stringify` 实现（待完成测试）\r\n\r\n```ts\r\nimport { IEventEmitter } from './IEventEmitter'\r\n// 这只是一个简单的 id 生成器\r\nimport { CallbackIdGenerator } from './CallbackIdGenerator'\r\n\r\nexport class MessageChannel {\r\n  constructor(private readonly emitter: IEventEmitter) {}\r\n\r\n  invoke(channel: string, data?: any): Promise<any> {\r\n    return new Promise((resolve) => {\r\n      const callbackId = CallbackIdGenerator.generate()\r\n      this.emitter.on(callbackId, (msg) => {\r\n        resolve(msg === undefined ? undefined : JSON.parse(msg))\r\n        this.emitter.offByChannel(callbackId)\r\n      })\r\n      this.emitter.emit(channel, JSON.stringify({ data, callbackId }))\r\n    })\r\n  }\r\n\r\n  on(channel: string, handle: (data: any) => any) {\r\n    this.emitter.on(channel, async (msg) => {\r\n      const value = JSON.parse(msg) as { callbackId: string; data: any }\r\n      const res = await handle(value.data)\r\n      if (value.callbackId) {\r\n        this.emitter.emit(value.callbackId, JSON.stringify(res))\r\n      }\r\n    })\r\n  }\r\n\r\n  offByChannel(channel: string) {\r\n    this.emitter.offByChannel(channel)\r\n  }\r\n}\r\n```\r\n\r\n使用\r\n\r\n```ts\r\nmessageChannel.on('hello', (name: string) => `hello ${name}`)\r\nexpect(await messageChannel.invoke('hello', 'liuli')).toBe('hello liuli')\r\n```\r\n\r\n但它仍存在一些问题\r\n\r\n- `invoke` 方法一定会包含回调，即便是事实上不需要关心回调的也一样\r\n\r\n## 支持仅触发事件的 `emit` 函数\r\n\r\n主要思路是添加 `type` 字段标识调用的类型，即由调用者决定是否需要关心返回值。\r\n\r\n```ts\r\nimport { IEventEmitter } from './IEventEmitter'\r\nimport { CallbackIdGenerator } from './CallbackIdGenerator'\r\n\r\ntype MessageChannelData = { data?: any } & (\r\n  | { type: 'emit' }\r\n  | { type: 'invoke'; callbackId: string }\r\n)\r\n\r\nexport class MessageChannel {\r\n  constructor(private readonly emitter: IEventEmitter) {}\r\n\r\n  invoke(channel: string, data?: any): Promise<any> {\r\n    return new Promise((resolve) => {\r\n      const callbackId = CallbackIdGenerator.generate()\r\n      this.emitter.on(callbackId, (msg) => {\r\n        resolve(msg === undefined ? undefined : JSON.parse(msg))\r\n        this.emitter.offByChannel(callbackId)\r\n      })\r\n      this.emitter.emit(\r\n        channel,\r\n        JSON.stringify({\r\n          type: 'invoke',\r\n          data,\r\n          callbackId,\r\n        } as MessageChannelData),\r\n      )\r\n    })\r\n  }\r\n\r\n  emit(channel: string, data?: any): void {\r\n    this.emitter.emit(channel, {\r\n      type: 'emit',\r\n      data,\r\n    } as MessageChannelData)\r\n  }\r\n\r\n  on(channel: string, handle: (data: any) => any) {\r\n    this.emitter.on(channel, async (msg) => {\r\n      const value = JSON.parse(msg) as MessageChannelData\r\n      const res = await handle(value.data)\r\n      if (value.type === 'invoke') {\r\n        this.emitter.emit(value.callbackId, JSON.stringify(res))\r\n      }\r\n    })\r\n  }\r\n\r\n  offByChannel(channel: string) {\r\n    this.emitter.offByChannel(channel)\r\n  }\r\n}\r\n```\r\n\r\n## 最终希望达成什么样子？\r\n\r\n下面是一些希望能够做到的使用方式\r\n\r\n```ts\r\ninterface ITestApi {\r\n  hello(name: string): string\r\n}\r\n\r\nconst messageChannel = new MessageChannel(new EventEmitter())\r\nmessageChannel.expose('test', {\r\n  hello(name: string) {\r\n    return `hello ${name}`\r\n  },\r\n})\r\nconst client = messageChannel.wrap<ITestApi>('test')\r\nconsole.log(await client.hello('liuli'))\r\n```\r\n","createdTime":1635018187061,"updatedTime":1635076559743,"resources":[],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"bafce41b0e6840908c5b5452c0fca1db","title":"JavaScript 沙箱探索","body":"## 场景\r\n\r\n最近基于 web 在做一些类似于插件系统一样的东西，所以折腾了一下 js 沙箱，以执行第三方应用的代码。\r\n\r\n## 沙箱基础功能\r\n\r\n在实现之前（好吧，其实是在调研了一些方案之后），确定了沙箱基于 event bus 形式的通信实现上层的功能，基础的接口如下\r\n\r\n```ts\r\nexport interface IEventEmitter {\r\n  /**\r\n   * 监听事件\r\n   * @param channel\r\n   * @param handle\r\n   */\r\n  on(channel: string, handle: (data: any) => void): void\r\n\r\n  /**\r\n   * 取消监听\r\n   * @param channel\r\n   */\r\n  offByChannel(channel: string): void\r\n\r\n  /**\r\n   * 触发事件\r\n   * @param channel\r\n   * @param data\r\n   */\r\n  emit(channel: string, data: any): void\r\n}\r\n\r\n/**\r\n * 一个基本 js vm 的能力\r\n */\r\nexport interface IJavaScriptShadowbox extends IEventEmitter {\r\n  /**\r\n   * 执行任意代码\r\n   * @param code\r\n   */\r\n  eval(code: string): void\r\n\r\n  /**\r\n   * 销毁实例\r\n   */\r\n  destroy(): void\r\n}\r\n```\r\n\r\n除了通信的能力之外，还额外要求了两个方法：\r\n\r\n- `eval`: 执行一段 js 代码\r\n- `destroy`: 销毁沙箱，供内部实现处理一些清理任务\r\n\r\n![JavaScript 沙箱示意图.drawio.svg](:/9ba85a775b4e4bfea70f3da8def2f8e5)\r\n\r\n下面吾辈将分别演示使用 `iframe/web worker/quickjs` 执行任意 js 的方法\r\n\r\n## iframe 实现\r\n\r\n老实说，谈到 web 中的沙箱，可能第一时间想到的就是 iframe 了，但它是以 html 作为入口文件，而非 js，这对于希望将 js 作为入口而不一定需要显示 iframe 的场景而言就不甚友好了。\r\n\r\n![1634797302936](:/94972af176de4e67ab763bdc7862aa26)\r\n\r\n当然可以将 js 代码包裹到 html 中然后执行\r\n\r\n```ts\r\nfunction evalByIframe(code: string) {\r\n  const html = `<!DOCTYPE html><body><script>${code}</script></body></html>`\r\n  const iframe = document.createElement('iframe')\r\n  iframe.width = '0'\r\n  iframe.height = '0'\r\n  iframe.style.display = 'none'\r\n  document.body.appendChild(iframe)\r\n  const blob = new Blob([html], { type: 'text/html' })\r\n  iframe.src = URL.createObjectURL(blob)\r\n  return iframe\r\n}\r\n\r\nevalByIframe(`\r\ndocument.body.innerHTML = 'hello world'\r\nconsole.log('location.href: ', location.href)\r\nconsole.log('localStorage: ',localStorage)\r\n`)\r\n```\r\n\r\n但 iframe 有以下几个问题\r\n\r\n- 几乎与 `eval` 没有什么区别（主要是使用 `Object.createObjectURL` 导致同源了）-- 致命的\r\n- 可以访问所有浏览器的 api -- 我们更希望它仅能访问注入的 api，而不允许访问所有 dom api\r\n\r\n## web worker 实现\r\n\r\n基本上，web worker 是一个受限的 js 运行时，以 js 为入口，和 iframe 差不多的通信机制\r\n\r\n```ts\r\nfunction evalByWebWorker(code: string) {\r\n  const blob = new Blob([code], { type: 'application/javascript' })\r\n  const url = URL.createObjectURL(blob)\r\n  return new Worker(url)\r\n}\r\n\r\nevalByWebWorker(`\r\nconsole.log('location.href: ', location.href)\r\n// console.log('localStorage: ', localStorage)\r\n`)\r\n```\r\n\r\n但同时，它确实比 iframe 要更好一点\r\n\r\n- 仅支持有限的浏览器 api，包括 `localStorage/document` 在内的 api 均无法访问，具体参考：[[MDN] Web Workers 可以使用的函数和类](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers)\r\n- 所有注入的 api 均为异步操作，毕竟基于 `postMessage/onmessage`\r\n\r\n## quickjs 实现\r\n\r\n> 使用 quickjs 的主要灵感来源于 [figma 构建插件系统的一篇博客](https://www.figma.com/blog/how-we-built-the-figma-plugin-system/)，[quickjs 中文文档](https://github.com/quickjs-zh/QuickJS)\r\n\r\nquickjs 是什么？它是一个 JavaScript 的运行时，虽然我们最常用的运行时是浏览器和 nodejs，但也有许多其他的运行时，可以在 [GoogleChromeLabs/jsvu](https://github.com/GoogleChromeLabs/jsvu#supported-engines-per-os) 找到更多。而 quickjs 是其中一个轻量级、嵌入式、并且支持编译为 wasm 运行在浏览器上的一个运行时，同时它对 js 的特性支持到 es2020（包括最喜爱的 `Promise` 和 `async/await`）。\r\n\r\n```ts\r\nasync function evalByQuickJS(code: string) {\r\n  const quickJS = await getQuickJS()\r\n  const vm = quickJS.createVm()\r\n  const res = vm.dump(vm.unwrapResult(vm.evalCode(code)))\r\n  vm.dispose()\r\n  return res\r\n}\r\n\r\nconsole.log(await evalByQuickJS(`1+1`))\r\n```\r\n\r\n- 优点\r\n  - 事实上，在安全性方面它是无可匹敌的，因为运行在不同的 vm 上，很难出现现有微前端基于 Proxy 可能出现的安全问题。\r\n  - 虽然没有实际测试，但 figma 的那篇博客中指出浏览器的结构化克隆在处理大型对象时存在性能问题，而 quickjs 不存在这种问题。\r\n- 缺点\r\n  - 没有全局 api，包括常见的 `console/setTimeout/setInterval` 都不是 js 的特性，而是浏览器、nodejs 运行时实现的，所以必须手动实现并注入，这是一个显著的缺点。\r\n  - 无法使用浏览器的 DevTool 调试\r\n  - 由于底层使用 c 实现，所以需要手动管理内存的释放\r\n\r\n## 结论\r\n\r\n最终，我们选择了基于接口实现了 web worker 与 quickjs 的 EventEmitter，并支持随时切换的能力。\r\n","createdTime":1634656638540,"updatedTime":1635076522232,"resources":[{"id":"94972af176de4e67ab763bdc7862aa26","title":"1634797302936","file_extension":"png","user_updated_time":1634797303360},{"id":"9ba85a775b4e4bfea70f3da8def2f8e5","title":"JavaScript 沙箱示意图.drawio.svg","file_extension":"svg","user_updated_time":1634657477395}],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"c0232eb08d0f4fb5a1ed997bbd04e130","title":"基于 quickjs 封装 JavaScript 沙箱","body":"## 场景\r\n\r\n在前文 [JavaScript 沙箱探索](:/bafce41b0e6840908c5b5452c0fca1db) 中声明了沙箱的接口，并且给出了一些简单的执行任意第三方 js 脚本的代码，但并未实现完整的 `IJavaScriptShadowbox`，下面便讲一下如何基于 quickjs 实现它。\r\n\r\nquickjs 在 js 的封装库是 [quickjs-emscripten](https://github.com/justjake/quickjs-emscripten/)，基本原理是将 c 编译为 wasm 然后运行在浏览器、nodejs 上，它提供了以下基础的 api。\r\n\r\n```ts\r\nexport interface LowLevelJavascriptVm<VmHandle> {\r\n  global: VmHandle\r\n  undefined: VmHandle\r\n  typeof(handle: VmHandle): string\r\n  getNumber(handle: VmHandle): number\r\n  getString(handle: VmHandle): string\r\n  newNumber(value: number): VmHandle\r\n  newString(value: string): VmHandle\r\n  newObject(prototype?: VmHandle): VmHandle\r\n  newFunction(name: string, value: VmFunctionImplementation<VmHandle>): VmHandle\r\n  getProp(handle: VmHandle, key: string | VmHandle): VmHandle\r\n  setProp(handle: VmHandle, key: string | VmHandle, value: VmHandle): void\r\n  defineProp(\r\n    handle: VmHandle,\r\n    key: string | VmHandle,\r\n    descriptor: VmPropertyDescriptor<VmHandle>,\r\n  ): void\r\n  callFunction(\r\n    func: VmHandle,\r\n    thisVal: VmHandle,\r\n    ...args: VmHandle[]\r\n  ): VmCallResult<VmHandle>\r\n  evalCode(code: string): VmCallResult<VmHandle>\r\n}\r\n```\r\n\r\n下面是一段官方的代码示例\r\n\r\n```ts\r\nimport { getQuickJS } from 'quickjs-emscripten'\r\n\r\nasync function main() {\r\n  const QuickJS = await getQuickJS()\r\n  const vm = QuickJS.createVm()\r\n\r\n  const world = vm.newString('world')\r\n  vm.setProp(vm.global, 'NAME', world)\r\n  world.dispose()\r\n\r\n  const result = vm.evalCode(`\"Hello \" + NAME + \"!\"`)\r\n  if (result.error) {\r\n    console.log('Execution failed:', vm.dump(result.error))\r\n    result.error.dispose()\r\n  } else {\r\n    console.log('Success:', vm.dump(result.value))\r\n    result.value.dispose()\r\n  }\r\n\r\n  vm.dispose()\r\n}\r\n\r\nmain()\r\n```\r\n\r\n可以看到，创建 vm 中的变量后还必须留意调用 `dispose`，有点像是后端连接数据库时必须注意关闭连接，而这其实是比较繁琐的，尤其是在复杂的情况下。简而言之，它的 api 太过于底层了。在 github issue 中有人创建了 [quickjs-emscripten-sync](https://github.com/reearth/quickjs-emscripten-sync)，这给了吾辈很多灵感，所以吾辈基于 quickjs-emscripten 封装了一些工具函数，辅助而非替代它。\r\n\r\n## 简化底层 api\r\n\r\n主要目的有两个\r\n\r\n- 自动调用 `dispose`\r\n- 提供更好的创建 vm 值的方法\r\n\r\n### 自动调用 `dispose`\r\n\r\n主要思路是自动收集所有需要调用 `dispose` 的值，使用高阶函数在 callback 执行完之后自动调用。\r\n\r\n> 这里还需要注意避免不需要的多层嵌套代理，主要是考虑到下面更多的底层 api 基于它实现，而它们之间可能存在嵌套调用。\r\n\r\n```ts\r\nimport { QuickJSHandle, QuickJSVm } from 'quickjs-emscripten'\r\n\r\nconst QuickJSVmScopeSymbol = Symbol('QuickJSVmScope')\r\n\r\n/**\r\n * 为 QuickJSVm 添加局部作用域，局部作用域的所有方法调用不再需要手动释放内存\r\n * @param vm\r\n * @param handle\r\n */\r\nexport function withScope<F extends (vm: QuickJSVm) => any>(\r\n  vm: QuickJSVm,\r\n  handle: F,\r\n): {\r\n  value: ReturnType<F>\r\n  dispose(): void\r\n} {\r\n  let disposes: (() => void)[] = []\r\n\r\n  function wrap(handle: QuickJSHandle) {\r\n    disposes.push(() => handle.alive && handle.dispose())\r\n    return handle\r\n  }\r\n\r\n  //避免多层代理\r\n  const isProxy = !!Reflect.get(vm, QuickJSVmScopeSymbol)\r\n  function dispose() {\r\n    if (isProxy) {\r\n      Reflect.get(vm, QuickJSVmScopeSymbol)()\r\n      return\r\n    }\r\n    disposes.forEach((dispose) => dispose())\r\n    //手动释放闭包变量的内存\r\n    disposes.length = 0\r\n  }\r\n  const value = handle(\r\n    isProxy\r\n      ? vm\r\n      : new Proxy(vm, {\r\n          get(\r\n            target: QuickJSVm,\r\n            p: keyof QuickJSVm | typeof QuickJSVmScopeSymbol,\r\n          ): any {\r\n            if (p === QuickJSVmScopeSymbol) {\r\n              return dispose\r\n            }\r\n            //锁定所有方法的 this 值为 QuickJSVm 对象而非 Proxy 对象\r\n            const res = Reflect.get(target, p, target)\r\n            if (\r\n              p.startsWith('new') ||\r\n              ['getProp', 'unwrapResult'].includes(p)\r\n            ) {\r\n              return (...args: any[]): QuickJSHandle => {\r\n                return wrap(Reflect.apply(res, target, args))\r\n              }\r\n            }\r\n            if (['evalCode', 'callFunction'].includes(p)) {\r\n              return (...args: any[]) => {\r\n                const res = (target[p] as any)(...args)\r\n                disposes.push(() => {\r\n                  const handle = res.error ?? res.value\r\n                  handle.alive && handle.dispose()\r\n                })\r\n                return res\r\n              }\r\n            }\r\n            if (typeof res === 'function') {\r\n              return (...args: any[]) => {\r\n                return Reflect.apply(res, target, args)\r\n              }\r\n            }\r\n            return res\r\n          },\r\n        }),\r\n  )\r\n\r\n  return { value, dispose }\r\n}\r\n```\r\n\r\n使用\r\n\r\n```ts\r\nwithScope(vm, (vm) => {\r\n  const _hello = vm.newFunction('hello', () => {})\r\n  const _object = vm.newObject()\r\n  vm.setProp(_object, 'hello', _hello)\r\n  vm.setProp(_object, 'name', vm.newString('liuli'))\r\n  expect(vm.dump(vm.getProp(_object, 'hello'))).not.toBeNull()\r\n  vm.setProp(vm.global, 'VM_GLOBAL', _object)\r\n}).dispose()\r\n```\r\n\r\n甚至支持嵌套调用，而且仅需要在最外层统一调用 `dispose` 即可\r\n\r\n```ts\r\nwithScope(vm, (vm) =>\r\n  withScope(vm, (vm) => {\r\n    console.log(vm.dump(vm.unwrapResult(vm.evalCode('1+1'))))\r\n  }),\r\n).dispose()\r\n```\r\n\r\n### 提供更好的创建 vm 值的方法\r\n\r\n主要思路是判断创建 vm 变量的类型，自动调用相应的函数，然后返回创建的变量。\r\n\r\n```ts\r\nimport { QuickJSHandle, QuickJSVm } from 'quickjs-emscripten'\r\nimport { withScope } from './withScope'\r\n\r\ntype MarshalValue = { value: QuickJSHandle; dispose: () => void }\r\n\r\n/**\r\n * 简化使用 QuickJSVm 创建复杂对象的操作\r\n * @param vm\r\n */\r\nexport function marshal(vm: QuickJSVm) {\r\n  function marshal(value: (...args: any[]) => any, name: string): MarshalValue\r\n  function marshal(value: any): MarshalValue\r\n  function marshal(value: any, name?: string): MarshalValue {\r\n    return withScope(vm, (vm) => {\r\n      function _f(value: any, name?: string): QuickJSHandle {\r\n        if (typeof value === 'string') {\r\n          return vm.newString(value)\r\n        }\r\n        if (typeof value === 'number') {\r\n          return vm.newNumber(value)\r\n        }\r\n        if (typeof value === 'boolean') {\r\n          return vm.unwrapResult(vm.evalCode(`${value}`))\r\n        }\r\n        if (value === undefined) {\r\n          return vm.undefined\r\n        }\r\n        if (value === null) {\r\n          return vm.null\r\n        }\r\n        if (typeof value === 'bigint') {\r\n          return vm.unwrapResult(vm.evalCode(`BigInt(${value})`))\r\n        }\r\n        if (typeof value === 'function') {\r\n          return vm.newFunction(name!, value)\r\n        }\r\n        if (typeof value === 'object') {\r\n          if (Array.isArray(value)) {\r\n            const _array = vm.newArray()\r\n            value.forEach((v) => {\r\n              if (typeof v === 'function') {\r\n                throw new Error('数组中禁止包含函数，因为无法指定名字')\r\n              }\r\n              vm.callFunction(vm.getProp(_array, 'push'), _array, _f(v))\r\n            })\r\n            return _array\r\n          }\r\n          if (value instanceof Map) {\r\n            const _map = vm.unwrapResult(vm.evalCode('new Map()'))\r\n            value.forEach((v, k) => {\r\n              vm.unwrapResult(\r\n                vm.callFunction(vm.getProp(_map, 'set'), _map, _f(k), _f(v, k)),\r\n              )\r\n            })\r\n            return _map\r\n          }\r\n          const _object = vm.newObject()\r\n          Object.entries(value).forEach(([k, v]) => {\r\n            vm.setProp(_object, k, _f(v, k))\r\n          })\r\n          return _object\r\n        }\r\n        throw new Error('不支持的类型')\r\n      }\r\n      return _f(value, name)\r\n    })\r\n  }\r\n\r\n  return marshal\r\n}\r\n```\r\n\r\n使用\r\n\r\n```ts\r\nconst mockHello = jest.fn()\r\nconst now = new Date()\r\nconst { value, dispose } = marshal(vm)({\r\n  name: 'liuli',\r\n  age: 1,\r\n  sex: false,\r\n  hobby: [1, 2, 3],\r\n  account: {\r\n    username: 'li',\r\n  },\r\n  hello: mockHello,\r\n  map: new Map().set(1, 'a'),\r\n  date: now,\r\n})\r\nvm.setProp(vm.global, 'vm_global', value)\r\ndispose()\r\nfunction evalCode(code: string) {\r\n  return vm.unwrapResult(vm.evalCode(code)).consume(vm.dump.bind(vm))\r\n}\r\nexpect(evalCode('vm_global.name')).toBe('liuli')\r\nexpect(evalCode('vm_global.age')).toBe(1)\r\nexpect(evalCode('vm_global.sex')).toBe(false)\r\nexpect(evalCode('vm_global.hobby')).toEqual([1, 2, 3])\r\nexpect(new Date(evalCode('vm_global.date'))).toEqual(now)\r\nexpect(evalCode('vm_global.account.username')).toEqual('li')\r\nevalCode('vm_global.hello()')\r\nexpect(mockHello.mock.calls.length).toBe(1)\r\nexpect(evalCode('vm_global.map.size')).toBe(1)\r\nexpect(evalCode('vm_global.map.get(1)')).toBe('a')\r\n```\r\n\r\n目前支持的类型与 [JavaScript 结构化克隆算法](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Structured_clone_algorithm) 对比，后者在很多地方（iframe/web worker/worker_threads）均有使用\r\n\r\n| 对象类型        | quickjs            | 结构化克隆         | 注意                           |\r\n| --------------- | ------------------ | ------------------ | ------------------------------ |\r\n| 所有的原始类型  | :heavy_check_mark: | :x:                | symbols 除外                   |\r\n| Function        | :heavy_check_mark: | :heavy_check_mark: |                                |\r\n| Array           | :heavy_check_mark: | :heavy_check_mark: |                                |\r\n| Object          | :heavy_check_mark: | :heavy_check_mark: | 仅包括普通对象（如对象字面量） |\r\n| Map             | :heavy_check_mark: | :heavy_check_mark: |                                |\r\n| Set             | :heavy_check_mark: | :heavy_check_mark: |                                |\r\n| Date            | :heavy_check_mark: | :heavy_check_mark: |                                |\r\n| Error           | :x:                | :x:                |                                |\r\n| Boolean         | :x:                | :heavy_check_mark: | 对象                           |\r\n| String          | :x:                | :heavy_check_mark: | 对象                           |\r\n| RegExp          | :x:                | :heavy_check_mark: | lastIndex 字段不会被保留。     |\r\n| Blob            | :x:                | :heavy_check_mark: |                                |\r\n| File            | :x:                | :heavy_check_mark: |                                |\r\n| FileList        | :x:                | :heavy_check_mark: |                                |\r\n| ArrayBuffer     | :x:                | :heavy_check_mark: |                                |\r\n| ArrayBufferView | :x:                | :heavy_check_mark: | 这基本上意味着所有的类型化数组 |\r\n| ImageData       | :x:                | :heavy_check_mark: |                                |\r\n\r\n> 以上不支持的非常见类型并非 quickjs 不支持，仅仅是 marshal 暂未支持。\r\n\r\n## 实现 console/setTimeout/setInterval 等常见 api\r\n\r\n由于 console/setTimeout/setInterval 均不是 js 语言级别的 api（但是浏览器、nodejs 均实现了），所以吾辈必须手动实现并注入它们。\r\n\r\n### 实现 console\r\n\r\n基本思路：为 vm 注入全局 console 对象，将参数 dump 之后转发到真正的 console api\r\n\r\n```ts\r\nimport { QuickJSVm } from 'quickjs-emscripten'\r\nimport { marshal } from '../util/marshal'\r\n\r\nexport interface IVmConsole {\r\n  log(...args: any[]): void\r\n  info(...args: any[]): void\r\n  warn(...args: any[]): void\r\n  error(...args: any[]): void\r\n}\r\n\r\n/**\r\n * 定义 vm 中的 console api\r\n * @param vm\r\n * @param logger\r\n */\r\nexport function defineConsole(vm: QuickJSVm, logger: IVmConsole) {\r\n  const fields = ['log', 'info', 'warn', 'error'] as const\r\n  const dump = vm.dump.bind(vm)\r\n  const { value, dispose } = marshal(vm)(\r\n    fields.reduce((res, k) => {\r\n      res[k] = (...args: any[]) => {\r\n        logger[k](...args.map(dump))\r\n      }\r\n      return res\r\n    }, {} as Record<string, Function>),\r\n  )\r\n  vm.setProp(vm.global, 'console', value)\r\n  dispose()\r\n}\r\n\r\nexport class BasicVmConsole implements IVmConsole {\r\n  error(...args: any[]): void {\r\n    console.error(...args)\r\n  }\r\n\r\n  info(...args: any[]): void {\r\n    console.info(...args)\r\n  }\r\n\r\n  log(...args: any[]): void {\r\n    console.log(...args)\r\n  }\r\n\r\n  warn(...args: any[]): void {\r\n    console.warn(...args)\r\n  }\r\n}\r\n```\r\n\r\n使用\r\n\r\n```ts\r\ndefineConsole(\r\n  vm,\r\n  (['log', 'info', 'warn', 'error'] as const).reduce((res, k) => {\r\n    res[k] = console[k]\r\n    return res\r\n  }, {} as IVmConsole),\r\n)\r\n```\r\n\r\n### 实现 setTimeout\r\n\r\n基本思路\r\n\r\n![基于 quickjs 实现 setTimeout 与 clearTimeout.drawio.svg](:/f4568d723eb942838d7a068d46f721a1)\r\n\r\n1. 为 vm 注入全局 `setTimeout/clearTimeout` 函数\r\n2. setTimeout\r\n   1. 将传过来的 `callbackFunc` 注册为 vm 全局变量\r\n   2. 在系统层执行 `setTimeout`\r\n   3. 将 `clearTimeoutId => timeoutId` 写到 map，返回一个 `clearTimeoutId`\r\n   4. 执行刚刚注册的全局 vm 变量，并清除回调\r\n3. clearTimeout: 根据 `clearTimeoutId` 在系统层调用真实的 `clearTimeout`\r\n\r\n> 不直接返回 setTimeout 返回值的原因在于在 nodejs 中返回值是一个对象而非一个数字，所以需要使用 map 兼容\r\n\r\n```ts\r\nimport { QuickJSVm } from 'quickjs-emscripten'\r\nimport { withScope } from '../util/withScope'\r\nimport { VmSetInterval } from './defineSetInterval'\r\nimport { deleteKey } from '../util/deleteKey'\r\nimport { CallbackIdGenerator } from '@webos/ipc-main'\r\n\r\n/**\r\n * 注入 setTimeout 方法\r\n * 需要在注入后调用 {@link defineEventLoop} 让 vm 的事件循环跑起来\r\n * @param vm\r\n */\r\nexport function defineSetTimeout(vm: QuickJSVm): VmSetInterval {\r\n  const callbackMap = new Map<string, any>()\r\n  function clear(id: string) {\r\n    withScope(vm, (vm) => {\r\n      deleteKey(\r\n        vm,\r\n        vm.unwrapResult(vm.evalCode(`VM_GLOBAL.setTimeoutCallback`)),\r\n        id,\r\n      )\r\n    }).dispose()\r\n    clearInterval(callbackMap.get(id))\r\n    callbackMap.delete(id)\r\n  }\r\n  withScope(vm, (vm) => {\r\n    const vmGlobal = vm.getProp(vm.global, 'VM_GLOBAL')\r\n    if (vm.typeof(vmGlobal) === 'undefined') {\r\n      throw new Error('VM_GLOBAL 不存在，需要先执行 defineVmGlobal')\r\n    }\r\n    vm.setProp(vmGlobal, 'setTimeoutCallback', vm.newObject())\r\n    vm.setProp(\r\n      vm.global,\r\n      'setTimeout',\r\n      vm.newFunction('setTimeout', (callback, ms) => {\r\n        const id = CallbackIdGenerator.generate()\r\n        //此处已经是异步了，必须再包一层\r\n        withScope(vm, (vm) => {\r\n          const callbacks = vm.unwrapResult(\r\n            vm.evalCode('VM_GLOBAL.setTimeoutCallback'),\r\n          )\r\n          vm.setProp(callbacks, id, callback)\r\n          //此处还是异步的，必须再包一层\r\n          const timeout = setTimeout(\r\n            () =>\r\n              withScope(vm, (vm) => {\r\n                const callbacks = vm.unwrapResult(\r\n                  vm.evalCode(`VM_GLOBAL.setTimeoutCallback`),\r\n                )\r\n                const callback = vm.getProp(callbacks, id)\r\n                vm.callFunction(callback, vm.null)\r\n                callbackMap.delete(id)\r\n              }).dispose(),\r\n            vm.dump(ms),\r\n          )\r\n          callbackMap.set(id, timeout)\r\n        }).dispose()\r\n        return vm.newString(id)\r\n      }),\r\n    )\r\n    vm.setProp(\r\n      vm.global,\r\n      'clearTimeout',\r\n      vm.newFunction('clearTimeout', (id) => clear(vm.dump(id))),\r\n    )\r\n  }).dispose()\r\n\r\n  return {\r\n    callbackMap,\r\n    clear() {\r\n      ;[...callbackMap.keys()].forEach(clear)\r\n    },\r\n  }\r\n}\r\n```\r\n\r\n使用\r\n\r\n```ts\r\nconst vmSetTimeout = defineSetTimeout(vm)\r\nwithScope(vm, (vm) => {\r\n  vm.evalCode(`\r\n      const begin = Date.now()\r\n      setInterval(() => {\r\n        console.log(Date.now() - begin)\r\n      }, 100)\r\n    `)\r\n}).dispose()\r\nvmSetTimeout.clear()\r\n```\r\n\r\n### 实现 setInterval\r\n\r\n基本上，与实现 setTimeout 流程差不多\r\n\r\n```ts\r\nimport { QuickJSVm } from 'quickjs-emscripten'\r\nimport { withScope } from '../util/withScope'\r\nimport { deleteKey } from '../util/deleteKey'\r\nimport { CallbackIdGenerator } from '@webos/ipc-main'\r\n\r\nexport interface VmSetInterval {\r\n  callbackMap: Map<string, any>\r\n  clear(): void\r\n}\r\n\r\n/**\r\n * 注入 setInterval 方法\r\n * 需要在注入后调用 {@link defineEventLoop} 让 vm 的事件循环跑起来\r\n * @param vm\r\n */\r\nexport function defineSetInterval(vm: QuickJSVm): VmSetInterval {\r\n  const callbackMap = new Map<string, any>()\r\n  function clear(id: string) {\r\n    withScope(vm, (vm) => {\r\n      deleteKey(\r\n        vm,\r\n        vm.unwrapResult(vm.evalCode(`VM_GLOBAL.setTimeoutCallback`)),\r\n        id,\r\n      )\r\n    }).dispose()\r\n    clearInterval(callbackMap.get(id))\r\n    callbackMap.delete(id)\r\n  }\r\n  withScope(vm, (vm) => {\r\n    const vmGlobal = vm.getProp(vm.global, 'VM_GLOBAL')\r\n    if (vm.typeof(vmGlobal) === 'undefined') {\r\n      throw new Error('VM_GLOBAL 不存在，需要先执行 defineVmGlobal')\r\n    }\r\n    vm.setProp(vmGlobal, 'setIntervalCallback', vm.newObject())\r\n    vm.setProp(\r\n      vm.global,\r\n      'setInterval',\r\n      vm.newFunction('setInterval', (callback, ms) => {\r\n        const id = CallbackIdGenerator.generate()\r\n        //此处已经是异步了，必须再包一层\r\n        withScope(vm, (vm) => {\r\n          const callbacks = vm.unwrapResult(\r\n            vm.evalCode('VM_GLOBAL.setIntervalCallback'),\r\n          )\r\n          vm.setProp(callbacks, id, callback)\r\n          const interval = setInterval(() => {\r\n            withScope(vm, (vm) => {\r\n              vm.callFunction(\r\n                vm.unwrapResult(\r\n                  vm.evalCode(`VM_GLOBAL.setIntervalCallback['${id}']`),\r\n                ),\r\n                vm.null,\r\n              )\r\n            }).dispose()\r\n          }, vm.dump(ms))\r\n          callbackMap.set(id, interval)\r\n        }).dispose()\r\n        return vm.newString(id)\r\n      }),\r\n    )\r\n    vm.setProp(\r\n      vm.global,\r\n      'clearInterval',\r\n      vm.newFunction('clearInterval', (id) => clear(vm.dump(id))),\r\n    )\r\n  }).dispose()\r\n\r\n  return {\r\n    callbackMap,\r\n    clear() {\r\n      ;[...callbackMap.keys()].forEach(clear)\r\n    },\r\n  }\r\n}\r\n```\r\n\r\n### 实现事件循环\r\n\r\n但有一点麻烦的是，quickjs-emscripten 不会自动执行事件循环，即 Promise 在 resolve 之后不会自动执行下一步。官方提供了 `executePendingJobs` 方法让我们手动执行事件循环，如下所示\r\n\r\n```ts\r\nconst { log } = defineMockConsole(vm)\r\nwithScope(vm, (vm) => {\r\n  vm.evalCode(`Promise.resolve().then(()=>console.log(1))`)\r\n}).dispose()\r\nexpect(log.mock.calls.length).toBe(0)\r\nvm.executePendingJobs()\r\nexpect(log.mock.calls.length).toBe(1)\r\n```\r\n\r\n所以我们实现可以使用一个自动调用 `executePendingJobs` 的函数\r\n\r\n```ts\r\nimport { QuickJSVm } from 'quickjs-emscripten'\r\n\r\nexport interface VmEventLoop {\r\n  clear(): void\r\n}\r\n\r\n/**\r\n * 定义 vm 中的事件循环机制，尝试循环执行等待的异步操作\r\n * @param vm\r\n */\r\nexport function defineEventLoop(vm: QuickJSVm) {\r\n  const interval = setInterval(() => {\r\n    vm.executePendingJobs()\r\n  }, 100)\r\n  return {\r\n    clear() {\r\n      clearInterval(interval)\r\n    },\r\n  }\r\n}\r\n```\r\n\r\n现在只要调用 defineEventLoop 即会循环执行 `executePendingJobs` 函数了\r\n\r\n```ts\r\nconst { log } = defineMockConsole(vm)\r\nconst eventLoop = defineEventLoop(vm)\r\ntry {\r\n  withScope(vm, (vm) => {\r\n    vm.evalCode(`Promise.resolve().then(()=>console.log(1))`)\r\n  }).dispose()\r\n  expect(log.mock.calls.length).toBe(0)\r\n  await wait(100)\r\n  expect(log.mock.calls.length).toBe(1)\r\n} finally {\r\n  eventLoop.clear()\r\n}\r\n```\r\n\r\n## 实现沙箱与系统之间的通信\r\n\r\n现在，我们沙箱还欠缺的就是通信机制了，下面我们便实现一个 `EventEmiiter`。\r\n\r\n核心是让系统层和沙箱都实现 EventEmitter，quickjs 允许我们向沙箱中注入方法，所以我们可以注入一个 Map 和 `emitMain` 函数。让沙箱既能够向 Map 中注册事件以供系统层调用，也能通过 `emitMain` 向系统层发送事件。\r\n\r\n![沙箱与系统之间的通信.drawio.svg](:/ff279700bc3646e68b53ba833dce9a5f)\r\n\r\n```ts\r\nimport { QuickJSHandle, QuickJSVm } from 'quickjs-emscripten'\r\nimport { marshal } from '../util/marshal'\r\nimport { withScope } from '../util/withScope'\r\nimport { IEventEmitter } from '@webos/ipc-main'\r\n\r\nexport type VmMessageChannel = IEventEmitter & {\r\n  listenerMap: Map<string, ((msg: any) => void)[]>\r\n}\r\n\r\n/**\r\n * 定义消息通信\r\n * @param vm\r\n */\r\nexport function defineMessageChannel(vm: QuickJSVm): VmMessageChannel {\r\n  const res = withScope(vm, (vm) => {\r\n    const vmGlobal = vm.getProp(vm.global, 'VM_GLOBAL')\r\n    if (vm.typeof(vmGlobal) === 'undefined') {\r\n      throw new Error('VM_GLOBAL 不存在，需要先执行 defineVmGlobal')\r\n    }\r\n    const listenerMap = new Map<string, ((msg: string) => void)[]>()\r\n    const messagePort = marshal(vm)({\r\n      //region vm 进程回调函数定义\r\n      listenerMap: new Map(),\r\n      //给 vm 进程用的\r\n      emitMain(channel: QuickJSHandle, msg: QuickJSHandle) {\r\n        const key = vm.dump(channel)\r\n        const value = vm.dump(msg)\r\n        if (!listenerMap.has(key)) {\r\n          console.log('主进程没有监听 api: ', key, value)\r\n          return\r\n        }\r\n        listenerMap.get(key)!.forEach((fn) => {\r\n          try {\r\n            fn(value)\r\n          } catch (e) {\r\n            console.error('执行回调函数发生错误: ', e)\r\n          }\r\n        })\r\n      },\r\n      //endregion\r\n    })\r\n    vm.setProp(vmGlobal, 'MessagePort', messagePort.value)\r\n    //给主进程用的\r\n    function emitVM(channel: string, msg: string) {\r\n      withScope(vm, (vm) => {\r\n        const _map = vm.unwrapResult(\r\n          vm.evalCode('VM_GLOBAL.MessagePort.listenerMap'),\r\n        )\r\n        const _get = vm.getProp(_map, 'get')\r\n        const _array = vm.unwrapResult(\r\n          vm.callFunction(_get, _map, vm.newString(channel)),\r\n        )\r\n        if (!vm.dump(_array)) {\r\n          return\r\n        }\r\n        for (\r\n          let i = 0, length = vm.dump(vm.getProp(_array, 'length'));\r\n          i < length;\r\n          i++\r\n        ) {\r\n          vm.callFunction(\r\n            vm.getProp(_array, vm.newNumber(i)),\r\n            vm.null,\r\n            marshal(vm)(msg).value,\r\n          )\r\n        }\r\n      }).dispose()\r\n    }\r\n    return {\r\n      emit: emitVM,\r\n      offByChannel(channel: string): void {\r\n        listenerMap.delete(channel)\r\n      },\r\n      on(channel: string, handle: (data: any) => void): void {\r\n        if (!listenerMap.has(channel)) {\r\n          listenerMap.set(channel, [])\r\n        }\r\n        listenerMap.get(channel)!.push(handle)\r\n      },\r\n      listenerMap,\r\n    } as VmMessageChannel\r\n  })\r\n  res.dispose()\r\n  return res.value\r\n}\r\n```\r\n\r\n> 可以看到，我们除了实现了 IEventEmitter，还额外添加了字段 listenerMap，这主要是希望向上层暴露更多细节，便于在需要的时候（例如清理全部注册的事件）可以直接实现。\r\n\r\n使用\r\n\r\n```ts\r\ndefineVmGlobal(vm)\r\nconst messageChannel = defineMessageChannel(vm)\r\nconst mockFn = jest.fn()\r\nmessageChannel.on('hello', mockFn)\r\nwithScope(vm, (vm) => {\r\n  vm.evalCode(`\r\nclass QuickJSEventEmitter {\r\n    emit(channel, data) {\r\n        VM_GLOBAL.MessagePort.emitMain(channel, data);\r\n    }\r\n    on(channel, handle) {\r\n        if (!VM_GLOBAL.MessagePort.listenerMap.has(channel)) {\r\n            VM_GLOBAL.MessagePort.listenerMap.set(channel, []);\r\n        }\r\n        VM_GLOBAL.MessagePort.listenerMap.get(channel).push(handle);\r\n    }\r\n    offByChannel(channel) {\r\n        VM_GLOBAL.MessagePort.listenerMap.delete(channel);\r\n    }\r\n}\r\n\r\nconst em = new QuickJSEventEmitter()\r\nem.emit('hello', 'liuli')\r\n`)\r\n}).dispose()\r\nexpect(mockFn.mock.calls[0][0]).toBe('liuli')\r\nmessageChannel.listenerMap.clear()\r\n```\r\n\r\n## 目前 quickjs 沙箱的限制\r\n\r\n下面是目前实现的一些限制，也是以后可以继续改进的点\r\n\r\n- `console` 仅支持常见的 `log/info/warn/error` 方法\r\n- `setTimeout/setInterval` 事件循环时间没有保证，目前大约在 100ms 调用一次\r\n- 无法使用 chrome devtool 调试，也不会处理 sourcemap（figma 至今的开发体验仍然如此，后面可能添加开关支持在 web worker 中调试）\r\n- vm 中出现错误不会将错误抛出来并打印在控制台\r\n- 各个 api 调用的顺序与清理顺序必须手动保证是相反的，例如 vm 创建必须在 `defineSetTimeout` 之前，而 `defineSetTimeout` 的清理函数调用必须在 `vm.dispose` 之前\r\n","createdTime":1635061876080,"updatedTime":1635076361314,"resources":[{"id":"f4568d723eb942838d7a068d46f721a1","title":"基于 quickjs 实现 setTimeout 与 clearTimeout.drawio.svg","file_extension":"svg","user_updated_time":1635069054595},{"id":"ff279700bc3646e68b53ba833dce9a5f","title":"沙箱与系统之间的通信.drawio.svg","file_extension":"svg","user_updated_time":1635075679794}],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"b63ba6ff31c049f8a6703ce7022a79e6","title":"Git 速查清单","body":"记录一些最常用的命令（从上往下使用频率依次降低），当然，这里只是吾辈个人的，其他功能可能暂时还没用到呢\r\n\r\n> 详细的 git 相关知识强烈推荐 [Pro Git](https://git-scm.com/book/zh)\r\n\r\n## 基本命令\r\n\r\n| 关键词   | 命令格式                              | 命令解释                                                                       | 命令示例                                                                 | 命令解释                                                             |\r\n| -------- | ------------------------------------- | ------------------------------------------------------------------------------ | ------------------------------------------------------------------------ | -------------------------------------------------------------------- |\r\n| init     | `git init`                            | 为当前目录初始化 git 本地仓库                                                  |\r\n| add      | `git add [要追踪的文件/路径]`         | 添加到 git 跟踪                                                                | `git add -A`                                                             | 追踪仓库目录下的所有文件                                             |\r\n| commit   | `git commit [路径] [选项] [提交说明]` | 提交当前的修改内容                                                             | `git commit -a -m \"提交全部的修改\"`                                      | 提交了全部的修改内容（仍在本机）                                     |\r\n| remote   | `git remote [选项] [远程仓库名]`      | 操作 git 远程仓库                                                              | `git remote`                                                             | 显示所有远程仓库的别名                                               |\r\n|          |                                       |                                                                                | `git remote add origin https://github.com/rxliuli/rxliuli.github.io.git` | 为本地仓库关联一个远程仓库                                           |\r\n|          |                                       |                                                                                | `git remote show origin`                                                 | 显示 origin 远程仓库的详细信息                                       |\r\n|          |                                       |                                                                                | `git remote remove origin`                                               | 删除 origin 远程仓库                                                 |\r\n| push     | `git push [远程别名] [远程分支]`      | 推送本地修改到远程                                                             | `git push origin master`                                                 | 推送本地修改到远程 origin 的 master 分支上                           |\r\n| pull     | `git pull [远程别名] [远程分支]`      | 拉取远程修改到本地                                                             | `git pull origin master`                                                 | 拉去远程 origin 上 master 分支的修改到本地                           |\r\n| status   | `git status`                          | 查看本地仓库的状态，以此得知添加和修改的文件                                   |\r\n| clone    | `git clone [远程仓库地址]`            | 克隆一个远程仓库到本地，这里和 pull 不同点在于本地不存在要克隆的仓库           | `git clone https://github.com/rxliuli/rxliuli.github.io.git`             | 克隆吾辈的博客 github 仓库到本地                                     |\r\n| log      | `git log [选项]`                      | 查看 git 日志                                                                  | `git log`                                                                | 简单的查看 git commit 历史纪录                                       |\r\n| revert   | `git revert [提交记录 hash]`          | 撤销掉指定提交                                                                 | `git revert ab1c2d2`                                                     | 撤销一次提交内容，然后将撤销的内容作为修改提交一次，保留了所有的记录 |\r\n| reset    | `git reset [提交记录 hash]`           | 重置到某次提交上，和上面不一样的是不会添加新的提交记录，而是删除已有的提交记录 | `git reset ab1c2d2`                                                      | 不会在 log 中留下痕迹                                                |\r\n|          | `git reset HEAD~[N 回退次数]`         | 回退最近几次的提交, N 为几就回退几次                                           | `git reset HEAD~1`                                                       | 回退最近一次的提交                                                   |\r\n| branch   | `git branch [分支]`                   | git 分支(强大而又复杂的功能)                                                   | `git branch dev`                                                         | 创建 dev 分支                                                        |\r\n|          |                                       |                                                                                | `git branch`                                                             | 列出所有分支                                                         |\r\n|          |                                       |                                                                                | `git branch dev -D`                                                      | 删除名为 dev 的分支                                                  |\r\n| checkout | `git checkout [分支名]`               | 切换当前分支(分支之间不共享修改)                                               | `git checkout master`                                                    | 切换当前分支到 master 分支                                           |\r\n|          |                                       |                                                                                | `git checkout origin/dev -b dev`                                         | 拉取远程分支到本地并切换                                             |\r\n| merge    | `git merge [选项]`                    | 合并其他分支的修改到当前分支上                                                 | `git merge dev`                                                          | 合并 dev 分支的修改到当前分支(一般是 master 分支)                    |\r\n|          |                                       |                                                                                | `git merge origin/master --allow-unrelated-histories`                    | 强行合并远程分支到本地                                               |\r\n| push     | `git push [远程仓库名] :[分支名]`     | 删除掉指定的远程分支（仓库还在，只是删除分支）                                 | `git push origin :dev`                                                   | 删除远程仓库 origin 下的 dev 开发分支                                |\r\n| stash    | `git stash`                           | 暂存本地更改                                                                   |\r\n|          | `git stash list`                      | 查看所有暂存更改                                                               |\r\n|          | `git stash apply [index]`             | 重新应用指定暂存更改                                                           | `git stash apply`                                                        | 重新应用最新的暂存更改                                               |\r\n|          | `git stash drop [index]`              | 删除掉指定的暂存更改                                                           | `git stash drop`                                                         | 删除掉最新的暂存更改                                                 |\r\n\r\n## 复合命令\r\n\r\n### 撤销掉本地所有的修改\r\n\r\n命令\r\n\r\n```sh\r\ngit add -A && git stash && git stash drop\r\n```\r\n\r\n解释\r\n\r\n1. 添加所有更改到 git 追踪中（如果没有被忽略的话）\r\n2. 添加所有本地更改到暂存区域中\r\n3. 删除掉刚添加的最新暂存更改\r\n\r\n应用场景修改了一些文件但又没有提交，突然发现有问题，想把它们全删除了重来，或者全部回到上次提交，先把这些修改暂存起来（不加最后一条命令）\r\n\r\n### 区分文件名大小写\r\n\r\n命令\r\n\r\n```sh\r\ngit config core.ignorecase false\r\n```\r\n\r\n解释 Windows 下默认不区分文件名大小写，所以需要特别设置一下。\r\n\r\n### git push 强制推送\r\n\r\n命令\r\n\r\n```sh\r\ngit push -f\r\n```\r\n\r\n解释\r\n\r\n强制推送到远程分支，即便是远程包含本地不存在的提交\r\n\r\n### 忽略已经跟踪的文件的提交\r\n\r\n> 参考：[怎样让 Git 忽略当前已经更改的文件](https://ruby-china.org/topics/17948)\r\n\r\n忽略修改\r\n\r\n```sh\r\ngit update-index --assume-unchanged <files>\r\n```\r\n\r\n取消这种设定\r\n\r\n```sh\r\ngit update-index --no-assume-unchanged <files>\r\n```\r\n\r\n### 从远端拉取分支\r\n\r\n> 参考：[git 获取远程服务器的指定分支](https://www.cnblogs.com/phpper/p/7136048.html)\r\n\r\n命令\r\n\r\n```sh\r\ngit checkout -b [本地分支名(不存在)] [远程分支名]\r\n```\r\n\r\n示例\r\n\r\n```sh\r\ngit checkout -b dev origin/dev\r\n```\r\n\r\n### 忽略已提交的文件修改\r\n\r\n> 参考：[git 如何忽略已经提交的文件 (.gitignore 文件无效)](https://www.jianshu.com/p/e5b13480479b)\r\n\r\n主要用于忽略一些本地修改的文件但又不希望提交，同时也不希望添加到 .gitignore 中将之从云端排除的方式。\r\n\r\n```sh\r\ngit update-index --assume-unchanged [file-pattern]\r\n```\r\n\r\n### git 删除远程 tag\r\n\r\n显示本地 tag\r\n\r\n```sh\r\ngit tag\r\n```\r\n\r\n删除本地 tag\r\n\r\n```sh\r\ngit tag -d Remote_Systems_Operation\r\n```\r\n\r\n用 push, 删除远程 tag\r\n\r\n```sh\r\ngit push origin :refs/tags/Remote_Systems_Operation\r\n```\r\n\r\n删除远程分支\r\n\r\n```sh\r\ngit branch -r -d origin/branch-name\r\ngit push origin :branch-name\r\n```\r\n\r\n### 两个 git 仓库合并\r\n\r\n现在有两个仓库 [kktjs/kkt](https://github.com/kktjs/kkt.git) 和 [kktjs/kkt-next](https://github.com/kktjs/kkt-next.git) 我们需要将 `kkt-next` 仓库合并到 `kkt` 并保留 `kkt-next` 的所有提交内容。\r\n\r\n```sh\r\n# 1. 克隆主仓库代码\r\ngit clone git@github.com:kktjs/kkt.git\r\n\r\n# 2. 将 kkt-next 作为远程仓库，添加到 kkt 中，设置别名为 other\r\ngit remote add other git@github.com:kktjs/kkt-next.git\r\n\r\n# 3. 从 kkt-next 仓库中拉取数据到本仓库\r\ngit fetch other\r\n\r\n# 4. 将 kkt-next 仓库拉取的 master 分支作为新分支 checkout 到本地，新分支名设定为 dev\r\ngit checkout -b dev other/master\r\n\r\n# 5. 切换回 kkt 的 master 分支\r\ngit checkout master\r\n\r\n# 6. 将 dev 合并入 kkt 的 master 分支\r\ngit merge dev\r\n\r\n# 如果第 6 步报错 `fatal: refusing to merge unrelated histories`\r\n# 请执行下面命令 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\r\ngit merge dev --allow-unrelated-histories\r\n```\r\n\r\n> JetBrains IDE 提供了非常好用的冲突合并工具\r\n\r\n在合并时有可能两个分支对同一个文件都做了修改，这时需要解决冲突，对文本文件来说很简单，根据需要对冲突的位置进行处理就可以。对于二进制文件，需要用到如下命令:\r\n\r\n```sh\r\ngit checkout --theirs YOUR_BINARY_FILES     # 保留需要合并进来的分支的修改\r\ngit checkout --ours YOUR_BINARY_FILES       # 保留自己的修改\r\ngit add YOUR_BINARY_FILES\r\n```\r\n\r\n> 参考: [https://segmentfault.com/a/1190000021919753](https://segmentfault.com/a/1190000021919753)\r\n\r\n### 在 git 目录中忽略 git 子模块的所有变更\r\n\r\n> 参考 [git submodule](https://git-scm.com/docs/gitmodules#Documentation/gitmodules.txt-submoduleltnamegtignore)\r\n\r\n```shell\r\n# .gitmodules\r\n[submodule \"examples/blog-hexo-example/themes/next\"]\r\n  path = examples/blog-hexo-example/themes/next\r\n  url = https://github.com/theme-next/hexo-theme-next\r\n  ignore = all\r\n```\r\n\r\n### git 提交时忽略 hooks\r\n\r\n添加 `--no-verify` 参数即可\r\n\r\n```sh\r\ngit commit --no-verify\r\n```\r\n\r\n### Git 错误 Reset 恢复\r\n\r\n1. 找到使用 `git reset` 之前的最后一次提交的 `commit id`\r\n\r\n   ```sh\r\n   # 查看 git 记录的所有操作，包括回退操作也会记录\r\n   git reflog\r\n   ```\r\n\r\n2. 使用 `git reset --hard` 回退\r\n\r\n   ```sh\r\n   # 回退到指定提交，但不会将之后提交混入到未提交的内容\r\n   git reset --hard dd256c7d66ad2e9671cbd47650ffddc4267ca7d5\r\n   ```\r\n\r\n3. 使用 `git log` 检查最后一次提交是否恢复\r\n\r\n   ```sh\r\n   # 这时可以看到最后一次提交已经恢复了\r\n   git log\r\n   ```\r\n\r\n> 参考: [执行了 git reset，还有办法取消吗？](https://segmentfault.com/q/1010000000167491)\r\n\r\n### Git 高级合并\r\n\r\n前端想要调整项目组织将之前的项目放到 `monorepo` 中，所以需要使用 git 将之前的项目合并到新项目的指定目录中，同时保留所有记录。\r\n\r\n> 主要依赖功能 [高级合并 => 子树合并](https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6#_subtree_merge)，同时参考错误解决方案 [The “fatal: refusing to merge unrelated histories” Git error](https://www.educative.io/edpresso/the-fatal-refusing-to-merge-unrelated-histories-git-error)\r\n\r\n```sh\r\ngit remote add rack_remote https://github.com/rack/rack\r\ngit fetch rack_remote --no-tags\r\ngit checkout -b rack_branch rack_remote/master\r\ngit checkout master\r\ngit read-tree --prefix=rack/ -u rack_branch\r\ngit merge --squash -s recursive -Xsubtree=rack rack_branch --allow-unrelated-histories\r\n```\r\n\r\n### 系统更新后 git 错误\r\n\r\n需要修改 _~/.ssh/config_ 配置文件\r\n\r\n```sh\r\nHost *\r\n  ServerAliveInterval 10\r\n  HostKeyAlgorithms +ssh-rsa\r\n  PubkeyAcceptedKeyTypes +ssh-rsa\r\n```\r\n","createdTime":1580652937988,"updatedTime":1634900342074,"resources":[],"tags":[{"id":"0fe3bdc669564a3494e66bc1693d7f3f","title":"git","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"d25cb9b2f5d446ce852b03c15e8fb8e5","title":"Windows 上的工具清单","body":"> 但弄雕虫之技，尘芥草莽，于泥泞自勉……\r\n\r\n## 开发\r\n\r\n### JetBrains IDE：最棒的 IDE 系列\r\n\r\n[便携版], [部分开源], [跨平台]\r\n\r\n虽然说起最好的 IDE 什么的肯定是各种争论，但吾辈还是想说，在 Java、前端开发方面，JetBrains IDE 是目前最好的。\r\n\r\n优点：\r\n\r\n- 智能提示  \r\n  IDEA 在代码提示方面真的是无可比拟（相比于 Eclipse 来说），通常在还没有打完全部代码的时候，IDEA 就知道想要做什么了，然后给吾辈最常用的提示。并且，对于某些不太好的代码，IDEA 会提出一些建议甚至帮助进行安全的重构。一般而言吾辈认为，如果 IDEA 认为代码有问题，那么一般真的是代码有问题（确实有些情况下也不尽如此）\r\n- 开箱即用  \r\n  虽然很不起眼，但这确实很重要。当下载完 IDEA 之后，几乎不需要安装什么插件，进行繁复的配置，就能开始工作了！因为 IDEA 帮我们准备好了绝大多数情况所需要的插件，很多配置也都有着良好的默认值。\r\n- 插件系统  \r\n  或许 IDEA 的插件数量比不上 Eclipse，但 IDEA 的插件系统确实已经很完善了，至少，对于吾辈而言已然足够了。\r\n- 界面很棒  \r\n  其实这个就是吸引吾辈入坑 IDEA 的原因之一，毕竟曾经其他人都在用着 Eclipse 的时候，吾辈看到了 IDEA 的黑色主题就被吸引了，然后到现在成了 IDEA 的死忠粉。\r\n- 搜索功能  \r\n  非常强大的搜索功能，可以搜索类，文件，字段，以及全文搜索，包括正则表达式，文件后缀名等过滤功能。\r\n- 调试  \r\n  或许有人说，现代的 IDE 基本上都有调试功能吧。但 IDEA 是不同的，它可以同时调试 Java 与 JavaScirpt 以及其他所集成的语言，这可真是强大无比。使用 JavaScript 发送一个请求，然后进入后台代码调试，得到 SQL 语句，去查询数据库，而这一切，都是在 IDEA 内部完成的！\r\n- 语言注入  \r\n  这是 IDEA 比较高级的部分了，但这也是一个相当强大的功能。例如，有时候我们不得不手写 SQL 语句，或者在 JavaScript 中拼接 HTML 代码。难道我们必须要去对应的文件中编辑完之后复制过来么？不不不，语言注入就是可以为某一个代码片段注入为某一种语言，例如你可以为 Java 中的字符串注入 SQL 语言。在字符串中，你写 SQL 语句就有提示了！\r\n  > 当然，语言注入也是要符合基本法的，必须是 IDEA 支持的语言才行，不过 IDEA 对主流语言的支持都还不错。\r\n\r\n缺点：\r\n\r\n- 硬件杀手  \r\n  IDEA 是出了名的吃内存（日常），吃磁盘（扫描项目建立索引）以及 CPU（索引）。\r\n- 小病不断  \r\n  虽然 IDEA 很是强大，但各种小问题也是层出不穷。例如自定义的 Maven 到了新的项目就变成默认的了。。。\r\n\r\n常用的 Plugin：\r\n\r\n- Atom Material Icons：丰富的文件 icon，让不同类型的文件跟容易区分\r\n- Rainbow Brackets：为多个对称的括号使用不同的颜色便于区分\r\n- AceJump：在屏幕可见区域内任意跳转\r\n- String Manipulation：字符串操作工具，可以方便对变量名或其他字符串修改为其他风格，例如将变量从 **驼峰命名**（Java 标准命名） 修改为 **下划线命名**（SQL 标准命名）或者 **中缀线命名**（HTML/CSS 标准命名）。\r\n  > 其实这么多命名规范真心坑。。。\r\n- Translation：目前使用感觉最好的翻译插件，能够提供比较长的内容进行翻译（某些翻译插件只能翻译很短的内容）。\r\n- Quokka：快速运行一个 js、ts 文件验证想法\r\n- Wallaby：前端所见即所得测试工具，最近的更新超级强力，支持仅运行打开的测试的文件\r\n\r\n> 入门推荐教程（简体中文）：<https://github.com/judasn/IntelliJ-IDEA-Tutorial>\r\n\r\n### VSCode：基于 Web 技术最优秀的编辑器\r\n\r\n[便携版], [开源], [跨平台], [免费]\r\n\r\n> 具体可以参考：[官网](https://code.visualstudio.com/), [GitHub](https://github.com/Microsoft/vscode), [GitBook 中文介绍](https://jeasonstudio.gitbooks.io/vscode-cn-doc/content/)\r\n\r\nMS VSCode 是微软出品的一个跨平台，基于 Web 的，免费的开源文本编辑器。目前已经使用了半年多了，对其的了解也更加深入。就目前看来，VSCode 应该是使用 Web 技术实现的最优秀的编辑器。作为一个文本编辑器，大多数的文本文件都有语法支持的扩展真的太棒了，这点要强过专门的 IDE。\r\n\r\n主要优点：\r\n\r\n- 开箱即用：基本上下载完就能开始使用了，不需要太多自定义的配置 -- 实际上对于各类前端框架仍然需要安装形形色色的插件\r\n- 多语言支持：这是很多文本编辑器/IDE 都没有做到的，例如下面吾辈最喜欢的 IDEA 到目前为止官方仍然只支持英文，但吾辈觉得本土化之后才能对萌新更加友好（门槛低，学习曲线平缓）-- IDEA 支持中文了，但吾辈并未使用\r\n- 插件丰富：目前吾辈使用 VSCode 主要用于前端，编辑 Markdown 文章，一些系统/程序的配置文件等，安装了插件之后使用对各种功能的支持还算不错。\r\n\r\n缺点：\r\n\r\n很明显，MS 的东西最后会不会变成全家桶/流氓谁也不清楚，虽然去年貌似 MS 在 GitHub 上的贡献量超过了 Google，但想想 MS 的开源黑历史。。。而且，作为一个专门的编程编辑器，有许多的细节上还是很粗糙（貌似开源项目的通病），相比于专业的 IDE（例如 WebStorm）还是相差不少。下面举一些例子\r\n\r\n- 本地文件历史: 没有加入到 Git 管理中的文件丢失，血与泪的教训啊\r\n- 单词检查: 英文单词写错了还不知道，萌萌哒！\r\n- 代码跳转功能很弱: 专业 IDE 里几乎所有有关连的东西都是可以跳转的。例如在 CSS 中查看使用 class 的引用列表，在 HTML 中跳转到 CSS 的 class 定义处，HTML 中有代码提示 CSS 类。JS 中查看函数的引用列表，查看函数的定义处，查看函数的实现（老实说 VSCode 基于 ts 实现的代码提示感觉真是在下一盘大棋。。。）\r\n- Git 支持: VSCode 中 Git 支持还不成熟，并没有像 IDE 中那么方便与强大\r\n- HTML 标签修改的时候没有自动修改对应的标签: 纯粹是细节性问题\r\n- TODO 支持: 对 `TODO` 标签没有支持\r\n\r\n> 参考：[VSCode 与 WebStorm 横向对比](:/a305aafaac2b4ee8b9fa2f97898f1eea)\r\n\r\n### Google Chrome：最好的浏览器\r\n\r\n[部分开源], [跨平台], [免费]\r\n\r\n> [官网](https://www.google.com/chrome/), [Google Chromium 各版本下载](https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html)\r\n\r\n非常有名的浏览器，来源于 Google，在 PC 上不管是用于开发还是日常使用都能够满足需求。相比于国内的流氓而言非常干净简洁（至少，看起来而言），相比于 FireFox 来说更快，插件体系也已经足够庞大完整，基本上想要的都有了。Chrome 虽然已经很完美了，但 Google 却并非如此，最近 Chrome 开始变得越来越封闭了。首先是 Chrome 应用被删除，现在又禁止安装非官方商店中的第三方插件（目前仍可以通过开发者模式安装），真心越来越麻烦了。\r\n\r\n> 参考：[优化 Google Chrome 的使用体验](:/cdeb250dd4e04b168bc608cc9a118697)\r\n\r\n### drawio：开源免费的画图工具\r\n\r\n[便携版], [开源], [免费]，[跨平台]\r\n\r\n> [官网](https://app.diagrams.net/), [GitHub](https://github.com/jgraph/drawio)\r\n\r\n目前能找到的最好的免费开源的画图解决方案，能够制作流程图、UML 图、组织结构图、泳道图等绘图。允许导出为图片/HTML/PDF 等各种格式，全平台免费可用的解决方案。\r\n\r\n> ProcessOn 是一个更加本地化的解决方案，并且添加了思维导图支持，只允许在线编辑导致了数据的最终权力不在自己手上，强制收费则让（小）团队使用成为一件可望而不可及的事情。注：此处不是故意黑 ProcessOn，因为吾辈也是它的付费用户，但在团队内推广使用确实会存在一些问题。\r\n\r\n### Git：Git 版本控制系统\r\n\r\n[便携版], [开源], [跨平台], [免费]\r\n\r\n> [官网](https://git-scm.com/), [GitHub](https://github.com/git/git)\r\n\r\n最初由 Linus 开发的一个分布式的版本控制系统，现在已经是最流行的版本控制系统之一了。说到 Git 不得不提 GitHub，GitHub 为 Git 实现了一个在线代码（或者其他）托管平台，相当好用而且托管开源项目是免费的。其实对于吾辈而言 Git 只是一个用于在本地操作 GitHub 的客户端罢了（很少有添加到 Git 而没有提交到 GitHub 的代码）。正是因为 GitHub 对 Git 的支持之好，所以吾辈才喜欢使用 Git 的。。。（#因果颠倒）\r\n\r\n### Termius：简单漂亮的 SSH 连接工具\r\n\r\n[跨平台]\r\n\r\n> [官网](https://www.termius.com/)\r\n\r\n非常漂亮的一个远程连接工具，免费版本仅支持 SSH 连接，而 SFTP 则是收费版本的功能，吾辈作为前端感觉算是足够了。\r\n\r\n> 更强大的远程连接工具：[Mobaxterm](https://mobaxterm.mobatek.net/)，功能非常强大但界面复古（Win7 时代的风格）。\r\n\r\n## 日常\r\n\r\n### Win + R：快速启动\r\n\r\n虽说 Windows 上也有快速启动工具，但 Windows 原生的快速启动已然足够使用了。将快捷方式命名为一个简单的名字，例如将 **Google Chrome** 命名为 **GC**，然后丢到当前用户目录下，然后使用 **Win + R** 弹出运行窗口，然后输入 **GC**，系统就会启动 **Google Chrome** 了。\r\n\r\n当然，更好的方法是新建一个目录保存这些快速启动的快捷方式，然后将目录添加到环境变量中即可（`Path`）。\r\n\r\n### SSR：正常上网必须\r\n\r\n[便携版], [开源], [跨平台], [免费]\r\n\r\n> [GitHub](https://github.com/shadowsocksr-backup)\r\n\r\n为了正常浏览网络折腾与支付一些代价都是微不足道的，貌似比 `ShadowScoks` 要稳定一点，不过据传闻作者最初并未打算将其开源。\r\n\r\n### Proxifier：代理一切\r\n\r\n> [官网](https://www.proxifier.com/)\r\n\r\n虽然 SSR 可以连接代理服务器，同时还提供局域网内的 Socks5/HTTP 的代理，同时 Chrome 自动使用系统代理，所以我们可以方便的直接打开 Google 了。然而，并不是所有程序都像是 Chrome 浏览器那么友好，许多支持代理的程序都需要手动进行配置，更麻烦的地方是：很多程序不包含代理设置 -- 尤其是开发相关的工具链。\r\n\r\n先说几个具体的使用场景吧\r\n\r\n- 进行 web 开发时，有些 npm 包（electron/SQLLite）会在 install 时从网络下载二进制文件，而因为众所周知的原因，它们的下载速度并不快，而 nodejs 也不能配置代理（事实上，即便配置了，也不是所有 npm 包都会读）\r\n- 希望监听某些程序到底有没有发送网络请求，但却不能尽知\r\n\r\n### MacType：字体美化\r\n\r\n[开源], [免费]\r\n\r\n> [官网](http://www.mactype.net/), [GitHub](https://github.com/snowie2000/mactype)\r\n\r\nWindows 上的字体就是会出现锯齿（所谓的点阵字体真是坑），不过 MacType 可以缓解这一现象。它可以美化 Windows 对字体的渲染（绝大部分程序都不会出现问题），让吾辈在使用 Windows 的时候看着代码更舒服一点。\r\n\r\n> 附: MacType 配置推荐 **注册表加载 + Iof => XHei => Default** 附：字体个人推荐 [Sarasa-Gothic](https://github.com/be5invis/Sarasa-Gothic)，中文名是更纱黑体，包含 **英/简中/繁中/日** 四种语言\r\n\r\n### Joplin：适合开发者的笔记工具\r\n\r\n[便携版], [开源], [跨平台], [免费]\r\n\r\n> [官网](https://joplinapp.org/), [GitHub](https://github.com/laurent22/joplin)\r\n\r\n一个开源跨平台的笔记工具，使用的模式是本地程序 + 第三方服务同步的方式，编辑功能算是比较弱的，同步也不算是最好的，甚至于客户端也不算是最漂亮的。但是，它有一些非常显著的优点，甚至足以压倒以上的缺点。\r\n\r\n主要优点：\r\n\r\n1. 搜索很快，非常快\r\n2. 可以使用外部编辑器打开\r\n3. 数据都在自己手里，提供一次性导出全部的功能\r\n4. 使用标准的 md，可以直接复制到其他平台\r\n5. 可以基于它进行二次开发\r\n\r\n主要缺点：\r\n\r\n1. ui/ux 有点简陋\r\n2. 没有 vsc 插件导致使用外部编辑器也并不是非常方便\r\n\r\n> 之前吾辈使用过 OneNote 和 Notion，两者都是非常好的笔记工具，但两者存在的一些缺点导致吾辈在使用一段时间后选择了放弃。\r\n>\r\n> - OneNote：主要问题是需要自己调整文本格式，不支持 markdown，以及富文本带来的分享问题。\r\n> - Notion：主要问题是编辑体验不好，搜索非常慢，以及非标准 markdown 导致的分享问题。可以参考 [Notion 使用体验](:/6394b6d9a2ba4be7a17fec38f274a50c)\r\n\r\n### FDM：免费的多线程下载器\r\n\r\n[免费]\r\n\r\n> [官网](http://http://www.freedownloadmanager.org)\r\n\r\n全称 Free Download Manager，没什么太多好说的，但用起来还算不错，不会弹个窗口提示下载什么的。\r\n\r\n基本上满足吾辈日常的下载需求吧\r\n\r\n- [x] 提供客户端界面\r\n- [x] 多线程\r\n- [x] 集成 chrome\r\n- [x] 静默下载\r\n- [x] 下载后可以打开文件/文件夹\r\n- [x] 下载完成后弹窗提示（需要设置 Windows 10 通知）\r\n- [ ] 便携版（配置可携带化）\r\n\r\n### Bandizip：压缩/解压缩\r\n\r\n[便携版], [免费]\r\n\r\n> [官网](https://www.bandizip.com/)\r\n\r\n目前吾辈觉得最好的压缩/解压缩软件，具体压缩率/支持格式什么的吾辈也并非专业所以就不说了。但就使用体验上看 Bandizip 是要明显优于其他同类软件的（WinRAR, 7Zip）。\r\n\r\n吾辈看到的优点：\r\n\r\n- 预览压缩文件时左侧有文件夹树状列表，不需要再用鼠标点击进进出出的活塞运动了\r\n- 自动解压，这个功能相当棒，可以智能解压压缩文件到文件夹中（如果压缩包里面只有一个文件夹就直接解压出来，否则会将压缩包里面的内容解压到一个与压缩包同名的文件夹中），这个功能看起来很不起眼，但吾辈在此之前并未找到（需要特别注意压缩包的内容）\r\n\r\n> 注：最新版本强制更新还有广告，所以需要下载修改版或是旧版本，即便如此，它的自动解压仍然是非常优秀的解压功能。\r\n\r\n### JPEGView：图片浏览\r\n\r\n[便携版], [免费]\r\n\r\n> [官网](https://sourceforge.net/projects/jpegview/)\r\n\r\n简单而且好用的图片查看器，相比于吾辈之前使用的 ImageView（中文名是 **快眼看图王**）更快，相比于 HoneyView 更见简洁和易操作。\r\n\r\n主要优点如下：\r\n\r\n- 操作简单：滚轮缩放，按住移动，ESC 关闭，Left/Right 查看上/下张图片\r\n- 性能很高：实测打开速度比 imageview/honeyview 都要更快\r\n\r\n借用[知乎](https://www.zhihu.com/question/21305023)网友理想中的图片查看器需求图\r\n\r\n![理想中的图片查看器](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200408210706.png)\r\n\r\n### Everything：文件快速搜索\r\n\r\n[便携版], [免费]\r\n\r\n> [官网](https://www.voidtools.com/)\r\n\r\n用过 Windows Explorer（文件管理器）搜索文件的人都知道速度是有多慢，有了 Everything 之后这一切都是往事了。Everything 建立了全盘索引，可以对文件/文件夹进行实时搜索，速度之快简直和默认的文件管理器有天壤之别。当然，也能够根据正则表达式/类型进行高级查询。\r\n\r\n### Snipaste：截图/贴图\r\n\r\n[便携版], [免费]\r\n\r\n> [官网](https://zh.snipaste.com/), [GitHub](https://github.com/Snipaste), [GitBook 中文教程](https://docs.snipaste.com/zh-cn/)\r\n\r\n很漂亮，很漂亮，很漂亮！重要的话说三遍，Snipaste 相比于其他的截图软件（FSCapture）在使用时感觉漂亮了很多，而且在使用时会方便很多（截图完成后直接就进行编辑，而不是跳转到编辑器中编辑截图），保存时自动保存并且复制到剪切板也很方便。总而言之就是细节做的相当棒！\r\n\r\n### PicGo：图床上传\r\n\r\n[开源], [跨平台], [免费]\r\n\r\n> [官网](https://molunerfinn.com/PicGo/), [GitHub](https://github.com/rxliuli/PicGo)\r\n\r\n使用 Markdown 写作必备的图床工具，解决了吾辈关于 GitHub 图床的几个痛点。\r\n\r\n- 上传之前重命名\r\n- 上传一键就好\r\n- 上传后图片管理\r\n\r\n### ScreenToGif：录制 GIF 动态图\r\n\r\n[便携版], [开源], [免费]\r\n\r\n> [官网](https://www.screentogif.com/), [GitHub](https://github.com/NickeManarin/ScreenToGif)\r\n\r\n虽然吾辈已经有了截图工具，但某些时候单靠截图并不能很好的表达意思，这时候就需要使用 Gif 去记录一系列的操作。这也是 ScreenToGif 的主要功能，将记录转换成 Gif 动态图。\r\n\r\n嘛，虽然就使用上吾辈觉得还是有一些不便：\r\n\r\n- 吸附窗口操作不太直观\r\n- 保存时不能直接一键保存到指定目录并复制到剪切板\r\n\r\n不过这也是目前吾辈能找到的比较好用的一个了\r\n\r\n如何加速 gif 演示的速度\r\n\r\n1. **编辑 => 减少帧数**: 减少总共的帧数\r\n2. 选择所有帧数，**编辑 => 重新设置**: 设置每个帧的持续时间为最短\r\n\r\n### Steam：国外的游戏平台\r\n\r\n[跨平台], [免费]\r\n\r\n> [官网](https://steamcommunity.com)\r\n\r\n来自于金三胖出品的非常著名的游戏平台，非常之多的游戏在该平台上发售。Steam 提供了非常多的支付方式，对国内用户相当友好（支付宝/微信/银联）。吾辈个人是只玩 Galgame 的，所以能入正支持到做 Galgame 的公司表示还是很开心的。  \r\n唉，不过 Steam 也没能逃过魔掌呢。。。[steam 落户上海浦东](https://www.google.com/search?q=steam+%E8%90%BD%E6%88%B7%E4%B8%8A%E6%B5%B7%E6%B5%A6%E4%B8%9C)，吾辈表示转区势在必得了！\r\n\r\n> 附：Steam 上没有什么盗版游戏，所以想免费玩游戏的人就不用抱有什么幻想了\r\n\r\n### AIMP：本地音乐播放器\r\n\r\n[免費]\r\n\r\n> [官网](http://www.aimp.ru/)\r\n\r\n一个非常漂亮的本地音乐播放器，貌似对歌曲音质的支持也很好（没什么感触，不玩耳机的萌新一只）。。。\r\n\r\n### PotPlayer：视频播放器\r\n\r\n[便携版], [免费]\r\n\r\n> [官网](https://potplayer.daum.net)\r\n\r\n非常强大/漂亮的本地视频播放器，虽然也可以播放 URL 的视频资源，但主要还是播放本地视频，支持大多数常见格式而且对于 1080P 之上的画质支持非常棒！\r\n\r\n### qBittorrent：BT 下载\r\n\r\n[免费]\r\n\r\n> [官网](https://www.qbittorrent.org/)\r\n\r\n不错的 BT 客户端，相比于**大名鼎鼎**的比特彗星，它没有广告，没有等级。对于热门种子的下载速度十分喜人，最高可以跑到 10M 左右，比特彗星永远没有跑到这么高过。。。\r\n\r\n### Dism++：Windows 的一个集中式的系统管理工具\r\n\r\n[便携版], [免费]\r\n\r\n> [官网](https://www.chuyu.me), [GitHub](https://github.com/Chuyu-Team/Dism-Multi-language)\r\n\r\n一个集中式管理 Windows 各种设置的 GUI 控制面板，能够方便的控制系统的各种设置（包括 Windows 10 的更新。。。），提供了一个简单但却还算可以的垃圾清理工具，感觉上很干净而且可以独立运行！\r\n\r\n### TreeSizeFree：以树状视图查看文件夹\r\n\r\n[便携版], [免费]\r\n\r\n> [官网](https://www.jam-software.com/treesize_free)\r\n\r\n用来以树状结构查看文件夹大小的工具，可以知道到底是哪些文件占用了硬盘及其大小。\r\n\r\n### waifu2x-caffe：图片清晰化\r\n\r\n[便携版], [免费], [开源], [跨平台]\r\n\r\n> [官网](http://waifu2x.udp.jp), [GitHub](https://github.com/nagadomi/waifu2x), [GitHub Windows](https://github.com/lltcggie/waifu2x-caffe)\r\n\r\n可以让图片变得清晰，具体技术实现涉及机器学习等尖端技术（#dalao），可以说是很厉害了呢\r\n\r\n### LockHunter：解除文件占用\r\n\r\n[免费]\r\n\r\n> [官网](https://lockhunter.com/)\r\n\r\n在删除文件/目录时，偶尔会遇到文件占用的问题，这个小工具直接集成到 MS Explorer 右键菜单中，可以方便查看占用程序，并关闭它。\r\n\r\n### rufus：USB 启动盘制作工具\r\n\r\n[便携版], [免费], [开源]\r\n\r\n> [官网](https://rufus.ie/), [GitHub](https://github.com/pbatard/rufus)\r\n\r\n小巧方便的 USB 启动盘制作工具，完全的一键操作，**下载 => 解压 => 运行** 三连之后就是父母辈的人都能看懂的界面了！\r\n\r\n### ApowerMirror: 手机投屏\r\n\r\n[跨平台]\r\n\r\n> [官网](https://www.apowersoft.com/phone-mirror)\r\n\r\n在局域网内将手机屏幕投影到 PC 上，延迟性在半秒之内，基本上不影响使用。相比于 [TeamViewer](https://www.teamviewer.cn/cn/) 的主要优点是不走中央服务器，延迟没那么高。而与之类似的 [AirServer](https://www.airserver.com/) 却延迟很大，而且操作过快时就会崩溃。吾辈主要是在 PC 演示操作时，涉及到手机上的操作时，为了避免录屏中断或是后期拼接，故而需要将手机屏幕投影至 PC 方便持续录制。\r\n\r\n### HandBrake: 视频压缩工具\r\n\r\n[便携版], [跨平台], [免费], [开源]\r\n\r\n> [官网](https://handbrake.fr/)\r\n\r\n非常简单的视频压缩工具，对非专业人士非常友好，只要选择合适的**预设**，任何人都能批量将视频压缩。吾辈一般使用的是 `MP4+Web Optimized`，可以将 50M 的视频压缩到 10M 左右，同时支持删除音轨进一步缩小视频大小。\r\n\r\n> ref: [HandBrake 免費影片壓縮軟體教學，將視頻的檔案縮小。（Mac ,Windows）](https://www.pkstep.com/archives/37386)\r\n\r\n### OpenArk: 快捷键占用检查工具\r\n\r\n[便携版], [免费], [开源]\r\n\r\n> [官网](https://openark.blackint3.com/)\r\n\r\n遇到快捷键莫名其妙被占用的话可以使用这个工具查看，需要注意的是一些系统本身的快捷键无法被扫描到，例如 Windows 10 输入法的 `Ctrl+Space` 切换中英文。\r\n\r\n> 目前无法进入内核模式查看快捷键占用的情况，参考: <https://github.com/BlackINT3/OpenArk/issues/25>\r\n\r\n### inkscape: svg 图片编辑器\r\n\r\n[便携版], [免费], [开源], [跨平台]\r\n\r\n> [官网](https://inkscape.org/), [GitLab](https://gitlab.com/inkscape/inkscape)\r\n\r\n非常像 GIMP 的 svg 图片编辑器，细节打磨一般，但作为一个免费的临时工具却是足够了。\r\n\r\n### PureText\r\n\r\n[便携版], [免费]\r\n\r\n> [官网](https://stevemiller.net/puretext/)\r\n\r\n强制粘贴为普通文本。有时候从 VSCode/WebStorm 复制一些内容，粘贴到支持富文本格式的地方时，我们并不总是希望保留格式（例如背景颜色和语法高亮），而是更愿意以纯文本的方式粘贴，这个工具能帮我们做到这一点。\r\n\r\n> 参考：[复制和粘贴文本时剥离格式的 5 种方法 (Mac&Windows)](http://blog.itpub.net/69965725/viewspace-2707909/)\r\n\r\n## 国内流氓\r\n\r\n### QQ：国内不得不用的流氓 IM\r\n\r\n> [官网](https://im.qq.com/)\r\n\r\n垃圾 QQ，毁我人生！  \r\n好了，以上纯属吐槽不用在意。QQ 是腾讯的社交 IM，由于国内使用人数极其庞大，所以吾辈也不得不用的软件。一个软件居然会向系统添加驱动服务，而且禁用了还不让使用，真是厉害了呀。。。\r\n\r\n### 百度网盘：国内事实上的垄断网盘\r\n\r\n[跨平台], [免费]\r\n\r\n> [官网](https://pan.baidu.com/)\r\n\r\n国内事实上的大文件共享服务，目前对普通用户的限制非常大，逼得人不得不开通 [SVip](https://pan.baidu.com/buy/checkoutcounter?from=homepage&svip=1) 才能使用，但同时也不能得到满速下载，在下载量较大后，之后的下载就会在服务端限速，同时百度网盘的客户端非常讨厌，即便是 SVip 也会看到广告。\r\n\r\n---\r\n\r\n> Pass：以上国内的流氓吾辈使用的都是修改过的绿色版本，基本上没什么太多麻烦的东西了呢\r\n\r\n---\r\n\r\n## 废弃\r\n\r\n### neat-reader\r\n\r\n> [官网](https://www.neat-reader.com/)\r\n\r\n看起来最漂亮的 epub 阅读器。老实说第一次看真是惊艳到了，毕竟之前在用 Calibre 和 SumartraPDF，而且笔记和同步功能也都挺好用。\r\n\r\n---\r\n\r\n最后放弃了它，因为有些问题反馈了两次但官方一直没有回应。\r\n\r\n- 优化深色模式下公式的渲染（很模糊）\r\n- 无法批量选择书籍操作\r\n- 不支持快捷键\r\n  1. c-f 触发搜索\r\n  2. 选择并添加笔记后使用 c-enter 确定\r\n  3. 使用 ESC 隐藏笔记弹出框\r\n\r\n> 人类能够忍受一时的痛苦，但不能忍受持续的轻微痛苦\r\n\r\n### HeidiSQL：SQL 客户端\r\n\r\n[便携版], [开源], [免费]\r\n\r\n> [官网](https://www.heidisql.com/), [GitHub](https://github.com/HeidiSQL/HeidiSQL)\r\n\r\n一个支持 MSSQL,MySQL 和 PostgreSQL 的开源数据库轻量级客户端。吾辈使用这个 SQL 客户端最重要的原因就是满足了吾辈对于数据库文件的导入/导出需求，谁让 IDEA 自带的 DataGrip 没有导出功能呢\r\n\r\n> 附：吾辈很清楚 MySQL 有自带的导出命令，然而并不灵活。。。至少这个能够定义创建数据表，插入数据时使用的策略\r\n\r\n---\r\n\r\nJetBrains IDE 自带的 DataGrip 实在太好用了，所以。。。\r\n\r\n### ClipboardFusion：剪切板增强\r\n\r\n[便携版], [免费]\r\n\r\n> [官网](https://www.clipboardfusion.com/)\r\n\r\nWindows 剪切板增强工具，不得不说 Windows 上的工具确实很多。即使一个功能 Windows 本身支持的不好，然而总有其他的工具对其增强就是了。当然，吾辈需要的只是它的剪切板历史功能。\r\n\r\n> 注：目前 Windows 已经自带了剪切板历史功能，但尚未支持搜索，同时在布局上也并不是特别友好（只能显示 4 条），轻量级用户可以选择这个（毕竟是自带，很方便）。注：之前在用 Ditto，但后面在吾辈电脑上出现了 bug，所以更换了其他工具，但并不是说它不好。参考：[善用佳软评测](https://xbeta.info/ditto.htm) 对其的介绍很全面，这里也就无需赘述了。\r\n\r\n---\r\n\r\n冷响应速度过慢，滚回 Windows 的剪切版历史了。\r\n\r\n### Loseless Audio Validator：音频校验\r\n\r\n[便携版], [跨平台], [开源], [免费]\r\n\r\n> [官网](http://losslessaudiochecker.com/)\r\n\r\n校验音乐是否是真的 **Flac/Ape** 无损音质的，其实作为一个外行人吾辈表示并不理解什么音频波形什么的。\r\n\r\n---\r\n\r\n基本不用\r\n\r\n### Bandicam：视频录制\r\n\r\n> [官网](https://www.bandicam.com)\r\n\r\n还算好用的视频录制工具，可以很方便的进行视频的录制。特色功能：\r\n\r\n- 绘制模式：在录制视频时进行频幕上的编辑\r\n- 窗口依附：可以轻松指定需要录制的窗口\r\n- 多格式输出：支持输出多种格式，按照不同分辨率，预置平台输出\r\n- 添加水印：防盗利器，在视频中添加自己的 LOGO\r\n\r\n---\r\n\r\n基本不用\r\n\r\n### renamer：文件/文件夹重命名\r\n\r\n[便携版], [免费]\r\n\r\n> [官网](http://www.den4b.com/)\r\n\r\n或许很多人想吐槽，重命名不就一个 F2 的事情么？是的，如果只需要重命名一个文件，F2 是最快捷的方式。但 rename 针对的是需要重命名数十，数百个文件的情况，这种时候手动重命名实在太过于糟糕了点！\r\n\r\n---\r\n\r\nWindows PowerToys 已经包含该功能了\r\n\r\n### Mozilla FireFox：抱有期待的浏览器\r\n\r\n[开源], [跨平台], [免费]\r\n\r\n> [官网](https://firefox.com), [GitHub](https://github.com/mozilla/gecko-dev)\r\n\r\nFireFox 是一个将 IE 拉下神坛的浏览器，一个开源的注重隐私的浏览器，但现在，它已然有些没落了。尤其是最近的 FireFox57 后为了提升性能更新了浏览器的整体架构，导致旧的扩展基本全部失效，恢复曾经的附加扩展生态却又不知道需要多久了。但是，这些问题，相比于隐私（信息收集）与自由（不限制扩展）来说，还是值得考虑一下的，确实挺期待 FireFox 之后发展的。\r\n\r\n相比于其他的浏览器最大的特点就是隐私性和自由，收集隐私是完全可选的（国内的流氓浏览器信息收集简直过分），附加扩展基本不怎么限制（Chrome 限制扩展只能从官方商店直接安装）。\r\n\r\n> 补充:\r\n>\r\n> - 2019-06-18: 现在 Chrome 居然限制 **uBlock Origin** 这类的扩展了。。。\r\n\r\n---\r\n\r\n> 基本不用\r\n\r\n### QuickLook：文件管理器预览增强\r\n\r\n[便携版], [开源], [免费]\r\n\r\n> [官网](https://pooi.moe/QuickLook/), [GitHub](https://github.com/xupefei/QuickLook)\r\n\r\nWindows Explorer 预览功能增强，支持很多种格式的文件/文件夹进行预览，包括但不限于文本、图像、视频、音频、压缩包、文件夹等。在按下空格时，就弹出一个预览窗口，感觉还是不错的。\r\n\r\n---\r\n\r\n无法关闭的强制更新提示真是不厌其烦，都 2021 年了，连 Windows 系统都不会这么做了，这个非必须、常用工具还玩这种操作。\r\n\r\n## 名词解释\r\n\r\n### 便携版\r\n\r\n能够下载完解压之后无需安装即可直接使用的软件，所有的配置文件也都在程序运行的文件目录下（非用户目录下），理论上可以配置完成一次之后就可以用一辈子了（#笑）\r\n\r\n### 开源\r\n\r\n开放程序源代码，任何人都可以自由浏览\r\n\r\n### 部分开源\r\n\r\n指程序既有开源版本又有商业版本，所以标识为部分开源\r\n\r\n### 跨平台\r\n\r\n至少兼容两个主流 PC 系统平台（Windows/MacOS #Linux 桌面在哭泣 #笑）才会标记为跨平台\r\n\r\n### 免费\r\n\r\n所有功能都完全免费（或许有捐助请求）才会标识为免费，有收费的高级功能的程序不会被标记为免费，例如 IDEA 就不会被标识为免费\r\n\r\n> 以上均为吾辈个人主观认知，参考一下就好。。。\r\n","createdTime":1580652938031,"updatedTime":1634831547678,"resources":[],"tags":[{"id":"4e00e5550c864473a3f16e4b0698f1c3","title":"windows","parent_id":""},{"id":"95ddbbd925aa4358a46bfcbce4c3fb46","title":"工具","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"0171bcd51b1343d6a9ad54557d567c46","title":"在现代前端项目中使用 Worker","body":"## 场景\n\n由于需要做一些 CPU 密集型的计算，为了优化性能，吾辈开始尝试使用 worker 将计算任务放到其它线程（主要还是为了避免主线程卡死）。\n\n主要场景包括\n\n- 浏览器上的 `WebWorker/SharedWorker`：处理音频数据\n- nodejs 中的 `worker_threads`：解析 md/ts ast 然后处理\n\n> 为什么不用 wasm？-- 主要是由于它需要从零开始编写相关的代码，而非可以直接对现有的 js 代码稍微修改便能提高性能。\n\n## 浏览器\n\n> 目前 vite 对此默认支持浏览器 worker，不再需要任何配置，仅使用 comlink 简化使用体验即可。\n\n```ts\n// hello.worker.ts\nimport { expose } from 'comlink'\n\nexport function hello(name: string) {\n  return `hello ${name}`\n}\n\nexpose(hello)\n```\n\n```ts\n// main.ts\nimport type { hello } from './hello.worker'\nimport HelloWorker from './hello.worker?worker'\nimport { wrap } from 'comlink'\n;(async () => {\n  const asyncHello = wrap<typeof hello>(new HelloWorker())\n  const res = await asyncHello('liuli')\n  console.log(res)\n})()\n```\n\n## nodejs\n\n### nodejs 本身提供的解决方案\n\nnodejs 仍然像浏览器一样基于文件系统使用 worker_threads，但官方确实提供了一种有趣的解决方案 -- 在同一个文件中包含主线程与 worker 线程的代码，然后在其中使用逻辑判断。\n\n```ts\n// worker.ts\nimport { isMainThread, parentPort, Worker } from 'worker_threads'\nimport { expose, wrap } from 'comlink'\nimport nodeEndpoint from 'comlink/dist/umd/node-adapter'\nimport { wait } from '@liuli-util/async'\nimport { worker as helloType } from './worker'\n\nasync function _hello(name: string) {\n  await wait(100)\n  return `hello ${name}`\n}\n\nlet hello: (name: string) => Promise<string>\n\nif (isMainThread) {\n  hello = async (name: string) => {\n    const worker = new Worker(__filename)\n    try {\n      const helloWorker = wrap<typeof helloType>(nodeEndpoint(worker))\n      return await helloWorker(name)\n    } finally {\n      worker.unref()\n    }\n  }\n} else {\n  hello = _hello\n  expose(_hello, nodeEndpoint(parentPort!))\n}\n\nexport { hello }\n```\n\n```ts\n// main.ts\nimport { hello } from './worker.js'\n;(async () => {\n  console.log(await mixingThreadHello('liuli'))\n})()\n```\n\n看起来很简洁，但这种方案也并非尽善尽美，吾辈实际使用时发现以下问题\n\n- 不支持开发环境测试 ts 代码，必须编译为 js 才能运行\n- 由于基于文件系统，所以打包需要手动分块，或者不进行打包\n  rollup 参考 [output.manualChunks](https://rollupjs.org/guide/en/#outputmanualchunks)\n\n> 参考：[nodejs Worker](https://nodejs.org/api/worker_threads.html#worker_threads_class_worker)\n\n### 使用打包工具处理的调研方案\n\n- rollup-plugin-web-worker-loader\n  - 默认不会处理 ts 文件\n  - worker 中包含依赖时不会打包\n- rollup-plugin-worker-factory\n  - 没有看到 ts 的示例\n  - 默认会修改 Worker\n- @surma/rollup-plugin-off-main-thread\n  - 没有看到 ts 的示例\n\n目前没有找到满意的插件，后续可能不得不写一个 rollup 插件。还是那句话，没有对比就没有伤害，如果没有 vite 对 ts+worker 的良好支持，或许吾辈还能忍受这种糟糕的开发体验。\n\n尝试编写 rollup 插件 [rollup-plugin-worker-threads](https://github.com/rxliuli/liuli-tools/tree/master/libs/rollup-plugin-worker-threads)，以在 nodejs 中对 `worker_threads` 提供类似 vite 的开发体验。\n\n大致使用方式如下\n\n```ts\n// src/util/wrapWorkerFunc.ts\nimport { expose, Remote, wrap } from 'comlink'\nimport path from 'path'\nimport { isMainThread, parentPort, Worker } from 'worker_threads'\nimport nodeEndpoint from 'comlink/dist/umd/node-adapter'\n\n/**\n * 包装需要放到 worker 中执行的函数\n * 1. 当检查到当前文件不是 js 文件时会直接返回函数\n * 2. 当检查到在主线程时执行时，使用 Worker 包装并执行它\n * 3. 当检查到在 Worker 线程时，使用 expose 包装它然后执行\n * 注：目前是每次都创建新的 Worker，也许可以考虑支持复用 Worker\n * @param ep\n */\nexport function wrapWorkerFunc<T extends (...args: any[]) => any>(\n  ep: T,\n): Remote<T> {\n  if (path.extname(__filename) !== '.js') {\n    return ep as Remote<T>\n  }\n  if (isMainThread) {\n    return ((...args: any[]) => {\n      const worker = new Worker(__filename)\n      const fn = wrap<T>(nodeEndpoint(worker))\n      return (fn(...args) as Promise<any>).finally(() => worker.unref())\n    }) as Remote<T>\n  }\n  expose(ep, nodeEndpoint(parentPort!))\n  return ep as Remote<T>\n}\n```\n\n```ts\n// src/hello.worker.ts\nimport { wait } from '@liuli-util/async'\nimport { wrapWorkerFunc } from './util/wrapWorkerFunc'\n\nasync function _hello(name: string) {\n  await wait(100)\n  return `hello ${name}`\n}\n\nexport const hello = wrapWorkerFunc(_hello)\n```\n\n```ts\n// index.ts\nexport * from './hello.worker'\n```\n\n## 参考\n\n- [Integrating web workers in a React app with Comlink](https://blog.logrocket.com/integrating-web-workers-in-a-react-app-with-comlink/)\n- [Using comlink with typescript and worker-loader](https://lorefnon.tech/2019/03/24/using-comlink-with-typescript-and-worker-loader/)\n- [An issue around Angular CLI + Comlink + WorkerPlugin](https://medium.com/lacolaco-blog/an-issue-around-angular-cli-comlink-workerplugin-585be1c8d087)\n","createdTime":1609303052667,"updatedTime":1633921501650,"resources":[],"tags":[{"id":"a3f220fe6f2c4c50a1aa91707edb8741","title":"typescript","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"9eb819d95b5143c7844cacb6d6650c59","title":"立个 Flag，今年入坑 Kigurumi 并出一次漫展","body":"## 简介\r\n\r\n- Kigurumi 是什么？能吃么？\r\n- 是一种 cosplay 服装扮演，不能吃谢谢。\r\n\r\n借用 [Wiki](https://en.wikipedia.org/wiki/Animegao_kigurumi) 中的描述：“人偶扮演（着ぐるみ Kigurumi ?），是一种透过穿着类似 吉祥物服装的全身套装以在现实世界中达成还原卡通或动漫人物的 cosplay 形式。和 cosplay 不一样的是，表演者的脸会被 面具完整的包住，所穿着的服装也会掩盖住全身，借此表演者得以完全隐藏自己原本的身份，完全成为所要扮演的角色。早年 Kigurumi 只会出现在舞台秀上，近年来则逐渐变成 cosplayer 的一种扮演模式。在日本，这种形式的角色扮演又被称为是アニメ顔（中文：动漫颜），但一直以来都只有少数的玩家参与其中。约在 2005 年后，Kigurumi 慢慢地在各个国家和地区流行开来，包括中国，甚至是美国、加拿大与欧洲等地区。”\r\n\r\n预定 cosplay 角色是 [春日野穹](https://zh.moegirl.org.cn/zh-cn/%E6%98%A5%E6%97%A5%E9%87%8E%E7%A9%B9)\r\n\r\n![1613708879214](:/35276870c5974ef78bf55004376104af)\r\n\r\n## 道具\r\n\r\n- [头壳](https://item.taobao.com/item.htm?id=35058414957)\r\n- [Kigurumi 皮肤](https://item.taobao.com/item.htm?id=26710864059)\r\n- [Kigurumi 义乳](https://item.taobao.com/item.htm?id=45759058514)\r\n- [Cosplay 服装](https://item.taobao.com/item.htm?id=45035590608)\r\n- 其他杂费，包括但不限于鞋子、玩偶、额外材料费等\r\n\r\n预计花费 7038 软妹币，入坑门槛是真的高 XD。\r\n\r\n> 算是弥补不去吃糖的一些遗憾吧\r\n\r\n---\r\n\r\n## 已购\r\n\r\n确定了，大概要两个月吧\r\n\r\n![1614431297462](:/90ab8d5fa24a4612a40d73807bec8cb1) ![1614431308200](:/50811848a3f34cd1ad44173be01b88c6)\r\n\r\n暂时还未购买服装之类的东西，但这也是因为需要后续再确认一下身体尺码的参数是否正确之类的而已（另外吾辈已然有了 xd）。\r\n\r\n## 衣服到了\r\n\r\nf 居然有 4 斤，看来女生确实很辛苦呢\r\n\r\n![1615473034848](:/ac037581e08947959ef7db5bb593f4ba)\r\n\r\n> 由于身高问题，所以显得很小而已。。。\r\n\r\n## 照骗\r\n\r\n![1627228922113](:/dfd78dc3e0ef4bb0a5068d3895f1802e)\r\n\r\n![1627228947517](:/9903efe2e94d4063a381c2683f28d066)\r\n\r\n![1627228955245](:/92e8be89f8a14afd9cce7f0649477f0d)\r\n\r\n## 延期\r\n\r\n木有办法，实在是 cosplay 服装没有完成啊\r\n\r\n![1633086403949](:/ea2e178e791b47209a58598acdc11995)\r\n","createdTime":1613706967294,"updatedTime":1633086450467,"resources":[{"id":"35276870c5974ef78bf55004376104af","title":"1613708879214","file_extension":"png","user_updated_time":1613708880316},{"id":"50811848a3f34cd1ad44173be01b88c6","title":"1614431308200","file_extension":"png","user_updated_time":1614431308609},{"id":"90ab8d5fa24a4612a40d73807bec8cb1","title":"1614431297462","file_extension":"png","user_updated_time":1614431297884},{"id":"92e8be89f8a14afd9cce7f0649477f0d","title":"1627228955245","file_extension":"png","user_updated_time":1627228955580},{"id":"9903efe2e94d4063a381c2683f28d066","title":"1627228947517","file_extension":"png","user_updated_time":1627228947865},{"id":"ac037581e08947959ef7db5bb593f4ba","title":"1615473034848","file_extension":"png","user_updated_time":1615473035685},{"id":"dfd78dc3e0ef4bb0a5068d3895f1802e","title":"1627228922113","file_extension":"png","user_updated_time":1627228922664},{"id":"ea2e178e791b47209a58598acdc11995","title":"1633086403949","file_extension":"png","user_updated_time":1633086404978}],"tags":[{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""},{"id":"f5172282f275485bab67f712ba1b1bcf","title":"个人","parent_id":""}]},{"id":"664f86d038744a01894699e368cc2708","title":"前端资源管理","body":"- [前端资源管理](#前端资源管理)\n  - [框架及社区](#框架及社区)\n    - [react: 前端流行的 mvc 框架](#react-前端流行的-mvc-框架)\n      - [react-router: react 上的路由管理库](#react-router-react-上的路由管理库)\n        - [react-router-config: 集中式的 react-router 路由管理库](#react-router-config-集中式的-react-router-路由管理库)\n      - [react-use: react hooks 通用库](#react-use-react-hooks-通用库)\n      - [antd: 极其强大的中后台 ui 组件库](#antd-极其强大的中后台-ui-组件库)\n      - [mobx: 跨框架可变式的全局状态管理库](#mobx-跨框架可变式的全局状态管理库)\n      - [immer: 简化 react 中不可变数据的修改](#immer-简化-react-中不可变数据的修改)\n      - [use-query-params: 处理 react router 中的 query params](#use-query-params-处理-react-router-中的-query-params)\n        - [query-string: 所依赖的 url 查询字符串库，必须手动添加以使用最新版本](#query-string-所依赖的-url-查询字符串库必须手动添加以使用最新版本)\n      - [classnames: react css module 简化工具](#classnames-react-css-module-简化工具)\n      - [react-infinite-scroller: react 无限滚动通用组件](#react-infinite-scroller-react-无限滚动通用组件)\n      - [react-string-replace: react 中将 `string` 替换为 jsx 的工具函数](#react-string-replace-react-中将-string-替换为-jsx-的工具函数)\n    - [electron: Web 跨平台客户端解决方案](#electron-web-跨平台客户端解决方案)\n      - [electron-builder: electron 打包/更新一站式解决方案](#electron-builder-electron-打包更新一站式解决方案)\n      - [electron-devtools-installer: electron 客户端安装开发插件](#electron-devtools-installer-electron-客户端安装开发插件)\n    - [commander: cli 框架](#commander-cli-框架)\n      - [inquirer: 命令行交互式输入](#inquirer-命令行交互式输入)\n      - [figlet: 由字符串生成字符画以展示在命令行或浏览器](#figlet-由字符串生成字符画以展示在命令行或浏览器)\n      - [ora: 命令行进度输出工具](#ora-命令行进度输出工具)\n      - [chalk: 为命令行增色添彩](#chalk-为命令行增色添彩)\n    - [typescript: 为 js 添加了类型系统](#typescript-为-js-添加了类型系统)\n      - [type-fest: typescript 类型工具库](#type-fest-typescript-类型工具库)\n      - [@types/\\*: 社区类型定义库](#types-社区类型定义库)\n      - [ts-morph: 操纵 ts ast 必不可少的库](#ts-morph-操纵-ts-ast-必不可少的库)\n      - [dts-minify: 最小化 dts 类型定义的方式](#dts-minify-最小化-dts-类型定义的方式)\n  - [小型工具库](#小型工具库)\n    - [mockjs: mock 数据生成](#mockjs-mock-数据生成)\n    - [sweetalert2: 简单的网页弹窗提示](#sweetalert2-简单的网页弹窗提示)\n    - [axios: 通用 ajax 请求库](#axios-通用-ajax-请求库)\n    - [uuid: 前端 uuid 生成工具](#uuid-前端-uuid-生成工具)\n    - [jszip: js 上的 zip 处理库](#jszip-js-上的-zip-处理库)\n    - [dexie: Web IndexedDB 封装](#dexie-web-indexeddb-封装)\n    - [scroll-into-view-if-needed: 控制 dom 元素滚动到视图区域的工具库](#scroll-into-view-if-needed-控制-dom-元素滚动到视图区域的工具库)\n    - [jsbarcode: 生成一维码](#jsbarcode-生成一维码)\n    - [print-js: 浏览器端打印 pdf 的工具库](#print-js-浏览器端打印-pdf-的工具库)\n    - [luxon: 日期时间库](#luxon-日期时间库)\n    - [worker-plugin: webpack worker 插件](#worker-plugin-webpack-worker-插件)\n      - [comlink: 基于 Proxy 的一个 web worker rpc 实现](#comlink-基于-proxy-的一个-web-worker-rpc-实现)\n    - [fs-extra: nodejs fs 模块的 Promise 包装超集](#fs-extra-nodejs-fs-模块的-promise-包装超集)\n    - [git-rev-sync: 读取当前项目的 git 信息](#git-rev-sync-读取当前项目的-git-信息)\n    - [lodash: 前端通用工具库](#lodash-前端通用工具库)\n    - [ssh2-sftp-client: sftp 工具库](#ssh2-sftp-client-sftp-工具库)\n    - [levelup: 跨语言的高性能键值存储](#levelup-跨语言的高性能键值存储)\n    - [open: 在 nodejs 中打开链接、文件之类的东西](#open-在-nodejs-中打开链接文件之类的东西)\n    - [pdf-to-printer: 使用 nodejs 打印 pdf 的函数库](#pdf-to-printer-使用-nodejs-打印-pdf-的函数库)\n    - [os-locale: 在 nodejs 获取系统语言](#os-locale-在-nodejs-获取系统语言)\n    - [ajv: 前端 json 校验](#ajv-前端-json-校验)\n    - [diff-match-patch: Google 的文本差异对比](#diff-match-patch-google-的文本差异对比)\n    - [nest.js: 全栈 web 框架，类 spring boot](#nestjs-全栈-web-框架类-spring-boot)\n    - [typeorm: nodejs orm 库，和 nest.js 有着良好的集成](#typeorm-nodejs-orm-库和-nestjs-有着良好的集成)\n    - [chokidar: 跨平台的文件监视器](#chokidar-跨平台的文件监视器)\n    - [sqlite3: 嵌入式数据库](#sqlite3-嵌入式数据库)\n    - [remark: markdown 社区及工具集](#remark-markdown-社区及工具集)\n      - [unified: txt/markdown/html 解析器的抽象核心](#unified-txtmarkdownhtml-解析器的抽象核心)\n      - [remark-parse: 解析 markdown 的插件](#remark-parse-解析-markdown-的插件)\n      - [remark-gfm: 支持 gfm 的插件](#remark-gfm-支持-gfm-的插件)\n      - [remark-stringify: 序列化 ast 为 markdown 的插件](#remark-stringify-序列化-ast-为-markdown-的插件)\n      - [unist-util-visit: 遍历 ast 的插件](#unist-util-visit-遍历-ast-的插件)\n    - [puppeteer: 无头浏览器](#puppeteer-无头浏览器)\n  - [脚手架和打包工具](#脚手架和打包工具)\n    - [vite: 一个非常优秀的前端脚手架](#vite-一个非常优秀的前端脚手架)\n    - [rollup: 前端 npm 库打包工具](#rollup-前端-npm-库打包工具)\n      - [@rollup/plugin-commonjs: 捆绑 commonjs](#rollupplugin-commonjs-捆绑-commonjs)\n      - [@rollup/plugin-json: 引入的 json 文件](#rollupplugin-json-引入的-json-文件)\n      - [@rollup/plugin-node-resolve: 支持 require 语法](#rollupplugin-node-resolve-支持-require-语法)\n      - [rollup-plugin-copy: 复制静态资源](#rollup-plugin-copy-复制静态资源)\n      - [rollup-plugin-typescript2: 编译 ts](#rollup-plugin-typescript2-编译-ts)\n      - [rollup-plugin-auto-external: 自动将 dependencies 中的依赖作为外部依赖项](#rollup-plugin-auto-external-自动将-dependencies-中的依赖作为外部依赖项)\n      - [rollup-plugin-node-externals: 自动将 node 原生包作为外部依赖项](#rollup-plugin-node-externals-自动将-node-原生包作为外部依赖项)\n      - [rollup-plugin-add-shebang: 为打包后的 cli 程序添加 `#!/usr/bin/env node`](#rollup-plugin-add-shebang-为打包后的-cli-程序添加-usrbinenv-node)\n      - [rollup-plugin-terser: 压缩打包后的代码](#rollup-plugin-terser-压缩打包后的代码)\n  - [工程化](#工程化)\n    - [prettier: 代码统一格式化工具](#prettier-代码统一格式化工具)\n    - [eslint: 前端可配置的 linter 工具（实测还是没有 WebStorm 的内置 linter 好用）](#eslint-前端可配置的-linter-工具实测还是没有-webstorm-的内置-linter-好用)\n    - [env-cmd: 跨平台设置环境变量](#env-cmd-跨平台设置环境变量)\n    - [simple-git-hooks: 为项目配置简单的 git 钩子](#simple-git-hooks-为项目配置简单的-git-钩子)\n    - [lint-staged: 针对暂存的 git 文件运行 linters](#lint-staged-针对暂存的-git-文件运行-linters)\n    - [patch-package: 在本地覆盖任何有问题的 npm 包中的文件](#patch-package-在本地覆盖任何有问题的-npm-包中的文件)\n    - [jest: 单元测试框架](#jest-单元测试框架)\n      - [ts-jest: 支持 ts 单元测试的预设配置](#ts-jest-支持-ts-单元测试的预设配置)\n    - [ts-node: 直接运行 ts 文件](#ts-node-直接运行-ts-文件)\n    - [depcheck: 分析项目中的依赖项，检查幻影依赖](#depcheck-分析项目中的依赖项检查幻影依赖)\n    - [rimraf: 跨平台的文件删除](#rimraf-跨平台的文件删除)\n  - [文档](#文档)\n    - [esdoc: js 中最好的 api 文档生成工具](#esdoc-js-中最好的-api-文档生成工具)\n    - [typedoc: ts 中目前最好的 api 文档生成工具](#typedoc-ts-中目前最好的-api-文档生成工具)\n    - [fliegdoc: 更适合 monorepo 的 ts api 文档生成工具](#fliegdoc-更适合-monorepo-的-ts-api-文档生成工具)\n    - [storybook: 跨框架的 ui 组件文档生成器](#storybook-跨框架的-ui-组件文档生成器)\n    - [vuepress: 静态文档网站生成器](#vuepress-静态文档网站生成器)\n  - [有用的资源和社区](#有用的资源和社区)\n\n## 框架及社区\n\n### [react](https://reactjs.org/): 前端流行的 mvc 框架\n\n| 对比 | react                                              | vue                                           |\n| ---- | -------------------------------------------------- | --------------------------------------------- |\n| 优点 | 生态庞大                                           | 门槛很低，开发者友好                          |\n|      | IDE 支持完善                                       | 文档是前端框架中最好的                        |\n|      | 灵活                                               |                                               |\n|      | 与 TypeScript 结合完美                             |                                               |\n| 缺点 | 官方基本放任社区发展                               | IDE 支持一直都不那么完美                      |\n|      | 对开发者体验不太上心，这会在下面的社区中反复体现到 | 与 ts 结合不好，vue3 也未能解决模板的类型问题 |\n\n#### [react-router](https://reactrouter.com/): react 上的路由管理库\n\n##### [react-router-config](https://www.npmjs.com/package/react-router-config): 集中式的 react-router 路由管理库\n\n#### [react-use](https://github.com/streamich/react-use): react hooks 通用库\n\n#### [antd](https://ant.design/): 极其强大的中后台 ui 组件库\n\n#### [mobx](https://mobx.js.org/): 跨框架可变式的全局状态管理库\n\n#### [immer](https://immerjs.github.io/immer/): 简化 react 中不可变数据的修改\n\n#### [use-query-params](https://peterbeshai.com/use-query-params/): 处理 react router 中的 query params\n\n##### [query-string](https://github.com/sindresorhus/query-string#readme): 所依赖的 url 查询字符串库，必须手动添加以使用最新版本\n\n#### [classnames](https://github.com/JedWatson/classnames): react css module 简化工具\n\n#### [react-infinite-scroller](https://www.npmjs.com/package/react-infinite-scroller): react 无限滚动通用组件\n\n#### [react-string-replace](https://github.com/iansinnott/react-string-replace): react 中将 `string` 替换为 jsx 的工具函数\n\n### [electron](https://electronjs.org/): Web 跨平台客户端解决方案\n\n#### [electron-builder](https://www.electron.build/): electron 打包/更新一站式解决方案\n\n#### [electron-devtools-installer](https://github.com/MarshallOfSound/electron-devtools-installer): electron 客户端安装开发插件\n\n### commander: cli 框架\n\n> 听说有个 yargs，但没有实际使用过。\n\n#### inquirer: 命令行交互式输入\n\n| 对比 | inquirer             | enquirer         | prompts        |\n| ---- | -------------------- | ---------------- | -------------- |\n| 优点 | 积极维护             | 不依赖 rx.js     | 不依赖 rx.js   |\n|      | 支持更复杂的控制流程 | 面向对象         | 可组合的小函数 |\n| 缺点 | 依赖 rx.js           | 类型定义很坑     | 文档错误       |\n|      | 大而全的 api         | 不怎么维护       | 类型定义错误   |\n|      |                      | 插件开发文档一般 |\n\ninquirer 的替代方案总是标榜自己轻量没有 rxjs 依赖，但对 TypeScript 开发者体验做的真烂，目前已知包括 enquirer/prompts。\n\n> [npm thread 对比](https://www.npmtrends.com/enquirer-vs-inquirer-vs-prompt-vs-prompts)\n\n#### [figlet](https://github.com/patorjk/figlet.js): 由字符串生成字符画以展示在命令行或浏览器\n\n> 推荐使用 `textSync` 同步生成方法，除非这个库支持 `web worker/worker_threads`，否则对于计算密集型的代码意义不大\n\n#### [ora](https://www.npmjs.com/package/ora): 命令行进度输出工具\n\n#### [chalk](https://www.npmjs.com/package/chalk): 为命令行增色添彩\n\n### [typescript](https://www.typescriptlang.org/): 为 js 添加了类型系统\n\n#### [type-fest](https://github.com/sindresorhus/type-fest): typescript 类型工具库\n\n| 对比 | type-fest  | utility-types | ts-toolbelt          |\n| ---- | ---------- | ------------- | -------------------- |\n| 优点 | 使用广泛   | 符合直觉      | 及其大而全           |\n| 缺点 | 不符合直觉 | 不怎么更新了  | 不明白少即是多的道理 |\n\n> [npm thread](https://www.npmtrends.com/type-fest-vs-utility-types-vs-ts-toolbelt)\n\n#### [@types/\\*](https://github.com/DefinitelyTyped/DefinitelyTyped): 社区类型定义库\n\n#### [ts-morph](https://ts-morph.com/): 操纵 ts ast 必不可少的库\n\n> 还提供一个在线网站 [ts-ast-viewer](https://ts-ast-viewer.com/) 以供可视化的查看 ast 树结构注：`createSourceFile` 中的 `fileName` 参数可以不用管，在不需要 ts 写入文件的 api 的话\n\n#### dts-minify: 最小化 dts 类型定义的方式\n\n吾辈使用它主要是为了比较两个 ast 从语义上是否一致（曲线救国）\n\n1. 使用 `dts-minify` 将代码压成一行\n2. 使用 `prettier` 格式化\n3. 对比格式化后的文本\n\n> 官方提供了 [解决方案](https://github.com/dsherret/ts-morph/issues/499#issuecomment-440079701)，但实测格式不同时仍有问题\n\n## 小型工具库\n\n### [mockjs](http://mockjs.com/): mock 数据生成\n\n相比于更加大而全的 faker.js，由国人创造的 mockjs 更加简单好用（实际上大多数时候我们不需要那么复杂的 mock 功能）。\n\n### [sweetalert2](https://github.com/sweetalert2/sweetalert2): 简单的网页弹窗提示\n\n比 layer.js 看起来更现代，而且对现代框架（react）也有支持。\n\n### [axios](https://github.com/axios/axios): 通用 ajax 请求库\n\n### [uuid](https://github.com/uuidjs/uuid): 前端 uuid 生成工具\n\n### [jszip](https://stuk.github.io/jszip/): js 上的 zip 处理库\n\n### [dexie](https://dexie.org/): Web IndexedDB 封装\n\n### [scroll-into-view-if-needed](https://github.com/stipsan/scroll-into-view-if-needed): 控制 dom 元素滚动到视图区域的工具库\n\n### [jsbarcode](https://github.com/lindell/JsBarcode): 生成一维码\n\n### [print-js](https://github.com/crabbly/Print.js): 浏览器端打印 pdf 的工具库\n\n### [luxon](https://github.com/moment/luxon): 日期时间库\n\n### [worker-plugin](https://github.com/GoogleChromeLabs/worker-plugin): webpack worker 插件\n\n#### [comlink](https://github.com/GoogleChromeLabs/comlink): 基于 Proxy 的一个 web worker rpc 实现\n\n### [fs-extra](https://github.com/jprichardson/node-fs-extra): nodejs fs 模块的 Promise 包装超集\n\n### [git-rev-sync](https://github.com/kurttheviking/git-rev-sync-js): 读取当前项目的 git 信息\n\n### [lodash](https://www.lodashjs.com/): 前端通用工具库\n\n### [ssh2-sftp-client](https://github.com/theophilusx/ssh2-sftp-client): sftp 工具库\n\n### [levelup](https://github.com/Level/levelup): 跨语言的高性能键值存储\n\n### [open](https://github.com/sindresorhus/open): 在 nodejs 中打开链接、文件之类的东西\n\n### [pdf-to-printer](https://github.com/artiebits/pdf-to-printer): 使用 nodejs 打印 pdf 的函数库\n\n### [os-locale](https://github.com/sindresorhus/os-locale): 在 nodejs 获取系统语言\n\n### [ajv](https://github.com/ajv-validator/ajv): 前端 json 校验\n\n### [diff-match-patch](https://github.com/google/diff-match-patch): Google 的文本差异对比\n\n### [nest.js](https://nestjs.com/): 全栈 web 框架，类 spring boot\n\n### [typeorm](https://github.com/typeorm/typeorm): nodejs orm 库，和 nest.js 有着良好的集成\n\n### [chokidar](https://github.com/paulmillr/chokidar): 跨平台的文件监视器\n\n### sqlite3: 嵌入式数据库\n\n### [remark](https://remark.js.org/): markdown 社区及工具集\n\n| 对比 | remark             | markdown-it        |\n| ---- | ------------------ | ------------------ |\n| 优点 | 非常模块化         | 大而全             |\n|      | 对插件开发者友好   | 易于使用           |\n|      | prettier 使用它    |\n| 缺点 | 过度模块化         | 对插件开发者不友好 |\n|      | 部分模块仅支持 esm |\n|      | 文档分散           |\n|      | 社区作者之间踢皮球 |\n\n> 注：如果你不需要操纵 markdown ast，强烈建议使用一站式的 markdown-it\n\n基本使用\n\n```ts\nimport unified from 'unified'\nimport remarkParse from 'remark-parse'\nimport remarkStringify from 'remark-stringify'\nimport visit from 'unist-util-visit'\nimport unistUtilMap from 'unist-util-map'\nimport remarkGfm from 'remark-gfm'\nimport { format, Options } from 'prettier'\nimport { Node } from 'unist'\n\nconst md = unified().use(remarkParse).use(remarkGfm).use(remarkStringify, {\n  bullet: '-',\n  fences: true,\n  incrementListMarker: false,\n})\n\nconst node = unistUtilMap(md.parse(content), (node) => {\n  console.log('node: ', node)\n  return node\n})\nconst str = format(md.stringify(node), {\n  parser: 'markdown',\n  tabWidth: 2,\n})\nconsole.log(str)\n```\n\n#### unified: txt/markdown/html 解析器的抽象核心\n\n#### remark-parse: 解析 markdown 的插件\n\n#### remark-gfm: 支持 gfm 的插件\n\n#### remark-stringify: 序列化 ast 为 markdown 的插件\n\n#### unist-util-visit: 遍历 ast 的插件\n\n### [puppeteer](https://github.com/puppeteer/puppeteer): 无头浏览器\n\n## 脚手架和打包工具\n\n### vite: 一个非常优秀的前端脚手架\n\n| 对比 | vite           | create-react-app | snowpack           |\n| ---- | -------------- | ---------------- | ------------------ |\n| 优点 | 非常快         | react 官方脚手架 | react 是一等公民   |\n|      | 支持 ts 配置   |                  | 非常快             |\n|      | 开发者友好     |                  |                    |\n| 缺点 | vue 是一等公民 | 强制锁定版本     | 存在许多兼容性问题 |\n\n> 若非 snowpack 实在不争气，吾辈也不至于把 vite 作为 react 脚手架的首选\n\n### [rollup](https://github.com/rollup/rollup): 前端 npm 库打包工具\n\n| 对比 | rollup             | webpack          | esbuild                          |\n| ---- | ------------------ | ---------------- | -------------------------------- |\n| 优点 | 易于使用           | 非常灵活         | 非常快                           |\n|      | 库友好             | 生态庞大         | 支持 js/go API 和插件            |\n| 缺点 | 生态还不是那么丰富 | 灵活是一把双刃剑 | 使用 go 编写，生态上可能存在问题 |\n\n#### @rollup/plugin-commonjs: 捆绑 commonjs\n\n#### @rollup/plugin-json: 引入的 json 文件\n\n#### @rollup/plugin-node-resolve: 支持 require 语法\n\n#### rollup-plugin-copy: 复制静态资源\n\n#### rollup-plugin-typescript2: 编译 ts\n\n#### rollup-plugin-auto-external: 自动将 dependencies 中的依赖作为外部依赖项\n\n#### rollup-plugin-node-externals: 自动将 node 原生包作为外部依赖项\n\n#### rollup-plugin-add-shebang: 为打包后的 cli 程序添加 `#!/usr/bin/env node`\n\n#### rollup-plugin-terser: 压缩打包后的代码\n\n## 工程化\n\n### [prettier](https://prettier.io/): 代码统一格式化工具\n\n### [eslint](https://eslint.org/): 前端可配置的 linter 工具（实测还是没有 WebStorm 的内置 linter 好用）\n\n### [env-cmd](https://github.com/toddbluhm/env-cmd): 跨平台设置环境变量\n\n### [simple-git-hooks](https://github.com/toplenboren/simple-git-hooks): 为项目配置简单的 git 钩子\n\n为什么不使用 husky？因为在第五个版本之后作者做出了非常多糟糕的改变，许多有名的库不得不做出了改变，参考：<https://github.com/toplenboren/simple-git-hooks#who-uses-simple-git-hooks>\n\n### [lint-staged](https://github.com/okonet/lint-staged): 针对暂存的 git 文件运行 linters\n\n### [patch-package](https://www.npmjs.com/package/patch-package): 在本地覆盖任何有问题的 npm 包中的文件\n\n主要是处理一些 npm 模块可能存在小问题但又来不及提 PR 的情况下，在本地修改并生成 git patch 文件，在每次 `yarn install` 时合并这些 patch。\n\n- 修复包不支持 cjs 模块，参考：<https://github.com/remarkjs/remark-math/issues/56>\n- 修复 typescript 类型定义错误，参考：<https://stackoverflow.com/questions/67701504>\n\n### [jest](https://jestjs.io/): 单元测试框架\n\n#### [ts-jest](https://github.com/kulshekhar/ts-jest): 支持 ts 单元测试的预设配置\n\n### [ts-node](https://github.com/TypeStrong/ts-node): 直接运行 ts 文件\n\n### [depcheck](https://www.npmjs.com/package/depcheck): 分析项目中的依赖项，检查幻影依赖\n\n### rimraf: 跨平台的文件删除\n\n> 事实上，已经存在一个更强大的 \\*unix cli [shx](https://www.npmjs.com/package/shx)，但比较烦人的是必须添加 `shx` 前缀，例如\n>\n> - 复制：`shx cp -rf <src> <dest>`\n> - 删除：`shx rm -rf <path>`\n>\n> 而且包的大小比较大，如果不需要所有的 \\*unix 命令用起来感觉有点笨重（毕竟更复杂的脚本可以使用 gulp）\n\n## 文档\n\n![选择支.drawio.svg](:/d073b1ca7427427991328887419f5b57)\n\n### [esdoc](https://esdoc.org/): js 中最好的 api 文档生成工具\n\n### [typedoc](https://typedoc.org/): ts 中目前最好的 api 文档生成工具\n\n### fliegdoc: 更适合 monorepo 的 ts api 文档生成工具\n\n### [storybook](https://storybook.js.org/): 跨框架的 ui 组件文档生成器\n\n### vuepress: 静态文档网站生成器\n\n> 很多对比已经在 VuePress 官网上的 [为什么不是](https://vuepress.vuejs.org/zh/guide/#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF) 里面说明了，吾辈只对比 vuepress 与 docusaurus。\n\n| 对比 | vuepress               | docusaurus                   |\n| ---- | ---------------------- | ---------------------------- |\n| 优点 | 开发者友好             | 基于 react                   |\n|      | 功能非常齐全           |                              |\n| 缺点 | 配置还是多了点         | 翻译基于配置而非 markdown    |\n|      | 修改 js 配置无法热更新 | 开发者体验并不是那么友好     |\n|      |                        | 文档存在错误，完成度相对更低 |\n\n> 和 snowpack 一样，基于 react 的解决方案实在不争气。\n\n## 有用的资源和社区\n\n- [react+ts 使用指南](https://react-typescript-cheatsheet.netlify.app/)\n- [grid 可视化布局生成器](https://grid.layoutit.com/)\n- [中文文档排版指北](https://github.com/sparanoid/chinese-copywriting-guidelines)\n- [css 全面指南](https://css-tricks.com/)\n- [react 示例网站](https://reactjsexample.com/)\n- [js 技术趋势](https://stateofjs.com/)\n- [css 技术趋势](https://stateofcss.com/)\n","createdTime":1605746810098,"updatedTime":1632937242614,"resources":[{"id":"d073b1ca7427427991328887419f5b57","title":"选择支.drawio.svg","file_extension":"svg","user_updated_time":1622200012004}],"tags":[{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"224a1dc91731489097aeb59f62d16558","title":"Git 频繁要输入密码的问题","body":"## 场景\n\n突然就遇到了，每次使用 `Git` 进行 `pull`/`push` 操作时都要输入密码，真是超级麻烦！\n\n## 原因\n\n在 `Git` 服务器上面设置了 `SSH` 密钥但仍然使用 `HTTP/HTTPS` 连接就会出现这个问题\n\n## 解决方案\n\n### 1. 配置一个本地文件记录用户名/密码\n\n进入到 git 根目录下，执行下面的命令即可\n\n```bash\ngit config --global credential.helper store\n```\n\n### 2. 使用 SSH 连接\n\n在本机生成一个密钥对（已有的话就不需要了），参见 [使用 SSH 连接 Linux 服务器](:/e241d9845dda448c8a1d9e5d2b100790)，将密钥对的公钥（`id_rsa.pub`）配置到你的远程仓库即可。\n\n> [GitHub SSH 设置](https://github.com/settings/keys)\n","createdTime":1580652937989,"updatedTime":1632841493743,"resources":[],"tags":[{"id":"0fe3bdc669564a3494e66bc1693d7f3f","title":"git","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"7f94aa8c6eff4eaaab7004361fe0614f","title":"Windows 使用技巧","body":"## 快捷键\n\n### 系统\n\n- `Win-E`：打开系统文件浏览器\n- `Win-Tab`：打开程序网格面板，类似于 `C-Tab`，但默认不会切换，而是展开全屏面板选择一个正在运行的程序切换过去\n- `Win-R`：打开**运行**\n- `Win-S`：搜索任何东西\n- `Win-A`：展开右侧通知面板\n- `C-Tab`：切换程序\n- `CS-Esc`：打开任务管理器\n- `C-F`：在当前页内容中搜索关键字\n  - `Enter`：下一个匹配关键字\n  - `S-Enter`：上一个匹配关键字\n\n### 非常见\n\n- `C-空格`：切换半角/全角标点符号\n- `C-.`：切换中英文标点符号（隐藏的很深。。。）\n- `Win-长按`: 显示快捷键指南\n- `Win-Top`: 最大化\n- `Win-Down`: 最小化\n- `Win-Left`: 左侧贴靠\n- `Win-Left`: 右侧贴靠\n\n### 删除系统快捷键\n\n以下输入法会影响到 IDE 使用，需要禁用\n\n- 系统\n  - 输入法 ![1623122443753](:/4b6cacb250374c37a3ba48f202c26de0)\n    - `CS-F`: 输入法简繁体切换\n    - `C-空格`: 中英文切换\n- QQ ![1623122471651](:/f80aec5f992142258ea21003e4b36729)\n  - `CA-S`: 屏幕录制\n  - `CA-O`: 屏幕识图\n  - `F6`: 群通话按住发言\n  - `CA-F`: 屏幕翻译\n\n> 建议使用 OpenArk 查找快捷键占用的问题 ![1623122585291](:/d9df37c041034ad3b3feaaf32a8cd67e)\n\n## 高级功能\n\n### 定时关机\n\n使用以下命令会在指定时间后关机\n\n```sh\nshutdown –s –t [second time]\n```\n\n例如以下命令指的是在 1h 后关机\n\n```sh\nshutdown –s –t 3600\n```\n\n> 参考: [百度 win10 怎么定时关机？](https://jingyan.baidu.com/article/93f9803f06bb90e0e46f55ec.html)\n\n### [PowerToys 使用](:/9ffd18234dcb40f6a1f88fd3654c463b)\n\n### Windows 为当前用户添加开机自启项\n\n每次打开电脑，开机之后总是要启动 Chrome 浏览器等一些常用应用，而常用应用中有的有开机自启的选项，有些则没有。每次打开都是重复性的操作，真是不厌其烦。。。\n\n下面是 Windows 当前用户的自启动目录的路径\n\n```cmd\nC:\\Users\\{你的用户名}\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\n```\n\n我们可以为想要自启动的程序创建一个快捷方式，然后将快捷方式放到这个目录下就可以啦\n\n然而，直接放快捷方式太多的话管理起来可能会是个麻烦，所以我们可以使用脚本，下面给出两种脚本示例\n\n- ahk 脚本\n\n  ```ahk\n  ; 开机自启 Chrome 浏览器\n  Run Chrome\n  ```\n\n- cmd 脚本\n\n  ```cmd\n  rem 开机自启 Chrome 浏览器\n  start chrome\n  ```\n\n### cmd 命令提示符工具文件所在路径？\n\n```sh\nwhere cmd\n```\n\n> 参考：[知乎：cmd 命令提示符工具文件所在路径？](https://www.zhihu.com/question/49124998)\n\n### 隐藏桌面系统图标\n\n![1623386196951](:/30d25e553fed4f06b250d4670b32d04f)\n\n> 参考：[显示或隐藏回收站](https://support.microsoft.com/zh-cn/windows/%E6%98%BE%E7%A4%BA%E6%88%96%E9%9A%90%E8%97%8F%E5%9B%9E%E6%94%B6%E7%AB%99-0d4d40aa-be23-91ec-96ab-338818d5e5fb)\n\n### SSR 存在时无法打开 Microsoft Store 等 UWP 应用\n\n今天突然发现打不开 Microsoft Store，一直卡在请求界面。因为之前遇到过几次打不开 Microsoft Store 的情况，所以知道大概率又是代理的问题。查了下资料，终于彻底（~ 存疑~）解决了这个问题。\n\n原因\n\nUWP 有沙箱的安全机制，无法连接到 127.0.0.1\n\n解决方法\n\n为所有 UWP 应用单独设置代理，以管理员身份启动 PowerShell（win+x 后按 a）后运行下列命令：\n\n```sh\nforeach($f in Get-ChildItem $env:LOCALAPPDATA\\Packages) {CheckNetIsolation.exe LoopbackExempt -a \"-n=$($f.Name)\"}\n```\n\n## 开发\n\n### 设置正确的开发所需网络环境\n\n> 事物的价值取决于被需要的程度\n\n场景\n\n在国内网络环境中，开发是一件比较痛苦的事情，尤其是各种依赖，包括但不限于 Linux 包、NPM、GitHub、Maven 等等，都慢的让人心态爆炸。\n你可能已经遇到过很多次下面这种问题了\n\n- 依赖无法安装，卡到最后一点点\n- 某些依赖（例如 node-sass/electron/sharp 等）会在 `postinstall` 阶段从 GitHub 下载二进制文件，但一直下载不下来\n\n解决方案\n\n1. 购买一个代理服务，参考：[DuyaoSS - 机场测速和简介 [SS/SSR/V2Ray] 【联通】更新中](https://www.duyaoss.com/archives/3/)\n2. 使用 SSR 配置代理，Windows 的下载链接：<https://github.com/HMBSbige/ShadowsocksR-Windows>（选择 win64 下载）\n3. 使用 Proxifier 透明代理客户端，它能从系统级别强制让程序走代理，目前支持 win/mac，官网：<http://www.proxifier.com/>\n4. 配置 Proxifier 使 nodejs 的所有 http 请求都走代理\n5. 自定义 DNS：使用世界上最好的 [1.1.1.1](https://1.1.1.1/) 代替默认的 DNS（可选）\n\n下面是 gif 演示\n\n![演示配置SSR](:/e596b55573c0428584f92759c9df7ac6)\n![配置Proxifer](:/080d96fdedc54c358cf6f1f73e75d8de)\n\n> 代理服务的**稳定**和**价格**只能二选其一，速度不是核心因素，因为大多数代理服务的速度都能够满足常用需求（例如 youtube 观看视频流畅），再提高会出现边际效应。\n\n### 下载 windows 10 镜像\n\n> [windows 开发镜像](https://developer.microsoft.com/en-us/windows/downloads/virtual-machines/)\n\n有时候需要在虚拟机中测试，而微软官方提供了封装好的虚拟机镜像，包括流行的 VMWare/Hyper-V/VirtualBox/Parallels。\n\n### 安装 Build Tools for Visual Studio 2019\n\n主要是处理一些二进制依赖，例如 [imagemin-pngquant](https://github.com/imagemin/imagemin-pngquant/issues/46)\n\n解决方案 1\n\n在管理员模式下运行以下命令\n\n```sh\nnpm install --global --production windows-build-tools\n```\n\n> 参考: <https://github.com/antvis/L7/issues/101>，吾辈使用这种方法没有安装成功\n\n---\n\n解决方案 2\n\n1. 从 [这里](https://visualstudio.microsoft.com/zh-hant/downloads/) 下载 **Build Tools for Visual Studio 2019** 安装器\n2. 在 tab **可用** 下选择 **Visual Studio 生成工具 2019 => 使用 C++ 的桌面开发** 安装\n","createdTime":1585530377612,"updatedTime":1632818050012,"resources":[{"id":"080d96fdedc54c358cf6f1f73e75d8de","title":"配置Proxifer","file_extension":"gif","user_updated_time":1632817963715},{"id":"30d25e553fed4f06b250d4670b32d04f","title":"1623386196951","file_extension":"png","user_updated_time":1623386197488},{"id":"4b6cacb250374c37a3ba48f202c26de0","title":"1623122443753","file_extension":"png","user_updated_time":1623122444074},{"id":"d9df37c041034ad3b3feaaf32a8cd67e","title":"1623122585291","file_extension":"png","user_updated_time":1623122585607},{"id":"e596b55573c0428584f92759c9df7ac6","title":"演示配置SSR","file_extension":"gif","user_updated_time":1632817954827},{"id":"f80aec5f992142258ea21003e4b36729","title":"1623122471651","file_extension":"png","user_updated_time":1623122471933}],"tags":[{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"4196df6a040f4c0aa3016547d895bf6b","title":"WebStorm 使用技巧","body":"## WebStorm 全局默认配置\r\n\r\n使用场景：  \r\n使用 WebStorm 经常会遇到一种情况，在这个项目自顶了一些设置（**Settings** 而非 **Project Structure**，例如 自定义的 Maven，项目字符编码等等），到了新的项目全部恢复了默认值又要重新设定。\r\n\r\n解决方案：  \r\n通过 WebStorm 的默认设置（**File > Other Settings > Default Settings**）就可以设定全局的 **Settings**，而不需要在每个项目中重新设定一次。\r\n\r\n> 默认设定按吾辈的理解应该是用于设定那些可以使项目级别的设置，例如 **代码检查**，**代码样式** 等。毕竟大部分的设置都是全局的嘛\r\n\r\n## Alt-Enter 操作提示\r\n\r\nAlter-Enter 大概是 WebStorm 最强大快捷键了，放在不同的位置有不同的功能。\r\n\r\n- 警告（代码下面有黄色波浪线），会自动帮我们修复警告。\r\n  代码重复，代码冗余（1/0 之类），多余的变量（声明完就立刻返回/声明完最多只使用了一次）\r\n- 错误（代码下面有红色波浪线），一般会提出合适的修复建议。\r\n  代码缺少注解，具体子类有未实现的方法\r\n- 接口名（接口的名字），一般会提示可以生成实现类或者跳转到实现类\r\n- 自动修复变量名的问题（不符合驼峰）\r\n- 普通类名，一般会提示创建测试类，没有 JavaDoc 注释还会提示生成注释\r\n- 字符串里面，会提示使用 [语言注入](#语言注入)\r\n- 跳转到注入语言的编辑面板\r\n\r\n## Double Shift 任意搜索\r\n\r\n这个功能其实是集成了多个搜索，但有时候真的很好用，集成的功能包括\r\n\r\n- 搜索 `Settings`（`CS-A`）：搜索 WebStorm 的设置\r\n- 搜索 `class`（`C-N`）：搜索代码里的 class 类\r\n- 搜索 `File`（`CS-N`）：搜索任何文件\r\n- 搜索 `symbol`（`CSA-N`）：搜索符号，主要用于搜索 Spring MVC 路径\r\n- 搜索 `Tool Windows`（`C-Tab`）：搜索工具窗口\r\n- 搜索 `Run configuration`（`SA-F9/F10`）：搜索运行的配置项\r\n- 搜索 `Action`（`Alt-Enter`）：搜索当前位置的代码可执行操作\r\n\r\n如果你知道需要搜索的类型，请尽量使用单独的搜索选项，毕竟速度上会有一些优势\r\n\r\n## 列编辑\r\n\r\n列编辑是一个非常有趣的功能，可以让你同时编辑多行文本。\r\n\r\n共有下面几种方式触发\r\n\r\n- 使用鼠标中键下拉或上拉选中多行\r\n- 使用 `A-J` 依次选择相同的代码片段，并使用 `SA-J` 取消选择\r\n- 使用 `CSA-J` 选中当前文件所有匹配的代码片段\r\n- 使用 `CA-Top/Bottom` 向上或向下选择多行（需要添加快捷键 `Editor Actions => Clone Caret Above/Clone Caret Below`）\r\n\r\nGIF 演示\r\n\r\n![GIF 演示](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190627110522.gif)\r\n\r\n## 常用快捷键\r\n\r\n> 快捷键想要熟练没有什么好的办法，却是只能多加使用了。如果你还不熟悉 WebStorm 的快捷键，可以使用 [Key Promoter X](https://github.com/halirutan/IntelliJ-Key-Promoter-X) 插件来提示你使用快捷键操作。\r\n\r\n- 搜索\r\n  - `C-N` ：搜索类\r\n  - `CS-N` ：搜索文件\r\n  - `CSA-N` ：搜索字段名(包含数据库字段)/方法名\r\n  - `SS` ：搜索接口路径，类名，文件名，字段名/方法名\r\n  - `CS-F`：全局搜索代码（该快捷键与 Windows10 的默认输入法冲突，可以修改快捷键，或者换用其他输入法）\r\n- 面板操作\r\n  - `ESC`：返回到编辑器中\r\n  - `C-E` ：列出最近操作的文件历史以及可操作面板列表，然后可以通过输入单词跳转到对应的面板\r\n  - `C-Tab -> *`：列出最近操作的文件历史以及可操作面板，并能通过单个字母导航到对应的操作面板（需要一直按住 `Ctrl`）\r\n  - `A-Top/Bottom/Left/Right` ：左右是切换标签页，上下是切换方法\r\n  - `F12` ：跳转到最后一个使用的面板\r\n  - `CS-F12` ：收起/显示所有面板\r\n  - `C-F12` ：在一个悬浮面板上列出所有字段/方法\r\n  - `A-F11`: 列出可以快速运行的任务，支持 `npm/gulp`\r\n- 选择\r\n  - `C-W/CS-W` ：扩大/缩小选择区域范围\r\n  - `CS-[/]`：选择至当前区域的开始/结束\r\n  - `A/SA-J` ：选中/反选相同的单词进行列编辑（一个个的选中）\r\n  - `CSA-J` ：选中多个相同的单词（当前文件全部选中）\r\n- 代码跳转\r\n  - `CA-Left/Right` ：跳转到上一个/下一个浏览的位置\r\n  - `CS-Backspace` ：回退到上一个编辑的位置\r\n  - `C-Top/Bottom/Left/Right`：左右是跳转到上一个/下一个单词，上下是移动屏幕（非移动光标）\r\n  - `C-;` ：屏幕内任意跳转（需要安装 **Ace Jumper** 插件）\r\n  - `Home` ：跳转到行首/编辑器的最左侧\r\n  - `End` ：跳转到行尾\r\n  - `C-Home/End` ：跳转到文件的开始/结尾\r\n  - `C-Page Up/Page Down` ：跳转到当前屏幕的第一行/最后一行\r\n  - `F2/S-F2` ：跳转到下一个/上一个错误/警告的位置\r\n  - `C-Left/C-Right` ：跳转到上一个/下一个单词的位置\r\n  - `C-B` ：跳转到变量/方法的声明处\r\n  - `CS-B` ：跳转到变量/方法的具体实现处，如果不止一处就会列出下拉框\r\n    > 注：这里吾辈修改了快捷键，毕竟 `CA-B` 单手按起来还真有点麻烦\r\n\r\n> 注：在 WebStorm 看来左侧字母上面的数字键和右侧小键盘的数字键是不同的！\r\n> 注: `Shift` 一般用于 **增强/取反** 功能。例如 `C-F` 搜索当前文件，`CS-F` 搜索所有文件，`F2` 跳转到下一个错误，`S-F2` 跳转到上一个错误。\r\n\r\n## 常用插件\r\n\r\n- [JRebel for IntelliJ](https://plugins.jetbrains.com/plugin/4441-jrebel-for-intellij)：做 Java Web 开发时真心免不了的 Plugin，能够有效解决 Web 容器（例如 Apache Tomcat）启动速度慢的问题（因为几乎所有的资源都能够热加载，热部署）\r\n- [LiveEdit](https://plugins.jetbrains.com/plugin/7007-liveedit)：提供了 HTML/CSS/JavaScript 的实时预览和刷新功能\r\n- [MybatisX](https://plugins.jetbrains.com/plugin/10119-mybatisx)：Mybatis 的一个辅助开发插件，能够比较愉快的使用 Mybatis 框架了\r\n- [Alibaba Java Coding Guidelines](https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines)：Alibaba 出品的一个 Java 规范检查插件，能够规避一些不好的代码\r\n- [Translation](https://plugins.jetbrains.com/plugin/8579-translation)：目前使用感觉最好的翻译插件，能够提供比较长的内容进行翻译（某些翻译插件只能翻译很短的内容）\r\n- [String Manipulation](https://plugins.jetbrains.com/plugin/2162-string-manipulation)：字符串操作工具，可以方便对变量名或其他字符串修改为其他风格，例如将变量从 **驼峰命名**（Java 标准命名） 修改为 **下划线命名**（SQL 标准命名）或者 **中缀线命名**（HTML/CSS 标准命名）。\r\n  > 其实这么多命名规范真心坑。。。\r\n- [Key Promoter X](https://plugins.jetbrains.com/plugin/9792-key-promoter-x)：使用鼠标操作时提示对应的快捷键\r\n- [Custom Postfix Templates](https://plugins.jetbrains.com/plugin/9862-custom-postfix-templates)：提供自定义的后缀模板\r\n- [Markdown Navigator](https://plugins.jetbrains.com/plugin/7896-markdown-navigator)：WebStorm 平台的 Markdown 写作插件，比自带的 Markdown Support 要好很多，主要在需要写的 Markdown 内容中含有代码时比较方便\r\n- [Maven Helper](https://plugins.jetbrains.com/plugin/7179-maven-helper)：一个 Apache Maven 的辅助操作插件\r\n- [CodeGlance](https://plugins.jetbrains.com/plugin/7275-codeglance)：在编辑器右侧显示一块代码缩略图，主要为了方便使用滑块进行上下滑动\r\n- [Grep Console](https://plugins.jetbrains.com/plugin/7125-grep-console)：自定义控制台的输出颜色\r\n- [.ignore](https://plugins.jetbrains.com/plugin/7495--ignore)：在使用版本控制时，快速忽略某些文件/文件夹，目前支持广泛\r\n- [CMD support](https://plugins.jetbrains.com/plugin/5834-cmd-support)：Cmd 支持，主要是方便在 WebStorm 中直接运行 bat 脚本\r\n- [NodeJS](https://plugins.jetbrains.com/plugin/6098-nodejs)：集成了 NodeJS，可以直接在 WebStorm 中运行 NodeJS\r\n- [Vue.js](https://plugins.jetbrains.com/plugin/9442-vue-js)：集成 Vue.js 框架\r\n- [ESLint](https://plugins.jetbrains.com/plugin/7494-eslint)：前端代码规范\r\n- [Prettier](https://plugins.jetbrains.com/plugin/10456-prettier)：根据上面 ESLint 的规范自动格式化代码\r\n- [Properties to YAML Converter](https://plugins.jetbrains.com/plugin/8000-properties-to-yaml-converter)：将 `Properties` 文件快速转换为 `YAML` 格式的配置文件\r\n- [WakaTime](https://plugins.jetbrains.com/plugin/7425-wakatime)：统计使用的编程语言，不同 IDE 的记录\r\n\r\n## 语言注入\r\n\r\n为某一段区域的注入其他语言，WebStorm 最常见的就是在 JavaScript 的字符串中注入了 HTML/CSS/JavaScript，使得在字符串内也有代码提示可用。\r\n\r\n> 此功能常用于 JavaScript 字符串拼接 HTML 代码，当然目前这个需求在 ES6 中由 `模板字符串` 原生实现了。\r\n\r\n我们也可以手动注入，例如为 Java 中的字符串注入 SQL 语言，这样在写 SQL 语句就不用跑到 SQL 编辑器那里写完 SQL 语句在粘贴过来了。\r\n\r\n我们也可以自定义语言注入的规则，例如让 `vm.evalCode` 中的字符串默认为 js 代码。\r\n\r\n![1632817508056](:/49e8605f93954313a6f95621d977785b)\r\n\r\n> 参考: <https://www.jetbrains.com/help/webstorm/using-language-injections.html#configure-injection-rules>\r\n\r\n## Live Template/Postfix Template 模板\r\n\r\nLive Template 模板就是那种在 Java 中输入 `sout` 就可以生成以下代码的模板功能，而这功能在 WebStorm 还可以自定义。\r\n\r\n```java\r\nSystem.out.println($END$);\r\n```\r\n\r\n例如吾辈就定义了 `autowired` 用于生成\r\n\r\n```java\r\n@Autowired private $BeanClass$ $BeanName$;\r\n$END$\r\n```\r\n\r\n或者 `thread`\r\n\r\n```java\r\nnew Thread(() -> {\r\n    $END$\r\n}).start();\r\n```\r\n\r\n此功能使用得当甚至能大量减少重复编码。不过相比之下另外一个代码生成功能吾辈更加喜欢，但 WebStorm 在 2018.2 版本之前并不支持自定义，所以功能上来说就显得稍弱一些，当然吾辈也使用插件（Custom Postfix Templates [GitHub](https://github.com/xylo/intellij-postfix-templates#download)）实现了自定义的需求。最新版本 WebStorm 原生支持了自定义功能（[WebStorm 官方介绍](https://blog.jetbrains.com/idea/2014/03/postfix-completion/)），但实现尚不完善。\r\n\r\n此功能可以做到另外一种形式的模板字符串，例如输入 `\"str\".var` 然后回车会得到\r\n\r\n```java\r\nString $variableName$ = \"str\";$END$\r\n```\r\n\r\n或者 `\"str\".sout`\r\n\r\n```java\r\nSysout.out.println(\"str\");\r\n```\r\n\r\n吾辈也自定义一些，例如输入了 `\"str\".val`，会生成\r\n\r\n```java\r\nfinal String $variableName$ = \"str\";$END$\r\n```\r\n\r\n## 一些有用的配置项\r\n\r\n### soft wrap 强制换行\r\n\r\nWebStorm 在一行过长时会出现横向滚动条，那我们不想要它出现以便于能直接使用键盘就能看完要怎么办呢？\r\n\r\n可以在 _Settings ⇒ Editor ⇒ General ⇒ Soft Wraps_ 中找到设置，将 **Soft-wrap files** 的值修改为 `*` 即可。\r\n\r\n![强制换行](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191212090747.png)\r\n\r\n### 根据源代码自动滚动项目\r\n\r\n可以在跳转文件时，使文件目录自动聚焦在当前编辑的文件上，这在很多时候是有利于查看目录/文件的。\r\n\r\n2019.3 之后\r\n\r\n在 _Project ⇒ Always Select Opened File_ 中可以找到这个配置，启用即在整个项目中启用了。\r\n\r\n![根据源代码自动滚动项目设置](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191224100414.png)\r\n\r\n2019.3 之前\r\n\r\n在 _Project ⇒ Tool ⇒ Autoscroll from Source_ 中可以找到这个配置，启用即在整个项目中启用了。\r\n\r\n![根据源代码自动滚动项目设置](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191212090627.png)\r\n\r\n### 项目外部依赖\r\n\r\n在传统 web 项目中，会有需要让 IDE 索引通过 script 标签引入的依赖，但现代前端绝大多数时候不应该让 IDE 处理。\r\n\r\n![1619968206663](:/2bceea193e1945aeac57b5342eed3fcc)\r\n\r\n你需要在设置 _File | Settings | Languages & Frameworks | JavaScript | Libraries_ 中取消不需要索引的依赖项。\r\n\r\n![1619968548104](:/96fd64b1eae1494698b5aa092574b1e2)\r\n\r\n### 在 TypeScript 项目中使用强类型提示\r\n\r\n在 TypeScript 项目中，我们的代码提示应该基于 TypeScript 而非 WebStorm 的索引，因为前者要精确的多。\r\n\r\n![1619969180589](:/b3561ab309a6462386c726372f30aeb2)\r\n\r\n涉及到以下几个选项\r\n\r\n- _File | Settings | Editor | General | Code Completion => Only type-based completion_\r\n\r\n### typescript 项目中禁用 WebStorm 的索引\r\n\r\n### 设置背景图片\r\n\r\n最新的 WebStorm 支持设置背景图片，具体设置在 _File | Settings | Appearance & Behavior | Appearance_，效果如下\r\n\r\n![1623482286209](:/837c6b07d00449dc9f61b083087b516d)\r\n\r\n## 复制 WebStorm 提示的报错\r\n\r\n> 这个技巧的发现来源于一个同事\r\n\r\n有时候 WebStorm 提示我们错误，当我们把鼠标放在上面时会有一个 `Tooltip`。但当我们想要复制这个错误时，却发现选择时 `Tooltip` 很容易消失，即便在较新版本中进行了改进，但想要复制仍然是非常痛苦的一件事，那么如何更加简单的复制错误呢？\r\n实际上，当我们将光标移动到错误上面时，左下角的状态栏中会有该错误并且可以右键复制！\r\n\r\n![复制 WebStorm ToolTip 提示](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200430145423.png)\r\n\r\n> 相关问题参考：<https://youtrack.jetbrains.com/issue/WebStorm-70943>，这是一个相当古老（2011 年）的问题，但 JetBrains 的开发者一开始甚至不认为这是一个问题，直到最近才着手修复它。\r\n> 附：或许 JetBrains 的开发人员并不需要面向 Google 编程？#笑\r\n\r\n## 浏览器报错在 WebStorm 打开相应文件\r\n\r\n> 参考：\r\n>\r\n> - [React 调试的时候如何打开指定的编辑器 /webstorm](https://juejin.im/post/6844903967206408206)\r\n\r\nreact 项目下其实就是添加环境变量 `REACT_EDITOR` 而已，可以使用 `.env.local` 进行配置\r\n\r\n```env\r\nREACT_EDITOR=[WebStorm 的路径]\r\n```\r\n\r\n## 设定默认 jest 运行单元测试\r\n\r\n在包含 react-scripts 依赖的项目中，WebStorm 会默认使用 react-scripts 运行测试，这在单体项目中当然很好，但如果是 monorepo，则会出现一些问题。react-scripts 运行时会强制修改 `tsconfig.json/react-app-env.d.ts`，这在一些 node 子模块中会出现问题，而 react-scripts 目前还不能关闭这个功能。所以只能修改 WebStorm 的测试运行工具了，可以在 `Edit configuration` 中修改 `Jest => Jest Package` 字段值为 `jest`，更推荐设置 `Templates => Jest => Jest Package` 字段，因为它可以一劳永逸。\r\n\r\n![1615086542056](:/468e71461fca48fa9ae306f2da89fc48)\r\n\r\n> 参考：[How to configure react-script so that it doesn't override tsconfig.json on 'start'](https://stackoverflow.com/questions/53794875)\r\n","createdTime":1580652937994,"updatedTime":1632817588769,"resources":[{"id":"2bceea193e1945aeac57b5342eed3fcc","title":"1619968206663","file_extension":"png","user_updated_time":1619968207509},{"id":"468e71461fca48fa9ae306f2da89fc48","title":"1615086542056","file_extension":"png","user_updated_time":1615086542734},{"id":"49e8605f93954313a6f95621d977785b","title":"1632817508056","file_extension":"png","user_updated_time":1632817508858},{"id":"837c6b07d00449dc9f61b083087b516d","title":"1623482286209","file_extension":"png","user_updated_time":1623482286851},{"id":"96fd64b1eae1494698b5aa092574b1e2","title":"1619968548104","file_extension":"png","user_updated_time":1619968548762},{"id":"b3561ab309a6462386c726372f30aeb2","title":"1619969180589","file_extension":"png","user_updated_time":1619969181269}],"tags":[{"id":"05f6657b073e4bf3959bdb9a2fecda83","title":"webstorm","parent_id":""},{"id":"95ddbbd925aa4358a46bfcbce4c3fb46","title":"工具","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"9fb9955796ef4773af71a53b8ff7f8ef","title":"工具网站","body":"## 前端\r\n\r\n- [2019 前端开发者学习路线汇总](https://frontendmasters.com/books/front-end-handbook/2019/)\r\n\r\n## 工具\r\n\r\n- [i18ns](https://i18ns.com/): 国际化 i18n 全语言翻译\r\n- [codepen](https://codepen.io/): 前端页面代码分享(`HTML/CSS/JavaScript`)\r\n- [appsgeyser](https://www.appsgeyser.com/): 封装前端/网站为 App\r\n- [cloudflare](https://www.cloudflare.com/): CDN/免费的 HTTPS\r\n- [netlify](https://www.netlify.com/): 前端免费 CI(持续集成)\r\n- [smms](https://sm.ms/): 免费稳定的图床(国内)\r\n- [office-converter](https://cn.office-converter.com/Online-Document-Converter): 文档在线转换\r\n- [I tell you](https://msdn.itellyou.cn/): 微软相关资源下载\r\n- [vectormagic](https://vectormagic.com/): 图像类型在线转换\r\n- [Firefox Send](https://send.firefox.com/): 安全的分享文件\r\n- [draw](https://www.draw.io/): 画图工具\r\n- [flaticon](https://www.flaticon.com/): 矢量图标库\r\n- [iconfont](https://www.iconfont.cn/): 阿里矢量图标库\r\n- [colorhunt](https://colorhunt.co/): CSS 颜色搭配\r\n- [uigradients](https://uigradients.com/): 渐变颜色推荐\r\n- [cssfontstack](https://www.cssfontstack.com/): 查看字体在各个系统的预装概率\r\n- [rg-adguard](https://tb.rg-adguard.net/): Windows 第三方下载站（实际调用 MS 的链接）\r\n- [Picsum](https://picsum.photos/): 图片占位网站\r\n- [taag](http://patorjk.com/software/taag/): 文字转字符画\r\n- [asciiflow](http://asciiflow.com/): 手绘字符画\r\n- [GeoGebra](https://www.geogebra.org/): 数学作图工具\r\n- [send anywhere](https://send-anywhere.com/): 文件共享\r\n- [excalidraw](https://github.com/excalidraw/excalidraw): web 白板\r\n- [stackshare](https://stackshare.io/): 各种技术差异及对比\r\n- [img2go](https://www.img2go.com/zh): 在线图片编辑器\r\n\r\n## 网站\r\n\r\n- [Explore Pens on CodePen](https://codepen.io/pens/): CSS/Canvas/SVG 创意分享\r\n- [namesilo](https://www.namesilo.com/): 域名服务\r\n- [vultr](https://www.vultr.com/): VPS 服务\r\n- [inoreader](https://www.inoreader.com/): RSS 订阅/管理/阅读\r\n- [leetcode](https://leetcode.com/problemset/all/): 算法刷题\r\n- [owllook](https://www.owllook.net/): 在线开源小说阅读\r\n- [codelf](https://unbug.github.io/codelf/): 变量命名神器\r\n- [旧版 Chromium 下载](https://sourceforge.net/projects/crportable/files/): 便于调试之用\r\n- [picdiet](https://www.picdiet.com/zh-cn): 图片在线本地压缩\r\n- [aconvert](https://www.aconvert.com/)：在线常用工具网站，包括图像转换（`png <=> ico`），文档转换等等\r\n- [种子书城](https://zhongzisc.blogspot.com/)：一个有趣的 epub 书籍分享/下载网站\r\n- [DeepL 深度翻译](https://www.deepl.com/translator)\r\n- [worldvectorlogo](https://worldvectorlogo.com/): 免费 svg icon 下载\r\n- [a4k](https://www.a4k.net/): 字幕下载\r\n\r\n## 论坛\r\n\r\n- [SegmentFault](https://segmentfault.com/): 国内前端问答论坛\r\n- [MDN 开发者网站](https://developer.mozilla.org/zh-CN/): 世界上最好的前端文档（详尽的本地化）\r\n- [Google Web](https://developers.google.com/web/): Google Web 的开发者文档(包含最新但不一定实用的知识)\r\n\r\n## 教程\r\n\r\n- [Pro Git](https://git-scm.com/book/zh/v1): Git 功能详述\r\n- [ES6 教程](http://es6.ruanyifeng.com/): 通俗易懂的 ES6 入门教程\r\n- [material desgin](https://material.io/design/): materail 主题设计原则\r\n\r\n## 博客\r\n\r\n- [Frank's Blog/前端迷](http://ru23.com/): 前端底层知识\r\n- [阮一峰的网络博客](http://www.ruanyifeng.com/blog/): 通俗易懂的博客\r\n- [善用佳软](http://xbeta.info/): 精品的软件评测系列（很久没更新了）\r\n- [利器](https://liqi.io/): 分享创造者和他们的工具（不一定是编程领域）\r\n- [可乐橙](https://colachan.com/)：有着奇思妙想的 UI 设计师\r\n\r\n## 库\r\n\r\n- [chartjs](https://www.chartjs.org/): JavaScript 图表\r\n- [jquery](https://jquery.com/): 上个世代最流行的前端库\r\n- [Commander.js](https://github.com/tj/commander.js/blob/master/Readme_zh-CN.md): nodejs 命令行解析工具\r\n\r\n## 优秀文章\r\n\r\n- [程序员跳槽时，如何高效地准备面试？](https://juejin.im/post/5aa0d65a5188251880387b01)\r\n\r\n## 学习\r\n\r\n- [freecodecamp 免费学习认证网站](https://www.freecodecamp.org/learn/front-end-libraries/react/create-a-simple-jsx-element)\r\n","createdTime":1584167100042,"updatedTime":1631523179750,"resources":[],"tags":[{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"d4305821fd2a4dfc827811c17ca85fe6","title":"个人与开源","body":"## 场景\r\n\r\n昨天，吾辈的 GitHub 提交已经超过了去年一整年。就在前几天，有人从 GitHub 上找到了吾辈，所以想谈一些吾辈关于开源的认识。\r\n\r\n2020\r\n\r\n![1624672304685](:/4d3552ea84da470f94be5a4265cb37b4)\r\n\r\n2021\r\n\r\n![1624672317484](:/e6d42dad38404bb98f6b44003be4d0b6)\r\n\r\n## 为什么要做开源项目\r\n\r\n最初的想法是觉得开源很酷，许多厉害的人都创造了许多有趣的开源工具，典型的就是 Linux。后面工作之后坚持下来的原因更多是公司的项目很一般，所以只能通过开源项目来提高技术能力，并希望做出一点有用的东西。\r\n\r\n收益\r\n\r\n- 学习开源项目的架构和设计\r\n- 实践自己的想法、尝试新的技术\r\n- 证明自己的技术能力\r\n- 认识一些志同道合的人\r\n- 做自己使用的工具总是可以做的更好\r\n\r\n成本\r\n\r\n- 花费额外的时间和精力，对于工作的人来说这两个的重要程度不言而喻\r\n- 几乎无法得到经济上的回报\r\n- 前期可能没什么人会在意你，会有一段时间的孤独（不仅仅是做开源项目，任何创作型的行为皆然）\r\n\r\n## 两个方向\r\n\r\n就如同所有事情一样，做开源项目也有不同的选择，吾辈正在做的主要有两个方向：\r\n\r\n- 面向开发者的工具\r\n- 面向一般用户的工具\r\n\r\n### 面向开发者的工具\r\n\r\n正如其名，是做面向开发者使用的工具，从 UX 角度包括各种函数类库、CLI 命令行工具以及可视化开发工具等等。\r\n\r\n- 函数类库：lodash、moment 之类，对于开发者最灵活的方式，一般绑定编程语言\r\n- CLI 命令行工具：create-react-app、vite 之类，一般是为了解决某一类问题创建，可以跨编程语言组合\r\n- 可视化开发工具：例如 @vue/cli-service、VSCode、JetBrains 插件之类，一般是为了提供更加直观的使用方式，但也最不灵活和难以集成\r\n\r\n怎么说呢，由开发者创建的开发者工具总是更容易的，尤其是当自己也使用时，更容易理解和优化功能。吾辈在工作之后创造了一些工具\r\n\r\n- [@liuli-util/\\*](https://github.com/rxliuli/liuli-util) 系列函数库：主要是希望减小工具库的 API 面积（lodash 许多函数吾辈很少用到）\r\n- [@liuli-util/cli](https://www.npmjs.com/package/@liuli-util/cli)：主要是为了解决上面一系列工具库打包的问题，做到零配置打包的能力，类似 microbundle（preact 作者创建的工具）\r\n- [i18next-dts-gen](https://www.npmjs.com/package/@liuli-util/i18next-dts-gen): 为 i18next 的 json 配置文件产生类型定义的方法，主要是应用在下面的一系列面向一般用户的工具中\r\n- [vite-jetbrains-plugin](https://plugins.jetbrains.com/plugin/16897): 将 vite 集成到 jetbrains ide 的插件\r\n\r\n但同样的，这种选择也有自身的缺陷：主要是开发者本质上也只是用户的一个小部分群体，相当于放弃了开发者之外的庞大用户。而且开发者总是吐槽别人家的文档写的很烂，但同时又觉得写文档是一个麻烦的事情，所以使用体验一般不怎么样，许多名不见经传的工具往往只有作者能在 5 分钟内开始使用它。\r\n\r\n### 面向一般用户的工具\r\n\r\n相比于面向开发者，面向一般用户首先就天然拥有更多的受众，像每周基本上都会出现在 GitHub 热点中的 hexo 主题便是如此。但同时，想要创造一个对一般用户友好的工具并不简单，一般用户对各种麻烦的容忍程度不比开发者，否则也不会有产品经理、UI/UX 这种岗位了。\r\n\r\n- 没有文档：不容易或找不到正确使用的方法，一般就会不用了\r\n- 出现错误：我才不管是谁的锅，你让我用的不爽，我就不会用你。\r\n- 使用命令行：虽然现在命令行已经比较友好了，但对于一般用户而言仍然很难使用，更何况这是个很多人只用手机的时代。\r\n- 有外部依赖：依赖于 nodejs、python 等运行时对于一般用户而言都很麻烦\r\n\r\n吾辈主要在做的是 joplin 相关的一系列工具\r\n\r\n- [joplin-vscode-plugin ![install](https://img.shields.io/visual-studio-marketplace/i/rxliuli.joplin-vscode-plugin)](https://marketplace.visualstudio.com/items?itemName=rxliuli.joplin-vscode-plugin): joplin 的 vscode 插件\r\n- [joplin-blog](https://www.npmjs.com/package/joplin-blog): 将 Joplin 作为数据源导出 blog/wiki\r\n- [joplin-search-integration](https://chrome.google.com/webstore/detail/joplin-search-integration/mcjkdcifkhjenpfjacnbhpdcnjknjkhj): 在 Google/Bing/Baidu 搜索中集成 joplin 笔记的搜索结果\r\n- [joplin-batch-web](https://joplin-utils.rxliuli.com/joplin-batch-web/): 处理一些 Joplin 本身不支持的批量操作，以可视化界面的形式展现出来。\r\n- [joplin-api](https://www.npmjs.com/package/joplin-api): Joplin 的 api 封装，适用于 web/nodejs，也是以上成果的基础\r\n- [userjs](https://github.com/rxliuli/userjs): 一些自用的油猴脚本，主要用来改善网页浏览体验。\r\n\r\n事实上，能够做面向一般用户的工具（吾辈也是一般用户），也是吾辈从后端转向前端的理由之一。\r\n\r\n## 总结\r\n\r\n无论如何，现在的世界都已经筑基于开源项目之上，吾辈也会坚持一直做下去。\r\n","createdTime":1624669545249,"updatedTime":1631157275529,"resources":[{"id":"4d3552ea84da470f94be5a4265cb37b4","title":"1624672304685","file_extension":"png","user_updated_time":1624672305235},{"id":"e6d42dad38404bb98f6b44003be4d0b6","title":"1624672317484","file_extension":"png","user_updated_time":1624672317776}],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"b363e4f8f1c04983b35860ae09c6377a","title":"2021 第十一周","body":"## 快速一览\n\n- 周五正式离职\n- 阿里云 DataV 内推失败\n- 一家中小公司面试失败\n- 周三请几位同事一起吃了顿饭\n- 打算下周回老家休息一周\n- GitHub 评级上升至 A++\n- joplin-search-integration 功能已基本实现\n- 尝试 git 约定式提交\n\n## 工作\n\n天空中不会留下飞鸟的痕迹。这周五，吾辈已然从公司离职了，和吾辈相关的东西都会随着时间慢慢消失吧。\n曾经有人对吾辈说：“年轻真好，没有房贷家庭的压力，可以来一场说走就走的旅行呢！” 这句话不能说完全没有道理，因为吾辈认识的两个人都因为家庭（其实可能主要是房贷）的原因不敢离职，一位朋友借钱贷款导致 3 年内不敢离职，而另一位前同事则自称离职两个月就要破产了。\n但吾辈却并不认为未成家就没有压力了，作为一个稍微有点努力的普通人，看到一丝机会便想抓住，但却一直未能得偿所愿的情况下，也会焦虑、迷惘与痛苦。另一位博主在 [极限](https://innei.ren/notes/81) 一文中也曾经发出过对内卷的感慨。我们既是（内卷）受害者，但亦为加害者。\n\n那么，吾辈想要去什么样的公司呢？\n\n拥有优秀 team 的公司\n\n- 不是外包：吾辈不是针对谁，是说所有的外包公司都是垃圾\n- 公司有一定的规模：一个人闭门造车不可取\n- 公司能够正常盈利：不能盈利的公司是万恶之源\n- 公司的技术栈比较新：jq/ng1 项目根本不值得去维护\n- 不是 996：虽然互联网公司加班已经难以避免，但吾辈仍然不想去 996 福报，身体会首先撑不住\n\n这周也面试了另一家在做低代码平台的公司，老实说吾辈确实有点想去了，但似乎最终吾辈要求的薪资超过了它们的预算。。。想想都知道想找到合适的公司非常困难，但如果不去找合适的公司会变成什么样子呢？\n\n- 一直在做业务性的工作，到头来一直在低层次徘徊，突破不了自身的天花板\n- 经历过这些事情之后，感慨国内不能做纯技术路线，遂转技术管理方向\n- 按照父母的期望相亲结婚，然后终生为经济（房贷）所困\n\n这周工作日基本上有时间就在刷算法，但第一章的最后两小节，算法分析和连通性算法部分还是让吾辈感觉麻烦了，练习基本上只完成了 1.4.10-1.4.19。\n\n## 生活\n\n周三和公司的三位同事吃了一顿饭，发现公司的管理层也有非常多的内耗，这是吾辈之前没想到或者说没有察觉到的。\n\n- 两位管理层的矛盾\n- 公司老人与新人的矛盾\n- 老板的理想与现实的矛盾\n\n打算回老家休息一周，常年呆在这边，为了抓住渺茫的机会，不断地尝试和努力，或许，适时后退一步也好。毕竟人类，总是贪婪而不知足的生物啊。\n\n![1616313126720](:/1ef24ee24f444202955ab68dd94c6b1b)\n\n这周不知道为什么 GitHub 的评级反而上升了，可能是吾辈最近活跃 GitHub 变得比较多了？总而言之吾辈还是很开心啦！\n\n![github status](https://github-readme-stats.vercel.app/api?username=rxliuli&show_icons=true&theme=tokyonight&line_height=40&v=5)\n\n[joplin-search-integration](https://github.com/rxliuli/joplin-search-integration) 是一个将 joplin 的笔记结果集成到 google 搜索的一个 chrome 插件（理论上所有 chromium base 的浏览器应该都 ok），是从上上周开始的一个计划，至今为止发布了 v0.1.4 版本，功能性已然足够，不过细节方面仍然存在许多优化之处。\n\n由于看到了一篇文章 [約定式提交 Conventional Commits](https://cythilya.github.io/2021/03/16/conventional-commits/)，发现其中博主面临的问题吾辈也曾经遇到过，然而并未解决，所以在个人项目中进行了尝试，感觉还不错，和吾辈**不是强制的规范就不是规范**的想法很接近。\n","createdTime":1616310576620,"updatedTime":1631094525121,"resources":[{"id":"1ef24ee24f444202955ab68dd94c6b1b","title":"1616313126720","file_extension":"png","user_updated_time":1616313127164}],"tags":[{"id":"7e40798e7aec482f9a0c93ef1bef6673","title":"周报","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"4a311eccb0794367a7c3f54ec685fa0e","title":"2020 复盘及 2021 计划","body":"## 2020 复盘\r\n\r\n> [年初计划](:/30c2fb56f8a349b1b6f45b9dc0a049ea)\r\n>\r\n> 明年，吾辈最想要接触的是 Web 桌面开发，以及机器学习。\r\n>\r\n> - [x] NodeJS 后端开发\r\n> - [x] Web 桌面开发 Electron\r\n> - [ ] 机器学习 TensorFlow\r\n> - [x] 继续维护 Blog\r\n> - [ ] 继续坚持读书\r\n> - [ ] 尝试网络小说写作\r\n> - [ ] 尝试 Youtube 视频创作\r\n\r\n实际上 Web 桌面开发由于工作的原因算是接触的非常多，但机器学习几乎没什么了解。\r\n\r\n那么今年到底做了什么呢？\r\n\r\n| 时间  | 公司               | 个人                       |\r\n| ----- | ------------------ | -------------------------- |\r\n| 1 月  | 疫情发生           | 过了最惨的年               |\r\n| 2 月  | 远程办公           |\r\n| 3 月  | 业务开发           |\r\n| 4 月  | 开始招人           | 替换技术栈 vue => ts+react |\r\n| 5 月  | 995 福报中         | 接触 Electron              |\r\n| 6 月  | 995 福报中         | 开始使用 joplin 管理笔记   |\r\n| 7 月  | 程序定制化修改     | 开发 joplin-vscode-plugin  |\r\n| 8 月  | 程序定制化修改     | 开始了解 Monorepo 工程化   |\r\n| 9 月  | 程序定制化修改     |\r\n| 10 月 | 程序定制化修改     | 开发 joplin-charts         |\r\n| 11 月 | 开始新的项目       | 完善 joplin 周边工具链     |\r\n| 12 月 | 开始另一个新的项目 | 开发 joplin-blog           |\r\n\r\n今年主要入的一个大坑是 joplin，虽说一开始仅仅是作为笔记工具使用，但中途因为遇到了一些问题所以参与了部分周边工具的开发，占用了不少的业余时间。然而，开源程序的魅力就在于此：当不能满足需求时，吾辈可以通过开发来改变这一切。\r\n\r\n开源项目\r\n\r\n- [rx-util](https://github.com/rxliuli/rx-util): 前端通用工具库，虽然今年没怎么更新，但也是因为逐渐变得完善的愿意\r\n- [joplin-vscode-plugin](https://marketplace.visualstudio.com/items?itemName=rxliuli.joplin-vscode-plugin&ssr=false#overview): joplin 的 vscode 插件，使用 vscode 接管自己的笔记管理，支持大多数 joplin 的功能（通过 web clipper service）\r\n- [joplin-blog](https://github.com/rxliuli/joplin-blog): 将 joplin 作为数据源导出 blog\r\n- [joplin-charts](https://rxliuli.com/joplin-charts/#/): 展示 joplin 的一些统计图表数据\r\n- [joplin-api](https://www.npmjs.com/package/joplin-api): joplin 的 api 封装，适用于 web/nodejs，也是以上成果的基础\r\n- [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped): 参与了一个类型定义包的错误修复，熟悉了基本的贡献流程（其实也挺繁琐的）\r\n- [user.js](https://github.com/rxliuli/userjs): 一些自用的油猴脚本 -- 仅维护常用的几个了\r\n- [liuli-cli](https://github.com/rxliuli/liuli-cli): 前端 npm 包的脚手架生成 cli 工具 -- 不怎么维护了\r\n- [vue-url-persist](https://github.com/rxliuli/vue-url-persist): vue url 序列化参数的包 -- 自从主要技术栈更换为 react 之后就不怎么维护了\r\n\r\n但显而易见，去年是吾辈工作的第三年，但成长速度确实不尽人意。至于原因，吾辈内里倒也十分清楚。\r\n\r\n- 客观原因：\r\n  - 当公司的 team 不能为自己的成长提供帮助时，也只能一个人走着自己的探索之路，但这时常会感到灰心丧气，甚至破罐破摔式的放弃挣扎。-- 然后在一段时间时间后回想起来感到后悔，仿若贤者时间一般。\r\n  - 疫情（是一个非常不好的开始）\r\n- 主观原因\r\n  - 没找到一条明确的变得更好的途径，内心迷茫。上一次这样的时候吾辈从后端转职为了前端，但这一次，吾辈不清楚应该怎么做。\r\n  - 懒散、无法坚持，这些缺点今年切实的体现在了吾辈身上，而这却又无法轻易摆脱。\r\n  - 生活没有规律，睡得很晚，周末没有合理的安排时间出去活动。\r\n\r\n## 新的计划\r\n\r\n总体而言，核心目标仍然没有变化：**活下去，活得更好**。但执行层面确实需要发生一些变化。\r\n\r\n目标\r\n\r\n- [ ] 制定并坚持合理的时间计划\r\n- [ ] 切实地找到新的学习方法\r\n- [ ] 看完之前购买的书籍\r\n- [ ] 学习英语\r\n\r\n开源项目\r\n\r\n- [x] 编写 Electron 经验之谈系列博客 -- 1 月\r\n- [x] 完善 joplin-blog cli，提高效率，优化 UX -- 2 月上旬\r\n- [x] 重构 web logger 日志工具 -- 2 月上旬\r\n- [x] 重构 rx-util 工具包，将之分解为独立的一系列模块，避免耦合 nodejs/dom 和庞大难以引入的问题 -- 春节\r\n\r\n希望今年自己能变得更好，在一切糟糕到无法挽回之前，离开这里 -- 世界那么大，吾辈也想出去看看。\r\n\r\n> 2020 是过去十年最坏的一年，但或许，是今后十年最好的一年。\r\n","createdTime":1609505671035,"updatedTime":1631093858322,"resources":[],"tags":[{"id":"8010d32086404c1db68e023251387cc0","title":"开源","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""},{"id":"f5172282f275485bab67f712ba1b1bcf","title":"个人","parent_id":""}]},{"id":"1a6dda43a5a84e61b4b16865d8e52373","title":"实践 lerna monorepo","body":"> 已转入 yarn2，放弃使用 lerna+yarn1 的组合，具体原因参考 [yarn2 使用](:/556ea9eee38842c0be108ada810b711f) 中描述的动机。\n\n## 历史\n\n- 上古时期，前端没有工程化的概念可言，复用代码也不过是将某些 css、js 代码片段保存到笔记，需要时复制到项目中，仅此而已。参考：[55 个提高你 CSS 开发效率的必备片段](https://github.com/Wscats/CV/issues/29)，或是 [jquery 库](http://www.htmleaf.com/jQuery/)\n- 莽荒时代，前端出现了 nodejs 和 npm，于是一大批通用代码被发布到了 npm 平台，可以在项目中简单配置即可使用通用的库，任何人都可以简单的将代码发布到 npm。参考：[lodash](https://www.npmjs.com/package/lodash)\n- 现代，由于前端项目的复杂度逐渐上升，所以出现了 monorepo 工具以更简单的复用代码。例如层出不穷的 monorepo 支持工具 [lerna](https://lerna.js.org/)、[@microsoft/rush](https://rushjs.io/)、[yarn 2](https://yarnpkg.com/features/workspaces)、[pnpm](https://pnpm.js.org/en/workspaces)、[npm 7](https://docs.npmjs.com/cli/v7/using-npm/workspaces)\n\n> 自去年 10 月开始，吾辈使用 lerna 重构个人和公司的项目，以应对愈加复杂的前端项目。\n\n## 为什么需要 monorepo？\n\n> 借用一下 lerna 官网的简介：\n>\n> 将大型代码仓库分割成多个独立版本化的 软件包（package）对于代码共享来说非常有用。但是，如果某些更改 跨越了多个代码仓库的话将变得很 麻烦 并且难以跟踪，并且， 跨越多个代码仓库的测试将迅速变得非常复杂。\n>\n> 为了解决这些（以及许多其它）问题，某些项目会将 代码仓库分割成多个软件包（package），并将每个软件包存放到独立的代码仓库中。但是，例如 Babel、 React、Angular、Ember、Meteor、Jest 等项目以及许多其他项目则是在 一个代码仓库中包含了多个软件包（package）并进行开发。\n\n你可能会认为除了大型开源项目之外，monorepo 对于小型项目和生产环境的业务项目没有太多价值。但这是错的，前者我在微型工具库 [liuli-util](https://github.com/rxliuli/liuli-util) 上进行了实践，确定了它对于维护和使用确实有帮助。而后者，甚至出现了专门为业务项目的 monorepo 工具 [@microsoft/rush](https://rushjs.io/pages/intro/why_mono/)，微软在 [rushstack](https://github.com/microsoft/rushstack) 项目中大规模使用了它。\n\n## 为什么选择 lerna？\n\n那么，有了这么多 monorepo 工具，为什么我们选择 lerna？\n\n- [lerna](https://lerna.js.org/)\n- [@microsoft/rush](https://rushjs.io/)\n- [yarn 2](https://yarnpkg.com/features/workspaces)\n- [pnpm](https://pnpm.js.org/en/workspaces)\n- [npm 7](https://docs.npmjs.com/cli/v7/using-npm/workspaces)\n\n其实，除了 lerna 与 @microsoft/rush 之外，其它竞争对手都是包管理器，仅仅只是提供了 workspace 的工作空间，并未提供更高级功能。\n\n> lerna 和 @microsoft/rush 的 npm 趋势对比参考: <https://www.npmtrends.com/lerna-vs-@microsoft/rush>\n\n下图是一个对比\n\n| 对比项 | lerna        | @microsoft/rush |\n| ------ | ------------ | --------------- |\n| star   | 26,824       | 2,392           |\n| 周下载 | 1,155,241    | 100,386         |\n| 使用者 | 知名开源项目 | 微软系产品      |\n\n就吾辈的实际使用体验而言，相比于 lerna，rush 默认包含了更多的东西，而非通过组合一系列可选的工具支持，这增长了相当的门槛。\n\n下面是吾辈对其的一些认知过程\n\n- rush.js 是真的感觉很【专业】，限定了很多很多东西\n- <https://rushjs.io/pages/maintainer/setup_policies/>\n- 像是这里，通过 allowedPackagesPolicy 的方式对 team 中所有开发人员都可以直接引入新的 npm 包做出了限制\n- 唉，rush 比 lerna 复杂多了，做了很多很多的预定义的事情，这就意味着，它对项目维护者（而非开发者）的要求更高\n- 和 ide 没完全集成真痛苦.JPG\n- 吾辈总算明白这些配置为什么是【推荐配置】而不是【默认配置】了，引发的错误太多了（毕竟 npm 包很多并不规范）\n- rush monorepo 的一个问题是，某些包总喜欢强制指定依赖包的特定版本（例如 react-scripts），而 rush 总是“聪明”的仅安装最新的，导致添加的项目莫名其妙的炸掉\n- 吾辈的锅，它在最后给了方法 <https://rushjs.io/pages/advanced/installation_variants/>\n- 但一整个进阶主题都是在处理这个问题。。。\n- 算了，吾辈放弃了，rush + pnpm 感觉上维护配置成本太高了，滚回 lerna + yarn 了\n\n> rush 在功能、目标和文档方面更好，但现阶段而言还是 lerna 更成熟。\n\n## lerna 是什么？\n\n简而言之，Lerna 是一个管理工具，用于管理包含多个软件包（package）的 JavaScript 项目。可以在一个项目中创建多个模块（基本上模块也可以认为是一个项目），并且可以在本地的模块之间互相关联。\n\nlerna 项目的基本结构如下\n\n生产项目\n\n- 根目录\n  - `apps`: 生产项目\n    - `app-1`\n    - `app-2`\n  - `libs`: 通用模块\n    - `lib-1`\n    - `lib-2`\n  - `package.json`\n  - `lerna.json`\n\n开源库\n\n- 根目录\n  - `libs`: 模块根目录\n    - `lib-1`\n    - `lib-2`\n  - `package.json`\n  - `lerna.json`\n\n> 目录的名字灵感来源于 [rushstack](https://github.com/microsoft/rushstack)\n\n## 使用 lerna 的优点\n\n> 其中部分优点是 monorepo 固有的优势，但也有 lerna 独有的功能。\n\n- 更容易抽离公共代码: 模块之间可以互相引用并且即时生效\n- 更容易统一\n  - 项目配置: `tsconfig.json/prettier.json/git hooks`\n  - 管理和发布一系列包: `lerna publish`\n  - 修改依赖立刻生效: `lerna bootstrap`\n  - 依赖版本: 和默认合并不同版本的依赖\n  - 文档生成和合并: `fliegdoc`\n  - 代码风格: `prettier/git hooks`\n  - 在一个模块运行另一个模块的命令: `lerna run <cmd> --scope <pkg>`\n  - 打包工具和流程: 封装更适合项目的打包 cli\n\n目前稍微大点的开源项目不是已经转为了 lerna monorepo，就是已经在转换的路上（很像最近流行的使用 typescript 重构库）。包括但不限于以下这些：\n\n![1614158368615](:/1481553a70764d679f18841199b9db09)\n\n> 吾辈目前使用的笔记工具 Joplin 也在去年使用 lerna 重构了，参考：[Lerna migration](https://github.com/laurent22/joplin/pull/4039)。\n\n## 总结\n\n使用 lerna 虽然会增加一些复杂度，但带来的优点仍然是超过缺点的。\n\n> 吾辈之所以相信 monorepo 会成为主流的原因是后端已经使用了这么多年的 maven/gradle，如果真的有什么问题，那不会直到现在还在使用。\n","createdTime":1614049403125,"updatedTime":1630925702027,"resources":[{"id":"1481553a70764d679f18841199b9db09","title":"1614158368615","file_extension":"png","user_updated_time":1614158369019}],"tags":[{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"930763abc6ae4cfbbb45bc17a9947596","title":"vue3 使用有感","body":"> 假若没有看见光明，我本可以忍受黑暗。\r\n\r\n## 场景\r\n\r\n自上家公司从去年 5 月份开始成功推广 react 之后，很长一段时间吾辈一直在使用它，而今年，离职之后新的公司再次使用 vue3，因而见证了两个 team 踏入了同一条河流。不过 vue 作者说 vue3 使用 ts 重写，对其支持很好，吾辈姑且安心了一点，但经过近一个月的实践，吾辈还是发现了种种问题。\r\n\r\n> 从 vue 迁移到 react 的原因参考: [2020 吾辈在公司推动的前端技术演进](:/5ea2552c67d34130b68cc11143d6191c)\r\n\r\n## 基本感受\r\n\r\n- vue3 的生态不稳定，而且仍然比较小\r\n- vue3 和 ts 的结合仍然不算好\r\n- webstorm/vscode 对 vue3+ts 的支持比较糟糕\r\n\r\n## vue3 的生态\r\n\r\n> vue 官方承认自身社区比 react 更小，但他们很明智的没有说出来，这究竟代表了什么。\r\n\r\n- vue+ts 结合的体验很糟糕，下面会详述\r\n- vue 的大版本升级虽然没有 react 那么快，但每次升级都是完全破坏性的，整个社区都要重新构建\r\n- ant-design-vue 2 使用 vue3 重构，但使用体验仍然比不上官方的 ant-design（例如 Table 的能力还远远比不上 ant-design）\r\n- antv 系列官方基本优先或仅支持 react，例如只有 react 版本的 G2Plot/Graphin\r\n- 结合 storybook 有点恶心，需要在字符串中写模板\r\n- vue-router 开发环境和生产环境的行为不一致，开发环境支持 `import()`，生产环境则必须是 `() => import()`\r\n- 许多周边 npm 包都是 next/beta/rc 版本\r\n- 异步组件比较奇葩，用了一种 map 的方式实现\r\n\r\n## vue+ts 结合\r\n\r\n- 模板是个失败的设计，很多问题都是由模板衍生而来\r\n- props 和 ts 结合仍有问题\r\n- 模板中只能编写 js，但 vue-tsc 会使用 tsc 检查，这会导致一些奇怪的问题很难解决\r\n- 使用 tsx 也会存在一些问题，但可能是现有条件下最好的解决方案（antdv 使用该方式），参考：[极致的开发体验！Vite + Vue 3 + tsx 完整教程](https://juejin.cn/post/6972094589251354632)\r\n\r\n### vue 模板到底有什么问题？\r\n\r\n相比于 vue 模板，jsx（或者说 react）的设计非常巧妙，它不需要 props/attrs/emits/slot/指令 这一系列 vue 的功能，而仅仅只需要 props，而它能够使得 dts 就能够完全支持 react 组件的接口定义，进而使编辑器能够通过 ts 做提示、导航和重构。而 vue 一时看起来方便开发者的设计，例如 props 支持定义类型、必填校验及 getter/setter，未在 props 声明的属性会被放到 attrs 并自动绑定到组件根元素上，前者在和 ts 结合时导致要重复定义 props 的类型，后者导致在支持 fragments 时反而需要手动指定绑定 attrs 的元素。\r\n\r\n下面是一个 antdv List 组件的使用示例，如果不看文档，没人知道 slot 到底可以挂的是羊头，还是狗肉\r\n\r\n```html\r\n<template>\r\n  <a-list item-layout=\"horizontal\" :data-source=\"data\">\r\n    <a-list-item slot=\"renderItem\" slot-scope=\"item, index\">\r\n      <a-list-item-meta\r\n        description=\"Ant Design, a design language for background applications, is refined by Ant UED Team\"\r\n      >\r\n        <a slot=\"title\" href=\"https://www.antdv.com/\">{{ item.title }}</a>\r\n        <a-avatar\r\n          slot=\"avatar\"\r\n          src=\"https://zos.alipayobjects.com/rmsportal/ODTLcjxAfvqbxHnVXCYX.png\"\r\n        />\r\n      </a-list-item-meta>\r\n    </a-list-item>\r\n  </a-list>\r\n</template>\r\n```\r\n\r\nvscode vetur 和 jetbrians(web-types) 为了解决开发体验的问题选择了两条不同的道路，但都存在一些问题，参考：[web-types.json 目前仍然有问题，包括某些 slot/item 仍然是错误的](https://github.com/vueComponent/ant-design-vue/issues/4467)，可以想见，既然连 antdv 这么流行的 vue ui 组件库都无法保证没有问题，更别提整个 vue 生态中的其他 ui 组件库了。\r\n\r\n### props 和 ts 结合还有什么问题？\r\n\r\nprops 在 vue3 的 ts 有所增强，至少能够使用 `PropType` 复杂类型了，例如下面\r\n\r\n```ts\r\nimport { defineComponent, PropType } from 'vue'\r\ninterface User {\r\n  name: string\r\n  age: number\r\n}\r\n\r\nexport default defineComponent({\r\n  name: 'List',\r\n  props: {\r\n    // 使用 PropType 定义复杂类型\r\n    list: Array as PropType<User[]>,\r\n  },\r\n  setup(props) {\r\n    // 这儿的 props 类型是正确的\r\n    console.log(props.list)\r\n    return {}\r\n  },\r\n})\r\n```\r\n\r\n但它仍然存在一些问题\r\n\r\n**无法复用现有的类型**。例如当我们已经有一个后端返回的数据结构类型了，而我们希望组件仅需要其中的部分字段，而这无法使用 ts 的类型操作完成。究其原因，还是因为 vue 的 props 定义仍然是值而非类型。\r\n**无法使用 ts 的可选属性**。vue props 仍保留定义 `required/default/validator` 的功能，所以并不能使用 ts 的可选属性。下面的示例代码将上面限制表现的的淋漓尽致\r\n\r\n```tsx\r\n// react\r\ninterface User {\r\n  name: string\r\n  age?: number // 利用了 ts 的可选属性\r\n  address: string\r\n}\r\n// 使用 ts 的类型操作，只取 name/age 字段\r\nconst User: React.FC<Pick<User, 'name' | 'age'>> = (props) => {\r\n  return (\r\n    <div>\r\n      {props.name} {props.age}\r\n    </div>\r\n  )\r\n}\r\n// vue\r\ndefineComponent({\r\n  name: 'User',\r\n  props: {\r\n    // 重新定义，和 ts 格格不入\r\n    name: {\r\n      type: String,\r\n      required: true,\r\n    },\r\n    age: Number,\r\n  },\r\n})\r\n```\r\n\r\n**无法使用泛型**。最典型的莫过于 List 组件，我们希望传入的 data 数据决定 slot 中参数的类型，目前这是不可能的。下面是 react 中的泛型组件示例（本质上是泛型函数，对 `state=>ui` 的抽象是真的彻底）\r\n\r\n```tsx\r\n// 定义泛型函数\r\nfunction List<T>(props: {\r\n  list: T[]\r\n  renderItem(item: T, i: number): ReactNode\r\n}) {\r\n  return <ul>{props.list.map(props.renderItem)}</ul>\r\n}\r\n\r\ninterface User {\r\n  name: string\r\n  age?: number\r\n}\r\n\r\nexport const Hello: React.FC = () => {\r\n  return (\r\n    <List\r\n      list={[{ name: '琉璃' }] as User[]}\r\n      renderItem={(item, i) => <li key={i}>{item.name}</li>}\r\n    />\r\n  )\r\n}\r\n```\r\n\r\n### 模板中只能编写 js，但 vue-tsc 会使用 tsc 检查，这会导致一些奇怪的问题很难解决\r\n\r\n模板里不能使用 ts，但 vue-tsc 却会检查 ts，然后就 GG 了\r\n\r\n![1628152139838](:/de927ddb9b34400fb8ac6d4e675e1b87)\r\n\r\n如上图，就因为模板中的函数参数没有指定类型导致 vue-tsc 报告错误了，但模板中也确实不能定义参数类型，所以目前只能将之放到 script 中并在 setup 函数返回（是不是感觉挺蠢的？）\r\n\r\n## webstorm/vscode 对 vue3+ts 的支持比较糟糕\r\n\r\n具体表现在提示、导航和重构。吾辈在想，是不是 vue 的开发者都习惯了这种问题，代码导航靠 C-F 一个个查找，重构时 CS-F 一个个手动替换（群友吐槽说：“不然怎样，就 vue 那个框架设计，完全不考虑静态分析好吧……估计反馈给 yyx，得到的回答是：这么爱静态分析，滚去用 angular”）\r\n\r\n- 在 monorepo 中 vue-ts 提示很慢\r\n- monorepo 中同时包含 react 子模块时，无法使用 vue tsx，webstorm 会默认为是 react tsx\r\n- 重构不支持自动重命名 ref/setup 返回值/模板引用\r\n\r\n## 一些感受到的优点\r\n\r\n上面吐槽了那么多，vue 及其社区也并非没有可取之处\r\n\r\n- vue3 的 hooks api 对心智负担确实更小，不太容易出现 react hooks 两个烦人的问题\r\n  - 强制要求依赖，但很容易错误（各种依赖引发的问题）\r\n  - 状态声明的方式独树一帜，与一般 js 隔离了。例如许多基于闭包实现的高阶函数都必须重写，但在 vue hooks 中则不用（好吧其实也需要，但至少能生效）\r\n- vite/vuepress 很好用，比 snowpack/docusaurus 更好用（即便吾辈使用的是 react 技术栈，但仍然使用它们作为构建和文档工具）\r\n\r\n## 其他\r\n\r\n### 使用异步组件\r\n\r\n> 参考：[vue3 官方文档](https://v3.cn.vuejs.org/guide/component-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6)\r\n\r\n1. 全局注册所有异步组件（能够以编程的方式注册的方法）\r\n\r\n   ```ts\r\n   const components: Record<string, Lazy<Component>> = {\r\n     hello: () => import('hello'),\r\n   }\r\n   ;[...Object.entries(components)].forEach(([k, v]) => {\r\n     app.component(k, defineAsyncComponent(v))\r\n   })\r\n   ```\r\n\r\n2. 通过 `component` 组件渲染\r\n\r\n   ```html\r\n   <component is=\"hello\" />\r\n   ```\r\n\r\n可以看到，基本上就是通过 map 的方式维护，要在局部引用之前还必须先在全局注册一下昭告天下 xd\r\n\r\n### 使用 provide/inject 模拟 react context\r\n\r\n为什么要模拟 react context？\r\n因为 vue3 仍然基于字符串实现的 provide/inject，而字符串可以任意写且不包含类型。\r\n\r\n```ts\r\nimport { inject, provide } from 'vue'\r\n\r\n// context 实例本身就已经包含了 key 与值的类型了\r\ninterface Context<T> {\r\n  key: Symbol\r\n  init?: T\r\n}\r\n\r\n/**\r\n * 创建一个上下文，用于在当前组件的所有子孙组件共享状态\r\n * 基于 provide/inject 实现，但支持强类型，而且使用 Symbol，永不重复而且无需考虑命名问题\r\n * @param init\r\n * @param key\r\n */\r\nexport function createContext<T>(init?: T, key?: string): Context<T> {\r\n  return {\r\n    key: Symbol(key),\r\n    init,\r\n  }\r\n}\r\n\r\n/**\r\n * 为所有子孙组件注入状态\r\n * @param context\r\n * @param value\r\n */\r\nexport function useProvide<T>(context: Context<T>, value: T) {\r\n  provide(context.key, value)\r\n}\r\n\r\n/**\r\n * 使用祖先节点注入的状态，可能为 null/undefined\r\n * @param context\r\n */\r\nexport function useInject<T>(context: Context<T>): T | undefined {\r\n  return inject(context.key, context.init)\r\n}\r\n```\r\n\r\n使用\r\n\r\n```ts\r\nconst stringContext = createContext()\r\nuseProvide(stringContext, 'hello')\r\nconst value = useInject(stringContext)\r\nconsole.log(value)\r\n```\r\n\r\n> 关于这点，官方提出了自己的解决方案，参考: <https://v3.cn.vuejs.org/api/composition-api.html#provide-inject>\r\n\r\n```ts\r\nconst key: InjectionKey<string> = Symbol()\r\nprovide(key, 'foo') // 若提供非字符串值将出错\r\nconst foo = inject(key) // foo 的类型: string | undefined\r\n```\r\n\r\n## 总结\r\n\r\n上面只是吾辈的一些吐槽，但考虑到成本问题，在公司推广 react 短期来看仍然是不现实的（vue3、ts 甚至 esnext 都有人未能基本掌握）。\r\n","createdTime":1628135115911,"updatedTime":1630566504846,"resources":[{"id":"de927ddb9b34400fb8ac6d4e675e1b87","title":"1628152139838","file_extension":"png","user_updated_time":1629616830871}],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"d86454b85c8f4c38aef6fa1575487e7f","title":"vue","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"51b60e96b1d542fda593fed9ae3bd9a3","title":"CSS Grid 页面布局","body":"## 背景\r\n\r\n> [grid 可视化布局](https://grid.layoutit.com/), [css grid 完整指南](https://css-tricks.com/snippets/css/complete-guide-grid/)\r\n\r\n早就知道 css grid 布局非常强大，但之前由于兼容性问题一直没有机会尝试，近来在生产环境中大规模尝试使用它，并尝试在 react 中进行封装：[在 react 中优雅的使用 grid 实现页面布局](:/ea5fd9fe209540d0a94fde5d8a789a1f)，于此记录一下各种常见布局的 grid 实现。\r\n\r\n> 附：grid 真的是一个非常强大自适应布局系统。\r\n\r\n## 示例\r\n\r\n> 注：以下示例均默认引用了 [Normalize.css](https://necolas.github.io/normalize.css/)\r\n\r\n### 中后台基本布局\r\n\r\n![中后台基本布局](:/3114e38d083649efa048f3e5bedf5b59)\r\n\r\n```html\r\n<body>\r\n  <style>\r\n    html,\r\n    body,\r\n    .container {\r\n      height: 100%;\r\n    }\r\n\r\n    .container {\r\n      display: grid;\r\n      /* 定义行和列 */\r\n      grid-template-columns: 300px 1fr;\r\n      grid-template-rows: auto 1fr;\r\n      /* 定义布局的地图，未设定 area 则默认堆叠 */\r\n      grid-template-areas: 'header header';\r\n    }\r\n    .header {\r\n      grid-area: header;\r\n    }\r\n    .container > * {\r\n      border: solid 1px red;\r\n    }\r\n  </style>\r\n  <div class=\"container\">\r\n    <header class=\"header\">header</header>\r\n    <section>sidebar</section>\r\n    <section>content</section>\r\n  </div>\r\n</body>\r\n```\r\n\r\n[中后台基本布局.html](:/9a639cd730ad4ecfb13144d183b9ac11)\r\n\r\n### 纵向布局\r\n\r\n![纵向布局](:/822f302b44d74f40a77f5d50bfd19238)\r\n\r\n```html\r\n<body>\r\n  <style>\r\n    html,\r\n    body,\r\n    .container {\r\n      height: 100%;\r\n    }\r\n\r\n    .container {\r\n      display: grid;\r\n      /* 下面这行指定了\r\n        第一行按照内容自适应高度\r\n        第二行占有剩余高度\r\n         */\r\n      grid-template-rows: auto 1fr;\r\n    }\r\n\r\n    .container > * {\r\n      border: solid 1px red;\r\n    }\r\n  </style>\r\n  <div class=\"container\">\r\n    <header>header</header>\r\n    <section>content</section>\r\n  </div>\r\n</body>\r\n```\r\n\r\n[纵向布局.html](:/ed16a3151010453897c2e38a714fe48e)\r\n\r\n### 模拟 flex margin-left 或 margin-right\r\n\r\n![模拟 flex margin-left 或 margin-right](:/88680a1d45be472896d73286759e6e3c)\r\n\r\n```html\r\n<body>\r\n  <style>\r\n    .container {\r\n      display: grid;\r\n      /* 下面两行是关键 */\r\n      grid-template-columns: auto 1fr auto;\r\n      justify-items: end;\r\n    }\r\n\r\n    .container > * {\r\n      border: solid 1px red;\r\n    }\r\n  </style>\r\n  <header class=\"container\">\r\n    <img src=\"https://picsum.photos/20\" alt=\"logo\" />\r\n    <div>用户名</div>\r\n    <div>消息</div>\r\n  </header>\r\n</body>\r\n```\r\n\r\n[模拟 flex margin-left 或 margin-right.html](:/b64b37dd36d8485c8242380d56bd8371)\r\n\r\n### 根据内容自适应贴靠在一边\r\n\r\n如下图展示一个图片列表\r\n\r\n![根据内容自适应贴靠在一边](:/6d92a3ad621a4f29b3436107764a2fdb)\r\n\r\n```html\r\n<body>\r\n  <style>\r\n    .container {\r\n      display: grid;\r\n      grid-template-columns: auto auto;\r\n      /* 下面一行是关键，效果类似于 flex-start */\r\n      justify-content: start;\r\n      grid-gap: 8px;\r\n    }\r\n  </style>\r\n  <section class=\"container\">\r\n    <img src=\"https://picsum.photos/seed/1/100\" />\r\n    <img src=\"https://picsum.photos/seed/2/100\" />\r\n    <img src=\"https://picsum.photos/seed/3/100\" />\r\n    <img src=\"https://picsum.photos/seed/4/100\" />\r\n    <img src=\"https://picsum.photos/seed/5/100\" />\r\n    <img src=\"https://picsum.photos/seed/6/100\" />\r\n  </section>\r\n</body>\r\n```\r\n\r\n[根据内容自适应贴靠在一边.html](:/a591f0eb17604196976eebb3e005941c)\r\n\r\n### 针对任意数量的元素水平布局（替代 flex）\r\n\r\n```css\r\n.container {\r\n  display: grid;\r\n  /* 主要是这个属性 */\r\n  grid-auto-flow: column;\r\n}\r\n```\r\n\r\n可以很容易实现居中布局\r\n\r\n![1630307731953](:/66bd831ec3b048ae99926dddc5543d59)\r\n\r\n[针对任意数量的元素水平布局.html](:/553ed7795e714516b8be9be83eab5e6b)\r\n\r\n## 真实案例\r\n\r\n嵌套的 grid 布局，外层处理横向布局，内层用以垂直对齐图片和文字。\r\n\r\n![1629475754345](:/b09e5e0cb82e4b95b1710a95124333e9)\r\n\r\n纵向布局，内容区域自适应撑高容器到 100%。\r\n\r\n![1629475763454](:/443aea600d2d4b568c26974c4dd57b38)\r\n","createdTime":1607522234732,"updatedTime":1630307732504,"resources":[{"id":"3114e38d083649efa048f3e5bedf5b59","title":"Snipaste_2020-12-09_22-43-38.png","file_extension":"png","user_updated_time":1607525028126},{"id":"443aea600d2d4b568c26974c4dd57b38","title":"1629475763454","file_extension":"png","user_updated_time":1629475763758},{"id":"553ed7795e714516b8be9be83eab5e6b","title":"针对任意数量的元素水平布局.html","file_extension":"html","user_updated_time":1630307695206},{"id":"66bd831ec3b048ae99926dddc5543d59","title":"1630307731953","file_extension":"png","user_updated_time":1630307732264},{"id":"6d92a3ad621a4f29b3436107764a2fdb","title":"Snipaste_2020-12-09_22-33-08.png","file_extension":"png","user_updated_time":1607524422895},{"id":"822f302b44d74f40a77f5d50bfd19238","title":"Snipaste_2020-12-09_22-12-56.png","file_extension":"png","user_updated_time":1607523300079},{"id":"88680a1d45be472896d73286759e6e3c","title":"Snipaste_2020-12-09_22-24-47.png","file_extension":"png","user_updated_time":1607523965816},{"id":"9a639cd730ad4ecfb13144d183b9ac11","title":"中后台基本布局.html","file_extension":"html","user_updated_time":1607524664280},{"id":"a591f0eb17604196976eebb3e005941c","title":"根据内容自适应贴靠在一边.html","file_extension":"html","user_updated_time":1607523540898},{"id":"b09e5e0cb82e4b95b1710a95124333e9","title":"1629475754345","file_extension":"png","user_updated_time":1629475754703},{"id":"b64b37dd36d8485c8242380d56bd8371","title":"模拟 flex margin-left 或 margin-right.html","file_extension":"html","user_updated_time":1607523394148},{"id":"ed16a3151010453897c2e38a714fe48e","title":"纵向布局.html","file_extension":"html","user_updated_time":1607522468834}],"tags":[{"id":"300027ec7dbd4dde992cecd230704041","title":"grid","parent_id":""},{"id":"8f339224ff5c4b5aa4103e407b04ed0e","title":"css","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"ea5fd9fe209540d0a94fde5d8a789a1f","title":"在 react 中优雅的使用 grid 实现页面布局","body":"> 这篇现在来看感觉是用 react 组件用疯了，好孩子不要学。\n\n## 场景\n\n吾辈在做 electron 应用的时候遇到了这种布局，顶部是 header，然后是页面中的 toolbar，紧接着右边有一个侧边栏列表，左侧的内容又分为了两块区域。这种布局在中后台系统中应该很常见，但之前并未特别留意过布局通用化。\n\n![布局.drawio.svg](:/d61642e05753427d98ad17a468eea52e)\n\n- 使用 `css calc()` 计算高度\n- 基于 `css calc()` 封装 `Col/Row` 组件，然后使用组件进行布局（主要模仿 antd grid）\n- 使用 `css grid` 自适应布局\n- 使用 `css grid` 封装组件\n\n## 使用 `css calc()` 计算高度\n\n最初，吾辈使用 `css calc()` 计算剩余高度，以占满全部高度。但这样实现存在的一个明显问题是，每当吾辈需要在纵向添加一行时，都要修改 `calc()` 重新计算高度。如果存在嵌套内容时，甚至会导致层层声明 `height: calc(100% - *px)`，而且难以复用，这是很难接受的。\n\n下面是一个实现上面那种布局的方法\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>grid test</title>\n    <style>\n      * {\n        margin: 0;\n        padding: 0;\n        box-sizing: border-box;\n      }\n      html,\n      body,\n      .container {\n        height: 100%;\n      }\n      .header {\n        height: 64px;\n      }\n      .main {\n        height: calc(100% - 64px);\n      }\n      .toolbar {\n        height: 64px;\n      }\n      .content {\n        height: calc(100% - 64px);\n        display: flex;\n      }\n      .main-content {\n        display: inline-block;\n        width: calc(100% - 300px);\n        height: 100%;\n      }\n      .sider {\n        display: inline-block;\n        width: 300px;\n        height: 100%;\n      }\n      .form {\n        height: 300px;\n      }\n      .list {\n        height: calc(100% - 300px);\n      }\n      .header,\n      .main,\n      .toolbar,\n      .content,\n      .sider,\n      .form,\n      .list {\n        border: solid 1px red;\n        overflow-y: auto;\n        text-align: center;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"container\">\n      <nav class=\"header\">header</nav>\n      <main class=\"main\">\n        <header class=\"toolbar\">toolbar</header>\n        <div class=\"content\">\n          <div class=\"main-content\">\n            <section class=\"form\">form</section>\n            <section class=\"list\">list</section>\n          </div>\n          <section class=\"sider\">sider</section>\n        </div>\n      </main>\n    </div>\n  </body>\n</html>\n```\n\n可以看到，不仅 html 部分嵌套众多，css 部分也需要反复计算宽高，这实在不是一件令人愉快的代码。\n\n## 基于 `css calc()` 封装 `Col/Row` 组件布局\n\n由于不希望每次都去写类似下面的代码，因而吾辈产生了封装组件的想法。\n\n```css\n.container {\n  height: 100%;\n  overflow-y: auto;\n}\n```\n\n初次尝试\n\n> 基本思路来源于 antd 的 [Grid 布局](https://ant.design/components/grid-cn)，之所以没有使用 antd grid 的原因是它并不支持纵向的布局，即便是 Layout 布局组件也不是那么好用。\n\n- `FullHeight`: 让子组件占满父组件的全部高度\n- `VerticalCol`: 占全高的一列\n- `VerticalRow`: 可控制占比列中的一行\n\n```tsx\ntype FullHeightProps = {\n  children: ReactElement\n}\n\n/**\n * 让子组件占满父组件的全部高度\n */\nconst FullHeight: React.FC<FullHeightProps> = (props) => {\n  return cloneElement(props.children, {\n    ...props.children.props,\n    style: {\n      height: '100%',\n      overflowY: 'auto',\n      ...props.children.props.style,\n    },\n  })\n}\n\n// 垂直布局的上下文\n\nexport type VerticalColContextType = {\n  //分割的份数\n  gutter: number\n}\n\n/**\n * 垂直布局的上下文环境\n */\nexport const VerticalColContext = createContext<VerticalColContextType>({\n  gutter: 24,\n})\n\ntype VerticalColProps = {\n  children: ReactElement<VerticalRowProps> | ReactElement<VerticalRowProps>[]\n  style?: CSSProperties\n}\n\n/**\n * 垂直布局的一列\n * 默认占父容器的全部高度\n */\nconst VerticalCol = React.forwardRef<HTMLDivElement, VerticalColProps>(\n  (props, ref) => (\n    <VerticalColContext.Provider\n      value={{\n        gutter: 24,\n      }}\n    >\n      <FullHeight>\n        <div style={props.style} ref={ref}>\n          {props.children}\n        </div>\n      </FullHeight>\n    </VerticalColContext.Provider>\n  ),\n)\n\nexport type VerticalRowProps = {\n  span?: number\n  style?: CSSProperties\n}\n\n/**\n * 用来控制每一行占比的元素\n */\nconst VerticalRow: React.FC<VerticalRowProps> = (props) => {\n  const { gutter } = useContext(VerticalColContext)\n  return (\n    <div\n      style={{\n        height: `calc(100% / ${gutter} * ${props.span})`,\n        overflowY: 'auto',\n        ...props.style,\n      }}\n    >\n      {props.children}\n    </div>\n  )\n}\n\nVerticalRow.defaultProps = {\n  span: 0,\n}\n```\n\n基本使用大概长这样\n\n```tsx\n<VerticalCol\n  style={{\n    height: '100%',\n  }}\n>\n  <VerticalRow span={2} style={{ backgroundColor: 'red' }}>\n    内容块 1\n  </VerticalRow>\n  <VerticalRow span={22} style={{ backgroundColor: 'green' }}>\n    内容块 2\n  </VerticalRow>\n</VerticalCol>\n```\n\n看起来还不错，简单的使用组件就可以按比例分割页面了。但一旦在复杂的实际页面使用时，麻烦就接踵而来了。\n\n```tsx\n<VerticalCol\n  style={{\n    height: 800,\n  }}\n>\n  <VerticalRow span={2} style={{ backgroundColor: 'red' }}>\n    <header>\n      <h1>标题</h1>\n    </header>\n  </VerticalRow>\n  <VerticalRow span={22} style={{ backgroundColor: 'green' }}>\n    <FullHeight>\n      <Row>\n        <FullHeight>\n          <Col\n            span={18}\n            style={{\n              backgroundColor: 'aqua',\n            }}\n          >\n            内容区域\n          </Col>\n        </FullHeight>\n        <FullHeight>\n          <Col\n            span={6}\n            style={{\n              backgroundColor: 'blue',\n            }}\n          >\n            {Array(100)\n              .fill(0)\n              .map((_, i) => (\n                <h2\n                  style={{\n                    color: 'white',\n                  }}\n                >\n                  {i}\n                </h2>\n              ))}\n          </Col>\n        </FullHeight>\n      </Row>\n    </FullHeight>\n  </VerticalRow>\n</VerticalCol>\n```\n\n可以看到，这里仅仅是使用 Component 代替了 css class 而已，并未减少页面布局的复杂性，而且由于使用组件进行布局，导致组件的结构变得更深了。\n\n## 使用 `css grid` 自适应布局\n\ncss grid 确实强大无比，尤其是 `grid-template-areas` 功能，直接改变了传统网页的布局方式。现在，自适应布局变得异常简单。\n\n下面是使用 grid 的方式实现布局的代码，可以看到最复杂的部分其实是在 `grid-template-areas`，它确定了不同元素占有的区块。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>grid test</title>\n    <style>\n      html,\n      body,\n      .grid-container {\n        margin: 0;\n        padding: 0;\n        box-sizing: border-box;\n      }\n\n      .grid-container {\n        height: 100%;\n        display: grid;\n        grid-template-columns: 1fr 300px;\n        grid-template-rows: 64px 64px 430px 1fr;\n        grid-template-areas:\n          'header header'\n          'toolbar toolbar'\n          'form sider'\n          'list sider';\n      }\n      .header {\n        grid-area: header;\n      }\n      .toolbar {\n        grid-area: toolbar;\n      }\n      .sider {\n        grid-area: sider;\n      }\n      .form {\n        grid-area: form;\n      }\n      .list {\n        grid-area: list;\n      }\n      .header,\n      .toolbar,\n      .sider,\n      .form,\n      .list {\n        border: 1px solid red;\n        overflow-y: auto;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"grid-container\">\n      <nav class=\"header\"></nav>\n      <header class=\"toolbar\"></header>\n      <section class=\"sider\"></section>\n      <section class=\"form\"></section>\n      <section class=\"list\"></section>\n    </div>\n  </body>\n</html>\n```\n\n但 grid 也并非尽善尽美，它仅对直接子组件生效，而孙子及其子节点则不在 `grid` 的布局范围，这导致为子组件编写 grid 布局样式时，仍然存在一些样板代码。\n\n```css\n/* 下面是典型的样板代码 */\n.grid-container {\n  height: 100%;\n  display: grid;\n}\n.header {\n  grid-area: header;\n}\n.toolbar {\n  grid-area: toolbar;\n}\n.sider {\n  grid-area: sider;\n}\n.form {\n  grid-area: form;\n}\n.list {\n  grid-area: list;\n}\n.header,\n.toolbar,\n.sider,\n.form,\n.list {\n  overflow-y: auto;\n}\n```\n\n## 使用 `css grid` 封装组件\n\n事实上，吾辈确实找到了一个现有的基于 grid 的 react 布局组件库 [react-grid-layout](https://github.com/STRML/react-grid-layout)，而且非常强大，但很遗憾的是它并 [不支持 react 17](https://github.com/STRML/react-grid-layout/issues/1329)。但其 api 及封装方式确实有参考意义，所以吾辈也尝试封装一个 `Grid` 组件。\n\n```tsx\ntype Unit = `${number}${'px' | 'fr'}`\n\ntype GridProps<\n  T extends string,\n  R extends Unit[] = Unit[],\n  C extends Unit[] = Unit[],\n  A extends { [P in keyof R]: { [P in keyof C]: T } } = {\n    [P in keyof R]: { [P in keyof C]: T }\n  },\n> = {\n  rows: R\n  cols: C\n  areas: A\n  children: ReactElement[]\n} & CommonStyleProps\n\n/**\n * 使用 grid 进行布局的容器组件\n */\nfunction Grid<T extends string>(props: GridProps<T>) {\n  return (\n    <div\n      className={props.className}\n      style={\n        {\n          height: '100%',\n          display: 'grid',\n          gridTemplateColumns: props.cols.join(' '),\n          gridTemplateRows: props.rows.join(' '),\n          gridTemplateAreas: props.areas\n            .map((row) => '\"' + row.join(' ') + '\"')\n            .join(' '),\n          ...props.style,\n        } as CSSProperties\n      }\n    >\n      {props.children.map((child) => {\n        console.log('child key: ', child.key)\n        return cloneElement(child, {\n          ...child.props,\n          style: {\n            gridArea: child.key,\n            border: 'solid 1px red',\n          } as CSSProperties,\n        })\n      })}\n    </div>\n  )\n}\n```\n\n使用起来比较简单，唯一残念的是子元素中的 key 无法使用 ts 自动推导或强制约束。\n\n```tsx\n<Grid<AreaItemName>\n  style={{\n    height: 'calc(100vh - 48px)',\n  }}\n  rows={['48px', '48px', '300px', '1fr']}\n  cols={['1fr', '300px']}\n  areas={[\n    ['header', 'header'],\n    ['toolbar', 'toolbar'],\n    ['form', 'sider'],\n    ['list', 'sider'],\n  ]}\n>\n  <header key={'header' as AreaItemName}>header</header>\n  <section key={'toolbar' as AreaItemName}>toolbar</section>\n  <section key={'sider' as AreaItemName}>sider</section>\n  <section key={'form' as AreaItemName}>form</section>\n  <section key={'list' as AreaItemName}>list</section>\n</Grid>\n```\n\n看起来不错，然而实际上这还是有缺陷的。\n\n1. 子组件必须处理了 `props.style`，因为 `cloneElement` 仅仅为原组件注入了属性（默认的 react html 元素均已处理）\n   1. 当布局的子组件需要监听滚动时，由于外层使用 div 在自定义组件外部，实际上并不能取到 ref，需要在业务组件再设置一次滚动。\n2. 类型约束未能完全生效，例如子元素的 key，就没办法做到类型自动推导限定\n3. 子组件内容过多时仍然会导致父元素出现滚动条\n\n接下来一个个解决\n\n### 1. 子组件必须处理了 `props.style`，因为 `cloneElement` 仅仅为原组件注入了属性（默认的 react html 元素均已处理）\n\n当需要为自定义的业务组件布局时，有两种思路\n\n1. 在外层套 `div`\n2. 由组件处理 `props.style`\n\n但这两种方式各有优劣\n\n前者父组件的布局不会受到子组件影响，意味着子组件更容易被复用。后者在子组件内部需要使用 ref 时，不需要再额外声明 css 以使之成为可滚动元素。\n\n下面是一个混合使用两者的的例子\n\n```tsx\nconst style: CSSProperties = { border: 'solid 1px red' }\ntype AreaItemName = 'header' | 'content' | 'sider'\n\nfunction Header() {\n  return <header style={style}>header</header>\n}\n\nfunction Content() {\n  return <main style={style}>content</main>\n}\n\nfunction Sider(props: CommonStyleProps) {\n  const $ref = useRef<HTMLElement>(null)\n  return wrapper(\n    <section style={style} ref={$ref}>\n      <ul>\n        {Array(100)\n          .fill(0)\n          .map((_, i) => (\n            <li key={i}>{i}</li>\n          ))}\n      </ul>\n      <BackTop target={() => $ref.current!}>\n        <ToTopOutlined\n          style={\n            {\n              fontSize: 24,\n              padding: 8,\n              borderRadius: '50%',\n              color: '#ffffff',\n              backgroundColor: '#8ECAFE',\n            } as CSSProperties\n          }\n        />\n      </BackTop>\n    </section>,\n    props,\n  )\n}\n\nreturn (\n  <Grid<AreaItemName>\n    style={{\n      height: 'calc(100vh - 48px)',\n    }}\n    rows={['48px', '1fr']}\n    cols={['1fr', '300px']}\n    areas={[['header', 'header']]}\n  >\n    <div key={'header' as AreaItemName}>\n      <Header />\n    </div>\n    <Content />\n    <Sider />\n  </Grid>\n)\n```\n\n### 2. 类型约束未能完全生效，例如子元素的 key，就没办法做到类型自动推导限定\n\n目前很难处理 `ReactElement` 类型，导致相关的类型自动推导特别麻烦，so...暂时没有好的办法。\n\n### 3. 子组件内容过多时仍然会导致父元素出现滚动条\n\n为子组件设置默认 `height/overflowY` 即可\n\n```tsx\nfunction Grid<T extends string>(props: GridProps<T>) {\n  const { cols = [], rows = [], areas = [], children } = props\n  return (\n    <div\n      className={props.className}\n      style={\n        {\n          height: '100%',\n          overflowY: 'auto',\n          display: 'grid',\n          gridTemplateColumns: cols.join(' '),\n          gridTemplateRows: rows.join(' '),\n          gridTemplateAreas: areas\n            .map((row) => '\"' + row.join(' ') + '\"')\n            .join(' '),\n          ...props.style,\n        } as CSSProperties\n      }\n    >\n      {children.map((child) => {\n        return cloneElement(child, {\n          ...child.props,\n          style: {\n            // 这里是关键\n            height: '100%',\n            overflowY: 'auto',\n            gridArea: child.key,\n            ...child.props.style,\n          } as CSSProperties,\n        })\n      })}\n    </div>\n  )\n}\n```\n\n## 总结\n\n老实说吾辈对现代前端的生态乱象表示很讨厌，尤其是 react 生态的 css 处理方案，仅 css-in-js 就有几十种可选方案，而官方又没有作为，导致没有统一的方式（vue 在这点上好很多）处理它们，所以吾辈才选择了 ui 组件 + css module 的方式。乍一看似乎回到了 HTML 标签控制样式的情况，但相比之下**组件**比 HTML 标签灵活得多，而且更容易扩展和组合（如果使用了 css 预处理器就是另外一回事了）。\n","createdTime":1606869930585,"updatedTime":1630307407698,"resources":[{"id":"d61642e05753427d98ad17a468eea52e","title":"布局.drawio.svg","file_extension":"svg","user_updated_time":1606870024033}],"tags":[{"id":"300027ec7dbd4dde992cecd230704041","title":"grid","parent_id":""},{"id":"5a7776c036cf46738cb6a729934a1a7b","title":"react","parent_id":""},{"id":"8f339224ff5c4b5aa4103e407b04ed0e","title":"css","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"932391b68ee84fd3aaa4585505224c2b","title":"基于 nodejs 的热更新 http 开发服务器","body":"## 场景\r\n\r\n之前一直在使用 [http-server](https://www.npmjs.com/package/http-server) 作为本地快速启动静态 http 服务器的命令行工具，然而直到今天，吾辈实在难以忍受其在修改完 `HTML` 文件后，http-server 不会自动刷新浏览器重新渲染页面，而是需要手动刷新才行，真的是不厌其烦，所以吾辈开始找更好的工具。\r\n\r\n> 注：http-server 其实也已经热更新到内存中了，只不过不会触发浏览器刷新页面。\r\n\r\n## 期望\r\n\r\n- [x] 零配置使用\r\n- [x] 修改文件保存后将自动触发浏览器刷新页面\r\n- [x] 基于 nodejs 开发\r\n- [ ] 允许特定的配置\r\n\r\n## 结果\r\n\r\n前端页面热更新\r\n\r\n- [live-server](https://www.npmjs.com/search?q=live-server): 自带热更新并启动即打开浏览器的 http 开发服务器\r\n- [anywhere](https://www.npmjs.com/package/anywhere): 与上面的 live-server 类似（由国人开发，已经一年没有更新了）\r\n\r\nnodejs 热更新\r\n\r\n- [chokidar-cli](https://www.npmjs.com/package/chokidar-cli): 文件修改后自动执行命令\r\n\r\nVSCode 插件\r\n\r\n- [LiveServer](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer): VSCode 中的插件，可以将任何一个 HTML 当作 web 程序打开，并自带热更新\r\n\r\n## live-server\r\n\r\n`live-server` 是一个 npm 包，全局安装之后可以很方便的使用，所以吾辈选择了这个。主要特点如下：\r\n\r\n- [x] 零配置\r\n- [x] 热插拔\r\n- [x] 自动打开浏览器\r\n\r\n下面来说一下如何使用\r\n\r\n1. 使用 npm 全局安装\r\n\r\n   ```sh\r\n   npm i -g live-server\r\n   ```\r\n\r\n2. 跳转到指定目录，然后使用 `live-server` 即可启动 http 服务器\r\n\r\n   ```sh\r\n   live-server\r\n   ```\r\n","createdTime":1580652938044,"updatedTime":1628140407145,"resources":[],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"8580a9e2317843ce8488213cd095e8e9","title":"前端使用工具强制实行代码规范（Vue）","body":"## 场景\r\n\r\n> [GitHub Demo](https://github.com/rxliuli/example/tree/master/linter_vue_example)\r\n\r\n非强制性的规范都不会成为真正的规范。在之前，我们也会在团队内编写一些开发规范文档，却总是不能真正有效的执行下去，原因何在？\r\n\r\n- 其一，人是健忘的，就算真正看完了规范文档，也不可能记住每一条规范，并且在代码中正确实践。\r\n- 其二，人是懒惰的，即便有着规范，但只要写代码的时候没有强制性，那总是不会在意的。\r\n\r\n那么，使用自动化的工具是为首选，而前端恰好有了一些可用的工具来帮助我们。\r\n\r\n## ESLint\r\n\r\nESLint 是一个对 JS 低级错误进行修复的工具，甚至于，现在连 TypeScript 官方也抛弃 TSLint 转向这个工具了，因为它的生态更大，实现的规则数量远远多于 TSLint，能把 JS 中的大部分低级错误检测出来，并能自动修复其中一部分。\r\n\r\n安装依赖\r\n\r\n```sh\r\nnpm i -D eslint babel-eslint eslint-plugin-vue @vue/cli-plugin-eslint\r\n```\r\n\r\n> 依赖解释\r\n>\r\n> - `eslint`: 本体包\r\n> - `babel-eslint`: eslint 与 babel 整合包\r\n> - `eslint-plugin-vue @vue/cli-plugin-eslint`: eslint 与 vue 整合包\r\n\r\n进行配置\r\n\r\n```js\r\n// .eslintrc.js\r\nmodule.exports = {\r\n  root: true,\r\n  //环境\r\n  env: {\r\n    browser: true,\r\n    commonjs: true,\r\n    es6: true,\r\n    node: true,\r\n  },\r\n  extends: [\r\n    //继承 vue 的标准特性\r\n    'plugin:vue/essential',\r\n    'eslint:recommended',\r\n  ],\r\n  rules: {\r\n    /**\r\n     * 禁止不需要的括号，例如 const i = (1 + 1)，但该规则存在的问题是会认为类两侧的圆括号也是不合法的\r\n     * 例如: billId => (StringValidator.isBlank(billId) ? '否' : '是')\r\n     */\r\n    // 'no-extra-parens': 'error',\r\n    /**\r\n     * 禁止魔法值，该规则的主要问题是很多误报\r\n     * 例如: offset / size + (offset % size === 0 ? 0 : 1)\r\n     */\r\n    'no-magic-numbers': 'off',\r\n\r\n    //禁止使用 var，强制要求使用 const/let\r\n    'no-var': 'error',\r\n    //不使用未定义的变量\r\n    'no-use-before-define': 'error',\r\n    //不允许在循环中使用 await，请使用 Promise.all\r\n    'no-await-in-loop': 'error',\r\n    //不允许使用 return await，直接返回 Promise 就好\r\n    'no-return-await': 'error',\r\n    //不允许使用 console 对象，因为会打印到控制台上\r\n    'no-console': 'error',\r\n    //使用 class 中的方法必须使用 this. 前缀\r\n    // 'class-methods-use-this': 'error',\r\n    //禁止使用 alert, confirm, prompt，该 API 会阻断所有其他操作，但该规则存在的问题是有可能需要之后用上方便统一调用呢？\r\n    'no-alert': 'error',\r\n    //禁止使用 eval，该操作是危险的\r\n    'no-eval': 'error',\r\n    'no-implied-eval': 'error',\r\n    //禁止使用 new Function 创建函数\r\n    'no-new-func': 'error',\r\n    //禁止使用包装类 String, Number, Boolean\r\n    'no-new-wrappers': 'error',\r\n    //禁止把语句作为计算结果返回，请使用两条语句\r\n    'no-return-assign': 'error',\r\n    //禁止使用不应该的 concat 连接，字符串请使用 + 连接，数组则可以使用 [...arr1, ...arr2]\r\n    'no-useless-concat': 'error',\r\n    //禁止 yoda 比较，不要用 1 === i 而是用 i === 1 更加自然\r\n    yoda: 'error',\r\n    //禁止没有用的三元运算符，就算是 ⑨ 也知道这样做有问题 answer === 1 ? true : false\r\n    'no-unneeded-ternary': 'error',\r\n    //禁止无用的计算属性 const obj = { ['1']: 1 }\r\n    'no-useless-computed-key': 'error',\r\n    //如果可以使用解构，那就进行警告，例如 const name = user.name 就应该被替换为 const { name } = user，避免了重复声明，也能进行默认赋值等操作\r\n    'prefer-destructuring': 'warn',\r\n    //使用 rest 不定参数代替全局变量 arguments\r\n    'prefer-rest-params': 'error',\r\n    //使用扩展运算符代替 apply 调用\r\n    'prefer-spread': 'error',\r\n    //使用 Symbol 必须使用描述说明它要做什么\r\n    'symbol-description': 'error',\r\n    //如果可以使用反射，那就是用反射调用，Reflect 代替 delete 关键字删除对象属性\r\n    'prefer-reflect': 'warn',\r\n  },\r\n  parserOptions: {\r\n    //使用 babel 解析语法\r\n    parser: 'babel-eslint',\r\n    //使用 es2017 的语法\r\n    ecmaVersion: 2017,\r\n  },\r\n};\r\n```\r\n\r\n如果有需要忽略的文件也可以在 _.eslintignore_ 文件中进行配置\r\n\r\n```ignore\r\n// .eslintignore\r\n`// 忽略掉 TypeScript 类型定义文件\r\n*/**/*.d.ts`\r\n```\r\n\r\n添加脚本\r\n\r\n```json\r\n// package.json\r\n{\r\n  // 其他配置。。。\r\n  \"scripts\": {\r\n    \"lint:js\": \"vue-cli-service lint\",\r\n    \"fix:js\": \"vue-cli-service lint --fix\"\r\n  }\r\n  // 其他配置。。。\r\n}\r\n```\r\n\r\n运行脚本\r\n\r\n```sh\r\nnpm run lint:js\r\n```\r\n\r\n现在，你可以检测到代码中的问题，并修复它了。\r\n\r\n相关链接\r\n\r\n- [ESLint 官网](https://eslint.org)\r\n- [vue eslint 整合包](https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-eslint)\r\n\r\n> WebStorm 配置 ESLint 即时检查:\r\n>\r\n> - ![WebStorm 使用 ESLint](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190926114439.png)\r\n> - 参考: <https://stackoverflow.com/questions/28808857>\r\n\r\n## StyleLint\r\n\r\n> 不建议使用，本身只是对 css 代码的排序，而且很多时候只提出问题但不负责解决问题（那么只有解决提出问题的工具了 xd），或许使用 postcss 是个更好的选择。\r\n\r\nStyleLint 是一个用来对 CSS 进行校验/修复的工具，和 ESLint 类似，但却针对 CSS 方面。我们使用它用来避免一些不好的 CSS 写法，也能避免 code review 时被其他人吐槽。。。\r\n\r\n安装依赖\r\n\r\n```sh\r\nnpm i -D stylelint stylelint-config-standard stylelint-order stylelint-scss\r\n```\r\n\r\n> 依赖解释\r\n>\r\n> - `stylelint`: 本体包\r\n> - `stylelint-config-standard`: stylelint 标准配置\r\n> - `stylelint-scss`: stylelint scss 支持插件包\r\n> - `stylelint-order`: stylelint 属性排序插件\r\n\r\n进行配置\r\n\r\n```js\r\n// stylelint.config.js\r\nmodule.exports = {\r\n  plugins: ['stylelint-scss', 'stylelint-order'],\r\n  extends: ['stylelint-config-standard'],\r\n  rules: {\r\n    /**\r\n     * 关键问题在于是否要忽略空检查\r\n     * 下面两种都会被判断为错误\r\n     * <style lang=\"scss\" scoped></style>\r\n     * a {}\r\n     * 上面一种是很常见的\r\n     */\r\n    // 'no-empty-source': null,\r\n    //禁止注释两侧出现空白（IDEA 默认就没有空白）\r\n    'comment-whitespace-inside': 'never',\r\n    //scss 的特定符号将被 css 检查时忽略而在 scss 检查时才会生效\r\n    'at-rule-no-unknown': null,\r\n    'scss/at-rule-no-unknown': true,\r\n    //CSS 声明定义顺序，自定义 class 放在默认元素上面\r\n    'order/order': ['custom-properties', 'declarations'],\r\n    /**\r\n     * CSS 属性顺序\r\n     * 1. 控制外部属性\r\n     * 2. 盒模型\r\n     * 3. 视觉\r\n     * 4. 其他\r\n     * 5. 未定义\r\n     */\r\n    'order/properties-order': [\r\n      [\r\n        //指令\r\n        'composes',\r\n        '@import',\r\n        '@extend',\r\n        '@mixin',\r\n        '@at-root',\r\n        //盒模型相关\r\n        'display',\r\n        'flex',\r\n        'flex-basis',\r\n        'flex-direction',\r\n        'flex-flow',\r\n        'flex-grow',\r\n        'flex-shrink',\r\n        'flex-wrap',\r\n        'grid',\r\n        'grid-area',\r\n        'grid-auto-rows',\r\n        'grid-auto-columns',\r\n        'grid-auto-flow',\r\n        'grid-gap',\r\n        'grid-row',\r\n        'grid-row-start',\r\n        'grid-row-end',\r\n        'grid-row-gap',\r\n        'grid-column',\r\n        'grid-column-start',\r\n        'grid-column-end',\r\n        'grid-column-gap',\r\n        'grid-template',\r\n        'grid-template-areas',\r\n        'grid-template-rows',\r\n        'grid-template-columns',\r\n        'gap',\r\n        'align-content',\r\n        'align-items',\r\n        'align-self',\r\n        'justify-content',\r\n        'justify-items',\r\n        'justify-self',\r\n        'order',\r\n        'float',\r\n        'clear',\r\n        'box-sizing',\r\n        'width',\r\n        'min-width',\r\n        'max-width',\r\n        'height',\r\n        'min-height',\r\n        'max-height',\r\n        'margin',\r\n        'margin-top',\r\n        'margin-right',\r\n        'margin-bottom',\r\n        'margin-left',\r\n        'padding',\r\n        'padding-top',\r\n        'padding-right',\r\n        'padding-bottom',\r\n        'padding-left',\r\n        //定位相关\r\n        'position',\r\n        'top',\r\n        'right',\r\n        'bottom',\r\n        'left',\r\n        'z-index',\r\n        //边框\r\n        'border',\r\n        'border-color',\r\n        'border-style',\r\n        'border-width',\r\n        'border-top',\r\n        'border-top-color',\r\n        'border-top-width',\r\n        'border-top-style',\r\n        'border-right',\r\n        'border-right-color',\r\n        'border-right-width',\r\n        'border-right-style',\r\n        'border-bottom',\r\n        'border-bottom-color',\r\n        'border-bottom-width',\r\n        'border-bottom-style',\r\n        'border-left',\r\n        'border-left-color',\r\n        'border-left-width',\r\n        'border-left-style',\r\n        'border-radius',\r\n        'border-top-left-radius',\r\n        'border-top-right-radius',\r\n        'border-bottom-right-radius',\r\n        'border-bottom-left-radius',\r\n        'border-image',\r\n        'border-image-source',\r\n        'border-image-slice',\r\n        'border-image-width',\r\n        'border-image-outset',\r\n        'border-image-repeat',\r\n        'border-collapse',\r\n        'border-spacing',\r\n        //溢出\r\n        'object-fit',\r\n        'object-position',\r\n        'overflow',\r\n        'overflow-x',\r\n        'overflow-y',\r\n        //版式\r\n        'color',\r\n        'font',\r\n        'font-weight',\r\n        'font-size',\r\n        'font-family',\r\n        'font-style',\r\n        'font-variant',\r\n        'font-size-adjust',\r\n        'font-stretch',\r\n        'font-effect',\r\n        'font-emphasize',\r\n        'font-emphasize-position',\r\n        'font-emphasize-style',\r\n        'font-smooth',\r\n        'line-height',\r\n        'direction',\r\n        'letter-spacing',\r\n        'white-space',\r\n        'text-align',\r\n        'text-align-last',\r\n        'text-transform',\r\n        'text-decoration',\r\n        'text-emphasis',\r\n        'text-emphasis-color',\r\n        'text-emphasis-style',\r\n        'text-emphasis-position',\r\n        'text-indent',\r\n        'text-justify',\r\n        'text-outline',\r\n        'text-wrap',\r\n        'text-overflow',\r\n        'text-overflow-ellipsis',\r\n        'text-overflow-mode',\r\n        'text-orientation',\r\n        'text-shadow',\r\n        'vertical-align',\r\n        'word-wrap',\r\n        'word-break',\r\n        'word-spacing',\r\n        'overflow-wrap',\r\n        'tab-size',\r\n        'hyphens',\r\n        'unicode-bidi',\r\n        'columns',\r\n        'column-count',\r\n        'column-fill',\r\n        'column-gap',\r\n        'column-rule',\r\n        'column-rule-color',\r\n        'column-rule-style',\r\n        'column-rule-width',\r\n        'column-span',\r\n        'column-width',\r\n        'page-break-after',\r\n        'page-break-before',\r\n        'page-break-inside',\r\n        'src',\r\n        //视觉\r\n        'list-style',\r\n        'list-style-position',\r\n        'list-style-type',\r\n        'list-style-image',\r\n        'table-layout',\r\n        'empty-cells',\r\n        'caption-side',\r\n        'background',\r\n        'background-color',\r\n        'background-image',\r\n        'background-repeat',\r\n        'background-position',\r\n        'background-position-x',\r\n        'background-position-y',\r\n        'background-size',\r\n        'background-clip',\r\n        'background-origin',\r\n        'background-attachment',\r\n        'background-blend-mode',\r\n        //动画\r\n        'transition',\r\n        'transition-delay',\r\n        'transition-timing-function',\r\n        'transition-duration',\r\n        'transition-property',\r\n        'animation',\r\n        'animation-name',\r\n        'animation-duration',\r\n        'animation-play-state',\r\n        'animation-timing-function',\r\n        'animation-delay',\r\n        'animation-iteration-count',\r\n        'animation-direction',\r\n        'animation-fill-mode',\r\n        //其他\r\n        'appearance',\r\n        'content',\r\n        'clip',\r\n        'clip-path',\r\n        'counter-reset',\r\n        'counter-increment',\r\n        'resize',\r\n        'user-select',\r\n        'nav-index',\r\n        'nav-up',\r\n        'nav-right',\r\n        'nav-down',\r\n        'nav-left',\r\n        'pointer-events',\r\n        'quotes',\r\n        'touch-action',\r\n        'will-change',\r\n        'zoom',\r\n        'fill',\r\n        'fill-rule',\r\n        'clip-rule',\r\n        'stroke',\r\n      ],\r\n      {\r\n        unspecified: 'bottom',\r\n      },\r\n    ],\r\n    //CSS 属性值顺序\r\n    // 'order/properties-alphabetical-order': [],\r\n  },\r\n};\r\n```\r\n\r\n添加脚本\r\n\r\n```json\r\n// package.json\r\n{\r\n  // 其他配置。。。\r\n  \"scripts\": {\r\n    \"lint:css\": \"stylelint src/**/*.{vue,html,css,scss,sass}\",\r\n    \"fix:css\": \"stylelint --fix src/**/*.{vue,html,css,scss,sass}\"\r\n  }\r\n  // 其他配置。。。\r\n}\r\n```\r\n\r\n运行脚本\r\n\r\n```sh\r\nnpm run lint:css\r\n```\r\n\r\n相关链接\r\n\r\n- [StyleLint 官网](https://stylelint.io/)\r\n- [如何在 WebStorm 中使用 StyleLint 自动修复](https://stackoverflow.com/questions/54304313/stylelint-fix-in-webstorm)\r\n\r\n> WebStorm 使用 WebStorm 配置 StyleLint 即时检查: ![WebStorm 配置即时检查](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190926113520.png) 参考 <https://stackoverflow.com/questions/54304313/>\r\n>\r\n> 添加外部工具以进行快速修复 ![添加外部工具以进行快速修复](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190926113953.png) 然后添加一个快捷键即可\r\n\r\n## Prettier\r\n\r\nPrettier 是一个代码格式化工具，但并非针对一种语言，对 `HTML/CSS/JavaScript/Vue/SCSS` 都有效果。可以通过配置文件在不同项目间统一代码格式化，以修正不同编辑器/IDE 之间格式化不同的问题。\r\n\r\n安装依赖\r\n\r\n```sh\r\nnpm i -D prettier eslint-plugin-prettier eslint-config-prettier prettier-eslint-cli stylelint-config-prettier stylelint-prettier\r\n```\r\n\r\n> 依赖解释\r\n>\r\n> - `prettier`: 本体包\r\n> - `eslint-plugin-prettier eslint-config-prettier prettier-eslint-cli`: prettier 与 eslint 整合包\r\n> - `stylelint-config-prettier stylelint-prettier`: prettier 与 stylelint 整合包\r\n\r\n进行配置\r\n\r\n```js\r\n// .prettierrc.js\r\nmodule.exports = {\r\n  // 缩进宽度\r\n  tabWidth: 4,\r\n  // 单行最大宽度\r\n  printWidth: 120,\r\n  // 去掉代码结尾的分号\r\n  semi: false,\r\n  // 使用单引号替代双引号\r\n  singleQuote: true,\r\n  // 尽量在所有地方都添加尾逗号\r\n  trailingComma: 'all',\r\n  // 换行符\r\n  endOfLine: 'crlf',\r\n};\r\n```\r\n\r\n还需要修改 eslint 与 stylelint 的一些配置\r\n\r\n```js\r\n// .eslintrc.js\r\nmodule.exports = {\r\n  // 其他配置。。。\r\n  extends: [\r\n    //继承 vue 的标准特性\r\n    'plugin:vue/essential',\r\n    'eslint:recommended',\r\n    //避免与 prettier 冲突\r\n    'plugin:prettier/recommended',\r\n  ],\r\n  // 其他配置。。。\r\n};\r\n```\r\n\r\n```js\r\n// stylelint.config.js\r\nmodule.exports = {\r\n  // 其他配置。。。\r\n  extends: ['stylelint-config-standard', 'stylelint-config-prettier'],\r\n  // 其他配置。。。\r\n};\r\n```\r\n\r\n添加脚本\r\n\r\n```json\r\n// package.json\r\n{\r\n  // 其他配置。。。\r\n  \"scripts\": {\r\n    \"format\": \"prettier-eslint --write \\\"src/**/*.{js,vue,html,scss,css}\\\"\"\r\n  }\r\n  // 其他配置。。。\r\n}\r\n```\r\n\r\n运行脚本\r\n\r\n```sh\r\nnpm run format\r\n```\r\n\r\n相关链接\r\n\r\n- [prettier 官网](https://prettier.io)\r\n- [WebStorm 使用 Prettier 官方文档](https://www.jetbrains.com/help/webstorm/prettier.html)\r\n\r\n> WebStorm 配置使用 Prettier 快速格式化: ![WebStorm 配置使用 Prettier 快速格式化](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190926115309.png) 建议修改为全局使用 Prettier 格式化，避免记忆两个格式化快捷键\r\n\r\n## husky 与 lint-staged\r\n\r\n强制使用 linter 检查代码，不通过检查则无法提交代码，以使 linter 真正得到有效执行。\r\n\r\n安装依赖\r\n\r\n```sh\r\nnpm i -D husky lint-staged\r\n```\r\n\r\n> 依赖解释\r\n>\r\n> - `husky`: 在项目中添加 git 钩子，在 git 各个生命周期（姑且这样称呼吧）中执行一些自定义操作。我们这里主要是用在 git 提交之前执行 linter 操作，不通过则提交无效。\r\n> - `lint-staged`: 简而言之，就是只针对 git 提交的文件进行一些操作，而非整个项目的所有文件。我们这里主要是用在 git 提交之前进行 linter 时只针对提交的文件，以进行渐进式的重构。\r\n\r\n进行配置\r\n\r\n```js\r\n// .huskyrc.js\r\nmodule.exports = {\r\n  hooks: {\r\n    // git commit 前的钩子\r\n    'pre-commit': 'lint-staged',\r\n    // 修复 IDEA 的一些奇怪问题 <https://youtrack.jetbrains.com/issue/IDEA-135454>\r\n    'post-commit': 'git update-index --again',\r\n  },\r\n};\r\n```\r\n\r\n```js\r\n// lint-staged.config.js\r\nmodule.exports = {\r\n  'src/**/*.{js,vue}': ['eslint --fix', 'git add'],\r\n  'src/**/*.{vue,html,css,scss,sass}': ['stylelint --fix', 'git add'],\r\n  'src/**/*.{js,vue,html,css,scss,sass}': ['prettier-eslint --write', 'git add'],\r\n};\r\n```\r\n\r\n> 有人说 **lint-staged** 并行运行多个命令可能会有问题，因为 nodejs 本身在写入文件时不会加锁，导致多线程下可能存在问题（吾辈目前还没遇到过.JPG）\r\n\r\n之后，在我们使用 `git commit` 时就会触发 lint 操作了！\r\n\r\n相关链接\r\n\r\n- [husky GitHub](https://github.com/typicode/husky)\r\n\r\n## 总结\r\n\r\n基本上，这些工具初次配置起来还是非常麻烦的，但这是一件一劳永逸的事情，所以还是值得花时间去做的。\r\n\r\n> 注: 目前还存在的问题是: ESLint 检测出来的部分错误能使用 **A-Enter** 修复 Prettier 与 WebStorm 自身格式化不能共存（自动切换） Prettier 在 WebStorm 中无法直接配置导致上面问题存在的必要性 StyleLint 不能使用 **A-Enter** 修复且不能与 WebStorm 共存可能的解决方案是找一下是否有一种方式能够让 WebStorm 一个快捷键执行多条命令，或者，写一个可用的插件。\r\n\r\n> 参考\r\n>\r\n> - [eslint+husky+prettier+lint-staged 提升前端应用质量](https://juejin.im/post/5c67fcaae51d457fcb4078c9)\r\n","createdTime":1580652937919,"updatedTime":1628075628245,"resources":[],"tags":[{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"d86454b85c8f4c38aef6fa1575487e7f","title":"vue","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"d984e195f1b1469ca49ff364374ce3d8","title":"关于前端组件通信的一些理解","body":"## 场景\n\n> 吾辈同时是 vue/react 的使用者。\n\n在使用现代前端框架时，我们经常要要面对的问题之一就是组件之间的通信，目前我们有着很多选择，包括但不限于以下这些。\n\n- `Super Component Props`: 将状态或操作放在父组件，然后传递到子组件。该特性在 vue/react 都存在\n- `Context/Provider Pattern`: 将状态放在父组件，然后所有的子组件都可以获取到。例如 react 中的 context 或 vue 中的 `provide/inject`\n- `Global State`: 全局状态管理器。包含 redux/vuex/mobx/xstate 等一系列状态管理器。\n- `EventEmitter`: 全局事件触发器。包含 nodejs 和一些第三方实现。\n\n然而，有了如此多的解决方案，到底该在那些场景下使用那些解决方案呢？\n\n## 分类\n\n首先，我们将以上组件通信的解决方案分为两类\n\n| 解决方案                   | 是否在 react 生命周期中 |\n| -------------------------- | ----------------------- |\n| `Super Component Props`    | √                       |\n| `Context/Provider Pattern` | √                       |\n| `Global Store`             | ×                       |\n| `EventEmitter`             | ×                       |\n\n![状态管理选择树.drawio.svg](:/4fc5f8a2c4ff4cfd9257233cc4a8c5ae)\n\n\n### `Super Component Props`\n\n> 适合简单的父子组件通信。参考: [组件 & Props](https://zh-hans.reactjs.org/docs/components-and-props.html)\n\n为什么 `props` 适合简单的父子通信呢？因为 `props` 是框架中基础的父子组件通信方式，模板代码也是最少的。\n\n下面是一个简单的示例：将一个组件内输入框的值渲染到另一个组件中。\n\n![最终效果](https://img.rxliuli.com/20200818203510.png)\n\n```tsx\nconst Hello: React.FC<{ name: string }> = (props) => {\n  return (\n    <section>\n      <h3>hello {props.name}</h3>\n    </section>\n  );\n};\n\nconst InputName: React.FC<Pick<InputHTMLAttributes<HTMLInputElement>, 'value' | 'onChange'>> = (\n  props\n) => {\n  return <input {...props} />;\n};\n\nconst App = () => {\n  const [name, setName] = useState('');\n  return (\n    <div>\n      <InputName value={name} onChange={(e) => setName(e.target.value)} />\n      <Hello name={name} />\n    </div>\n  );\n};\n```\n\n如题，对于这种简单的父子组件传值，使用 props 是最简单合适的。\n\n下面演示使用其他几种方式的实现\n\n---\n\n使用 context\n\n```tsx\nconst HelloContext = React.createContext<{\n  name: string;\n  setName: (name: string) => void;\n}>({\n  name: '',\n  setName: () => {},\n});\n\nconst Hello: React.FC = () => {\n  // 模板代码\n  const context = useContext(HelloContext);\n  return (\n    <section>\n      <h3>hello {context.name}</h3>\n    </section>\n  );\n};\n\nconst InputName: React.FC = () => {\n  // 模板代码\n  const context = useContext(HelloContext);\n  return <input name={context.name} onChange={(e) => context.setName(e.target.value)} />;\n};\n\nconst App = () => {\n  const [name, setName] = useState('');\n  return (\n    <HelloContext.Provider value={{ name, setName }}>\n      <InputName />\n      <Hello />\n    </HelloContext.Provider>\n  );\n};\n```\n\n可以看到，加的 context 能被深层子组件读取的优势并未体现出来，反而多了一些模板代码。\n\n---\n\n使用 global state，此处使用 mobx 进行演示\n\n```tsx\n// 模板代码\nclass HelloStore {\n  @observable\n  name = '';\n  @action\n  setName(name: string) {\n    this.name = name;\n  }\n}\n\nconst helloStore = new HelloStore();\n\nconst Hello: React.FC = observer(() => {\n  return (\n    <section>\n      <h3>hello {helloStore.name}</h3>\n    </section>\n  );\n});\n\nconst InputName: React.FC = observer(() => {\n  return <input name={helloStore.name} onChange={(e) => helloStore.setName(e.target.value)} />;\n});\n\nconst App = () => {\n  // 模板代码\n  useMount(() => {\n    helloStore.setName('');\n  });\n  return (\n    <div>\n      <InputName />\n      <Hello />\n    </div>\n  );\n};\n```\n\n可以看到，store 是全局可用的，但也需要在相应组件内做初始化动作，而非像 props/context 那样受组件生命周期控制，自动的初始化和销毁状态。\n\n---\n\n```tsx\nconst em = new EventEmitter<{\n  update: [string];\n}>();\n\nconst Hello: React.FC = () => {\n  // 模板代码\n  const [name, setName] = useState('');\n  // 模板代码\n  useEffectOnce(() => {\n    em.add('update', setName);\n    return () => {\n      em.remove('update', setName);\n    };\n  });\n  return (\n    <section>\n      <h3>hello {name}</h3>\n    </section>\n  );\n};\n\nconst InputName: React.FC = () => {\n  // 模板代码\n  const [name, setName] = useState('');\n  function handleChange(e: ChangeEvent<HTMLInputElement>) {\n    const value = e.target.value;\n    setName(value);\n    // 模板代码\n    em.emit('update', value);\n  }\n  return <input name={name} onChange={handleChange} />;\n};\n\nconst App = () => {\n  return (\n    <div>\n      <InputName />\n      <Hello />\n    </div>\n  );\n};\n```\n\n可以看到，emitter 可以在不改变原有组件(`InputName`)的情况下在新的组件添加相关的逻辑，但确实会多一些模板代码，且需要维护两次状态。\n\n### `Context/Provider Pattern`\n\n> 适合深层的父组件共享状态给多个子组件，有时候会结合 `EventEmitter` 一起使用。\n\n为什么我们有了 props，甚至有了更强大的 `render props`（vue 中被称为 `slot`），却还是需要 context 呢？\n\n考虑以下场景，我们想要为一颗组件树的所有组件添加一些全局特性，例如 `theme`、`local`、`全局配色`，而你使用这些状态的组件又分散在各个地方时，便可以考虑使用 context。相比于全局状态，context 仅与框架而非状态管理库绑定，这对于第三方库（尤其是 UI 组件库）是大有益处的，例如 [rc-field-form](https://github.com/react-component/field-form) 和 [react-router](https://github.com/ReactTraining/react-router) 均有如此实现。理论上，当我们需要状态共享但 props 又不需要在组件外操作状态时，就应该首先选择 context。\n\n下面是一个简单的示例来说明使用 context 实现全局的 theme 控制。\n\n```tsx\ntype ThemeContextType = {\n  color: 'light' | 'black';\n};\nconst ThemeContext = React.createContext<ThemeContextType>({\n  color: 'light',\n});\nconst Theme = ThemeContext.Provider;\n\nconst Button: React.FC = (props) => {\n  const context = useContext(ThemeContext);\n  return (\n    <button className={context.color !== 'black' ? 'light' : 'black'}>{props.children}</button>\n  );\n};\nconst Tag: React.FC = (props) => {\n  const context = useContext(ThemeContext);\n  return <span className={context.color !== 'black' ? 'light' : 'black'}>{props.children}</span>;\n};\nconst App = () => {\n  return (\n    <Theme value={{ color: 'black' }}>\n      <Button>按钮</Button>\n      <Tag>标签</Tag>\n    </Theme>\n  );\n};\n```\n\n问题\n\n- 仅限于同一个父组件树下的两个子组件共享状态，当然你也可以说所有的组件都只有**单根**。\n- 无法在组件外部使用，这点是致命的，例如路由 `history` 对象弹窗无法在逻辑层使用是不可接受的（需要在请求接口报 404 时跳转登录页面）。\n- 使用时的模板代码要稍微更多一点，相比与 mobx 的话。\n\n### `Global Store`\n\n> 适合在组件树上相隔较远的组件/组件外共享状态和逻辑使用。\n\n那么，继续来看以下场景，当我们需要在多个组件/组件外共享状态时，例如当前登录的用户信息，便应该优先考虑使用状态管理器。\n\n```tsx\ninterface UserInfo {\n  id: string;\n  username: string;\n  nickname: string;\n}\nclass UserStore {\n  @observable\n  userInfo?: UserInfo;\n  refresh(userInfo: UserInfo) {\n    this.userInfo = userInfo;\n  }\n}\n\nconst userStore = new UserStore();\n\nasync function post<T>(url: string, data: object) {\n  const response = await fetch(url, {\n    method: 'post',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      client: {\n        //在组件外使用用户信息\n        uid: userStore.userInfo?.id,\n      },\n      data: data,\n    }),\n  });\n  return (await response.json()) as T;\n}\n\ntype UserInfoForm = { username: string; password: string };\nconst Login: React.FC = () => {\n  const [form, dispatchForm] = useReducer<\n    Reducer<UserInfoForm, { name: keyof UserInfoForm; value: string }>\n  >(\n    (state, action) => {\n      return {\n        ...state,\n        [action.name]: action.value,\n      };\n    },\n    { username: '', password: '' }\n  );\n  async function handleSubmit(e: FormEvent<HTMLFormElement>) {\n    e.preventDefault();\n    console.log('handleSubmit: ', form);\n    //登录时刷新用户信息\n    const userInfo = await post<UserInfo>('/login', form);\n    userStore.refresh(userInfo);\n  }\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label htmlFor={'username'}>用户名：</label>\n        <input\n          name={'username'}\n          value={form.username}\n          onChange={(e) =>\n            dispatchForm({\n              name: 'username',\n              value: e.target.value,\n            })\n          }\n        />\n      </div>\n      <div>\n        <label htmlFor={'password'}>密码：</label>\n        <input\n          name={'password'}\n          type={'password'}\n          value={form.password}\n          onChange={(e) =>\n            dispatchForm({\n              name: 'password',\n              value: e.target.value,\n            })\n          }\n        />\n      </div>\n      <div>\n        <button type={'submit'}>提交</button>\n      </div>\n    </form>\n  );\n};\nconst App = observer(() => {\n  return (\n    <div>\n      {/*在组件中使用 store 的值*/}\n      <header>{userStore.userInfo?.nickname}</header>\n    </div>\n  );\n});\n```\n\n问题\n\n- 需要自己管理状态的初始化与清理，不跟随组件的生命周期进行变化。\n- 全局状态是混乱的根源，过度使用害人害己\n- 无论何时都存在，占用额外的内存资源\n\n### `EventEmitter`\n\n> 适合用于逻辑层的状态通信或是组件之间的监听/通知操作，不修改组件状态存储的结构，无法复用状态。\n\n在不想改变组件状态/操作的代码结构而仅仅只是想要简单的通信时，EventEmitter 是一种合适的方式。设想以下场景，当你已经写完了一个复杂的组件，而突然 UI/UX 又在另一个相隔很远的地方添加了另一个相关的组件并且需要通信时，在你不想对原组件大刀阔斧的改动时，那么 EventEmitter 是一个合适的选择。\n\n例如下面这段代码，假设你已经写完了复杂的 MainContent 组件（当然下面代码中的 MainContent 并不算复杂），但后来需求变化，想在 Header 组件中添加一个刷新按钮，而不希望变更代码状态结构的时候，便可以尝试使用 EventEmitter 了。\n\n```tsx\n/**\n * 随机数生成器（从 0 开始，不包含最大值）\n * 线性同余生成器\n * @link 网上常能见到的一段 JS 随机数生成算法如下，为什么用 9301, 49297, 233280 这三个数字做基数？ - 猫杀的回答 - 知乎\n https://www.zhihu.com/question/22818104/answer/22744803\n */\nexport const rand = (function () {\n  let seed = Date.now();\n  function rnd() {\n    seed = (seed * 9301 + 49297) % 233280.0;\n    return seed / 233280.0;\n  }\n  return function rand(num: number) {\n    return Math.floor(rnd() * num);\n  };\n})();\n\nconst Header: React.FC = () => {\n  return (\n    <header>\n      <h2>标题</h2>\n    </header>\n  );\n};\nconst MainContent: React.FC = () => {\n  const [list, setList] = useState<number[]>([]);\n  function load() {\n    setList(\n      Array(10)\n        .fill(0)\n        .map(() => rand(100))\n    );\n  }\n  useMount(() => {\n    load();\n  });\n  return (\n    <section>\n      <ul>\n        {list.map((i) => (\n          <li key={i}>{i}</li>\n        ))}\n      </ul>\n    </section>\n  );\n};\nconst App = () => {\n  return (\n    <div>\n      <Header />\n      <MainContent />\n    </div>\n  );\n};\n```\n\n使用 EventEmitter 进行通知，其中的 useEventEmitter hooks 来源于 [使用 React Context 结合 EventEmitter](:/3b1502f22ad645b5a6521b39b145e560)。\n\n```tsx\ntype RefreshEmitterType = { refresh: [] };\nconst Header: React.FC = () => {\n  const { emit } = useEventEmitter<RefreshEmitterType>();\n  return (\n    <header>\n      <h2>标题</h2>\n      {/*不同，添加触发操作*/}\n      <button onClick={() => emit('refresh')}>刷新</button>\n    </header>\n  );\n};\nconst MainContent: React.FC = () => {\n  const [list, setList] = useState<number[]>([]);\n  const load = useCallback(() => {\n    setList(\n      Array(10)\n        .fill(0)\n        .map(() => rand(100))\n    );\n  }, []);\n  useMount(load);\n  //不同，添加监听\n  const { useListener } = useEventEmitter<RefreshEmitterType>();\n  useListener('refresh', load);\n  return (\n    <section>\n      <ul>\n        {list.map((v, i) => (\n          <li key={i}>{v}</li>\n        ))}\n      </ul>\n    </section>\n  );\n};\nconst App = () => {\n  return (\n    //不同\n    <EventEmitterRC>\n      <Header />\n      <MainContent />\n    </EventEmitterRC>\n  );\n};\n```\n\n问题\n\n- 需要自己管理事件的注册和清理，不跟随特定组件的生命周期变化。\n- 无论何时都存在，占用额外的内存资源（但相比于全局状态占用的仍然是非常低的）\n- 使用不当可能导致多个组件由重复的状态\n\n## 结论\n\n一种解决方案的劣势可能是另一种方案的优势，总是要选择合适的方案才是最好的。\n","createdTime":1596307420261,"updatedTime":1627979110022,"resources":[{"id":"4fc5f8a2c4ff4cfd9257233cc4a8c5ae","title":"状态管理选择树.drawio.svg","file_extension":"svg","user_updated_time":1627979098805}],"tags":[{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"7fc05ef7c1274b168504c216a6774ea6","title":"为 i18next json 配置文件生成 dts 类型定义","body":"## 场景\r\n\r\n吾辈有一些项目需要使用 i18next 来处理国际化，但是使用 typescript 需要有类型定义，所以之前在 [joplin-utils](https://github.com/rxliuli/joplin-utils) 项目中维护和使用。昨天做了很多重构，现在已经分离出来并作为公共 npm 包发布。如果有人感兴趣，可以尝试一下。\r\n\r\n> [English](https://liuli-tools.rxliuli.com/tools/i18next-dts-gen/), [简体中文](https://liuli-tools.rxliuli.com/zh/tools/i18next-dts-gen/)\r\n\r\n## 简介\r\n\r\ni18next 的 typescript 类型定义生成器，可以从多个语言翻译 json 文件中生成类型定义，支持嵌套对象与参数。\r\n\r\n## 使用\r\n\r\n> 这个 cli 本身国际化配置的类型定义生成也是由 cli 完成的（自举）\r\n\r\n```shell\r\ni18next-dts-gen --dirs src/i18n # 扫描这个目录下的 json 文件并生成 index.d.ts 类型定义\r\n```\r\n\r\n详情\r\n\r\n```shell\r\n$ i18next-dts-gen -h\r\nUsage: bin [options]\r\n\r\n根据 json 生成 .d.ts 类型定义\r\n\r\nOptions:\r\n  -i, --dirs <dirs...>  包含一或多个翻译文件的目录\r\n  -w, --watch             是否使用监视模式\r\n  -h, --help              display help for command\r\n```\r\n\r\n## 代码\r\n\r\n下面是在 nodejs 中使用\r\n\r\n```ts\r\n// src/util/I18nextUtil.ts\r\nimport i18next from 'i18next'\r\n\r\nexport enum LanguageEnum {\r\n  En = 'en',\r\n  ZhCN = 'zhCN',\r\n}\r\n\r\nexport class I18nextUtil<\r\n  T extends Record<\r\n    string,\r\n    {\r\n      params: [key: string] | [key: string, params: object]\r\n      value: string\r\n    }\r\n  >,\r\n> {\r\n  constructor() {}\r\n\r\n  async changeLang(lang: LanguageEnum) {\r\n    await i18next.changeLanguage(lang)\r\n  }\r\n\r\n  /**\r\n   * 加载国际化\r\n   */\r\n  async init(resources: Record<LanguageEnum, object>, language: LanguageEnum) {\r\n    await i18next.init({\r\n      lng: language,\r\n      resources: Object.entries(resources).reduce((res, [k, v]) => {\r\n        Reflect.set(res, k, {\r\n          translation: v,\r\n        })\r\n        return res\r\n      }, {}),\r\n      keySeparator: false,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 根据 key 获取翻译的文本\r\n   * @param args\r\n   */\r\n  t<K extends keyof T>(...args: T[K]['params']): T[K]['value'] {\r\n    // @ts-ignore\r\n    return i18next.t(args[0], args[1])\r\n  }\r\n}\r\n```\r\n\r\n```ts\r\n// src/constants/i18n.ts\r\nimport { TranslateType } from '../i18n'\r\nimport osLocale from 'os-locale'\r\nimport { I18nextUtil, LanguageEnum } from '../util/I18nextUtil'\r\n\r\nexport async function getLanguage(): Promise<LanguageEnum> {\r\n  const language = await osLocale()\r\n  /**\r\n   * os-locale => i18next 的语言类型字符串映射\r\n   */\r\n  const map: Record<string, LanguageEnum> = {\r\n    'zh-CN': LanguageEnum.ZhCN,\r\n    'en-US': LanguageEnum.En,\r\n  }\r\n  return map[language] || LanguageEnum.En\r\n}\r\n\r\nexport const i18n = new I18nextUtil<TranslateType>()\r\n```\r\n\r\n```ts\r\n// src/bin.ts\r\nasync function main() {\r\n  await i18n.init({ en, zhCN }, await getLanguage())\r\n  console.log(i18n.t('hello', { name: 'liuli' }))\r\n}\r\n```\r\n\r\n或者在浏览器中\r\n\r\n```tsx\r\n// App.tsx\r\nfunction getLanguage() {\r\n  return navigator.language.startsWith('zh')\r\n    ? LanguageEnum.ZhCN\r\n    : LanguageEnum.En\r\n}\r\n\r\nexport const App: React.FC<AppProps> = () => {\r\n  useMount(async () => {\r\n    await i18n.init({ en, zhCN }, getLanguage())\r\n    // 然后再做其它的事情，例如加载路由\r\n  })\r\n\r\n  return <div />\r\n}\r\n```\r\n\r\n当然，如果你需要在其他环境中使用，应该仅需实现对应的 `getLanguage` 函数即可。\r\n\r\n## 技巧\r\n\r\n提示\r\n\r\n![prompt](:/e4b7c0ed2d1b445b8309839cd041cf36)\r\n\r\n导航\r\n\r\n![navigation](:/86cc0f02cb594abebe57ba79c8d46f72)\r\n\r\n搜索和替换\r\n\r\n![searchAndReplace](:/990fd29f95134939a6f4bcf1670d20f4)\r\n\r\n## 动机\r\n\r\n为什么已经有了很多第三方的类型定义生成器，甚至最新版 i18next 官方已经推出了 typescript 解决方案，吾辈还要写这个呢？\r\n\r\n简而言之，都不完善。\r\n\r\n先从 i18next 官方的解决方案说起，它是将 json 文件替换为 ts 文件，但不能支持参数和嵌套对象。\r\n\r\n> 注：最新版似乎利用了 typescript 4.2 的递归类型和模板字符串类型来保证类型安全，但这实际上是不怎么好用的。另外只有 react-i18next 是可用的。\r\n>\r\n> - [i18next typescript support](https://react.i18next.com/latest/typescript)\r\n> - [StackOverflow i18next 的类型定义](https://stackoverflow.com/questions/58277973/how-to-type-check-i18n-dictionaries-with-typescript/58308279#58308279)\r\n\r\n再来说 [i18next-typescript](https://github.com/LFDM/i18next-typescript) 这个第三方库，几乎能满足吾辈的需求了，除了一点：支持对象参数。还有像是 Jack 菊苣的 [i18n-codegen](https://github.com/Jack-Works/i18n-codegen)，代码设计上非常优雅，但同样的，不支持 react 之外的生态。\r\n\r\n另外，就吾辈而言，认为使用生成器生成简单的类型要比从类型系统上支持这种功能更加容易，也更加合理。\r\n\r\n## 设计\r\n\r\n![架构图](https://github.com/rxliuli/liuli-tools/raw/dev/docs/zh/tools/i18next-dts-gen/images/schema.drawio.svg)\r\n\r\n![流程图](https://github.com/rxliuli/liuli-tools/raw/dev/docs/zh/tools/i18next-dts-gen/images/flowchart.drawio.svg)\r\n\r\n## FAQ\r\n\r\n### 是否支持 i18next 的全部特性？\r\n\r\n否，这里支持的仅为 i18next 的一个子集。\r\n\r\n- [x] 为多个本地化 json 配置文件生成类型定义\r\n- [x] 支持包含参数\r\n  - [ ] 不支持嵌套参数\r\n- [ ] 不支持嵌套的 key -- 我们认为使用 . 分割就足够了，而且这样也更容易全局查找和替换\r\n- [ ] 不支持配置命名空间、嵌套的分割字符串，我们认为约定大于配置\r\n- [ ] 不支持 json 之外的配置文件，我们认为 json 文件对于非开发者都更友好，而且在需要时开发者更容易处理。它还是跨语言的，包括 golang/rust 的 i18n 框架均支持\r\n- [ ] 不支持 i18next 命名空间，即将翻译文件分割 -- 大部分时候翻译的内容并没有那么多，不超过 1000 个我都不太愿意分割\r\n  > 可以通过不同的 i18n 对象实现另类的分割就是了\r\n- [ ] 不支持在 vue 模板中提示、检查和跳转\r\n","createdTime":1624234664971,"updatedTime":1627790089141,"resources":[{"id":"86cc0f02cb594abebe57ba79c8d46f72","title":"navigation","file_extension":"gif","user_updated_time":1627229187775},{"id":"990fd29f95134939a6f4bcf1670d20f4","title":"searchAndReplace","file_extension":"gif","user_updated_time":1627229196610},{"id":"e4b7c0ed2d1b445b8309839cd041cf36","title":"prompt","file_extension":"gif","user_updated_time":1627229173390}],"tags":[{"id":"a3f220fe6f2c4c50a1aa91707edb8741","title":"typescript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"a305aafaac2b4ee8b9fa2f97898f1eea","title":"VSCode 与 WebStorm 横向对比","body":"## 前言\r\n\r\n> 不能认清自己，怎能看清别人？\r\n\r\n最近很长一段时间，VSCode 似乎成为了前端口中的标准开发编辑器，前端圈到处都在推荐 VSCode，劝说其他人放弃 Sublime, WebStorm, Atom 之流，仿佛真的是**信巨硬，得永生**一般。而吾辈作为一个长时间使用 JetBrains 系 IDE 的全沾开发者，这里就来对比一下 WebStorm 与后起之秀 VSCode 之前的异同点吧\r\n\r\n## 比较\r\n\r\n### 插件生态\r\n\r\nVSCode 的生态无疑非常好，基于 Web 技术构建的编辑器同样可以使用 Web 技术开发插件，而 Web 开发人员的数量也确实非常庞大。且由于其轻量跨平台的特性，受到很多开发者的喜爱，将之作为主力文件编辑器或者将其打造成 IDE 使用。它们的插件市场首页分别如下\r\n\r\nVSCode\r\n![VSCode 插件市场](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190830232931.png)\r\n\r\nWebStorm\r\n![WebStorm 插件市场](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190830232701.png)\r\n\r\nWebStorm 官方给出的插件总数是 1607，而 VSCode 吾辈并未找到插件的总数量，但显而易见，VSCode 的插件数量应该远远高于这个数字。而且你可以看到 WebStorm 下载量第一的插件仅仅只下载过 **5,558,762** 次，而 VSCode 的热门插件的下载数量是以 M 来计算的。我们来搜索一下前端流行打包工具 `webpack`，对比一下结果。\r\n\r\nVSCode\r\n![webpack for vscode](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190830233610.png)\r\n\r\nWebStorm\r\n![webpack for WebStorm](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190830233724.png)\r\n\r\n是的，VSCode 搜索到了 16 个插件，而 WebStorm 的搜索结果是。。。**0**？不了解 WebStorm 的小伙伴可能会有疑问，难道 WebStorm 不支持 webpack 嘛？那要它何用，还是拉出去砍了吧！\r\n泥萌先别急着掀桌子，个中缘由且听吾辈细细说来。之所以出现这种情况，主要是因为二者的策略不同造成的。WebStorm 的目标是让用户拥有开箱即用的生产力工具，下载安装完成后就可以立即进行项目开发了，所以它将很多功能内置了 IDE 之中，或者是由官方开发插件出来，然后直接集成到 IDE 中，给个人开发者开发插件的机会不多。\r\n而 VSCode 由于官方的开发团队没那么强大，而且又是免费的开源产品，所以理所当然只能发动广大人民群众的力量了，所以有很多插件就只能交给第三方开发者进行开发和维护。而这点也造成了安装完 VSCode 之后并不能立即使用，还需要下载插件、进行配置等一系列操作。\r\n以上两种模式的孰优孰劣早有人分析过，这里吾辈只说自己的使用体验。WebStorm 的开箱即用做的确实比 VSCode 更好，但问题在于如果官方不支持的话就会很难受，因为其实并没有太多人同时精通前端和 Java（是的，必须使用 Java 开发插件）。这也是吾辈目前仍然使用 VSCode 作为主力文本编辑器编辑配置文件，以及使用它写 Markdown 文章的原因，包括这篇文章亦是通过 VSCode 写出来的。\r\n![Markdown 写作截图](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190830235425.png)\r\n\r\n> 附: 插件开放让第三方实现与官方自己实现并集成的优劣之分参考知乎的一篇文章: [Visual Studio Code 有哪些工程方面的亮点](https://zhuanlan.zhihu.com/p/35303567)。\r\n> 通过插件来扩展功能的做法已经是司空见惯了，但如何保证插件和原生功能一样优秀呢？历史告诉我们：不能保证。大家可以参考 Eclipse，插件模型可以说是做得非常彻底了，功能层面也是无所不能，但存在几个烦人的问题：不稳定、难用、慢，所以不少用户转投 IntelliJ 的怀抱。可谓成也插件，败也插件。问题的本质在于信息不对称，它导致不同团队写出来的代码，无论是思路还是质量，都不一致。最终，用户得到了一个又乱又卡的产品。所以要让插件在稳定性、速度和体验的层面都做到和原生功能统一，只能是一个美好的愿望。\r\n> 来看看其他 IDE 是怎么做的，Visual Studio 自己搞定所有功能，并且做到优秀，让别人无事可做，这也成就了其 “宇宙第一 IDE” 的美名；IntelliJ 与之相仿，开箱即用，插件可有可无。这么看起来，自己搞定所有的事情是个好办法，但大家是否知道，Visual Studio 背后有上千人的工程团队，显然，这不是 VS Code 这二十几号人能搞定的。他们选择了让大家来做插件，那怎么解决 Eclipse 所遇到的问题呢？\r\n> 这里分享一个小知识 ——Eclipse 核心部分的开发者就是早期的 VS Code 团队。嗯，所以他们没有两次踏入同一条河流。与 Eclipse 不同，VS Code 选择了把插件关进盒子里。\r\n> 这样做首先解决的问题就是稳定性，这个问题对于 VS Code 来说尤为重要。都知道 VS Code 基于 Electron，实质上是个 node.js 环境，单线程，任何代码崩了都是灾难性后果。所以 VS Code 干脆不信任任何人，把插件们放到单独的进程里，任你折腾，主程序妥妥的。\r\n> VS Code 团队的这一决策不是没有原因的，正如前面提到的，团队里很多人其实是 Eclipse 的旧部，自然对 Eclipse 的插件模型有深入的思考。Eclipse 的设计目标之一就是把组件化推向极致，所以很多核心功能都是用插件的形式来实现的。遗憾的是，Eclipse 的插件运行在主进程中，任何插件性能不佳或者不稳定，都直接影响到 Eclipse，最终结果是大家抱怨 Eclipse 臃肿、慢、不稳定。VS Code 基于进程做到了物理级别的隔离，成功解决了该问题。实际上进程级别的隔离也带出了另一个话题，那就是界面与业务逻辑的隔离。\r\n\r\n### 智能提示\r\n\r\n作为写代码的工具，代码提示已经司空见惯了。但是，就算同样是代码提示，有的代码提示只是简单的代码片段（`snippets`），而有的却是基于代码语法树分析进行的，甚至于编辑器会学习使用者的习惯，将最常用的提示放在最前面。WebStorm 从始至终一直都是第三种，而 VSCode 最近官方才开发了基于 AI 自动学习的智能提示插件 [Visual Studio IntelliCode](https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode)。\r\n\r\nVSCode\r\n![VSCode 智能提示](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831030339.gif)\r\n\r\nWebStorm\r\n![WebStorm 智能提示](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831030506.gif)\r\n\r\n### 自动修复\r\n\r\n我们在日常开发中经常会遇到一些低级问题，而编辑器其实是有可能帮我们自动修复的。这里便对吾辈了解的一些问题进行对比，问题详细信息请参考文章 [JavaScript 规范整理](:/69eedef48bf54c3ca692b43a115a118f)\r\n\r\n> 注: VSCode 没有原生的自动修复功能，必须使用插件才行。\r\n\r\n| 分类     | 对比项                                       | VSCode | WebStorm |\r\n| -------- | -------------------------------------------- | ------ | -------- |\r\n| 命名规范 |\r\n|          | 不要使用拼音命名                             | 支持   | 支持     |\r\n|          | 函数中的变量                                 | 支持   | 支持     |\r\n|          | 内部变量                                     | 不支持 | 不支持   |\r\n|          | 不要使用无意义的前缀命名                     | 支持   | 支持     |\r\n| ES6      |\r\n|          | 优先使用 const/let                           | 支持   | 支持     |\r\n|          | 使用新的函数声明方式                         | 支持   | 支持     |\r\n|          | 优先使用箭头函数而非 function                | 不支持 | 支持     |\r\n|          | 不要使用 if 判断再赋予默认值                 | 不支持 | 不支持   |\r\n|          | 优先使用 Map 做键值对映射而非传统的对象      | 不支持 | 不支持   |\r\n|          | 优先使用模板字符串拼接多个字符串变量         | 不支持 | 支持     |\r\n|          | 当独立参数超过 3 个时使用对象参数并解构      | 不支持 | 支持     |\r\n|          | 不要写多余的 await                           | 支持   | 支持     |\r\n|          | 不要使用 == 进行比较                         | 支持   | 支持     |\r\n|          | 使用计算属性名替代使用方括号表示法赋值       | 不支持 | 不支持   |\r\n| 逻辑代码 |\r\n|          | 不要判断一个 Boolean 值并以此返回 Boolean 值 | 支持   | 支持     |\r\n|          | 不要使用多余的变量                           | 支持   | 支持     |\r\n|          | 不要使用嵌套 if                              | 不支持 | 支持     |\r\n|          | 不要先声明空对象然后一个个追加属性           | 不支持 | 不支持   |\r\n|          | 不要使用无意义的函数包裹                     | 不支持 | 不支持   |\r\n|          | 不要使用三元运算符进行复杂的计算             | 不支持 | 支持     |\r\n|          | 如果变量有所关联则使用对象而非多个单独的变量 | 不支持 | 不支持   |\r\n|          | 应该尽量解决编辑器警告                       | 不支持 | 不支持   |\r\n|          | 使用类型定义参数对象                         | 不支持 | 不支持   |\r\n|          | 尽量扁平化代码                               | 支持   | 支持     |\r\n|          | 自执行函数前面必须加分号                     | 不支持 | 不支持   |\r\n\r\n下面是一张 WebStorm 官方使用自动修复的动图\r\n![WebStorm 自动修复](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831030641.gif)\r\n\r\n### 重构\r\n\r\n说起重构的话，VSCode 可以简单的说是做的**太少**，而 WebStorm 则是相反做的**太多**，下面继续以表格的形式进行对比。\r\n\r\n> WebStorm 较新版本已经修复了 2018.02 重命名会自动索引字符串的问题（变成可选项了）。\r\n\r\n| 分类   | 操作             | VSCode   | WebStorm |\r\n| ------ | ---------------- | -------- | -------- |\r\n| 重命名 |\r\n|        | 变量重名名       | 支持     | 支持     |\r\n|        | 复杂变量重命名   | 不支持   | 支持     |\r\n|        | 全局重命名       | 支持     | 支持     |\r\n|        | 正则重命名       | 存在 bug | 支持     |\r\n|        | 文件重命名       | 不支持   | 支持     |\r\n| 提取   |\r\n|        | 提取表达式为变量 | 支持     | 支持     |\r\n|        | 提取代码段为函数 | 支持     | 支持     |\r\n|        | 提取函数到新文件 | 支持     | 支持     |\r\n\r\nWebStorm 重命名文件\r\n![WebStorm 重命名文件](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831031020.gif)\r\n\r\n### Git/GitHub 集成\r\n\r\nVSCode 的 Git 支持一直不太行，就算加了插件 [GitLens](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens) 也无法比得上 WebStorm。\r\n\r\n| 分类   | 操作               | VSCode | WebStorm |\r\n| ------ | ------------------ | ------ | -------- |\r\n| Git    |\r\n|        | commit 提交        | 难用   | 支持     |\r\n|        | push 推送          | 支持   | 支持     |\r\n|        | pull 拉取          | 支持   | 支持     |\r\n|        | merge 合并         | 支持   | 支持     |\r\n|        | 历史记录           | 难用   | 支持     |\r\n|        | reset 回退         | 支持   | 支持     |\r\n|        | revert 回退        | 难用   | 支持     |\r\n|        | stash 暂存         | 支持   | 支持     |\r\n|        | branch 分支操作    | 支持   | 支持     |\r\n| GitHub |\r\n|        | 分享到 GitHub      | 不支持 | 支持     |\r\n|        | 从 GitHub 选择拉取 | 不支持 | 支持     |\r\n|        | 分享到 Gist        | 支持   | 支持     |\r\n\r\n放两张图对比一下\r\n\r\nVSCode GitLens\r\n![GitLens](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831022549.png)\r\n\r\nWebStorm\r\n![WebStorm Git](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831022643.png)\r\n\r\n> 新版的 GitLens 好用很多，不仅仅追求功能丰富，更对开发者体验非常关心。\r\n\r\n### 前端支持\r\n\r\n前面提过，VSCode 生态很好，基本上很多语言/框架都有支持，而且官方也有一些非常优秀的插件。但是，有一些地方很重要，VSCode 对于 HTML/CSS/JavaScript 这些 Web 基本元素的支持相比于 WebStorm 确实可以说的上是糟糕。\r\n\r\n先来测试前端三剑客: `HTML/CSS/JavaScript`。\r\n\r\nVSCode\r\n![VSCode](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831004550.gif)\r\n\r\nWebStorm\r\n![WebStorm](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831003352.gif)\r\n\r\n可以看到，对于 HTML/CSS 之间的代码提示、跳转这些基本功能，VSCode 其实并没有做好。现代前端说是不再写 HTML 了，但实际上终究还是要写（即便是 JSX 还是要符合写 HTML 的直觉的），VSCode 代码提示在这里明显不太够看。还有一点也很有趣，VSCode 在打完 `document.querySelector('#hello')` 之后彻底没了动静，而 WebStorm 在 `style` 输入完成之后，立刻就有了各种 CSS 属性提示了。\r\n\r\n> 附: VSCode 中通过输入 `h1.hello#hello` Tab 之后就得到代码是一种前端 HTML 代码编写方式，被称为 [Zen Coding](https://www.qianduan.net/zen-coding-a-new-way-to-write-html-code/)。但实际上，这种编写方式在代码提示方面存在劣势，所以使用 WebStorm 时并未演示。\r\n> 附: VSCode 引用文件路径提示需要插件 [Path Intellisense](https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense)\r\n\r\n对于库的开发者而言最难受的地方是 VSCode 实质上依赖于 TypeScript 才能做到代码提示，如果你也像吾辈是一位 JavaScript SDK 的开发者，那么也会遇到这件令人郁闷的事情: 如果想要使用你的 JavaScript SDK 的 VSCode 用户有正常的代码提示的话，你就必须接触 TypeScript。要么使用 TypeScript 重构整个 SDK，要么写 _.d.ts_ 专门为 VSCode 维护一份注释文档，详情可以参考文章 [JavaScript => TypeScript 迁移体验](:/03ee7047ae3c4203b0c4c4ebfd6d7bd9)。\r\n\r\n### 历史记录\r\n\r\n不知你是否曾遇到过，正在编辑着一个文件，突然断电，或者是因为其他什么原因，导致文件内容被清空了。或者是误删了代码之后之前的代码还没提交，又不能撤回那么多次，导致代码重写的经历呢？吾辈就曾经经历过，所以对本地历史记录这个功能相当重视，然而很遗憾，VSCode 依旧需要第三方插件 [Local History](https://marketplace.visualstudio.com/items?itemName=xyz.local-history) 才能支持。\r\n\r\nVSCode Local History\r\n![VSCode Local History](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831024208.png)\r\n\r\nWebStorm\r\n![WebStorm](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831024420.png)\r\n\r\n两者相比主要有以下不同\r\n\r\n| 对比项                 | VSCode | WebStorm                       |\r\n| ---------------------- | ------ | ------------------------------ |\r\n| 原始文件是否为人类可读 | 是     | 否（XML 不列入人类可读格式中） |\r\n| 是否可以添加标签       | 否     | 是                             |\r\n| 是否可以对比           | 是     | 是                             |\r\n| 是否可以合并           | 否     | 是                             |\r\n| 是否支持目录历史       | 否     | 是                             |\r\n\r\n> WebStorm 的支持目录的历史记录非常强大，相当于实时保存和提交的 git\r\n\r\n### 主题配色\r\n\r\n两者都支持黑暗主题，而且都是默认设置，也同样支持使用插件定制界面。下面是两者的截图\r\n\r\nVSCode\r\n![VSCode 主界面](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190830231558.png)\r\n\r\nWebStorm\r\n![WebStorm 主界面](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190830231815.png)\r\n\r\n事实上，上面两者都使用了主题。VSCode 是 Monokai，WebStorm 是 Material。但其实 WebStorm 的 [Material 主题](https://plugins.jetbrains.com/plugin/8006) 还是存在一些 Bug 的，例如有些地方图标莫名的错位之类，VSCode 目前吾辈还未曾遇到过这类问题。\r\n\r\n### 使用性能\r\n\r\nWebStorm 确实很吃内存，尤其是项目刚刚打开的时候，索引会疯狂地吃 CPU/内存/硬盘，如果电脑性能不行的话这个过程所需时间可能泡面都够了。但基于 Chrome 内核的 VSCode 在使用各种插件打造成前端 IDE 之后吃的内存也并不少。吾辈打开了项目 [rx-util](https://github.com/rxliuli/rx-util)，可以看到 VSCode 每个插件确实都放在了单独的进程里（Chrome 系的习惯 #笑），相比之下 WebStorm 只有两个进程，其中一个还是启动的 nodejs，整体对比下来其实相差不大。\r\n\r\n![任务管理器](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190831000118.png)\r\n\r\n> 不得不承认的是，WebStorm 吃的性能终究还是要比 VSCode 多。但是，能用钱堆硬件解决的问题，能算问题么？\r\n> ![1613744562293](:/6996b9a2e3f54a919287c7ea7d0027f7)\r\n\r\n### 工具集成\r\n\r\nJetBrains IDE 深度集成工具链，倾向于一切都以可视化界面点击/快捷键完成操作。而 VSCode 则有所不同，它有很多功能需要使用命令行/配置文件的形式完成。吾辈最开始使用 VSCode 时它甚至还没有配置界面，也只能使用 `launch.json` 启动 debugger（最新版似乎已经不是了），真是被吓到了。\r\n在调试、运行支持的工具时，一般 VSCode 仍然需要使用命令行工具，或者在需要调试时编写 `launch.json` 配置脚本。但 WebStorm 则更加深度集成的工具链，倾向于一切都以可视化界面点击/快捷键完成操作。拿运行和调试代码为例，统一支持可视化的形式运行或调试（自动生成 ide 配置，并支持在必要的时候调整），目前支持 npm/gulp/浏览器 js/jest/nodejs/electron/typescript/git。\r\n\r\n至于有人说一个命令的事情为什么要 ide 集成？\r\n\r\n- 安装依赖的时候停止索引，避免影响性能\r\n- 简单启动调试（至今吾辈仍然没有彻底搞懂 vscode 的调试，为什么不能点一下就启动调试？至于是浏览器、nodejs、electron 可能存在不同的差异，让 ide 去屏蔽这一层不就好了，反正 ide 能识别出来项目使用的技术栈（至少是 ide 支持的技术栈））\r\n- 显示单独的命令视图\r\n- 快速查找/运行命令\r\n\r\n> 有可能通过插件支持，但使用 VSCode 的人似乎更倾向于使用命令行（懒得找）。\r\n\r\n### 远程/协作编辑\r\n\r\nVSCode 通过 [live-share](https://github.com/MicrosoftDocs/live-share) 实现了远程开发，但 WebStorm 也通过官方插件 [Code With Me](https://www.jetbrains.com/code-with-me/) 和 [Projector](https://lp.jetbrains.com/projector/) 进行了支持。\r\n\r\n| 比较项   | VSCode | WebStorm  |\r\n| -------- | ------ | --------- |\r\n| 协同编辑 | 是     | 是        |\r\n| WSL 支持 | 是     | 是        |\r\n| 远程项目 | 是     | 是        |\r\n| 画板支持 | 是     | 否        |\r\n| 聊天     | 是     | 是        |\r\n| 语音     | 是     | 是        |\r\n| 免费     | 是     | IDEA 免费 |\r\n\r\n> 就吾辈实际使用而言，感觉这是个噱头功能，和许多云 IDE 差不多。\r\n\r\n### 东家\r\n\r\nVSCode 背后站着微软，俗成 **M\\$**，开发了宇宙最强 IDE Visual Studio。而 WebStorm 则是基于 JetBrains 平台专门为前端进行特殊处理优化的 IDE，背后则是业界最智能的 IDE 的开发公司 JetBrains（捷克公司）。两者在 IDE/编辑的开发上都相当有经验，然而，有一点本质的不同：IDE 对于 JetBrains 而言几乎是全部，而 VSCode 对于 M\\$ 则只是开发的一部分 -- 编辑器。\r\n\r\n`VSCode => VSCode Remote => GitHub => GitHub Actions => Azure`，从 MS 的一系列变化来看，这对开发者是真的相当上心，从本地开发、远程协作、版本控制、自动化流程控制 CI/CD 到部署到云端，完全是一站式的体验。相比于国内的云服务商，MS 显然更加开放、更加为开发者着想。\r\n而 JetBrains，虽然现在也有了编程语言 `Kotlin`、项目管理工具 `Space`（包含 CI/CD 工具 `TeamCity`），但本质上在其领域内，除了 IDE，其他的东西都没能形成特别大的优势（Kotlin 只能用于开发 Android 平台，而 Web 技术甚至能开发全端；`TeamCity` 虽然很漂亮，但似乎人们更喜欢开源的 `Jenkins`）。\r\n未来 VSCode 一统天下似乎是必然之势，但目前而言，其尚且年幼，唯有 WebStorm 正值壮年。\r\n\r\n> 附：例如某只企鹅，开发的大多数云服务都是私有服务，使用上比开源的还难用而且还强制绑定到自家云服务上，使人不得不用全家桶（问题是体验又烂，文档死难找）\r\n> 附: 居然连 “文档和 Demo 有可能过期，但代码一定是最新的” 这种话都能说出来，与 MS 花大力气创造开源的 `VSCode` 简直是天壤之别。\r\n> 附: 没有对比就没有伤害！\r\n\r\n## 总结\r\n\r\n其实在 Atom/VSCode 出现之前，WebStorm 因为在这个领域没有对手而发展缓慢，它们的出现使得 WebStorm 有了压力，良性竞争，这当然是好事。即便如此，就目前而言，VSCode 作为一个 IDE 来讲仍然比不上 JetBrains 全家桶系列。\r\n说了上面这么多，总的来说: 如果你需要一个文本编辑器，那么推荐你用 VSCode，因为它既漂亮又生态丰富，想写点什么很方便。但是，如果你需要真正开发项目，则 WebStorm 更加合适，完全开箱即用的体验，不需要安装/配置任何插件就能立刻开始项目，强大的编辑器可以让你写代码更舒服一点。（其实是没钱就用免费的 VSCode，有钱就上 WebStorm 啦！）\r\n\r\n> ref link: [Why I Switched From Visual Studio Code To JetBrains WebStorm](https://dev.to/mokkapps/why-i-switched-from-visual-studio-code-to-jetbrains-webstorm-939)\r\n> 吾辈个人非常同意作者及相关评论的观点：为 WebStorm 付费能减少折腾 VSCode 的时间，VSCode 的真正优势是启动时间，使用内存和免费。\r\n","createdTime":1580652938013,"updatedTime":1627789102357,"resources":[{"id":"6996b9a2e3f54a919287c7ea7d0027f7","title":"1613744562293","file_extension":"png","user_updated_time":1613744563057}],"tags":[{"id":"05f6657b073e4bf3959bdb9a2fecda83","title":"webstorm","parent_id":""},{"id":"2dc486a3eb624e698c76e4512f46af5e","title":"vscode","parent_id":""},{"id":"95ddbbd925aa4358a46bfcbce4c3fb46","title":"工具","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"2db1feef52c64dd78de72b6c7c321997","title":"使用 VSCode + Joplin 作为笔记工具","body":"> [joplin](https://joplinapp.org/), [joplin-vscode-plugin](https://marketplace.visualstudio.com/items?itemName=rxliuli.joplin-vscode-plugin)\n\n## 为什么吾辈使用 Joplin\n\n> 注: 开源、不受平台限制以及基于 markdown 容易迁移这是很重要的一点，因为没有人知道哪个笔记工具是最终的赢家，如果没有选对，那么至少要容易迁移。\n\n吾辈曾经使用过一些笔记工具，包括 印象、OneNote、Notion 这些，但最终都放弃了。关键还是在于吾辈核心的一些需求未能得到满足:\n\n1. 搜索要快\n2. 编辑器体验要好\n3. 数据应该能够全部导出\n4. 基于标准的 md，可以直接复制到其他平台\n5. 可以基于它进行二次开发\n6. 还没死\n\n下面让我们来细品以上工具的功能\n\n印象笔记\n\n好吧，印象笔记有国际版/国内版，但国内版本很明显属于收钱不做正事的典型，很长时间内都没有任何变化了。而且，markdown 支持并非官方自带，而是需要使用第三方插件才行（18 年底更新之后貌似支持了）。而且最近 [印象笔记又抢注国内的 notion 的图片商标](https://www.zhihu.com/question/343856067)，真可谓是国内独树一帜的**奇观** 了。\n\nOneNote\n\n老实说，如果习惯使用 Office 全家桶整理文档的话，OneNote 还是很香的，编辑体验和 Word 保持一致，搜索极快。但很遗憾的是，吾辈是坚定的 **万物基于 markdown** 人士，所以不喜欢 OneNote。\n\nNotion\n\n是目前遇到的一个比较满意的笔记工具，但主要有 3 点不太满意。\n\n1. 编辑器比较卡\n2. 搜索非常慢\n3. 无法导出全部数据\n\n> 具体参考：[Notion 使用体验](:/6394b6d9a2ba4be7a17fec38f274a50c)\n\n而 Joplin，则是吾辈能够解决 notion 的以上几个问题的笔记工具，同时开源免费，允许吾辈参与其中。\n\n主要优点：\n\n1. 搜索很快，非常快\n2. 可以使用外部编辑器打开\n3. 数据都在自己手里，提供一次性导出全部的功能\n4. 使用标准的 md，可以直接复制到其他平台\n5. 可以基于它进行二次开发\n\n主要缺点：\n\n1. ui/ux 有点简陋\n2. 没有 vsc 插件导致使用外部编辑器也并不是非常方便\n\n## 为什么吾辈要写 vscode 的这个插件\n\n1. 作为专业的编辑器在编辑功能上 vscode 是笔记工具无法比拟的。例如快捷键支持\n2. vscode 不仅仅是一个编辑器，更有着非常庞大的插件生态圈，所以在 markdown 格式化、linter 校验、pdf 导出等功能上早已实现，不需要在笔记工具里重复造轮子 -- 还可能是方轮子\n3. 事实上，我一直在使用 vscode 在进行 markdown 文档编辑工作，用 git + vscode 存储公司相关的文档。同时也在使用 joplin 存储个人的笔记资料，但目前经过一段时间发现我需要的是 vscode 的编辑 + joplin 的同步/搜索功能。\n\n所以我编写了这个插件，用以给与我有相同需求的人使用。\n\n> 参考: [Future of Joplin](https://discourse.joplinapp.org/t/future-of-joplin/11306)\n\n## 介绍\n\n在 VSCode 中集成 joplin，实现了 Joplin 的常用功能。\n\n![预览图](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200623085740.png)\n\n## 插件\n\n先简单列出吾辈与笔记相关的插件列表，它们都实现了某项特定功能且可以组合。\n\n- [Markdown All in One](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one): Markdown 语言支持\n- [markdown lint](https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint): Markdown linter 工具\n- [Prettier](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode): 多语言格式化工具，对 markdown 的支持非常好\n- [Markdown PDF](https://marketplace.visualstudio.com/items?itemName=yzane.markdown-pdf): Markdown 导出 PDF\n- [Draw.io Integration](https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio): draw.io 流程图集成\n  - [Markdown Preview Mermaid Support](https://marketplace.visualstudio.com/items?itemName=bierner.markdown-mermaid): 支持 mermaid 流程图 DSL，但 draw.io 更好用\n- [vscode-mindmap](https://marketplace.visualstudio.com/items?itemName=eightHundreds.vscode-mindmap): 思维导图集成（此为 fork 版本，但更加好用）\n- [Local History](https://marketplace.visualstudio.com/items?itemName=xyz.local-history): 本地历史记录\n- [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker): 单词拼写检查\n- [joplin-vscode-plugin](https://marketplace.visualstudio.com/items?itemName=rxliuli.joplin-vscode-plugin): joplin 笔记集成\n\n> 你可能注意到其中部分插件和 markdown 没什么关系，但它们对于编辑而言仍然是重要的，例如 Joplin 最近（v1.4.\\*）才实现的拼写检查功能已经存在现有的 VSCode 插件了。\n\n这些插件解决的问题吾辈也在 [joplin 与 vscode 之类的编辑器区别](https://discourse.joplinapp.org/t/future-of-joplin/11306/45?u=rxliuli) 提交，在此也不多赘述。\n\n## 解决的问题\n\n吾辈简单浏览了最近两周的 Joplin 帖子，其中下面这些问题在 VSCode 中似乎已经解决/实现了\n\n- [Please add an easy to access markdowns](https://discourse.joplinapp.org/t/please-add-an-easy-to-access-markdowns/12688): 快速添加列表\n- [Markdown keyboard shortcuts](https://discourse.joplinapp.org/t/markdown-keyboard-shortcuts/12668): markdown 快捷键支持\n- [Duplicate line command](https://discourse.joplinapp.org/t/duplicate-line-command/12650): 复制并粘贴到下一行\n- [Please auto replace to Bullet/Number/Checkbox list](https://discourse.joplinapp.org/t/please-auto-replace-to-bullet-number-checkbox-list/12319): 同样是快速添加列表\n- [Auto attach images as resources after external editor](https://discourse.joplinapp.org/t/auto-attach-images-as-resources-after-external-editor/3121): 外部编辑器粘贴图像支持 Joplin\n- [Integration of PlantUML](https://discourse.joplinapp.org/t/integration-of-plantuml/11029): PlantUML 集成\n- [Find and Replace](https://discourse.joplinapp.org/t/find-and-replace/7283): 查找和替换功能支持\n- [Making Joplin recognise YAML front matter](https://discourse.joplinapp.org/t/making-joplin-recognise-yaml-front-matter/12868): markdown yaml 元数据支持\n- [Plugin: Note Tabs](https://discourse.joplinapp.org/t/plugin-note-tabs/12752): 多标签页支持\n- [Option to show line numbers in editor](https://discourse.joplinapp.org/t/option-to-show-line-numbers-in-editor/8313): 显示行号\n- [Incomplete TOC sidebar](https://discourse.joplinapp.org/t/incomplete-toc-sidebar/10458): outline 支持\n- [Feature request: Folding sections of text](https://discourse.joplinapp.org/t/feature-request-folding-sections-of-text/5752): 代码块折叠\n\n## 效果\n\n最后，配置完成的 VSCode 编辑器编辑 Markdown 的效果图如下\n\n![编辑效果](https://img.rxliuli.com/20181201165338.png)\n","createdTime":1580652938016,"updatedTime":1626834024213,"resources":[],"tags":[{"id":"2dc486a3eb624e698c76e4512f46af5e","title":"vscode","parent_id":""},{"id":"6a9fbee743ec48fa9a4eff9999e11d49","title":"markdown","parent_id":""},{"id":"95ddbbd925aa4358a46bfcbce4c3fb46","title":"工具","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"1d714f3ebd97461aa3d488f9a133a7c3","title":"吾辈的工作","body":"> 去年国庆节时写的，忘记发了 xd\n\n## 前言\r\n\r\n国庆回老家散心，和家人交流了一些事情之后，想起了自己的工作，便想于此浅谈一番。\r\n\r\n> 好吧就是一个表妹需要写作业，但看着吾辈不写作业便缠着让吾辈写一篇关于工作的文章而已。\r\n\r\n## 家人\r\n\r\n> 当其他标准都不存在，金钱便成为唯一的标准。\r\n\r\n在老家的人看来，吾辈的工作算是非常好的了，而且大概率，他们也会希望自己的孩子进入这个行业吧。其实本质上，核心原因只有一条：**这个行业的工作工资都比较高**。从现在幼儿计算机教育行业的兴起也可见一斑，为人父母都希望自己的孩子能过得更好，而目前在国内过得更好的唯一方法是：**挣更多的钱**，也不外乎很多父母这样做了。\r\n\r\n但是，这个行业仍然不可避免的存在许多问题，当你和他们说到这些的时候\r\n\r\n- 住房问题\r\n- 交通问题\r\n- 加班问题\r\n- 吃饭问题（由以上问题衍生）\r\n- 自由问题\r\n\r\n他们总是视而不见，或心知肚明但仍然反驳道\r\n\r\n- 你们现在过的比我们好多了\r\n- 在大城市不就应该是这样么？\r\n- 打工的你还想要怎样？\r\n\r\n## 工作\r\n\r\n> 按照吾辈公司某个人的说法：**“这些年我待过这么多公司，从来没有哪一家公司的工作是让我感到开心的”**。\r\n\r\n对于吾辈而已，工作似乎在逐渐变成维系生存的一种手段，而非吾辈最初希望进入这个行业的理由：**做更有创造性的事情**。\r\n\r\n或许对于一些在大城市的程序员也同样适用的工作生活\r\n\r\n- 6.30 早晨起床，洗漱之后\r\n- 7.00 出门，坐地铁，大概 40min 左右\r\n- 到达公司，吃点早餐\r\n- 距离上班还有一点时间，开始看一些自己想看的技术相关的书籍、rss，邮件订阅等\r\n- 开始上班\r\n- 中午吃饭，吃完回到公司，玩会手机或电脑，然后午休\r\n- 下午上班、下班\r\n- 7.30 开始回家\r\n- 8.00+ 到家\r\n- 路上买了点饭，吃饭，洗澡\r\n- 大概接近 9.00 时没什么其他事情了\r\n- 一般会看一些感兴趣的书，但如果遇到有趣的小说、电影之类，则可能根本不会去碰\r\n\r\n每天重复这样的生活，甚至不知道自己技术的下一个转折点在哪里，浑浑噩噩，不知所谓。有时候痛恨自己不够努力，明知道自己的弱项在哪里但就是不去弥补，但有时候又觉得这一切都无所谓，只要能简单的活着就好。\r\n\r\n996 真的存在么？毫无疑问是真的，虽然吾辈没有切实经历过，但也经历过一段时间的 995。\r\n\r\n## 35 岁的魔咒\r\n\r\n两条“公理”\r\n\r\n- 人不能没有好奇心，失去好奇心就丧失了学习的源泉。\r\n- 如果终身学习是工作的唯一出路，那么对于大部分人来说，就是没有出路。\r\n\r\n是的，世界上普通人是如此之多，28 定律清楚的阐述这一切。那么，为什么国内互联网这个行业偏偏有 35 岁就不能继续工作的魔咒呢？其他行业为什么没有？\r\n\r\n- 这个行业的表层技术发展的太快，十年前应用层使用的技术和现如今的完全不一样，很多人跟不上这个发展，仍然希望能用十年前的技术完成现在的工作。\r\n- 国内对于弱者不友好，一旦有更低的成本，就会抛弃掉现有的方式。\r\n- 教育行业无疑是失败的，填鸭式教育让一群没有自己思想的人出现，现如今吾辈还在上小学的表妹教育的方式和十年前没什么变化，**抄小字**，熟悉而又陌生的字眼。\r\n\r\n其他行业为什么没有这个问题呢？甚至有些行业是越老越吃香的（例如医生）。\r\n\r\n- 其它行业的发展没那么快，十年前的知识到现在仍然是基本有效的，像是司机，十年前开车用到的技能和现在的几乎没什么不同。\r\n\r\n目前吾辈仍然是愿意花很多时间在技术方面，甚至放弃了很多本应是生活的时间，吾辈愿意为了以后更好的生活而忍受暂时的苦难，就像深水成美的励志歌曲唱的那样：“只要不服输，最后还是有指望...”，但是我们最后真正能够得到什么就不好说了...\r\n\r\n## 尾声\r\n\r\n或许，对于这个行业的人来说，出国才是唯一也是最好的选择吧！\r\n","createdTime":1601947880042,"updatedTime":1625900260663,"resources":[],"tags":[{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""},{"id":"f5172282f275485bab67f712ba1b1bcf","title":"个人","parent_id":""}]},{"id":"5ea2552c67d34130b68cc11143d6191c","title":"2020 吾辈在公司推动的前端技术演进","body":"## 上古时期\r\n\r\n> 吾辈来的时候已然不多，但部分 mobile 嵌入的静态页面仍然是这种形式\r\n\r\n后端模板（JSP/FreeMarker）+ 前端静态 HTML 页面。那是个前端开发非常卑微的时代，除了还原 UI 和兼容性之外，所有业务逻辑、路由跳转、状态管理、部署维护都由后端包办完成。前端能做的事情非常有限，UI 还原、CSS 样式以及浏览器兼容性（例如传统前端需要掌握的精确到 1px 的兼容到 IE6 的高保真切图技巧）是所需的关键技能点，或许还要负责 UI 相关的任务。但这其中，**许多更偏向于「手艺人」的工作，而非工程师的技术价值体现，更重要的是，它无法被沉淀为技术人的长期价值**。\r\n\r\n> 参考: [前端为什么会越来越复杂？](https://www.zhihu.com/question/375448022)\r\n> CSS 不是正交的，所以很麻烦，参考: [CSS 为什么这么难学？](https://zhuanlan.zhihu.com/p/29888231)\r\n\r\n问题\r\n\r\n- 难以应对大规模的项目开发，几乎没有工程化可言\r\n- 前后端耦合导致修改、发布困难（就我们公司有个 gw 项目就是反例）\r\n- 前端能做的事情非常有限，几近是后端的附属（App 有趣的一点就是极大的增强了客户端的能力，许多独立 App 开发者的工具类产品可能对后端的依赖极少）\r\n\r\n## 跨入现代前端: vue + webpack\r\n\r\n- 框架: vue\r\n- 项目组织: git 分支 + 目录\r\n\r\n> 在吾辈进来的时候基本是这样的\r\n\r\n![1614382963380](:/1e8dc3a95f054ef3b404bdc39f95e099)\r\n\r\n无论如何，前后端分离都已然是大势所趋，公司的项目也不例外，也从 jq 升级为了 vue。vue 是一个及其新手友好的框架，官方文档在前端开源框架中无出其右，所以选择它对招聘确实有一定的帮助（准入门槛低）。\r\n\r\n但这里确实存在一些问题，主要如下\r\n\r\n- vue 和 ts 结合的不好，所有前端项目，不是已经用了 ts，就是在走向 ts 的路上（去年 vue3 选择使用 ts 重写 v3）\r\n  - 这是一个设计失误，因为 vue 作者更相信另一个 facebook 的静态类型脚本语言 flow.js，但它最终失败了\r\n- vue 不是一个创新者，更像是一个现有技术的整合者，更新相比于 react v17/angular v11 慢得多（v3）\r\n- vue 和 ant design 结合的不好，因为蚂蚁金服使用 react 实现，vue 版本并非官方实现（关于这个 UI 框架的选择其实令吾辈有些困惑）\r\n- 项目组织方面使用 git 分支 + 目录的形式可能是模仿了后端，但由于目录之间并非模块的形式加上 git 没有规范可言导致没有利用本地模块的优势反而只有劣势\r\n- 有些项目使用原生 webpack 进行配置打包，而这实际上非常难以维护，参考: [webpack 为什么这么难用？](https://zhuanlan.zhihu.com/p/32148338)\r\n\r\n> 典型项目: 前端旧项目\r\n\r\n## 静态类型: 引入 typescript\r\n\r\n- 语言: typescript\r\n- 项目组织: 分散的 git 项目\r\n\r\n由于使用目录+分支管理的项目组织非常麻烦，所以后面的一些项目采用了每个业务创建一个 git 项目，然后最终将之打包整合到官网（其实就是不同的子路由），独立每个项目的开发和部署。而后希望通过 ts 的静态类型增强前端开发的效率及开发体验（主要是 IDE 在提示、重构和导航方面的支持），所以将之引入了进来，吾辈有自信可以解决任何遇到的 ts 问题。\r\n\r\n![1614383048466](:/86bcfe6872864bd282703cbb5522ff27)\r\n\r\n但老实说，问题仍然没有完全解决\r\n\r\n- ts 和 vue 2 结合的不好，甚至 vue 3 中 ts 也没能解决模板层面的问题，参考: [web-types 讨论](https://github.com/JetBrains/web-types/issues/15)\r\n- 分散的 git 项目之间如果存在相同代码，比较难以共享（但因为有 npm 私服所以还不太明显）\r\n- 组件粒度较粗，比较小的组件难以抽取\r\n\r\n> 典型项目: 新管理后台\r\n\r\n## 替换框架为 react\r\n\r\n事实上，引入 react 没有 ts 那么安全，因为这次吾辈不能说**吾辈有自信可以解决任何遇到的 react 问题**，因为吾辈也没有实际生产环境的经验。但吾辈仍然引入了，有以下几个考量\r\n\r\n- 更好的结合 ts 使用\r\n- 直接使用官方维护的 ant design for react 版本\r\n- 相比于 vue 好得多的 IDE 支持\r\n- 更好的开发大型项目（报告系统）\r\n- 尝试变化，使用最新的技术\r\n\r\n但这仍然并非终点，在报告系统项目中，单个前端项目的代码量首次达到了 2w+ 行（至今已到 4w+），分割模块势在必行，这里就提到了需要使用到 lerna 了。\r\n\r\n> 典型项目: 公开图库\r\n\r\n## 引入 lerna 以使用 monorepo\r\n\r\n- 项目组织: monorepo\r\n\r\nJava 后端的项目天然是 monorepo（因为 maven 的原因），而前端在很长时间内都没有类似的工具，直到吾辈遇到了 lerna。这点某位离职的同事有曾提及，但直到几个月后报告系统第一版基本结束时进行重构才真正实用。\r\n使用它吾辈改进了以下几点问题\r\n\r\n- 使用 monorepo 更好的组织模块，保证项目在超过 4w 行代码、20 个模块时仍然保持可维护性\r\n- 更简单的共享和复用代码，只要抽离一个模块即可在所有模块直接引用它了\r\n- 更加容易统一整个项目的技术栈，引入一个依赖的不同版本几乎不可能出现了\r\n- 更加容易容易统一项目的配置，保证整个项目的代码风格都是一致的（例如 eslint/prettier）\r\n\r\n![1614383172095](:/a5cc319a00a144349c494b91edb92079)\r\n\r\n> 典型项目: 旧版报告系统\r\n\r\n## 引入 gh-pages 简化发布\r\n\r\n事实上，生产环境的发布一直非常麻烦，即便建宏已经实现了两版的发布系统，但目前使用体验仍然不算好（gw 项目必须要用），但前后端分离的项目却不尽然。后来在一个偶然的情况下，吾辈发现了一种更高效的方式: [使用 gh-pages 发布前端项目](:/7b0fe35b00b345618a9323977a2e552a)，同时喜获冰淇淋一个。\r\n\r\n> 当然，由于后来主要在开发 electron 客户端，web 项目在生产环境的发布变得较少，但这件事仍然证明只要将现有的工具整合起来，仍然可能极大的提高生产力\r\n\r\n![1614383397001](:/3654c8048cb14577a2097aa0294fe4f3)\r\n\r\n> 典型项目-大屏看板\r\n\r\n## rushstack: 标准化的前端 monorepo\r\n\r\n- 项目组织: lerna monorepo => [rushstack](https://rushstack.io/)\r\n\r\n虽然 lerna 可以分割模块，但它并没有所谓的最佳实践，事实上，吾辈在微软的 monorepo 工具 rush 的相关项目 rushstack 中找到了一种最佳实践，在形式上有许多参考价值（虽然由于大而全且包含许多问题的原因导致没有 lerna 使用广泛），最新的两个生产项目均已重构成这种形式的 monorepo 项目，稍晚一些会将它们合并，便于之后它们的整合。\r\n\r\n![1614431686700](:/40a90f19f74143d3a676e7afdec3c658)\r\n\r\n在 rushstack 的介绍中有这么一段话非常有趣：\r\n灵活性有其缺点。Node.js 工具因其令人困惑的选项而臭名昭著：选择您的编译器、linter 工具、打包工具、包管理器、任务引擎、单元测试工具、测试断言库等。一旦决定（**下了赌注**），整合所有这些组件就变成了自己的软件项目。随着规模的扩大，这些成本可能会迅速增加！\r\n核心就是前端定制需求过多，要求工具链非常灵活，进而导致无法标准化（和现在的报告系统业务面临的问题多么相似。。。）\r\n\r\n> 典型项目 miis\r\n\r\n## 架构\r\n\r\n### 统一和规范\r\n\r\n- 定义统一的业务目录的结构，形成约定俗成\r\n- 通过更高层的 cli 抽象强制统一 `lib` 的项目结构，例如入口文件一定是 `lib/src/index.ts`，出口一定是 `dist/index.js`，而打包出来的一定默认支持 `esm/commonjs`\r\n- 使用 prettier+git hooks 统一项目中的代码风格\r\n- 通过 syncpack 统一多个模块之间的依赖版本\r\n- 通过多个模块中的 npm script，例如启动 web 项目的开发环境是 `start`，启动 electron 开发环境则是 `dev:win/mac`，打包项目是 `build`，而 `libs` 的模块打包发布是 `pub`，打包 electron 项目是 `pkg:*`\r\n\r\n### 分层和解耦\r\n\r\n- 通过 monorepo 分割 electron 项目不同的进程，将之作为单独的 nodejs 项目和 react 项目管理和发布\r\n- 通过使用 api class 的形式，将与后端的连接封装在单独的逻辑层，定义参数、返回值的类型，业务层直接引用相关的单例对象调用方法即可\r\n\r\n> 吾辈也好奇现代前端框架强绑定、重 UI 层的现在，如何更好的分离 UI 与业务逻辑\r\n\r\n### 优化\r\n\r\n- 使用 lerna 的 `--include-dependencies --stream` 参数尽可能按照依赖顺序并发运行命令，例如打包所有模块\r\n- 为了减少安装依赖上的麻烦，尝试过 `nrm/yrm` 改源，`npmrc` 配置镜像，但最终还是要求所有前端必须能够使用 SSR+透明代理工具，否则无法启动项目\r\n- 在公司 blog 上分享一些自己的心得和感触\r\n- 通过使用 docsify 提升文档维护者的体验，使用 VSCode 编辑文档，然后使用 git 提交便自动部署了\r\n- 引入 storybook 为通用组件编写交互式文档\r\n\r\n## 其他\r\n\r\n- 公司前端文档: 公司的前端项目在线文档，使用 git + markdown 增强开发者编辑体验，希望更多人在更好的维护它\r\n- common-util: 前端工具库，近期使用 monorepo 将之彻底重构\r\n  至少优化了以下几项\r\n  - [x] 清理不需要的功能，减少了 60% 的代码\r\n  - [x] 使用 monorepo 增强项目的可维护性\r\n  - [x] 支持 nodejs 引入\r\n  - [ ] 使用 monorepo 分割打包减小在项目中的引入成本 -- babel 的 567 三个版本转变的惨剧历历在目\r\n  - [ ] 找到对用户更友好的使用方式 class vs function -- 面向对象 vs 函数式\r\n- web-logger: 前端日志，已在报告系统及之后后所有的前端项目中实用，目前还未支持 nodejs\r\n","createdTime":1614382794612,"updatedTime":1625844069408,"resources":[{"id":"1e8dc3a95f054ef3b404bdc39f95e099","title":"1614382963380","file_extension":"png","user_updated_time":1614382963952},{"id":"3654c8048cb14577a2097aa0294fe4f3","title":"1614383397001","file_extension":"png","user_updated_time":1614383397589},{"id":"40a90f19f74143d3a676e7afdec3c658","title":"1614431686700","file_extension":"png","user_updated_time":1614431687126},{"id":"86bcfe6872864bd282703cbb5522ff27","title":"1614383048466","file_extension":"png","user_updated_time":1614383049180},{"id":"a5cc319a00a144349c494b91edb92079","title":"1614383172095","file_extension":"png","user_updated_time":1614383172671}],"tags":[{"id":"5c38ebba7c77410f8d9cd21aed524f92","title":"公司","parent_id":""},{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""},{"id":"f93505f3e7994607aec7afec41480af3","title":"经验","parent_id":""}]},{"id":"f7599ffb024149e1a8928b61e8fdcd42","title":"面相 vue 开发者的 react 入坑指南","body":"## 场景\r\n\r\n- 问：为什么吾辈要使用 React？\r\n- 答：React 拥有更加庞大的生态，以及对 TypeScript 的更好支持。\r\n  前者让需求实现变得更加简单，例如目前使用 Vue 做的后台管理系统使用了 Ant Design Vue 这个 UI 库，而它的上游 Ant Design 实际上官方维护的是 React 版本，而 Vue 并不是 **亲儿子**，导致一些问题并不像官方那么快解决。\r\n  后者强大的类型系统能降低维护成本，虽然开发时代码添加类型会稍加工作量，但可以降低维护成本，便于后续的修改、重构，同时 IDE 对其支持是 JavaScript 无法相提并论的。\r\n- 问：那 React 相比于 Vue 而言有什么区别？\r\n- 答：更强大、复杂、酷，对于没有现代前端开发经验的人而言可能非常困难，但一旦熟悉，则会非常喜欢它。组件化（`React Component/JSX`）、函数式（`React Hooks`）、不可变（`immutable`）都是非常有趣的思想，理解之后确实都能发现具体使用场景。\r\n  > Vue 作者说 **React + Mobx 就是更复杂的 Vue**，这句话确实有道理，下面在 [状态管理](#状态管理) 那里也进行了说明，但同时，相比于 `Vue + Vuex`，避免引入 Redux 的 `React + Mobx` 将是更简单的。\r\n- 问：有大公司在用么？\r\n- 答：作为能够支撑 Facebook 这种级别公司的 Web 产品的基础，显然它拥有相当多的生产环境实践。\r\n\r\n## 工程与周边生态\r\n\r\n以下皆基于 `vite` 创建的脚手架项目，并包含 `ts/mobx/react-router/immer` 等周边项目，虽然完全不了解以上内容亦可，但最好了解一下它们是做什么的，下面第一次提及时也会简单说明一下。\r\n\r\n### 创建项目\r\n\r\n使用 vite 创建 react-ts 项目，相比于 create-react-app，它更快而且对开发者更加友好，虽然它对 vue 是第一优先级支持。\r\n\r\n### 状态管理\r\n\r\n此处使用 mobx 对标，mobx 是一个状态管理库，以响应式、可变、简单方便为最大卖点。本质上可以认为为每个页面（页面内的所有组件）提供了一个全局对象，并实现了 vue 中的 `computed` 和 `watch`，所以 vue 的作者说 vue 是更简单的 react + mobx 确实有些道理，实际上这两个加起来能做到的事情不比原生 vue 多多少。\r\n\r\n但它们之间也有几点不同\r\n\r\n- vue 基于组件级别实现的 `computed` 和 `watch`，而 mobx 则是全局的\r\n- vue 是基于组件级别自动初始化和销毁，而 mobx 则是手动的\r\n- vue 基于组件但也受限于组件级别，全局状态仍要使用 vuex 这种 **大炮**，而 mobx 此时则是统一的\r\n- 不使用 vuex 的情况下一些组件很难进行拆分，因为拆分后各组件的一些数据仍然需要共享和修改，这种时候单用 vue 的 `data/props` 就显得有些力不从心\r\n\r\n是否需要支持 es5？\r\n\r\n- 是：高阶函数\r\n- 否：装饰器\r\n\r\n### 路由\r\n\r\n<!-- react-router 自 v4 之后不再直接提供集中式的路由配置，但可以通过 [react-router-config](https://www.npmjs.com/package/react-router-config) 来使用配置式的路由。 -->\r\n\r\n- 递归菜单栏\r\n- 使用高阶组件包装路由组件 `withRouter()`\r\n- 获取当前路由信息：`this.props.match`\r\n- 使用编程式的路由导航：`this.props.history`\r\n  - 注意 props 的类型变化\r\n\r\n异步组件和 vue 稍微有点差别，虽然也是需要 `import()` 语法，但却需要使用高阶组件。\r\n\r\n```jsx\r\nimport React from 'react'\r\n\r\nfunction AsyncRoute(\r\n  importComponent: () => PromiseLike<{ default: any }> | { default: any },\r\n) {\r\n  class AsyncComponent extends React.Component<any, any> {\r\n    constructor(props: any) {\r\n      super(props)\r\n      this.state = {\r\n        component: null,\r\n      }\r\n    }\r\n\r\n    async componentDidMount() {\r\n      const { default: component } = await importComponent()\r\n      this.setState({\r\n        component: component,\r\n      })\r\n    }\r\n\r\n    render() {\r\n      const C = this.state.component\r\n      return C ? <C {...this.props} /> : null\r\n    }\r\n  }\r\n\r\n  return AsyncComponent\r\n}\r\n\r\nexport default AsyncRoute\r\n```\r\n\r\n然后使用高阶组件包装即可\r\n\r\n```jsx\r\n<Route\r\n  path={'/system/task'}\r\n  component={AsyncRoute(() => import('../../index/HelloWorld'))}\r\n/>\r\n```\r\n\r\n> 注：高阶组件和高阶函数类似，指的是接收一个组件/返回一个组件的组件。\r\n\r\n### 代码组织\r\n\r\n- 导出：tsx/jsx 使用默认导出，避免需要高阶函数包装的场景\r\n- 优先使用函数式组件\r\n- src\r\n  - pages：页面级的组件\r\n    - component：页面级组件\r\n  - components：非页面相关的通用组件\r\n  - assets：静态资源\r\n\r\n### 命名规范\r\n\r\n- React\r\n  - 组件：必须使用大写驼峰，包括使用组件亦然\r\n  - store\r\n    - 必须使用 .store 后缀以区分普通 ts 文件\r\n    - 组件级 store 必须与组件名保持一致，例如 `Login` 组件对应的即为 `Login.store.ts`\r\n- CSS\r\n  - css 中的 class 必须使用小写驼峰命名法，避免 css module 找不到（cra 不会自动处理转换）\r\n  - 优先使用 `.module.css` 而非 `.css`，避免全局样式污染\r\n  - 页面级 css 必须与组件名保持一致，例如 `Login` 组件对应的即为 `Login.module.css`\r\n  - 非 css module 的代码必须使用 `\"\"` 而非 `{''}`\r\n\r\n### 修改默认配置\r\n\r\ncra 默认提供了脚本命令 `reject`，用于将 cra 封装的配置全部解压出来 -- 当然，此操作是不可逆的！但除了这种破坏性的方式之外，也有人找到了和 vue-cli 中类似的方式，不过需要第三方包 `react-app-rewired` 的支持。\r\n\r\n并在根目录添加配置文件 `config-overrides.js`，里面暴露出一个函数，即可修改 cra 的默认配置了。\r\n\r\n下面是一个简单的示例\r\n\r\n```js\r\nconst WorkerPlugin = require('worker-plugin')\r\n\r\n/* config-overrides.js */\r\nmodule.exports = function override(config, env) {\r\n  //region WebWorker 配置\r\n\r\n  //do stuff with the webpack config...\r\n  config.output.globalObject = 'this'\r\n  if (!config.plugins) {\r\n    config.plugins = []\r\n  }\r\n  config.plugins.push(new WorkerPlugin())\r\n\r\n  //endregion\r\n\r\n  return config\r\n}\r\n```\r\n\r\n## 重点\r\n\r\n### this 的值\r\n\r\n在 `class` 中使用箭头函数以直接绑定当前组件的实例，尽量不要使用 `function`，否则 `this` 可能是不明确的。\r\n\r\n```jsx\r\nimport React, { Component } from 'react'\r\n\r\nclass HelloWorld extends Component {\r\n  logMsg = () => {\r\n    console.log('msg')\r\n  }\r\n  render() {\r\n    return (\r\n      <div>\r\n        <h1>hello world</h1>\r\n        <button onClick={this.logMsg}>打印</button>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default HelloWorld\r\n```\r\n\r\n### CSS 样式隔离\r\n\r\ncra 创建的项目默认支持 css module，是 react 项目流行的一种 CSS 隔离方案。\r\n\r\n使用步骤\r\n\r\n1. 为需要的 css 文件使用 `.module.css` 后缀名\r\n2. 通过 `import styles from '*.module.css'` 在 `tsx` 中引入\r\n3. 在 `className={styles.*}` 使用 class 样式\r\n\r\n示例\r\n\r\n```css\r\n.helloWorld {\r\n  background-color: #000;\r\n}\r\n```\r\n\r\n```jsx\r\nimport styles from 'HelloWorld.module.css'\r\n\r\nexport default function HelloWorld() {\r\n  return <div className={styles.helloWorld}>hello world</div>\r\n}\r\n```\r\n\r\n注：\r\n\r\n- 此处的 `import styles from '*.module.css'` 不支持命名导入\r\n- 此处实现的逻辑和 Vue 是一致的，只要使用了其中一个样式 `class`，则整个文件都会引入\r\n- CSS 只要被引入了，就不会被删除，即便组件被销毁了亦然，所以页面内的 CSS 只会增加，不会减少\r\n\r\n如何添加多个，默认使用 cra 创建的项目支持使用模板字符串\r\n\r\n```jsx\r\nclassName={`${styles.className1} ${styles.className2}`}\r\n```\r\n\r\n看起来很丑？可以试试 [classnames](https://github.com/JedWatson/classnames)\r\n\r\n```jsx\r\nimport classNames from 'classnames'\r\n\r\nclassName={classNames(globalStyles.global, globalStyles.margin)}\r\n```\r\n\r\n但仍然很丑，正如 Sindre Sorhus 所说：[React 把简单的事情变复杂，复杂的事情变简单](https://twitter.com/sindresorhus/status/1001355913930858502)\r\n\r\n另一种个 API 是 `classNames.bind`\r\n\r\n```jsx\r\nimport classNames from 'classnames'\r\nconst cx={classNames.bind(globalStyles)}\r\nclassName={cx('global', 'margin')}\r\n```\r\n\r\n但这会让 WebStorm 损失所有的 CSS 关联，影响了包括代码提示/跳转/重构等功能，考虑到维护成本实在得不偿失。\r\n\r\n还有人提出了 typed css module，为所有的 `.module.css` 生成 `.d.ts` 类型定义，但这会和 css in js 一样丧失 css 预处理器的优势 ---- 并且，所有的工具链都需要重新支持这种关联，将之认为是 css。\r\n\r\n> 参考\r\n>\r\n> - [Css Modules by Example](https://www.javascriptstuff.com/css-modules-by-example/)\r\n> - [添加 CSS 模块样式表](https://create-react-app.dev/docs/adding-a-css-modules-stylesheet/)\r\n> - [babel-plugin-react-css-modules](https://github.com/gajus/babel-plugin-react-css-modules)\r\n\r\n### 引入图片\r\n\r\n在任何一个项目中，都少不了引入图片的需求。而 React 中，并未像 Vue 对 `img, audio, video` 这些标签进行特殊处理，以支持直接使用路径即可将对应的媒体文件打包进来，React 需要使用 `import img from '*'` 的**原始**形式让 webpack **知道**这是一个需要打包的资源。\r\n\r\n例如\r\n\r\n```jsx\r\nimport img from 'img.png'\r\n\r\nfunction render() {\r\n  reutrn(<img src={img} alt=\"img\" />)\r\n}\r\n```\r\n\r\n而对于 SVG 类型的图片，React 支持使用组件的形式引入。\r\n\r\n```jsx\r\nimport { ReactComponent as IconAudio } from '../../assets/icon/icon-audio.svg'\r\n\r\nfunction render() {\r\n  reutrn(<IconAudio />)\r\n}\r\n```\r\n\r\n### slot\r\n\r\n两种方案\r\n\r\n1. 使用 `{props.children}`，和 vue 的 `slot:default` 几乎一样，只是不能通过子组件传递参数。\r\n2. 如果需要传递多个命名 `slot`，则可以直接为 `props` 属性赋值为组件。例如 `title={<div>hello world</div>}`\r\n3. 如果需要使用子组件传参的话需要使用函数式组件的形式。例如 `title={value => <div>{value}</div>}`\r\n\r\n> 吐槽：函数式已经是政治正确了。\r\n\r\n使用函数式的 `slot` 时必须检查函数是否存在，如果不存在则不要调用，不像是 vue 中的 `slot` 是自动处理这一步的。\r\n\r\n```jsx\r\n{\r\n  this.props.tableOperate && this.props.tableOperate(this.state.innerValue)\r\n}\r\n```\r\n\r\n### watch 监听 props\r\n\r\n```jsx\r\ncomponentDidUpdate(prevProps: PropsType) {\r\n  // 典型用法（不要忘记比较 props）：\r\n  if (this.props.value !== prevProps.value) {\r\n    this.setState({\r\n      innerValue: this.props.value,\r\n    })\r\n  }\r\n}\r\n```\r\n\r\n### 生命周期\r\n\r\n相比于 Vue 的生命周期，React 显然更加**复杂**与**混乱**，而且，老实说有时候真的很难用。\r\n\r\n例如非常常见的生命周期 `componentWillUpdate`，它承担的责任实在是太多了，不仅 `watch` `state/props` 中的数据要用这个，连 React Router 的路由变化同样依赖于此。\r\n\r\n下面列出最常用的一些生命周期以及典型用例\r\n\r\n- `render`：只要 state 变化就会触发重新渲染，等价于 vue 中渲染模板 HTML 中的内容\r\n- `shouldComponentUpdate`：state 或者 props **变化前**就会执行，时机上早于 `render`。等价于 vue `beforeUpdate`，但可以在这个方法内 `return false` 阻止视图更新。\r\n- `componentDidUpdate`：state 或者 props **变化后**就会执行，时机上晚于 `render`。等价于 vue `updated`。\r\n  多用于监听一些数据变化执行一些副作用操作，但包含的种类可能会非常多。\r\n\r\n  > 注：此处 vue 中将之分为 `updated/watch/beforeRouteUpdate`，而在 React 中，全部由 `componentDidMount` 承担这个责任。\r\n\r\n- `componentDidMount`：当组件渲染**完成后**就会执行，时机上晚于 `render`，等价于 vue `mounted`。\r\n  多用于执行一些初始化操作，除非逻辑特别简单，否则不要在这个函数里放具体执行逻辑代码，而是专门写初始化函数在这里调用。\r\n- `UNSAFE_componentWillMount`：在组件渲染**完成前**就会执行，等价于 vue `beforeMount`，但被废弃了，替代解决方案参考 [怎么在没有 `created` 生命周期的情况下初始化数据并保证用户看不到默认空数据](#怎么在没有-created-生命周期的情况下初始化数据并保证用户看不到默认空数据)。\r\n- `componentWillUnmount`: 组件即将被销毁前调用，等价于 vue `beforeDestroy`。\r\n\r\n### 简化 state 修改\r\n\r\n使用 `setState` 很烦的一点是当你需要深度为某个属性赋值的时候，要为该属性上面所有的对象全部使用 `...` 或者其他方式拷贝一遍。\r\n\r\n例如\r\n\r\n```ts\r\nthis.setState({\r\n  user: {\r\n    ...this.state.user,\r\n    address: {\r\n      ...this.state.user.address,\r\n      city: newCity,\r\n    },\r\n  },\r\n})\r\n```\r\n\r\n当有多个属性需要赋值时就尤其的繁琐，而 [immerjs](https://github.com/immerjs/immer) 正好可以解决这种痛点\r\n\r\n使用 immer 重构之后\r\n\r\n```ts\r\nthis.setState(produce(this.state, draft => {\r\n  draft.user.address.city = newCity\r\n})\r\n```\r\n\r\n代码变得很简单了，虽然看起来是直接赋值，不过 immer 使用了 `Proxy` 和 `Object.freeze` 实现了对使用者友好的不可变数据修改，具体参考 。\r\n\r\n### React Hooks\r\n\r\nReact Hooks 是在 React 16.8 之后添加的一项新特性，一如既往，很多人又是吹的天花乱坠。老实说最开始 React Hooks 流行并且在各个地方大肆宣传时，吾辈非常讨厌它，因为它又向函数式靠近了一步----函数式政治正确真的很讨厌！所以，自正式学习 React 以来，吾辈都没有接触过 React Hooks，都是用 Class Component 实现组件。\r\n但现在，架不住好奇心和一些朋友的推荐，吾辈稍微看了一下这个新特性。\r\n\r\n它提供了两个主要的 API：\r\n\r\n- `useState`：声明一些可变状态\r\n- `useEffect`：声明一些副作用代码\r\n\r\n使用看起来很简单\r\n\r\n```jsx\r\nimport React, { useEffect, useRef, useState } from 'react'\r\n\r\nconst HelloHooks: React.FC = function() {\r\n  //region 计数器\r\n\r\n  const [count, setCount] = useState(1)\r\n  const [list, setList] = useState<string[]>([])\r\n  const countAdd = () => setCount(count + 1)\r\n  useEffect(() => {\r\n    console.log('count changed: ', count)\r\n    setList(\r\n      Array(count)\r\n        .fill(0)\r\n        .map((_, i) => `第 ${i + 1} 个元素`),\r\n    )\r\n    //监听 count 变化\r\n  }, [count])\r\n\r\n  //endregion\r\n\r\n  //region 自动聚焦输入框\r\n\r\n  const inputRef = useRef<HTMLInputElement>(null as any)\r\n  useEffect(() => {\r\n    inputRef.current.focus()\r\n    //不监听任何值变化，只在第一次渲染运行\r\n  }, [])\r\n\r\n  //endregion\r\n\r\n  return (\r\n    <div>\r\n      <div>\r\n        <input\r\n          ref={inputRef}\r\n          value={count}\r\n          type=\"number\"\r\n          onChange={e => setCount(parseInt(e.target.value))}\r\n        />\r\n        <button onClick={countAdd}>增加</button>\r\n      </div>\r\n      <ul>\r\n        {list.map((v, i) => (\r\n          <li key={i}>{v}</li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default HelloHooks\r\n```\r\n\r\n可以看到，上面用 `useState/useEffect` 两个函数实现了一些常见的功能：`state, componentDidMount, componentDidUpdate`，`useEffect` 甚至默认支持类似 vue `watch` 的使用方式。\r\n\r\n同时，使用 Hooks 可以轻易地封装出 `useModel`, vue 中的 `watch/computed` 甚至原生自带了！\r\n\r\n- `useMemo`：当依赖变化时计算属性\r\n- `useCallback`：当依赖变化时执行回调\r\n\r\n然而，Hooks 终究不是万能。\r\n\r\n- 使用 Hooks 封装控制 DOM 相关的代码做不到，例如使用高阶组件实现的根据某些条件控制组件是否加载。\r\n- 使用 Hooks 无法实现全部的生命周期，例如 `shouldComponentUpdate`。\r\n- Hooks `useEffect` 中调用的外部函数，无法即时获取到所有最新的 `state`，即便它们与 `useEffect` 同级（需要使用 `useCallback` 包装）\r\n- 使用 Hooks 会让函数变得很大，对开发人员的要求比之前更高（与 vue 3 的函数式 API 一样，都是由开发者自己完全控制代码块的分割）\r\n\r\n> 更多有关 React Hooks 的介绍，请参考：<https://zh-hans.reactjs.org/docs/hooks-intro.html> 以及 [Vue Composition API 与 React Hooks 的对比](https://vue-composition-api-rfc.netlify.com/#comparison-with-react-hooks)。\r\n\r\n<!-- ### React Props\r\n\r\nReact props 基本上能传递任何东西，所以承担了 vue 中的多个特性。\r\n\r\n- `props` 传递参数\r\n- `$emit` 传递事件\r\n- `slot` 传递组件\r\n\r\n从这点来看，React 真是 **少即是多** 的范例。 -->\r\n\r\n## 常见问题\r\n\r\n### React 有什么缺点\r\n\r\n核心缺点是官方对开发者体验不上心，许多周边项目或功能都没有 vue 的对等项友好。\r\n\r\n| 对比           | react                | vue                       |\r\n| -------------- | -------------------- | ------------------------- |\r\n| 脚手架         | create-react-app     | vite/vue-cli              |\r\n| 文档生成工具   | docusaurus           | vuepress                  |\r\n| 路由           | react router         | vue router                |\r\n| css 局部作用域 | css module/css in js | 内置完整的 css 作用域支持 |\r\n| 函数式         | react hooks          | vue composition           |\r\n\r\n### 怎么在没有 `created` 生命周期的情况下初始化数据并保证用户看不到默认空数据\r\n\r\n在 vue 中，吾辈经常在 created 生命周期中加载数据，避免用户看到默认的空数据，然而，React 中却没有这个生命周期，所以需要额外的处理。\r\n\r\n> 注：其实 vue 中用户也有可能看到空数据，但因为 Ajax 请求数据的速度也比较快，所以默认可以不用处理。\r\n\r\n一个可能解决方案是在指定元素外面包一层，在页面数据未加载之前，在元素上方添加一个 Loading 遮罩层提示**正在加载中**，等到数据加载完成后删除浮层。\r\n\r\n下面是一个简单的实现\r\n\r\n```css\r\n/* ComponentLoading.module.css */\r\n.componentLoadingDialog {\r\n  position: absolute;\r\n  left: 0;\r\n  top: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  z-index: 10;\r\n  background-color: #fff;\r\n}\r\n```\r\n\r\n```jsx\r\n// ComponentLoading.tsx\r\nimport React from 'react'\r\nimport { Spin } from 'antd'\r\nimport styles from './ComponentLoading.module.css'\r\n\r\ntype PropsType = {\r\n  /**\r\n   * 是否显示 loading?\r\n   */\r\n  isLoading: boolean\r\n  tip?: string\r\n}\r\n\r\n/**\r\n * 控制 Ajax 请求未完成前某个区域不展示默认数据\r\n * @param props\r\n * @constructor\r\n */\r\nconst ComponentLoading: React.FC<PropsType> = function(props) {\r\n  const { isLoading, tip = '正在加载中。。。' } = props\r\n  return (\r\n    <div style={{ position: 'relative' }}>\r\n      {isLoading && (\r\n        <div className={styles.componentLoadingDialog}>\r\n          <Spin tip={tip} />\r\n        </div>\r\n      )}\r\n\r\n      {/*注：默认会渲染 children 组件*/}\r\n      {props.children}\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default ComponentLoading\r\n```\r\n\r\n### React 和 vue 3 的对比\r\n\r\nvue 3 新增了 `Function-base` 的组件，看起来很像 React Hooks，但目前仍然无法在生产中实用。\r\n\r\n目前看来有以下缺点\r\n\r\n1. IDE 支持不好\r\n2. TS 不能解决 Vue 中的一些问题，尤其是对于模板层面简直无能为力\r\n3. Vue 3 函数式组件没有覆盖之前所有的功能\r\n4. 周边生态目前没有早期支持的迹象\r\n\r\n关于第二和第三点，吾辈认为这是 Vue 使用模板带来的一些天然的问题，几乎不可能解决。\r\n\r\n而 React 和 TS 结合比 Vue 要完善很多，包括类型校验完全使用 TS 而非自定义运行时校验机制。\r\n\r\n> 参考：\r\n>\r\n> - [Vue composition api comparison with React Hooks](https://vue-composition-api-rfc.netlify.com/#comparison-with-react-hooks)\r\n> - [谁能大致说下 vue 和 react 的最大区别之处？](https://aweiu.com/%E8%B0%81%E8%83%BD%E5%A4%A7%E8%87%B4%E8%AF%B4%E4%B8%8Bvue%E5%92%8Creact%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%BA%E5%88%AB%E4%B9%8B%E5%A4%84%EF%BC%9F/)\r\n\r\n### 开发环境代理\r\n\r\n开发环境配置代理几乎是必用功能。\r\n\r\n简单的情况直接在 `package.json` 中使用 `proxy` 字段即可\r\n\r\n> 参考：[Proxying API Requests in Development](https://create-react-app.dev/docs/proxying-api-requests-in-development)\r\n\r\n复杂的情况相比于 vue-cli 将全部配置统一在 `vue.config.js` 中，cra 看起来仍是分散式的。\r\n\r\n步骤\r\n\r\n1. 安装中间件 `yarn add -D http-proxy-middleware @types/`\r\n2. 创建文件 `src/setupProxy.ts`\r\n3. 编写配置\r\n\r\n   ```ts\r\n   import proxy from 'http-proxy-middleware'\r\n   const fs = require('fs-extra')\r\n   const path = require('path')\r\n\r\n   /**\r\n    * 开发环境代理\r\n    * @param app\r\n    * @return {string|*}\r\n    */\r\n   module.exports = function (app: any) {\r\n     const proxyConfig: proxy.Config = {\r\n       target: 'https://localhost:8000',\r\n       changeOrigin: true,\r\n       secure: false,\r\n       ws: true,\r\n       pathRewrite(api: string) {\r\n         const mockApiList = fs.readJSONSync(\r\n           path.resolve(__dirname, './config/mockApiList.json'),\r\n         )\r\n         return (\r\n           api +\r\n           (mockApiList.some((mockApi: string) => api.includes(mockApi))\r\n             ? '?mock=default&errCode=200'\r\n             : '')\r\n         )\r\n       },\r\n     }\r\n\r\n     app.use(proxy('/api', proxyConfig))\r\n   }\r\n   ```\r\n\r\n> 参考：\r\n>\r\n> - [http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware)\r\n> - [一篇读懂 http-proxy-middleware](https://juejin.im/post/5bd13c5ce51d457a203cebf4)\r\n\r\n### 怎么打包成不依赖于部署路径的 dist\r\n\r\n1. 修改 `package.json` 中字段 `homepage` 的值为 `.`\r\n2. 使用 react router 中的 hash mode，具体而言就是修改 _index.tsx_ 中使用如下代码，关键是 `HashRouter`\r\n\r\n   ```tsx\r\n   import React from 'react'\r\n   import ReactDOM from 'react-dom'\r\n   import { HashRouter } from 'react-router-dom'\r\n   import App from './App.tsx'\r\n\r\n   ReactDOM.render(\r\n     <React.StrictMode>\r\n       <HashRouter>\r\n         <App />\r\n       </HashRouter>\r\n     </React.StrictMode>,\r\n     document.getElementById('app'),\r\n   )\r\n   ```\r\n\r\n### 为什么 react hooks 总是有奇怪的问题\r\n\r\n根源在于 react 的 render 函数是多次执行，导致如果没有正确的声明依赖项或者顺序，就会导致出现奇怪的问题。\r\n\r\n典型的依赖声明问题\r\n\r\n> 参考: <https://codesandbox.io/s/react-hooks-useeffect-bixuzhengquedeshengmingyilaibaoguaqineibudiaoyongdeqitahanshudeyilaixiang-4iy1x>\r\n\r\n典型的顺序问题\r\n","createdTime":1580652937930,"updatedTime":1625723680871,"resources":[],"tags":[{"id":"5a7776c036cf46738cb6a729934a1a7b","title":"react","parent_id":""},{"id":"99c5001ffe5b42a6995369049b5f5aa9","title":"待更新","parent_id":""},{"id":"d86454b85c8f4c38aef6fa1575487e7f","title":"vue","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"253e3c2202a24fefbf6f6249ea472626","title":"Android 上最好的浏览器 Kiwi browser","body":"## 场景\n\n> [官网](https://kiwibrowser.com/)\n\n或许对于现在很多人来说，浏览器是一个很少使用的 App，因为所有功能都可以在 App 做，不需要使用浏览器。一方面，是由于国内的大环境就是把用户当成傻瓜（事实上，即便是吾辈目前所在的公司，在 UI/UX 设计方面也倾向于将用户当成傻瓜），导致用户真的是越来越傻瓜，甚至遇到了除了微信其他的都不怎么会用的地步，更何况浏览器这种“**高端**”的 App 呢？\n然而对于某些特定人群来说，尤其是不喜欢安装太多 App 的人来说，浏览器几乎是 App 上数一数二的应用了，甚至称之为互联网的入口都不为过（现在一般的傻瓜式用户大概认为微信才是吧，缅怀曾经互联网都是通过浏览器使用的时代）。\n在使用过 _UC => Chrome => FireFox => Kiwi browser_ 之后，吾辈可以确定的说，Kiwi browser 是目前 Android 上最好的浏览器，其中尤以支持 Chrome PC 版的 Plugin 最为有名。\n\n## 使用过的浏览器\n\n### UC 浏览器（国内版）\n\n在早期吾辈使用的浏览器中，UC 绝对是当年（2016 年之前）使用体验非常好的浏览器，直到后来被阿里系收购，导致它逐渐充斥着各种广告，甚至首先开辟出了[浏览器收费](http://kf.uc.cn/self_service/web/faqdetails-8311412_9210815_20559164_5.html)这一跨世纪倒车壮举。\n\n![UC 国内版首页](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141319.jpg)\n![UC 国内版搜索](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141320.png)\n\n> 附：这里的跨世纪倒车壮举指的是自从浏览器始祖 Netscape 被 MS 的 IE 使用系统捆绑 + 免费的策略干掉以后，后来流行起来的浏览器还从未出现过收费的（或许是吾辈孤陋寡闻了？）\n> 附：所有的国内浏览器都有内置的黑名单，例如 GitHub 上的 996 icu 就被国内浏览器屏蔽了，不仅仅是墙，就连浏览器都是墙的帮凶。参考：[国外网站无法访问？](http://kf.uc.cn/self_service/web/faqdetails-9212655_9212659_20389994_6.html)\n\n### UC 浏览器（国际版）\n\nUC 国际版，这是一个比较有趣的版本，没有国内版那么多花俏无用的功能，但同时不支持简体中文（当然支持繁体中文），同时保留了 UC 的核心功能——怪不得手机上 UC 的使用占有率很高呢！\n它默认支持的主要功能如下\n\n- 广告过滤\n- 黑暗模式\n- 手势方面几近完美\n- 下载功能\n- 自带 QR\n\n![UC 国际版首页](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141317.png)\n![UC 国际版搜索](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141318.png)\n\n看起来没什么太大的问题，然而，它却在隐私方面做的一如既往的烂，参考：[美媒:中国人上网须防泄露隐私 浏览器存安全隐患](https://web.archive.org/web/20180228041423/http://news.163.com/16/0330/10/BJDBF3TT00014AEE.html)\n\n### Chrome for Android\n\n后来，吾辈在 PC 上先后遇到了 FireFox 和 Chrome，简直比国内的各种浏览器干净整洁了一百倍。在实际使用过相当长的一段时间后，吾辈最终在 PC 上选择了 Chrome，手机上也安装了 Chrome 进行网页浏览，它的速度非常理想，使用体验也还算不错，尤其是翻译功能更是被完整地保留了下来。唯有一点，插件功能被整个砍掉了。\n\n![Chrome 首页](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141709.png)\n![Chrome 搜索](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141404.png)\n![Google 翻译功能](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141403.png)\n\n> 为什么 Chrome For Android 不支持插件？虽然官方说是为了使之能够在较旧的浏览器上也能正常运行，但实际上应该有两个原因\n>\n> 1. Android 是 Google 自己的，而 Google 对于 App 的控制力要超过网页，所以为了让用户使用 App，Google 不原因让用户更多的浏览网页。\n> 2. 大约 70％的 chrome 用户在 android 和 ios 端，只有 30％的 chrome 用户在台式机和 mac 上。谷歌知道，如果他们在智能手机上引入扩展功能，那么由于广告拦截器的存在，他们将损失很多钱，而且大多数互联网用户由于舒适性，大部分时间都倾向于将智能手机用于互联网。Google 在这里玩一个聪明的游戏。参考：<https://www.quora.com/Why-arent-there-any-extensions-for-Google-Chrome-on-Android>\n\n### FireFox for Android\n\n所以，在知道 FireFox 在 Android 上亦支持插件后，吾辈感觉它就是吾辈理想中的手机浏览器，吾辈在手机上也开始尝试使用 FireFox 了。但事与愿违，它真的太慢了。。。在使用体验上和 Chrome 无法相提并论,而且翻译插件的支持不完善导致有时候想在移动端阅读大量英文网页时还需要切到 Chrome.\n\n> 注：FireFox 的桌面版插件支持存在一些问题，同时插件官方一直未曾修复，这也是吾辈放弃 FireFox 的重要原因之一。\n\n![FireFox 首页](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141432.png)\n![FireFox 搜索](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141433.png)\n\n### Kiwi browser\n\n最终，吾辈遇到了 Kiwi browser，诚然，它也不是十全十美的，也有很多缺点。\n\n- 默认主页的新闻资讯很讨厌，而且还无法关闭。\n- 翻译功能没有 Chrome 强大，没有**就地**全文翻译的功能\n- 不是一个非常流行的浏览器，没有桌面版本，没有同步功能\n\n但有一个及其突出的优点，足以掩盖以上的所有缺点 -- 支持 Chrome 桌面版插件。\n\n![Kiwi 首页](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141349.png)\n![Kiwi 翻译](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200501141348.png)\n\n### 微型浏览器\n\n事实上，吾辈也曾断断续续地使用过一些微型浏览器，在功能上做的比较简洁（但并不意味着不够用），但内核却薄弱不堪（其实就是用系统默认浏览器的内核）。\n包括但不限于以下列表\n\n- [via 浏览器](https://play.google.com/store/apps/details?id=mark.via.gp&hl=en_US)\n- [h5 浏览器](https://www.coolapk.com/apk/org.noear.h5)\n- [X 浏览器](https://www.xbext.com/)\n\n其他吾辈没有使用过的浏览器可以参考：[手机浏览器有哪些？安卓平台良心浏览器推荐](https://m.xianjichina.com/news/details_145337.html)\n\n虽然这些微型浏览器理念很好：**少即是多，简单就是美！**，但实际上，这些没有内核的浏览器很多地方，尤其是性能方面，仍然受限于系统默认浏览器。大多数自带的插件系统，往往只是实现了一套加载 `*.user.js` 的机制罢了，而且生态之小与 Chrome/FireFox 这些主流其相比往往是天壤之别。\n\n## Kiwi browser 配置\n\n### Kiwi browser 推荐的插件\n\n- [uBlock Origin](https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm)：广告过滤\n- [Dark Reader](https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh)：为所有网站加上黑色主题，大部分情况下都还不错\n- [Tabliss](https://chrome.google.com/webstore/detail/tabliss-a-beautiful-new-t/hipekcciheckooncpjeljhnekcoolahp)：美丽的新标签页\n- [LastPass](https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd)：全平台密码管理器\n- [Tampermonkey](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN)：油猴脚本管理器\n\n> 桌面的 Chrome 使用建议可以参考：[优化 Google Chrome 的使用体验](:/cdeb250dd4e04b168bc608cc9a118697)\n\n### 二维码扫描\n\n有时候需要使用二维码扫描使用手机去打开某个网站，而 Kiwi 并没有自带这个功能，所以需要配合 App [二维码扫描](https://play.google.com/store/apps/details?id=mark.qrcode) 食用。\n","createdTime":1588303174785,"updatedTime":1624511393510,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"ac14d8147c2b4ee38414b1a4f66fb199","title":"Spring Mongo Data 使用","body":"## 前置要求\n\n本文假设你已经了解或知道以下技能，尤其而且是勾选的内容。\n\n- [x] Gradle\n- [x] SpringBoot\n- [x] MongoDB\n- [x] SpringBoot 集成 MongoDB\n\n> 注：本文不谈 SpringBoot 如何整合 MongoDB，如果需要可以去吾辈的另一篇记录 [将 Mybatis/MongoDB 集成到 SpringBoot 中的示例](:/6427d24f405346eea9fb15e9f317babb) 查看，并且本文以项目 [spring-boot-mybatis-plus-mongo-example](https://github.com/rxliuli/spring-boot-mybatis-plus-mongo-example) 为基础作为说明。\n\n## 使用\n\n> 注：Spring Data MongoDB 是 Spring Data 的一部分，下面统一使用 MongoData 来称呼。\n\n### 继承 MongoRepository<T, ID> 使用命名方法\n\n集成了 MongoData 之后，我们可以选择让 Dao 继承 `MongoRepository<T, ID>` 模板以获得通用方法，并且，可以通过特定方式的命名方法让 MongoData 来帮我们自动实现。\n\n例如\n\n```java\n@Repository\npublic interface UserInfoLogRepository extends MongoRepository<UserInfoLog, Long>, CustomUserInfoLogRepository {\n    /**\n     * 根据 id 查询用户日志信息\n     *\n     * @param id 查询的 id\n     * @return 用户日志\n     */\n    UserInfoLog findUserInfoLogByIdEquals(Long id);\n}\n```\n\n这个方法将会被 MongoData 自动实现，而我们做的只是让接口方法名符合 MongoData 的命名规范罢了。\n\n这里来说明一下 `findUserInfoLogByIdEquals` 方法，将之拆分开来\n\n- `find`: 代表查询的意思，可以想象成 SQL 中的 `select`\n- `UserInfoLog`: 代表查询的类型，可以想象成 `select` 中的表名（非必须，默认为当前 `MongoRepository` 的实体泛型类）\n- `By`: 代表着条件的开始，可以想象成 SQL 中的 `where`\n- `Id`: 代表着条件中的字段，可以想象成 `where` 下的条件字段名\n- `Equals`: 代表条件的操作，可以想象成 `where` 下的条件操作，此处等价于 `=`\n\n是的，MongoData 会自动根据方法名创建具体的实现，而我们要做的，仅仅是让方法名复合 MongoData 的规范而已。\n\n甚至于，我们可以添加更多的条件，例如下面的 `findUserInfoLogsByUserIdEqualsAndLogTimeGreaterThanEqualAndOperateRegex`\n\n```java\n/**\n  * 根据用户 id/记录时间/操作说明查询用户日志\n  *\n  * @param userId  用户 id\n  * @param logTime 记录时间\n  * @param operate 操作说明\n  * @return 用户日志\n  */\nList<UserInfoLog> findUserInfoLogsByUserIdEqualsAndLogTimeGreaterThanEqualAndOperateRegex(Long userId, LocalDateTime logTime, String operate);\n```\n\n当吾辈第一次看到这么长的方法名时（是的，足足有 71 个字符组成），也只能惊呼：**Oh my Gad!**  \n这对业务层的调用实在是太过于痛苦了，尤其而且能逼死强迫症（例如吾辈），所以下面就说一种更加灵活的解决方案！\n\n### 使用 MongoOperations 创建更加灵活的查询\n\n修改 `UserInfoLogRepository` 并定义 `listByParam()` 以替代上面的 `findUserInfoLogsByUserIdEqualsAndLogTimeGreaterThanEqualAndOperateRegex()` 方法\n\n```java\npublic interface UserInfoLogRepository {\n    /**\n     * 根据一些参数查询用户信息列表\n     *\n     * @param userInfoLog 参数对象\n     * @return 用户信息列表\n     */\n    List<UserInfoLog> listByParam(UserInfoLog userInfoLog);\n}\n```\n\n创建实现类 `UserInfoLogRepositoryImpl` 并实现 `listByParam()` 方法。这里注入 `MongoOperations` MongoDB 操作模板，它的实现类实际上是 `MongoTemplate`，然后使用 `Criteria` 定义复杂的查询。\n\n```java\n@Repository\npublic class UserInfoLogRepositoryImpl implements UserInfoLogRepository {\n    @Autowired\n    private MongoOperations mongoOperations;\n\n    @Override\n    public List<UserInfoLog> listByParam(UserInfoLog userInfoLog) {\n        final Criteria criteria = new Criteria();\n        if (userInfoLog.getUserId() != null) {\n            criteria.and(\"userId\")\n                    .is(userInfoLog.getUserId());\n        }\n        if (userInfoLog.getLogTime() != null) {\n            criteria.and(\"logTime\")\n                    .gte(userInfoLog.getLogTime());\n        }\n        if (userInfoLog.getOperate() != null) {\n            criteria.and(\"operate\")\n                    .regex(userInfoLog.getOperate());\n        }\n        return mongoOperations.find(new Query(criteria), UserInfoLog.class);\n    }\n}\n```\n\n可以看到，`listByParam()` 相对而言更加优雅，不过代码量上也有增加就是了。事实上，对于复杂的查询，最好使用这种方式进行查询。\n\n### 集合 MongoRepository 和 MongoOperations\n\n总之，上面两种方式各有优缺点。`MongoRepository` 对于大部分常见的操作基本都可以正常替代，而 `MongoOperations` 比之灵活得多，我们是否只能**鱼与熊掌不可兼得**呢？  \n当然不是，MongoData 在设计之初便充分权衡过方便与灵活性的平衡点，所以，我们可以同时使用它们！\n\n具体使用步骤如下\n\n#### 自定义更加复杂的 Dao 接口\n\n该接口定义需要自己实现的方法，需要同时被 `UserInfoLogRepository` 和 `UserInfoLogRepositoryImpl` 实现\n\n```java\npublic interface CustomUserInfoLogRepository {\n    /**\n     * 根据一些参数查询用户信息列表\n     *\n     * @param userInfoLog 参数对象\n     * @return 用户信息列表\n     */\n    List<UserInfoLog> listByParam(UserInfoLog userInfoLog);\n}\n```\n\n#### 定义一些简单操作的 Dao 接口\n\n注意，这里同时继承了 `CustomUserInfoLogRepository`\n\n```java\npublic interface UserInfoLogRepository extends MongoRepository<UserInfoLog, Long>, CustomUserInfoLogRepository {\n    /**\n     * 根据 id 查询用户日志信息\n     *\n     * @param id 查询的 id\n     * @return 用户日志\n     */\n    @Nullable\n    UserInfoLog findUserInfoLogByIdEquals(Long id);\n\n    /**\n     * 根据用户 id/记录时间/操作说明查询用户日志\n     *\n     * @param userId  用户 id\n     * @param logTime 记录时间\n     * @param operate 操作说明\n     * @return 用户日志\n     */\n    List<UserInfoLog> findUserInfoLogsByUserIdEqualsAndLogTimeGreaterThanEqualAndOperateRegex(Long userId, LocalDateTime logTime, String operate);\n}\n```\n\n#### 定义实现 UserInfoLogRepositoryImpl 类\n\n数据仓库 `UserInfoLogRepository` 的实现类，但请务必注意，实现类继承的是 `CustomUserInfoLogRepository` 接口，而非本应该继承的接口。而且实现类的名字必须是基础接口名 + `Impl`，因为 MongoData 默认使用的实现类就是这个名字。\n\n```java\npublic class UserInfoLogRepositoryImpl implements CustomUserInfoLogRepository {\n    @Autowired\n    private MongoOperations mongoOperations;\n\n    @Override\n    public List<UserInfoLog> listByParam(UserInfoLog userInfoLog) {\n        final Criteria criteria = new Criteria();\n        if (userInfoLog.getUserId() != null) {\n            criteria.and(\"userId\")\n                    .is(userInfoLog.getUserId());\n        }\n        if (userInfoLog.getLogTime() != null) {\n            criteria.and(\"logTime\")\n                    .gte(userInfoLog.getLogTime());\n        }\n        if (userInfoLog.getOperate() != null) {\n            criteria.and(\"operate\")\n                    .regex(userInfoLog.getOperate());\n        }\n        return mongoOperations.find(new Query(criteria), UserInfoLog.class);\n    }\n}\n```\n\n## 常用 API\n\n匹配标准：`Criteria`\n\n| 方法名        | 参数                           | 功能             |\n| ------------- | ------------------------------ | ---------------- |\n| `and`         | `String`                       | 并且             |\n| `not`         | `/Object`                      | 非               |\n| `orOperator`  | `Criteria...`                  | 并且是其他标准   |\n| `andOperator` | `Criteria...`                  | 并且是其他标准   |\n| `is`          | `Object`                       | 等于             |\n| `ne`          | `Object`                       | 不等于           |\n| `le`          | `Object`                       | 小于             |\n| `let`         | `Object`                       | 小于或等于       |\n| `gt`          | `Object`                       | 大于             |\n| `gte`         | `Object`                       | 大于或等于       |\n| `in`          | `Object.../Collection<?>`      | 在其中           |\n| `nin`         | `Object.../Collection<?>`      | 不在其中         |\n| `mod`         | `Number,Number`                | 模运算           |\n| `all`         | `Object.../Collection<?>`      | 包含全部         |\n| `size`        | `int`                          | 长度             |\n| `exists`      | `boolean`                      | 存在             |\n| `type`        | `int/Type...`                  | 结构化数据的类型 |\n| `regex`       | `String/String,String/Pattern` | 正则             |\n| `alike`       | `Example<?>`                   | 匹配到最像的     |\n| `isEqual`     | `Object,Object`                | 是否相等         |\n","createdTime":1587219249395,"updatedTime":1624276645735,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"6427d24f405346eea9fb15e9f317babb","title":"将 Mybatis/MongoDB 集成到 SpringBoot 中的示例","body":"## 前置要求\n\n本文假设你已经了解或知道以下技能，尤其而且是勾选的内容。\n\n- [x] Gradle\n- [x] SpringBoot\n- [x] Mybatis Plus\n- [x] MongoDB\n- [ ] SpringBoot MongoDB Data\n- [ ] H2DB\n- [ ] SpringTest\n\n## 场景\n\n> [GitHub 项目](https://github.com/rxliuli/spring-boot-mybatis-plus-mongo), [Blog 教程](:/6427d24f405346eea9fb15e9f317babb)\n\n需要同时使用 `Mybatis-Plus` 和 `MongoDB`，所以就去了解了一下如何集成它们。\n\n## 集成 Mybatis Plus\n\n### 创建 SpringBoot 项目\n\n使用 SpringIO 创建 SpringBoot 项目，初始依赖选择 `web`, `h2` 两个模块，gradle 配置如下\n\n```gradle\nplugins {\n    id 'org.springframework.boot' version '2.1.3.RELEASE'\n    id 'java'\n}\n\napply plugin: 'io.spring.dependency-management'\n\ngroup = 'com.rxliuli.example'\nversion = '0.0.1-SNAPSHOT'\nsourceCompatibility = '1.8'\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    runtimeOnly 'com.h2database:h2'\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n```\n\n> 注：数据库吾辈这里为了简单起见直接使用了 `H2DB`，真实项目中可能需要配置 `MySQL` 之类。为了简化项目依赖配置文件，所以使用了 Gradle 而非 Maven。\n\n### 引入 Mybatis-Plus 和 MongoDB 依赖\n\n在 `build.gradle` 中引入 `mybatis-plus-boot-starter` 依赖\n\n```gradle\ndependencies {\n    implementation group: 'com.baomidou', name: 'mybatis-plus-boot-starter', version: '3.0.7.1'\n}\n```\n\n### 添加测试数据库\n\n在 _src/resources_ 下创建两个 sql 文件 `schema-h2.sql` 和 `data-h2.sql`，简单的使用 `H2DB` 创建数据库/表并添加数据以供测试使用。\n\n数据库结构：`schema-h2.sql`\n\n```sql\ncreate schema spring_boot_mybatis_plus_mongo;\nuse spring_boot_mybatis_plus_mongo;\n\ncreate table user_info (\n  id   bigint primary key not null,\n  name varchar(20)        not null,\n  age  tinyint            not null,\n  sex  bool               not null\n);\n```\n\n数据库测试数据：`data-h2.sql`\n\n```sql\nuse spring_boot_mybatis_plus_mongo;\n\ninsert into user_info (id, name, age, sex) values (1, 'rx', 17, false);\ninsert into user_info (id, name, age, sex) values (2, '琉璃', 18, false);\n```\n\n### 配置 Mybatis Plus\n\n在 `application.yml` 中添加数据源配置\n\n```yml\n# DataSource Config\nspring:\n  datasource:\n    driver-class-name: org.h2.Driver\n    schema: classpath*:db/schema-h2.sql\n    data: classpath*:db/data-h2.sql\n    url: jdbc:h2:mem:test\n```\n\n### 添加一些实体/Dao/Service\n\n用户信息实体类：`com.rxliuli.example.springbootmybatisplusmongo.entity.UserInfo`\n\n```java\n@TableName(\"user_info\")\npublic class UserInfo implements Serializable {\n    @TableId\n    private Long id;\n    @TableField\n    private String name;\n    @TableField\n    private Integer age;\n    @TableField\n    private Boolean sex;\n\n    public UserInfo() {\n    }\n\n    public UserInfo(Long id, String name, Integer age, Boolean sex) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n        this.sex = sex;\n    }\n\n    // getter()/setter()\n}\n```\n\n用户信息 Dao：`com.rxliuli.example.springbootmybatisplusmongo.dao.UserInfoDao`\n\n```java\n@Repository\npublic interface UserInfoDao extends BaseMapper<UserInfo> {\n}\n```\n\n用户信息业务接口：`com.rxliuli.example.springbootmybatisplusmongo.service.UserInfoService`\n\n```java\npublic interface UserInfoService extends IService<UserInfo> {\n}\n```\n\n用户信息业务接口实现类：`com.rxliuli.example.springbootmybatisplusmongo.service.impl.UserInfoServiceImpl`\n\n```java\n@Service\npublic class UserInfoServiceImpl extends ServiceImpl<UserInfoDao, UserInfo> implements UserInfoService {\n}\n```\n\n### 配置 Mybatis Plus 扫描的路径\n\n在启动类配置 `Mybatis Plus`，这点非常重要，以致于吾辈要单独列出，可能会出现的问题参见 [踩坑](@#踩坑) 部分\n\n```java\n@SpringBootApplication\n@MapperScan(\"com.rxliuli.example.springbootmybatisplusmongo.**.dao.**\")\npublic class SpringBootMybatisPlusMongoApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootMybatisPlusMongoApplication.class, args);\n    }\n}\n```\n\n### 测试使用 Mybatis Plus 的 UserInfoService\n\n测试 Mybatis Plus 中 `IService` 接口的 `list()` 方法\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class UserInfoServiceTest {\n    @Autowired\n    private UserInfoService userInfoService;\n\n    @Test\n    public void list() {\n        final List<UserInfo> list = userInfoService.list();\n        assertThat(list)\n                .isNotEmpty();\n    }\n}\n```\n\n## 集成 MongoDB\n\n### 引入 MongoDB Boot Starter\n\n在 `build.gradle` 中引入 `spring-boot-starter-data-mongodb` 依赖\n\n```gradle\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-data-mongodb'\n}\n```\n\n### 配置 MongoDB\n\n在 `application.yml` 中添加 MongoDB 的配置，现在 `application.yaml` 应该变成了下面这样\n\n```yml\n# DataSource Config\nspring:\n  datasource:\n    driver-class-name: org.h2.Driver\n    schema: classpath*:db/schema-h2.sql\n    data: classpath*:db/data-h2.sql\n    url: jdbc:h2:mem:test\n  data:\n    # Integration mongodb\n    mongodb:\n      uri: mongodb://XXX:XXX@XXX:XXX/XXX\n```\n\n### 添加 Repository\n\n定义一些简单操作的 Dao 接口：`com.rxliuli.example.springbootmybatisplusmongo.repository.UserInfoLogRepository`\n\n```java\n@Repository\npublic interface UserInfoLogRepository extends MongoRepository<UserInfoLog, Long>, CustomUserInfoLogRepository {\n    /**\n     * 根据 id 查询用户日志信息\n     *\n     * @param id 查询的 id\n     * @return 用户日志\n     */\n    UserInfoLog findUserInfoLogByIdEquals(Long id);\n}\n```\n\n自定义更加复杂需求的 Dao 接口：`com.rxliuli.example.springbootmybatisplusmongo.repository.CustomUserInfoLogRepository`\n\n```java\npublic interface CustomUserInfoLogRepository {\n    /**\n     * 根据一些参数查询用户信息列表\n     *\n     * @param userInfoLog 参数对象\n     * @return 用户信息列表\n     */\n    List<UserInfoLog> listByParam(UserInfoLog userInfoLog);\n}\n```\n\n具体的实现类：`com.rxliuli.example.springbootmybatisplusmongo.repository.UserInfoLogRepositoryImpl`\n\n```java\n/**\n * 数据仓库 {@link UserInfoLogRepository} 的实现类，但请务必注意，实现类继承的是 {@link CustomUserInfoLogRepository} 接口，而非本应该继承的接口\n */\npublic class UserInfoLogRepositoryImpl implements CustomUserInfoLogRepository {\n    @Autowired\n    private MongoOperations mongoOperations;\n\n    @Override\n    public List<UserInfoLog> listByParam(UserInfoLog userInfoLog) {\n        final Criteria criteria = new Criteria();\n        if (userInfoLog.getUserId() != null) {\n            criteria.and(\"userId\")\n                    .is(userInfoLog.getUserId());\n        }\n        if (userInfoLog.getLogTime() != null) {\n            criteria.and(\"logTime\")\n                    .gte(userInfoLog.getLogTime());\n        }\n        if (userInfoLog.getOperate() != null) {\n            criteria.and(\"operate\")\n                    .regex(userInfoLog.getOperate());\n        }\n        return mongoOperations.find(new Query(criteria), UserInfoLog.class);\n    }\n}\n```\n\n### 配置 MongoDB 扫描的路径\n\n修改启动类，添加 `@EnableMongoRepositories` 注解用以配置 MongoDB 扫描的 `Repository` 路径\n\n```java\n@SpringBootApplication\n@MapperScan(\"com.rxliuli.example.springbootmybatisplusmongo.**.dao.**\")\n@EnableMongoRepositories(\"com.rxliuli.example.springbootmybatisplusmongo.**.repository.**\")\npublic class SpringBootMybatisPlusMongoApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootMybatisPlusMongoApplication.class, args);\n    }\n}\n```\n\n### 测试使用 MongoDB 的 UserInfoLogRepository\n\n1. 测试 `UserInfoLogRepository` 中由 MongoDB Data 自动实现的 `findUserInfoLogByIdEquals()` 方法\n2. 测试 `CustomUserInfoLogRepository` 中自定义复杂的 `listByParam()` 方法\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class UserInfoLogRepositoryTest {\n    @Autowired\n    private UserInfoLogRepository userInfoLogRepository;\n\n    /**\n     * 初始数据，最开始要运行一次\n     */\n    @Test\n    public void insert() {\n        userInfoLogRepository.insert(Lists.newArrayList(\n                new UserInfoLog(1L, 1L, \"登录\", LocalDateTime.now()),\n                new UserInfoLog(2L, 1L, \"退出\", LocalDateTime.now()),\n                new UserInfoLog(3L, 2L, \"登录\", LocalDateTime.now()),\n                new UserInfoLog(4L, 3L, \"退出\", LocalDateTime.now())\n        ));\n    }\n\n    @Test\n    public void findUserInfoLogByIdEquals() {\n        final UserInfoLog result = userInfoLogRepository.findUserInfoLogByIdEquals(1L);\n        assertThat(result)\n                .isNotNull();\n    }\n\n    @Test\n    public void listByParam() {\n        final UserInfoLog userInfoLog = new UserInfoLog(null, 1L, \"登\",\n                LocalDateTime.parse(\"2019-02-22T08:22:16.000Z\", DateTimeFormatter.ISO_DATE_TIME));\n        final List<UserInfoLog> result = userInfoLogRepository.listByParam(userInfoLog);\n        assertThat(result)\n                .isNotEmpty()\n                .allMatch(log ->\n                        Objects.equals(userInfoLog.getUserId(), log.getUserId())\n                                && log.getOperate().contains(userInfoLog.getOperate())\n                                && log.getLogTime().isAfter(userInfoLog.getLogTime())\n                );\n    }\n}\n```\n\n## 同时使用 Mybatis Dao 和 MongoDB Repository\n\n### 在 Service 中添加方法\n\n用户信息业务接口：`com.rxliuli.example.springbootmybatisplusmongo.service.UserInfoService`\n\n```java\npublic interface UserInfoService extends IService<UserInfo> {\n    /**\n     * 获取用户信息与用户日志的映射表\n     *\n     * @return 以 {@link UserInfo} -> {@link List<UserInfoLog>} 形式的 {@link Map}\n     */\n    Map<UserInfo, List<UserInfoLog>> listUserInfoAndLogMap();\n}\n```\n\n用户信息业务接口实现类：`com.rxliuli.example.springbootmybatisplusmongo.service.impl.UserInfoServiceImpl`\n\n```java\n@Service\npublic class UserInfoServiceImpl extends ServiceImpl<UserInfoDao, UserInfo> implements UserInfoService {\n    @Autowired\n    private UserInfoLogRepository userInfoLogRepository;\n\n    @Override\n    public Map<UserInfo, List<UserInfoLog>> listUserInfoAndLogMap() {\n        final List<UserInfo> userInfoList = list();\n        final List<UserInfoLog> userInfoLogList = userInfoLogRepository.findAll();\n        final Map<Long, List<UserInfoLog>> map = userInfoLogList.stream().collect(Collectors.groupingBy(UserInfoLog::getUserId));\n        return userInfoList.stream()\n                .collect(Collectors.toMap(user -> user, user -> map.getOrDefault(user.getId(), Collections.emptyList())));\n    }\n}\n```\n\n### 添加简单的 RestAPI 进行测试\n\n```java\n@RestController\n@RequestMapping(\"/api/user-info\")\npublic class UserInfoApi {\n    @Autowired\n    private UserInfoService userInfoService;\n\n    @GetMapping(\"/list\")\n    public List<UserInfo> list() {\n        return userInfoService.list();\n    }\n\n    @GetMapping(\"/list-user-info-and-log-map\")\n    public Map<String, List<UserInfoLog>> listUserInfoAndLogMap() {\n        return userInfoService.listUserInfoAndLogMap().entrySet().stream()\n                .collect(Collectors.toMap(kv -> JsonUtil.toJson(kv.getKey()), Map.Entry::getValue));\n    }\n}\n```\n\n### 测试 RestAPI\n\n现在，我们启动项目并打开浏览器，应当可以在以下地址看到对应的 JSON 数据\n\n- [用户信息列表](http://localhost:8080/api/user-info/list)\n\n  ```json\n  [\n    {\n      \"id\": 1,\n      \"name\": \"rx\",\n      \"age\": 17,\n      \"sex\": false\n    },\n    {\n      \"id\": 2,\n      \"name\": \" 琉璃 \",\n      \"age\": 18,\n      \"sex\": false\n    }\n  ]\n  ```\n\n- [用户信息及对应日志映射表](http://localhost:8080/api/user-info/list-user-info-and-log-map)\n\n  ```json\n  {\n    \"{\\\"id\\\":\\\"1\\\",\\\"name\\\":\\\"rx\\\",\\\"age\\\":17,\\\"sex\\\":false}\": [\n      {\n        \"id\": 1,\n        \"userId\": 1,\n        \"operate\": \" 登录 \",\n        \"logTime\": \"2019-02-22T16:22:16.099\"\n      },\n      {\n        \"id\": 2,\n        \"userId\": 1,\n        \"operate\": \" 退出 \",\n        \"logTime\": \"2019-02-22T16:22:16.099\"\n      }\n    ],\n    \"{\\\"id\\\":\\\"2\\\",\\\"name\\\":\\\"琉璃 \\\",\\\"age\\\":18,\\\"sex\\\":false}\": [\n      {\n        \"id\": 3,\n        \"userId\": 2,\n        \"operate\": \" 登录 \",\n        \"logTime\": \"2019-02-22T16:22:16.099\"\n      }\n    ]\n  }\n  ```\n\n## 踩坑\n\n1. Mybatis Plus 扫包范围  \n   使用 `@MapperScan` 限制 Mybatis Plus 扫描 `Dao` 的范围，注意不要扫到 MongoDB 的 `Repository`，否则会抛出异常\n\n   ```java\n   Caused by: org.springframework.beans.factory.support.BeanDefinitionOverrideException: Invalid bean definition with name 'userInfoLogRepository' defined in null: Cannot register bean definition [Root bean: class [org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean]; scope=; abstract=false; lazyInit=false; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null] for bean 'userInfoLogRepository': There is already [Generic bean: class [org.mybatis.spring.mapper.MapperFactoryBean]; scope=singleton; abstract=false; lazyInit=false; autowireMode=2; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodName=null; destroyMethodName=null; defined in file [D:\\Text\\spring-boot\\spring-boot-mybatis-plus-mongo\\out\\production\\classes\\com\\rxliuli\\example\\springbootmybatisplusmongo\\repository\\UserInfoLogRepository.class]] bound.\n   ```\n\n   原因是在 SpringMongoData 处理之前 Mybatis Plus 先扫描到并进行了代理，然后就会告诉你无法注册 SpringMongoData 相关的 `Repository`\n\n2. 使用 `@EnableMongoRepositories` 限制 SpringMongoData 扫描的范围\n\n   既然说到限制，自然也不得不说一下 SpringMongoData 本身，如果你已经使用了 `@MapperScan` 扫描 Mybatis 需要处理的 Dao，那么添加与否并不重要。但是，吾辈要说但是了，但是，如果你先使用的 MongoDB，那么如果没有使用 `@MapperScan` 处理 Mybatis 的 Dao 的话，就会抛出以下异常，所以为了安全起见还是都定义了吧\n\n   ```java\n   Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'userInfoServiceImpl': Unsatisfied dependency expressed through field 'baseMapper'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.rxliuli.example.springbootmybatisplusmongo.dao.UserInfoDao' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}\n   ```\n\n   说的是自动注入 `BaseMapper` 失败，实际上是因为 Mybatis 的 Dao SpringMongoData 无法处理。\n\n3. 最好使用不同的后缀名区分 `Mybatis Mapper` 和 `Mongo Repository`，或者放到不同的包  \n   也是为了避免扫描混乱，出现 `Mybatis` 扫描到 `Mongo Repository` 或是 `Mongo` 扫描到 `Mybatis Mapper` 的情况，出现上面的那两个错误。\n\n---\n\n那么，关于在 SpringBoot 中同时使用 Mybatis Plus 和 MongoDB 的搭建就到这里啦\n","createdTime":1587219249396,"updatedTime":1624276604526,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"d576cb4ea0ae4997aac7f137306203a4","title":"JavaScript 中的 ES6 Proxy","body":"## 场景\n\n> 就算只是扮演，也会成为真实的自我的一部分。对人类的精神来说，真实和虚假其实并没有明显的界限。入戏太深不是一件好事，但对于你来说并不成立，因为戏中的你才是真正符合你的身份的你。如今的你是真实的，就算一开始你只是在模仿着这种形象，现在的你也已经成为了这种形象。无论如何，你也不可能再回到过去了。\n\n`Proxy` 代理，在 JavaScript 似乎很陌生，却又在生活中无处不在。或许有人在学习 ES6 的时候有所涉猎，但却并未真正了解它的使用场景，平时在写业务代码时也不会用到这个特性。\n\n相比于文绉绉的定义内容，想必我们更希望了解它的使用场景，使其在真正的生产环境发挥强大的作用，而不仅仅是作为一个新的特性 -- **然后，实际中完全没有用到！**\n\n- 为函数添加特定的功能\n- 代理对象的访问\n- 作为胶水桥接不同结构的对象\n- 监视对象的变化\n- 还有更多。。。\n\n如果你还没有了解过 `Proxy` 特性，可以先去 [MDN Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 上查看基本概念及使用。\n\n## 为函数添加特定的功能\n\n下面是一个为异步函数自动添加超时功能的高阶函数，我们来看一下它有什么问题\n\n```js\n/**\n * 为异步函数添加自动超时功能\n * @param timeout 超时时间\n * @param action 异步函数\n * @returns 包装后的异步函数\n */\nfunction asyncTimeout(timeout, action) {\n  return function (...args) {\n    return Promise.race([\n      Reflect.apply(action, this, args),\n      wait(timeout).then(Promise.reject),\n    ])\n  }\n}\n```\n\n**一般而言**，上面的代码足以胜任，但问题就在这里，不一般的情况 -- 函数上面包含**自定义属性**呢？\n众所周知，JavaScript 中的函数是一等公民，即函数可以被传递，被返回，以及，被添加属性！\n\n例如下面这个简单的函数 `get`，其上有着 `_name` 这个属性\n\n```js\nconst get = async (i) => i\nget._name = 'get'\n```\n\n一旦使用上面的 `asyncTimeout` 函数包裹之后，问题便会出现，返回的函数中 `_name` 属性不见了。这是当然的，毕竟实际上返回的是一个匿名函数。那么，如何才能让返回的函数能够拥有传入函数参数上的所有自定义属性呢？\n一种方式是复制参数函数上的所有属性，但这点实现起来其实并不容易，真的不容易，不信你可以看看 Lodash 的 clone 函数。那么，有没有一种更简单的方式呢？答案就是 `Proxy`，它可以代理对象的指定操作，除此之外，其他的一切都指向原对象。\n下面是 `Proxy` 实现的 `asyncTimeout` 函数\n\n```js\n/**\n * 为异步函数添加自动超时功能\n * @param timeout 超时时间\n * @param action 异步函数\n * @returns 包装后的异步函数\n */\nfunction asyncTimeout(timeout, action) {\n  return new Proxy(action, {\n    apply(_, _this, args) {\n      return Promise.race([\n        Reflect.apply(_, _this, args),\n        wait(timeout).then(Promise.reject),\n      ])\n    },\n  })\n}\n```\n\n测试一下，是可以正常调用与访问其上的属性的\n\n```js\n;(async () => {\n  console.log(await get(1))\n  console.log(get._name)\n})()\n```\n\n好了，这便是吾辈最常用的一种方式了 -- **封装高阶函数，为函数添加某些功能**。\n\n## 代理对象的访问\n\n下面是一段代码，用以在页面上展示从后台获取的数据，如果字段没有值则默认展示 `''`\n\n模拟一个获取列表的异步请求\n\n```js\nasync function list() {\n  // 此处仅为构造列表\n  class Person {\n    constructor({ id, name, age, sex, address } = {}) {\n      this.id = id\n      this.name = name\n      this.age = age\n      this.sex = sex\n      this.address = address\n    }\n  }\n  return [\n    new Person({ id: 1, name: '琉璃' }),\n    new Person({ id: 2, age: 17 }),\n    new Person({ id: 3, sex: false }),\n    new Person({ id: 4, address: '幻想乡' }),\n  ]\n}\n```\n\n尝试直接通过解构为属性赋予默认值，并在默认值实现这个功能\n\n```js\n;(async () => {\n  // 为所有为赋值属性都赋予默认值 ''\n  const persons = (await list()).map(\n    ({ id = '', name = '', age = '', sex = '', address = '' }) => ({\n      id,\n      name,\n      age,\n      sex,\n      address,\n    }),\n  )\n  console.log(persons)\n})()\n```\n\n下面让我们写得更通用一些\n\n```js\nfunction warp(obj) {\n  const result = obj\n  for (const k of Reflect.ownKeys(obj)) {\n    const v = Reflect.get(obj, k)\n    result[k] = v === undefined ? '' : v\n  }\n  return obj\n}\n;(async () => {\n  // 为所有为赋值属性都赋予默认值 ''\n  const persons = (await list()).map(warp)\n  console.log(persons)\n})()\n```\n\n暂且先看一下这里的 `warp` 函数有什么问题？\n\n---\n\n这里是答案的分割线\n\n---\n\n- 所有属性需要预定义，不能运行时决定\n- 没有指向原对象，后续的修改会造成麻烦\n\n吾辈先解释一下这两个问题\n\n1. 所有属性需要预定义，不能运行时决定\n   如果调用了 `list[0].a` 会发生什么呢？是的，依旧会是 `undefined`，因为 `Reflect.ownKeys` 也不能找到没有定义的属性（`真*undefined`），因此导致访问未定义的属性仍然会是 `undefined` 而非期望的默认值。\n2. 没有指向原对象，后续的修改会造成麻烦\n   如果我们此时修改对象的一个属性，那么会影响到原本的属性么？不会，因为 `warp` 返回的对象已经是全新的了，和原对象没有什么联系。所以，当你修改时当然不会影响到原对象。\n   Pass: 我们当然可以直接修改原对象，但这很明显不太符合我们的期望：显示时展示默认值 `''` -- 这并不意味着我们愿意在其他操作时需要 `''`，否则我们还要再转换一遍。（例如发送编辑后的数据到后台）\n\n这个时候 `Proxy` 也可以派上用场，使用 `Proxy` 实现 `warp` 函数\n\n```js\nfunction warp(obj) {\n  const result = new Proxy(obj, {\n    get(_, k) {\n      const v = Reflect.get(_, k)\n      if (v !== undefined) {\n        return v\n      }\n      return ''\n    },\n  })\n  return result\n}\n```\n\n现在，上面的那两个问题都解决了！\n\n> 注: 知名的 GitHub 库 [immer](https://github.com/immerjs/immer) 就使用了该特性实现了不可变状态树。\n\n## 作为胶水桥接不同结构的对象\n\n通过上面的例子我们可以知道，即便是未定义的属性，`Proxy` 也能进行代理。这意味着，我们可以通过 `Proxy` 抹平相似对象之间结构的差异，以相同的方式处理类似的对象。\n\n> Pass: 不同公司的项目中的同一个实体的结构不一定完全相同，但基本上类似，只是字段名不同罢了。所以使用 `Proxy` 实现胶水桥接不同结构的对象方便我们在不同公司使用我们的工具库！\n> 嘛，开个玩笑，其实在同一个公司中不同的实体也会有类似的结构，也会需要相同的操作，最常见的应该是树结构数据。例如下面的菜单实体和系统权限实体就很相似，也需要相同的操作 -- **树 <=> 列表 相互转换**。\n\n思考一下如何在同一个函数中处理这两种树节点结构\n\n```js\n/**\n * 系统菜单\n */\nclass SysMenu {\n  /**\n   * 构造函数\n   * @param {Number} id 菜单 id\n   * @param {String} name 显示的名称\n   * @param {Number} parent 父级菜单 id\n   */\n  constructor(id, name, parent) {\n    this.id = id\n    this.name = name\n    this.parent = parent\n  }\n}\n/**\n * 系统权限\n */\nclass SysPermission {\n  /**\n   * 构造函数\n   * @param {String} uid 系统唯一 uuid\n   * @param {String} label 显示的菜单名\n   * @param {String} parentId 父级权限 uid\n   */\n  constructor(uid, label, parentId) {\n    this.uid = uid\n    this.label = label\n    this.parentId = parentId\n  }\n}\n```\n\n下面让我们使用 `Proxy` 来抹平访问它们之间的差异\n\n```js\nconst sysMenuProxy = { parentId: 'parent' }\nconst sysMenu = new Proxy(new SysMenu(1, 'rx', 0), {\n  get(_, k) {\n    if (Reflect.has(sysMenuProxy, k)) {\n      return Reflect.get(_, Reflect.get(sysMenuProxy, k))\n    }\n    return Reflect.get(_, k)\n  },\n})\nconsole.log(sysMenu.id, sysMenu.name, sysMenu.parentId) // 1 'rx' 0\n\nconst sysPermissionProxy = { id: 'uid', name: 'label' }\nconst sysPermission = new Proxy(new SysPermission(1, 'rx', 0), {\n  get(_, k) {\n    if (Reflect.has(sysPermissionProxy, k)) {\n      return Reflect.get(_, Reflect.get(sysPermissionProxy, k))\n    }\n    return Reflect.get(_, k)\n  },\n})\nconsole.log(sysPermission.id, sysPermission.name, sysPermission.parentId) // 1 'rx' 0\n```\n\n看起来似乎有点繁琐，让我们封装一下\n\n```js\n/**\n * 桥接对象不存在的字段\n * @param {Object} map 代理的字段映射 Map\n * @returns {Function} 转换一个对象为代理对象\n */\nfunction bridge(map) {\n  /**\n   * 为对象添加代理的函数\n   * @param {Object} obj 任何对象\n   * @returns {Proxy} 代理后的对象\n   */\n  return function (obj) {\n    return new Proxy(obj, {\n      get(target, k) {\n        // 如果遇到被代理的属性则返回真实的属性\n        if (Reflect.has(map, k)) {\n          return Reflect.get(target, Reflect.get(map, k))\n        }\n        return Reflect.get(target, k)\n      },\n      set(target, k, v) {\n        // 如果遇到被代理的属性则设置真实的属性\n        if (Reflect.has(map, k)) {\n          Reflect.set(target, Reflect.get(map, k), v)\n          return true\n        }\n        Reflect.set(target, k, v)\n        return true\n      },\n    })\n  }\n}\n```\n\n现在，我们可以用更简单的方式来做代理了。\n\n```js\nconst sysMenu = bridge({\n  parentId: 'parent',\n})(new SysMenu(1, 'rx', 0))\nconsole.log(sysMenu.id, sysMenu.name, sysMenu.parentId) // 1 'rx' 0\n\nconst sysPermission = bridge({\n  id: 'uid',\n  name: 'label',\n})(new SysPermission(1, 'rx', 0))\nconsole.log(sysPermission.id, sysPermission.name, sysPermission.parentId) // 1 'rx' 0\n```\n\n如果想看 JavaScirpt 如何处理树结构数据话，可以参考吾辈的 [JavaScript 处理树结构数据](:/7713263c9158489c95009be721e2c6bc)\n\n## 监视对象的变化\n\n接下来，我们想想，平时是否有需要监视对象的变化，然后进行某些处理呢？\n\n例如监视用户复选框选中项列表的变化并更新对应的需要发送到后台的 `id` 拼接字符串。\n\n```js\n// 模拟页面的复选框列表\nconst hobbyMap = new Map()\n  .set(1, '小说')\n  .set(2, '动画')\n  .set(3, '电影')\n  .set(4, '游戏')\nconst user = {\n  id: 1,\n  // 保存兴趣 id 的列表\n  hobbySet: new Set(),\n  // 发送到后台的兴趣 id 拼接后的字符串，以都好进行分割\n  hobby: '',\n}\nfunction onClick(id) {\n  user.hobbySet.has(id) ? user.hobbySet.delete(id) : user.hobbySet.add(id)\n}\n\n// 模拟两次点击\nonClick(1)\nonClick(2)\n\nconsole.log(user.hobby) // ''\n```\n\n下面使用 `Proxy` 来完成 `hobbySet` 属性改变后 `hobby` 自动更新的操作\n\n```js\n/**\n * 深度监听指定对象属性的变化\n * 注：指定对象不能是原始类型，即不可变类型，而且对象本身的引用不能改变，最好使用 const 进行声明\n * @param object 需要监视的对象\n * @param callback 当代理对象发生改变时的回调函数，回调函数有三个参数，分别是对象，修改的 key，修改的 v\n * @returns 返回源对象的一个代理\n */\nfunction watchObject(object, callback) {\n  const handler = {\n    get(_, k) {\n      try {\n        // 注意: 这里很关键，它为对象的字段也添加了代理\n        return new Proxy(v, Reflect.get(_, k))\n      } catch (err) {\n        return Reflect.get(_, k)\n      }\n    },\n    set(_, k, v) {\n      callback(_, k, v)\n      return Reflect.set(_, k, v)\n    },\n  }\n  return new Proxy(object, handler)\n}\n\n// 模拟页面的复选框列表\nconst hobbyMap = new Map()\n  .set(1, '小说')\n  .set(2, '动画')\n  .set(3, '电影')\n  .set(4, '游戏')\nconst user = {\n  id: 1,\n  // 保存兴趣 id 的列表\n  hobbySet: new Set(),\n  // 发送到后台的兴趣 id 拼接后的字符串，以都好进行分割\n  hobby: '',\n}\n\nconst proxy = watchObject(user, (_, k, v) => {\n  if (k === 'hobbySet') {\n    _.hobby = [..._.hobbySet].join(',')\n  }\n})\nfunction onClick(id) {\n  proxy.hobbySet = proxy.hobbySet.has(id)\n    ? proxy.hobbySet.delete(id)\n    : proxy.hobbySet.add(id)\n}\n// 模拟两次点击\nonClick(1)\nonClick(2)\n\n// 现在，user.hobby 的值将会自动更新\nconsole.log(user.hobby) // 1,2\n```\n\n当然，这里实现的 `watchObject` 函数还非常非常非常简陋，如果有需要可以进行更深度/强大的监听，可以尝试自行实现一下啦！\n\n## 缺点\n\n说完了这些 `Proxy` 的使用场景，下面稍微来说一下它的缺点\n\n- 运行环境必须要 ES6 支持\n  这是一个不大不小的问题，现代的浏览器基本上都支持 ES6，但如果泥萌公司技术栈非常老旧的话（例如支持 IE6），还是安心吃土吧 #笑 #这种公司不离职等着老死\n- 不能直接代理一些需要 this 的对象\n  这个问题就比较麻烦了，任何需要 this 的对象，代理之后的行为可能会发生变化。例如 `Set` 对象\n\n  ```js\n  const proxy = new Proxy(new Set([]), {})\n  proxy.add(1) // Method Set.prototype.add called on incompatible receiver [object Object]\n  ```\n\n  是不是很奇怪，解决方案是把所有的 `get` 操作属性值为 `function` 的函数都手动绑定 `this`\n\n  ```js\n  const proxy = new Proxy(new Set([]), {\n    get(_, k) {\n      const v = Reflect.get(_, k)\n      // 遇到 Function 都手动绑定一下 this\n      if (v instanceof Function) {\n        return v.bind(_)\n      }\n      return v\n    },\n  })\n  proxy.add(1)\n  ```\n\n## 总结\n\n`Proxy` 是个很强大的特性，能够让我们实现一些曾经难以实现的功能（所以这就是你不支持 ES5 的理由？#打），就连 Vue3+ 都开始使用 `Proxy` 实现了，你还有什么理由在乎上古时期的 IE 而不用呢？（ｖ＾＿＾）ｖ\n","createdTime":1609304078683,"updatedTime":1624276549384,"resources":[],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"c55a6470683e498f92ba05d7ff710b3a","title":"react 通用列表组件封装","body":"## 场景\n\n> [GitHub 源码](https://github.com/rxliuli/example/tree/master/basic_list)\n\n在后台项目中，即便使用了 antd，仍然存在太多太多的列表页面。这些列表页面大多数又是非常相似的，所以吾辈需要解决重复的简单列表的编写，避免每次都手动控制过滤器/分页之类的东西，将之抽象成配置项，然后通过配置生成列表页面。或许已经有很多人做过了这件事情，但于吾辈而言，这仍然是全新的体验，所以也便于此记录，并供之以他人参考。\n\n## 理念\n\n使用逐级递进的方式进行封装，使用者可以根据需求停留在一个合适的封装层次，使用不同封装层次的组件。\n\n- `BasicList`：高层列表封装组件\n  - `ListHeader`：列表页顶部工具栏组件\n    - `CommonHeader`: 通用的顶部工具栏组件\n  - `ListFilter`：过滤器组件\n    - `FilterSelect`：单选过滤器\n    - `FilterTimeRange`：时间区间过滤器\n    - `FilterSlot`：自定义过滤器\n  - `ListTable`：列表封装组件\n\nBasicList 使用步骤\n\n```mermaid\ngraph TD;\nA[添加 api class 实现 BasicListApi] --> B[添加配置项]\nB --> C{是否需要动态修改};\nC --> |是| C1[使用 useMemo 声明]\nC --> |否| C2[将之抽离到组件外部声明为常量]\nC1 --> D\nC2 --> D\nD{是否有非通用 Filter}\nD --> |是| D1[自定义 slot filter]\nD --> |否| D2[使用 select/time filter]\nD1 --> E\nD2 --> E\nE{是否需要自定义表格相关功能}\nE --> |是| E1[使用 filterOperate 配置]\nE --> |否| E2[不声明 filter 配置]\nE1 --> F\nE2 --> F\nF[列表渲染]\n```\n\nBasicList 渲染流程\n\n```mermaid\ngraph TB\nA[从 props 拿到配置项列表] --> B{header 是否为 ReactElement}\nB --> |是| B1[直接渲染]\nB --> |否| B2[使用 ListHeader 渲染 header 配置项]\nB1 --> C\nB2 --> C\nC{filters 是否存在}\nC --> |是| C1{filters 是否为 ReactElement}\n  C1 --> |是| C1A[直接渲染]\n  C1 --> |否| C1B[使用 ListFilter 渲染 filters 配置项] --> C1C[监听 initialParams 变化, 以随时修改 form]\nC --> |否| C2[不渲染]\nC1A --> D\nC1B --> D\nC2 --> D\nD[渲染列表]\n```\n\n## 使用示例\n\n### 使用基本 API\n\n> [GitHub 代码示例](https://github.com/rxliuli/example/blob/master/basic_list/src/pages/example/BasicListExample.tsx)\n\n如下所示，我们想要构造下面这样一个简单的列表页面，包含一个面包屑导航列表、搜索框、过滤条件选择器和一个表格。\n\n```tsx\nimport * as React from 'react'\nimport { Button } from 'antd'\nimport { Link } from 'react-router-dom'\nimport { Moment } from 'moment'\nimport { LabeledValue } from 'antd/es/select'\nimport { userApi } from './api/UserApi'\nimport {\n  BasicList,\n  BasicListPropsType,\n  FilterFieldTypeEnum,\n} from '../../components/list'\n\ntype PropsType = {}\n\ntype Config = Omit<BasicListPropsType, 'params'> & {\n  params?: {\n    keyword?: string\n    test?: number\n    birthdayTimeRange?: [Moment, Moment]\n  }\n}\nconst testOptionList: LabeledValue[] = [\n  { value: 0, label: '测试 0' },\n  { value: 1, label: '测试 1' },\n  { value: 2, label: '测试 2' },\n]\n\n//列表配置项\nconst config: Config = {\n  header: {\n    placeholder: '用户名/住址',\n    list: ['用户', '列表'],\n  },\n  filters: [\n    {\n      type: FilterFieldTypeEnum.Select,\n      label: '测试字段',\n      field: 'test',\n      options: testOptionList,\n    },\n    {\n      type: FilterFieldTypeEnum.TimeRange,\n      label: '生日',\n      field: 'birthdayTimeRange',\n    },\n  ],\n  columns: [\n    { field: 'id', title: 'ID' },\n    { field: 'name', title: '姓名' },\n    { field: 'birthday', title: '生日' },\n    {\n      field: 'operate',\n      title: '操作',\n      slot: (param) => <Link to={`/system/user/${param.record.id}`}>详情</Link>,\n    },\n  ],\n  api: userApi,\n}\n\n/**\n * 一个基本的列表页面\n * @constructor\n */\nconst BasicListExample: React.FC<PropsType> = () => {\n  return <BasicList {...config} />\n}\n\nexport default BasicListExample\n```\n\n### 使用自定义过滤器组件\n\n> [GitHub 代码示例](https://github.com/rxliuli/example/blob/master/basic_list/src/pages/example/CustomFilterListExample.tsx)\n\n事实上，总有各种奇怪的过滤器无法满足，这时候就需要添加一个自定义的过滤器了。\n例如下面这个过滤器，包含了年龄的值和单位，是不是感觉很奇怪\n\n关键代码配置如下\n\n```jsx\nconst config: Config = {\n  filters: [\n    {\n      type: FilterFieldTypeEnum.Slot,\n      label: '年龄',\n      field: 'age',\n      children: (\n        <Input.Group compact>\n          <Form.Item name={['age', 'value']} noStyle>\n            <InputNumber style={{ width: 'calc(100% - 64px)' }} />\n          </Form.Item>\n          <Form.Item name={['age', 'unit']} noStyle>\n            <Select style={{ width: 64 }} options={ageUnitOptionList} />\n          </Form.Item>\n        </Input.Group>\n      ),\n    },\n  ],\n  // 此处是为了添加过滤器的默认值\n  params: {\n    age: {\n      unit: 0,\n    },\n  },\n}\n```\n\n### 添加表格的额外操作\n\n> [GitHub 代码示例](https://github.com/rxliuli/example/blob/master/basic_list/src/pages/example/TableOperationListExample.tsx)\n\n有时候，我们需要添加一个额外的表格操作，例如导出/导入数据/删除选中数据。\n\n关键代码如下\n\n```jsx\nasync function handleBatchDelete({\n  selectedRowKeys,\n  setSelectedRowKeys,\n  searchPage,\n}: ListTableOperateParam) {\n  if (selectedRowKeys.length === 0) {\n    return\n  }\n  await userApi.batchDelete(selectedRowKeys)\n  setSelectedRowKeys([])\n  await searchPage()\n}\n\nconst config = useMemo<Config>(\n  () => ({\n    tableOperate: (params) => (\n      <Button onClick={() => handleBatchDelete(params)}>删除选中</Button>\n    ),\n  }),\n  [],\n)\n```\n\n### 过滤器的下拉框数据来源是异步的\n\n> [GitHub 代码示例](https://github.com/rxliuli/example/blob/master/basic_list/src/pages/example/AsyncSelectOptionsListExample.tsx)\n\n很多时候，我们的数据来源并不是由前端写死，而是从后台获取的，这就要求我们传入的值是 react 的一个 State 而非一个固定值。\n\n关键代码如下\n\n```jsx\nconst testOptionList = useAsyncMemo([], dictApi.list)\nconst config = useMemo<Config>(\n  () => ({\n    filters: [\n      {\n        type: FilterFieldTypeEnum.Select,\n        label: '测试字段',\n        field: 'test',\n        options: testOptionList,\n      },\n    ],\n  }),\n  [testOptionList],\n)\n```\n\n## 组件 API\n\n### BasicList\n\n参考 _src/components/common/table/js/BasicListOptions.d.ts_\n\n| `prop`           | 类型                                                               | 说明           |\n| ---------------- | ------------------------------------------------------------------ | -------------- |\n| `header`         | `BasicList.Header`                                                 | 标题栏相关配置 |\n| `[filters]`      | `BaseFilterField[]`                                                | 过滤器列表     |\n|                  | `((params: any, onChange: (params: any) => void) => ReactElement)` |                |\n| `[params]`       | `Params`                                                           | 查询参数       |\n| `columns`        | `TableColumn[]`                                                    | 列字段列表     |\n| `api`            | `BaseListApi`                                                      | api 对象       |\n| `[tableOptions]` | `TableOptions`                                                     | 一些其他选项   |\n| `[tableOperate]` | `ListTableOperate`                                                 | 一些其他操作   |\n\n### ListFilter\n\n| `prop`           | 类型                 | 说明                     |\n| ---------------- | -------------------- | ------------------------ | ------------------ | ---------- |\n| `[initialValue]` | `any`                | 查询参数                 |\n| `filters`        | `(FilterSelectType   | FilterTimeRangeType      | FilterSlotType)[]` | 过滤器列表 |\n| `onChange`       | `(value: T) => void` | 当过滤器的参数发生改变时 |\n\n### ListTable\n\n| `prop`           | 类型               | 说明         |\n| ---------------- | ------------------ | ------------ |\n| `columns`        | `TableColumn[]`    | 列字段列表   |\n| `api`            | `BaseListApi`      | api 对象     |\n| `params`         | `Params`           | 查询参数     |\n| `[tableOptions]` | `TableOptions`     | 一些其他选项 |\n| `[tableOperate]` | `ListTableOperate` | 一些其他选项 |\n\n## 其他类型定义\n\n下面是类型定义，所有的类型定义都有对应的 `.d.ts` 文件，请使用 `C-N` 搜索 `class`。\n\n| `HeaderNavItem` | 类型     | 说明                      |\n| --------------- | -------- | ------------------------- |\n| `string`        |          | 导航的名字                |\n| `name`          | `string` | 导航的名字                |\n| `[link]`        | `string` | 如果是 route 的话必须有值 |\n\n| `Header`      | 类型              | 说明             |\n| ------------- | ----------------- | ---------------- |\n| `list`        | `HeaderNavItem[]` | 导航元素列表     |\n| `placeholder` | `string`          | 搜索框的提示文本 |\n\n### 过滤器相关\n\n| `FilterFieldTypeEnum` | 类型 | 说明           |\n| --------------------- | ---- | -------------- |\n| `Slot`                | `1`  | 自定义 slot    |\n| `Select`              | `2`  | 普通选择框     |\n| `TimeRange`           | `3`  | 日期区间选择器 |\n\n| `FilterFieldBase` | 类型                  | 说明           |\n| ----------------- | --------------------- | -------------- |\n| `type`            | `FilterFieldTypeEnum` | 过滤器元素类型 |\n| `label`           | `string`              | 显示的标题     |\n\n| `FilterSelectType` | 类型              | 说明               |\n| ------------------ | ----------------- | ------------------ |\n| `extends`          | `FilterFieldBase` | 继承基本过滤器配置 |\n| `field`            | `string`          | 字段名             |\n| `options`          | `LabeledValue[]`  | 值列表             |\n\n| `FilterTimeRangeType` | 类型              | 说明               |\n| --------------------- | ----------------- | ------------------ |\n| `extends`             | `FilterFieldBase` | 继承基本过滤器配置 |\n| `field`               | `string`          | 字段名             |\n\n| `FilterSlotType` | 类型                                                            | 说明                 |\n| ---------------- | --------------------------------------------------------------- | -------------------- |\n| `extends`        | `FilterFieldBase`                                               | 继承基本过滤器配置   |\n| `field`          | `string`                                                        | 字段名               |\n| `children`       | `ReactElement`                                                  | `Form.Item` 的子元素 |\n| `[computed]`     | `(res: Record<string, any>, value: any) => Record<string, any>` | 自定义计算方法       |\n\n| `Params`  | 类型     | 说明         |\n| --------- | -------- | ------------ |\n| `keyword` | `string` | 查询关键字   |\n| `...args` | `any[]`  | 其他查询参数 |\n\n### 表格相关\n\n| `TableColumn` | 类型                                                             | 说明                   |\n| ------------- | ---------------------------------------------------------------- | ---------------------- |\n| `field`       | `string`                                                         | 在数据项中对应的字段名 |\n| `title`       | `string`                                                         | 列标题                 |\n| `[formatter]` | `(v: any, record: any) => any`                                   | 自定义字段格式化函数   |\n| `[slot]`      | `(param: { text: string; record: any; i: number }) => ReactNode` | 自定义 `slot`          |\n\n| `BaseListApi` | 类型                                     | 说明                                       |\n| ------------- | ---------------------------------------- | ------------------------------------------ |\n| `pageList`    | `(params: any) => Promise<PageRes<any>>` | 所有 ListTable 中的 api 对象必须实现该类型 |\n\n| `ListTableOperateParam` | 类型                                  | 说明                 |\n| ----------------------- | ------------------------------------- | -------------------- |\n| `searchPage`            | `(page?: PageParam) => Promise<void>` | 导航元素列表         |\n| `selectedRowKeys`       | `string[]`                            | 当前选中行的主键     |\n| `setSelectedRowKeys`    | `(selectedRowKeys: string[]) => void` | 设置当前选中行的主键 |\n| `page`                  | `PageData<any>`                       | 分页数据信息         |\n| `params`                | `Params`                              | 过滤器及搜索参数     |\n\n| `TableOptions` | 类型      | 说明                   |\n| -------------- | --------- | ---------------------- |\n| `[isSelect]`   | `boolean` | 是否可选，默认为 false |\n| `[rowKey]`     | `string`  | 行的唯一键，默认为 id  |\n\n## 总结\n\n相比于之前吾辈 [Vue 表格封装 BasicTableVue](:/90548a371a16435799bcbfae3e4dbfb6)，嗯，差距非常明显！\n","createdTime":1609302754700,"updatedTime":1624276510458,"resources":[],"tags":[{"id":"5a7776c036cf46738cb6a729934a1a7b","title":"react","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"ba2aa72859434d07b05a832faa058add","title":"使用 ESDoc 生成文档","body":"> [esdoc 官网](https://esdoc.org/), [博客地址](:/ba2aa72859434d07b05a832faa058add), [示例项目](https://github.com/rxliuli/esdocs-example)\r\n\r\n## 场景\r\n\r\n在尝试过使用 [markdown](https://md.rxliuli.com/), [jsdoc](http://usejsdoc.org/), [docz](https://www.docz.site/) 之后，吾辈终于找到了一个比较满意工具 -- esdocs。\r\n\r\n## 期望\r\n\r\n- **开箱即用**: 毫无疑问, js 正在把一切事情变得复杂，到处都是大量的配置，永远都学不会开箱即用\r\n- **支持 jsdoc 注释**: 已经熟悉了 jsdoc，所以不太希望切换到其他的注释规范了呢\r\n- **可配置自定义页**: 作为文档 API 列表还算合适，然而首页的话果然还是自定义最好\r\n\r\n因为以上的期望，吾辈最终选择了 esdocs。\r\n\r\n## 使用\r\n\r\n### 添加依赖\r\n\r\n```sh\r\nyarn add -D esdoc esdoc-standard-plugin\r\n```\r\n\r\n### 初始化配置\r\n\r\n创建一个配置文件 _.esdoc.json_\r\n\r\n```json\r\n{\r\n  \"source\": \"./src\",\r\n  \"destination\": \"./docs\",\r\n  \"plugins\": [{ \"name\": \"esdoc-standard-plugin\" }]\r\n}\r\n```\r\n\r\n当然，如果你使用的命令行是 **bash**/**git-for-bash**/**cmder** 的话，亦可使用命令快速完成\r\n\r\n```sh\r\necho '{\r\n  \"source\": \"./src\",\r\n  \"destination\": \"./docs\",\r\n  \"plugins\": [{\"name\": \"esdoc-standard-plugin\"}]\r\n}' > .esdoc.json\r\n```\r\n\r\n### 打包\r\n\r\n在 _package.json_ 中添加一个打包文档的 `script` 命令\r\n\r\n```json\r\n\"scripts\": {\r\n  \"docs\": \"esdoc\"\r\n}\r\n```\r\n\r\n然后使用 `yarn docs` 命令即可打包一份新鲜可用的文档啦\r\n\r\n### 查看\r\n\r\n然后打开 _docs/index.html_ 文件即可查看了，下面截张吾辈的工具库 [rx-util](https://rx-util.rxliuli.com/) 生成的文档。\r\n\r\n![rx-util](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190331002416.png)\r\n\r\n## 总结\r\n\r\n感觉是不是很简单，吾辈也是这样认为的呢！后面会整理一份 jsdoc 的标签列表，便于快速查找与一览。\r\n","createdTime":1580652937914,"updatedTime":1624276456241,"resources":[],"tags":[{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"d3f09581c92041e7a8475cc0d9e99c85","title":"使用 hexo next 搭建静态博客","body":"## 场景\n\n在碎片化学习的时代，没有体系化/总结的知识很快会被彻底遗忘，而博客可以帮助我们记忆平时零碎的知识。有人似乎认为想玩博客就必须要域名/服务器，这里吾辈不得不说明一下，这个认知是错误的。\n\n对于绝大多数网站来说，静态是无法满足复杂的需求的。然而我们只是想要日常写点博客，分享到网络上的话，却是不需要这些，静态博客也便是足够了。\n\n## 准备\n\n本文假设你是一位开发者并至少对下面打勾的内容有基本了解。\n\n-   [x] [git](https://git-scm.com/)：分布式版本控制工具\n-   [x] [gitlab](https://gitlab.com/)：私有代码托管平台\n-   [x] [Bash/PowerShell/Cmd](.)：命令行操作\n-   [x] [域名](.)：让别人能记住你的博客\n-   [ ] [nodejs](https://nodejs.org/)：JavaScript 运行环境\n-   [ ] [netlify](https://www.netlify.com/)：静态网站托管服务\n-   [ ] [VSCode](https://code.visualstudio.com/)：文本编辑器（类 IDE）\n\n## 使用 npm 全局安装 hexo\n\n如果你还没有安装 nodejs 的话可以去 [nodejs 官网下载页面](https://nodejs.org/en/download/) 进行下载并安装，具体步骤可以参考 [在 Windows 上安装 nodejs](.)。\n\n全局安装 hexo 命令行工具\n\n```sh\nnpm i hexo -g\n```\n\n安装过程\n\n![hexo cli 安装过程](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209170408.png)\n\n验证一下\n\n输入 `hexo`，应该会得到类似下面的响应\n\n![hexo 安装验证](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209170553.png)\n\n## 初始化 hexo 博客\n\n创建一个空的文件夹作为 hexo 博客目录，在命令行中进入这个文件夹然后执行初始化命令。\n\n```sh\nhexo init\n```\n\n输出\n\n![hexo init 输出](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209174358.png)\n\n安装完成后文件夹如下\n\n![安装后的文件夹](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209175833.png)\n\n## 本地运行博客\n\n使用命令运行一个本地的 hexo 博客服务器\n\n```sh\nhexo s\n```\n\n在浏览器打开 <http://localhost:4000/> 页面，可以看到 hexo 博客的初始页面\\\n![hexo 博客的初始页面](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209175541.png)\n\n嗯，有点丑，我们可以更换一下主题，本文主要讲解使用 [hexo next](https://theme-next.iissnan.com/) 主题。\n\n## 安装 next 主题\n\n1.  克隆并安装主题最新版本\n\n    ```sh\n    git clone https://github.com/iissnan/hexo-theme-next themes/next\n    ```\n\n1.  启用主题\\\n    打开根目录下的 *\\_config.yml* 文件，找到 `theme` 字段，将之修改为 `next` 即可\\\n    ![启用 next 主题](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209181850.png)\n\n1.  重新打开本地服务器测试一下\\\n    ![next 主题首页](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209182031.png)\n\n## 将代码托管到 gitlab\n\n> 肯定有人会问，为什么不用 github？\\\n> 原因很简单：如果你需要使用第三方服务的话肯定需要第三方服务的认证。例如 github 的 token，如果别人想要滥用这个 token 对你的博客做点什么，你却无法阻止，因为 github 托管代码是公开的。\n\n删除掉默认的 *landscape* 主题和 *next* 主题的 git 仓库，位置分别是\n\n-   *themes/landscape/*\n-   *themes/next/.git*\n\n在本地也初始化一下 git 仓库，然后初始提交全部\n\n```sh\ngit init\r\ngit add -A\r\ngit commit -a -m \"Initial Commit\"\n```\n\n所以，在 [gitlab](https://gitlab.com) 创建一个私有仓库（最好与本地博客文件夹同名）。\\\n![gitlab 创建私有仓库](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209182900.png)\n\n创建完成后会得到一个 git 远程仓库的地址\\\n![git 远程仓库地址](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209183821.png)\n\n将之设置为本地仓库的远程仓库\n\n```sh\ngit remote add origin [这里替换成你的远程仓库地址]\n```\n\n最后，提交一下吧\n\n```sh\ngit push origin master\n```\n\n提交完成后回到刚才创建的远程仓库的页面，会看到远程仓库中已经有文件了\\\n![提交完之后](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209184200.png)\n\n## 托管网站\n\n> 这里声明一下：之所以不使用 github 作为静态网站托管服务是因为 github 只能托管一个静态网站，老实说这是一件很麻烦的事情。毕竟，一个人并不止一个网站。\n\n具体差别如下：\n\n| 对比             | GitHub   | Netlify |\n| -------------- | -------- | ------- |\n| 价格             | 免费       | 免费      |\n| 构建限制           | 每小时 10 次 | 每分钟 3 次 |\n| 使用 HTTPS 的自定义域 | 是        | 是       |\n| 单击 回滚          | 没有       | 是       |\n| 资产优化           | 没有       | 是       |\n| 表格处理           | 没有       | 是       |\n| 部署预览           | 没有       | 是       |\n| 持续部署           | 没有       | 是       |\n| 自定义重写和重定向      | 没有       | 是       |\n| 兼容所有静态站点生成器    | 没有       | 是       |\n| 预呈现            | 没有       | 是       |\n| 拆分测试           | 没有       | 是       |\n| Lambda 函数集成    | 没有       | 是       |\n\n## 部署 netlify\n\n1.  首先你需要一个 [netlify](https://netlify.com/) 的账号，只需要邮箱即可注册。\n\n1.  登录之后进入你的 [个人首页](https://app.netlify.com/)\\\n    ![个人首页](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209211213.png)\n\n1.  由于我们的远程仓库使用的是 GitLab，所以我们连接自己的 GitLab 账户\\\n    ![连接到 GitLab](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209211441.png)\n\n1.  接下来找到我们的远程仓库\\\n    ![远程仓库](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209211616.png)\n\n1.  设定构建命令以及构建目录，没有意外的话 netlify 已经自动识别出这是 hexo 博客了\r\n    ![设定构建命令](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209211803.png)\n\n1.  部署站点\\\n    点击部署之后就会帮你自动部署，部署完成后就可以在线访问你的博客啦\\\n    ![在线自动部署](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209212501.png)\n\n1.  自定义域名\n\n    > 如果你还没有自己的域名（本文假定你有），可以直接跳转到步骤 9\n\n    1.  点击 **Domain settings** 进入域名设置\n    1.  点击 **Add custom domain** 添加自定义的域名\n    1.  点击 **Verify => Yes, add domain** 验证并确认添加\n    1.  点击 **Check DNS configuration** 检查 DNS 配置\n    1.  查看其中的 CNAME DNS 记录，一会还要用\n\n    ![Gif 图解](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190110234441.gif)\n\n1.  在你的域名 DNS 记录中添加上面的 CNAME 记录\n\n    1.  打开你的 DNS 管理器，这里以 [cloudflare](https://www.cloudflare.com) 为例\n    1.  添加一条 CNAME 记录，Name 是我们自定义的二级域名前缀 [blog-demo](https://blog-demo.rxliuli.com/)，Domain name 是 netlify 为我们自动生成的二级域名 [confident-joliot-3c1548.netlify.com](https://confident-joliot-3c1548.netlify.com/)。\n    1.  等待 DNS 刷新完成\n\n    ![Gif 图解](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190110235636.gif)\n\n    > 这里吾辈再推荐一次 [cloudflare](https://www.cloudflare.com)，DNS 刷新时间不会超过 5 分钟，真的是有够快的了！\n\n1.  访问博客\\\n    ![访问博客](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209212636.png)\n\n## 修改博客设置\n\n现在博客基本上部署到线上了，然而有很多地方需要配置，如果需要了解更多的功能可以访问 [hexo](https://hexo.io/) 或 [hexo next 主题](https://theme-next.iissnan.com/)，下面只说一些最重要的配置。\n\n在 *\\_config.yml* 配置文件中\n\n-   title：博客标题\n-   subtitle：博客子标题\n-   language：博客显示语言\n-   author：作者\n\n配置效果对照图\n\n![VSCode](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209214854.png)\\\n![浏览器](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209215051.png)\n\n## 写一个新的文章\n\n使用 hexo 命令即可创建新的文章（本质上是一个含有 yml 关于文章简介的 markdown 文件）\n\n```sh\nhexo new \"[文章名]\"\n```\n\n![创建新的文章](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209215646.png)\n\n随便写点什么\\\n![编辑 markdown 文件](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209215853.png)\n\n最后使用 git 将之提交到 GitLab 远程仓库，netlify 会监听并帮我们自动部署好一切的，再访问网站可以看到新的篇章了（如果内容很多可能要等一段时间）\\\n![新的篇章](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181209220703.png)\n\n这个示例 blog 被吾辈部署到 <https://hexo-next-blog-demo.rxliuli.com/>\n\n## 总结\n\n最后，吾辈推荐看看下面的内容\n\n-   [hexo 官网](https://hexo.io/)\n-   [next 主题官网](https://theme-next.iissnan.com/)\n-   [VSCode 搭建 markdown 写作环境](:/522048077c1343b79eb9f42640c02bd0)\n-   [Markdown 图片粘贴工具 PicGo](:/b2a69a4c7578423882c648fd93cc5a1f)\n-   [Markdown 图片粘贴工具 PicGo](:/b2a69a4c7578423882c648fd93cc5a1f)\n","createdTime":1580652938040,"updatedTime":1624276104096,"resources":[],"tags":[{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"b80cb42493004bb482cc1762d5e90c9e","title":"IDEA 设置 Git-Bash 为默认 Terminal","body":"IDEA 默认集成了 **Terminal**，但默认使用的终端确是 `cmd.exe`（`Windows10` 默认则是 `PowerShell`）。而众所周知，`Windows` 在命令行上做得确实有够难用的，所以我们可以选择其他的第三方终端进行使用。\n\n这里演示一下使用 `Git-Bash` 作为默认集成的终端\n\n在设置 `Settings > Tools > Terminal` 下有一个 `Shell path` 的选择框。\n\n在里面填写以下内容：\n\n```bash\n\"D:\\Program\\cmder\\vendor\\git-for-windows\\bin\\bash.exe\"  -login -i\n```\n\n> 注：这里吾辈直接使用了 `cmder` 内置的 `Git` 客户端，关于 `cmder` 可以参考另外一篇内容：[Cmder 启动报错](:/f97fcb0bc7d747e08ce70de500bf68cb)\\\n> 而且使用 Git-Bash 的话最好确保安装的 Git 是最新版本，否则 IDEA Terminal 有可能出现光标位置偏移的错误。\n\n字符串中的内容是本机上的 `Git-Bash` 的程序完全路径，后面两个参数则是为了避免在 `IDEA` 集成的终端下发生有中文时光标异常的问题。\n","createdTime":1580652938001,"updatedTime":1624276080589,"resources":[],"tags":[{"id":"34dfb4608c934c3b8d33e9605a180e39","title":"jetbrains","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"30c2fb56f8a349b1b6f45b9dc0a049ea","title":"2019 回忆及 2020 目标","body":"## 往事凌乱\n\n对于吾辈而言，今年发生的几件事情\n\n-   转型成为前端\n-   淡出 Twitter 中文圈，逐渐回归 Telegram/QQ\n-   博客写作频率逐渐降低，但 GitHub 使用逐渐变多\n-   扎起头发，便是在家中亦然\n-   换了一家 2C 的互联网公司\n\n年前想要做的事情，如今却也不大记得了。暂且记得，曾经觉得前端日新月异的想象，现实之中却不尽然。2C 的网站甚至到了目前仍然必须支持 `IE`，而且前端混乱的生态也让人头疼不已，不仅是 UI 在不同框架的实现不一致，甚至连很多纯 JS 库也是直接依赖于框架了，成为了某个框架的一部分。例如 `Redux`，号称是通用的状态管理库，然而除了 `React`，没有框架真正在使用它，`Vue` 有自己的 `Vuex`，`Angular` 也有 `RxJS`。\n\n> 前端框架之间的割裂与没有使用框架之前的割裂真是天壤之别。\n\n下半年，吾辈进入了一家 2C 的互联网公司，真的是各种加班，具体详情参考 [一些烦心事](:/4851df9b40f6427c8bccf86560d33529)。精力消耗殆尽，感觉有时间，但又不想学什么东西，陷入了某种怪圈之中。\n\n## 未来渺茫\n\n明年，吾辈最想要接触的是 Web 桌面开发，以及机器学习。\n\n-   [ ] NodeJS 后端开发\n-   [ ] Web 桌面开发 Electron\n-   [ ] 机器学习 TensorFlow\n-   [ ] 继续维护 Blog\n-   [ ] 继续坚持读书\n-   [ ] 尝试网络小说写作\n-   [ ] 尝试 Youtube 视频创作\n\n***\n\nPass 1: 感觉上，人工智能必然取代各种各样的工作，程序员或许也无法幸免于难，而最不容易被替代的，大概就是创作型的工作吧！\n\n***\n\nPass 2：下面是一段吾辈想要写作的小说的设定集\n\n```md\n# 设定集\r\n\r\n围绕时间基点进行跳跃，逐渐向着基点流动，但却永远不会真的到达。\r\n\r\n明线是琉璃和瑞雪的感情，暗线是探索世界的真实与否。\r\n\r\n第一卷 现实\r\n\r\n从琉璃在生日之前回溯了一天开始，后又回溯到出生点之时，再次开始了新的人生，直到，某个绝望的事实笼罩了她之后，心灰意冷的再次懵懵懂懂的回到了小时候。\r\n\r\n> 百合线\r\n\r\n第二卷 黑暗\r\n\r\n因为上一世受到了严重的心理阴影，看着所有的努力化作泡影，琉璃再也没有做任何事情的动力了。在学校中，她变成了七大不可思议的传说之一。随心所欲，和家人的关系破裂，虽靠着两世的经验尚未有大问题，但心却早已经死了。直到，高中快要结束之时，她，参加了瑞雪的葬礼。然而，瑞雪在临终前的话语终究让死掉的心产生了悸动。\r\n\r\n> 黑暗线\r\n\r\n第三卷 无限\r\n\r\n她说：无论多少次，吾辈一定会拯救你的。少女立下了拯救另一个少女的誓言，但一切真能如其所愿么？\r\n\r\n不断重复，不断轮回，一个人终究无法推动整个世界到达能够医治瑞雪的方式。甚至在某次暴露了这个秘密，直接了被切片研究，并最终导致世界大战爆发。\r\n\r\n第四卷 未来\r\n\r\n再次重生的少女，不，现在已经是老婆婆的琉璃，发现世界已经到了 2060 年了。是的，她没有再次回到过去，而是活到了未来。但是，她发现了一个怪异之处：时间，似乎在倒流？但是思维却并没有，为什么其他人却很习惯的样子呢？\r\n\r\n她，想了解这个世界。为什么时间逆流，产生了 绝对的宿命论！\r\n\r\n> 科幻线\r\n\r\n第四卷 幻想\r\n\r\n结果，再次在生日之后的前一刻，琉璃的时间再次跳跃到不知名的位置，没能回到原来的世界。而且，她也变成了一块石头，女娲石。后来，琉璃几经辗转，来到了红楼梦之中。神（张恒），降临了，但他却绝望的发现这是个虚假的世界。并且，发现了她。\r\n\r\n自此，琉璃被困在了各种 GalGame 和里番之中，虽是虚拟的世界，但却完全感同身受。\r\n\r\n最终，琉璃的灵魂想要转移到刚出生的琉璃身上，却被张恒阻止了。最终，到了琉璃的生日，世界，破碎了。张恒这才明白了什么，但也无法阻止。\r\n\r\n> 幻想线\r\n\r\n第五卷 死亡\r\n\r\n论琉璃的 999 种死法。\r\n\r\n突然有一天，琉璃发现自己很容易遭到意外了。一开始只是出门时碰到了一只黑猫，再之后是在高楼下差点被花盆砸中，后来甚至在一个十字路口碰到了车祸现场，最后，她在洗澡时莫名其妙的死掉了。\r\n\r\n第六卷 真相\r\n\r\n世界只是一个实验，为了培育超级 ai 所用。然而实验结束了，准备销毁她。在将要封存一切时，张恒留下的东西让她「消失」了。\r\n\r\n> 楚门的世界\r\n\r\n一切都是假的，都是人造的，是某个实验计划的一部分，而她，便是这个世界中的「楚门」，但她最后，却没有选择去留的权利，唯有死亡一途。\n```\n","createdTime":1580652937689,"updatedTime":1624276077188,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"6cd20ff9da8e4e2491563d0aa490703a","title":"使用 vue-cli 创建模板项目","body":"## 场景\n\n吾辈曾经只是个 Java 后端开发人员，原本对前端的了解大致只有 `HTML/CSS/JavaScript/JQuery` 级别，后来接触到了 `nodejs`。不仅是工作之需，吾辈个人而言也非常想要了解现代前端技术。然而天可怜见，吾辈刚入门 `nodejs` 并没有发现什么，但发现想要构建一个项目，需要用到前端工具链实在太多了。配置文件的数量甚至远远超过后端。\r\n所以为了快速开发，入门之后遇到问题再去解决，吾辈选择了使用 `nodejs + npm + vuejs + webpack + vscode` 组合，使用 `vue-cli` 快速搭建一个基于现代前端工具链前端项目。\n\n> 致那些想要了解前端但又不得其门的后端开发者，第一步的入门是最重要/最困难的。\n\n## 步骤\n\n### 前置要求\n\n想要继续向下阅读的话请务必确认你的 PC 上已经正确安装了 nodejs/npm，如果还未曾安装，请参考 [nodejs 官网](https://nodejs.org) 进行安装\n\n> `npm` 已经默认包含在 `nodejs` 中了\n\n### 第一步：全局安装 vue-cli\n\n打开命令行，安装 `vue-cli`\n\n```sh\nnpm install -g @vue/cli\n```\n\n安装完成后在命令行输入 `vue` 应该会有类似于以下的输出\n\n![vue-cli 安装完成验证](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181108140401.png)\n\n### 第二步：使用模板初始化一个项目\n\n命令格式\n\n```sh\n# option 是选项，template 是使用的模板，app-name 是要初始化项目的名字\r\nvue init [option] <template> <app-name>\n```\n\n例如我们使用 `vue init webpack vue-webpack-example` 初始化一个 `webpack` 模板的项目，大部分组件我们暂时还不需要，所以选择 `vue-router` 以及使用 `npm` 进行构建。\n\n![vue-cli 初始化 webpack 模板项目](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181108141449.png)\n\n初始化完成后我们在命令行进入文件夹 *vue-webpack-example* 中，现在我们可以通过 `npm run dev` 启动开发服务器模式和 `npm run build` 打包项目为静态文件\n\n尝试使用 `npm run dev` 运行项目，最后应该会得到如下输出\n\n![vue 项目运行输出](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181108184122.png)\n\n在浏览器打开链接 <http://localhost:8080>\n\n![vue 项目模板](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181108184257.png)\n\n### 第三步：初始化模板的一些坑\n\n当你使用 `npm run build` 打包好静态文件在 *dist* 目录后，从文件管理器直接运行，却发现浏览器只有一片空白。\n\n![vue 打包出来的文件在浏览器显示的空白页面](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181108185531.png)\n\n这是 `vue-cli` 默认模板的问题，具体原因与解决方案请参考 [Vue 打包的静态文件不能直接运行](:/fea6cbbcf50249e2be19548d3514d92e)\n\n那么，这篇使用 `vue-cli` 简单的建立项目就到这里啦，希望各位后端开发者都能尝试有趣的现代前端呢 -(๑☆‿ ☆#)ᕗ\n","createdTime":1580652937917,"updatedTime":1624275995982,"resources":[],"tags":[{"id":"d86454b85c8f4c38aef6fa1575487e7f","title":"vue","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"ba7f17b8f76347c08ae8a49893869942","title":"关于提问与帮助","body":"## 场景\n\n不知从何时起，帮助别人似乎开始变成了一件吃力不讨好的事情。刚刚吾辈在 QQ 里面看到这样的几句发言，所以熬夜写了这篇内容。\n\n![受助者的发言](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190129232524.png)\n\n真以为别人给予帮助是一种义务了，告诉你怎么查就是在帮助你了。**总不能把饭端到你面前，却还要嚷嚷着要别人喂你吃吧？**\\\n而且，帮助是要花费时间和精力的。很多人并不是总有时间来帮你找资料的，或许我们也只是在上班的时候想稍微休息一下，看到你的问题，就谈一下大概的解决方向而已。\n\n## 思考\n\n当你想要提问时，如何更加清晰的描述你的问题让别人更容易帮助你也是你的义务。不要觉得随便提问一个：*xx 应该怎么做？* 就会有人很快的回答你。吾辈个人认为提问之前最好了解下面几点\n\n-   **不要提一些容易产生争端的问题**\\\n    例如 *`Java` 和 `PHP` 哪个更好？*\\\n    这种问题不仅容易引战，更是毫无意义。不谈使用场合，比较则无意义。就连初中生都知道对比实验应该控制 **环境变量**，难道如此简单的事情你都不清楚，你是 **巨婴** 么？\n-   **如果是纯粹知识性的问题最好先查询官网**\\\n    例如 `Spring` 怎么集成 `Mybatis`？\\\n    这种连官方文档都没过一遍就来问，就算说了也只能是鸡同鸭讲，对牛弹琴罢了。这种时候你需要的是 **学习** 而不是 **提问**。\n-   **大部分问题已经被解决过了**\\\n    虽然不想承认，但我们的所知所想所遇已然在这个世界上重复了无数次，善用搜索引擎很重要 —— 这里吾辈只推荐 **Google**，不推荐的只有 **百度**。\n-   **你遇到了非常冷门的问题**\\\n    那你要描述你的问题，让别人能简单的还原问题，才能更好的解决你的问题，最好附上一个可重现的 `github` 示例仓库。推荐提问的网站：国外 [stack overflow](https://segmentfault.com/questions)，国内 [segmentfault](https://segmentfault.com/questions)，提问之前可以看一下 [提问的智慧](https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README.md)。\n\n## 标准示例\n\n下面是在 Segmentfault 提问时的简单规范\n\n![Segmentfault 简单规范](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190129233329.png)\n\n下面是一个简单的提问示例\n\n````markdown\n# JavaScript 中如何获取子类？\r\n\r\n如题，使用 es6 class 定义的类，如何获取指定基类的所有子类呢？\r\n\r\n例如下面定义了三个类 `A, B, C`\r\n\r\n```js\r\nclass A {}\r\nclass B extends A {}\r\nclass C extends A {}\r\n```\r\n\r\n吾辈如何获取到 A 的所有子类呢？(=^-ω-^=)\r\n\r\n---\r\n\r\n有人说这个问题毫无意义，难道泥萌没有遇到过根据状态切换多种操作的情况么？难道一个一个的使用 if-else 判断会比使用 class 实现多态更优雅么？┐(￣ヮ￣)┌\n````\n\n渲染之后\n\n***\n\n# JavaScript 中如何获取子类？\n\n如题，使用 es6 class 定义的类，如何获取指定基类的所有子类呢？\n\n例如下面定义了三个类 `A, B, C`\n\n```js\nclass A {}\r\nclass B extends A {}\r\nclass C extends A {}\n```\n\n吾辈如何获取到 A 的所有子类呢？(=^-ω-^=)\n\n***\n\n有人说这个问题毫无意义，难道泥萌没有遇到过根据状态切换多种操作的情况么？难道一个一个的使用 if-else 判断会比使用 class 实现多态更优雅么？┐(￣ヮ￣)┌\n\n***\n\n是的，这是由 `Markdown` 写出来的。作为提问者，让别人能更简单知道自己的问题是必要的，而 `Markdown` 天生的 **写作语言**。所以吾辈也建议使用 `Markdown` 进行提问，至少，能传递的信息要比纯文本丰富很多，不是么？\n\n## 终末\n\n最后，吾辈个人认为如果解决了问题之后，作为提问者也有必要将之分享出来，避免后人继续踩坑。分享的方式可以使用 **博客**，**微信公众号** 之类的方式，如果能将一个问题讲明白给别人听，那才说明自己懂得了如何解决这个问题！\n\n> 吾辈在 segementfault 上的提问 [JavaScript 中如何获取子类？](https://segmentfault.com/q/1010000017910469) 以及之后写的一篇博客 [JavaScript 避免使用 if-else 的方法](:/6586ffbb50ac49ceb31397ce58b49f16)\n","createdTime":1580652937694,"updatedTime":1624275911975,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"d6cb150792f94929af671bc6b685657f","title":"手游-ウチの姫-回坑感想","body":"> 多图预警\n\n## 缘由\n\n在月初的周末，吾辈因为最近的 [一些烦心事](:/4851df9b40f6427c8bccf86560d33529)，毫无动力的躺在床上做一条无所事事的咸鱼。偶然想起来 4 年前玩过的一个游戏：[我家公主最可爱](https://pf.goone.tw/)，也是吾辈至今唯一玩过的手游，念及于此，便忍不住找了一下，果不其然，国服坟头草已然几丈高了，台服亦然，唯有日服坚持下来了，到了明年便是这个游戏的第 6 个年头了。\n日服 App 名字的全称是 **ウチの姫さまがいちばんカワイイ　- ひっぱりアクション RPGx 美少女ゲームアプリ**（虽然名字意思仍然和中文一样，但看起来却没那么羞耻了呢，或许是因为看不懂日语的缘故吧），简称 **ウチの姫**。\n下面是 [Google Play 页面](https://play.google.com/store/apps/details?id=jp.co.cyberagent.uh)\n\n![Google Play 首页截图](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229210115.png)\n\n看起来很可爱，所以吾辈想着闲着也是闲着，便轻松加愉快的重新尝试了这个游戏。\n\n## 玩法\n\n刚进入游戏首页，便有两个妹纸在抱着一只，嗯，青蛙一样的生物看着我们，而这只青蛙，自然是这个游戏的男主角啦 #笑\n\n![游戏首页](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229210505.png)\n\n进入游戏，之后的首页是这样的\n\n![进入游戏后的主页面](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229210833.png)\n\n游戏的基本玩法很简单，就是收集公主，然后让（青蛙）王子在公主的帮助下击败魔王的弹珠游戏（然而又是一个无稽之谈 #笑）\n\n![普通回合](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229211410.png)\n\n![Boss 回合](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229211447.png)\n\n然后，在打通关卡后，可以获得经验与一些公主，不过大多数都是特殊属性的公主，可以用来强化、进化以及觉醒的一些素材，统称为 **狗粮**（为什么公主被作为狗粮了 #惊哭）\n\n![获得经验](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229211911.png)\n\n![获得公主](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229212030.png)\n\n下面是一个公主的属性面板（`Status` 还是 `Properties` 呢 #笑）\n\n![属性面板](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229212322.png)\n\n可以看到的属性就有\n\n-   所属元素：存在克制关系 `光 <=> 暗`，`火 => 风 => 水 => 火...`\n-   名字：公主的名字\n-   稀有度：目前真正能用的稀有度依次是 `UR/UR+/UR++ => PUR/PUR+/PUR++ => XUR`，一般而言稀有度越高这张卡的强度可能性就越高\n-   公主自身等级：影响 HP/攻击力\n-   HP：体力值，在副本时计算的是队伍（4 位公主与 1 位外援）的总和，不过没有攻击力对强度影响大\n-   攻击力：攻击力，在副本时仅计算当前活跃公主的攻击力，对强度影响较大，因为 Boss 普遍体力非常高\n-   强度：这张卡在官方眼中的强度，强度高可能不强，但低了一定不强\n-   爱情度：影响 HP/攻击力/技能冷却回合\n-   公主队长技能：作为队长时实用的技能\n-   公主技能：能够持续几回合并有冷却时间的技能\n-   绊技能：在爱情度达到 `300` 后解锁，一半只能到 `200`\n-   附加能力属性：影响能够强化的附加能力\n-   自带防御：能够防御场上某种类型的陷阱\n-   追加属性：影响 HP/攻击力/攻击时的效果，锁住的话需要使用 **才开** 开锁，**才与** 赋值\n-   爱情度封印：影响附加能力位，爱情度 `200/300` 会锁住两个附加能力位，必须在爱情度到达之后次啊会解锁\n\n是不是感觉太复杂了，吾辈刚进入游戏的时候也是这样想的，所以就去加了一个国内的 QQ 讨论群（居然还有一些人再玩这个游戏呢），以次绕过了新手时期的困惑（虽然不是新手，但已然太久没玩，而且变化也很多）\n\n## 图鉴\n\n本质上，这是一个集卡（舔卡 #大雾）游戏\n\n下面是进入游戏必然获得几位公主：**亲女儿（爱姬） + 御三家（红苍翠）**\n\n![亲女儿](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229220923.png)\n![红](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229220947.png)\n![蓝](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229220959.png)\n![绿](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229221008.png)\n\n然而，还有各种 **卡哇伊** 的公主需要通过活动副本（#肝）/抽奖机制（#氪）获得\n\n![公主 1](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229221354.png)\n![公主 2](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229221435.png)\n![公主 3](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229221434.png)\n![公主 4](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229221433.png)\n![公主 5](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229221432.png)\n![公主 6](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229221436.png)\n![公主 7](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229221431.png)\n\n## 机制\n\n当然，作为一个手游，那么自然是有体力与扭蛋（抽奖）这两种机制了，下面由吾辈来一一说明\n\n体力值：上限与等级直接挂钩，长久来看，大致是等级的 `1/3` 左右，每次进入副本消耗体力值，会随着时间逐渐恢复（不会超过体力上限），但也可以用 **月石** 可以增加体力上限的体力值（有可能超过上限）\n\n![副本](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229214543.png)\n\n至于为什么吾辈的体力这么多（`5972/141`），原因便是吾辈连续升级了几十次，每次升级就会增加以此体力上限的体力值，故而才这么多的！当然，这种重复性的工作吾辈作为一个开发者自然是写了一个 AutoJS 脚本自动刷活动，连续两天几乎没停，但也只升了 50 级左右，可见升级的困难了。\n\n![AutoJS 脚本](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229215050.png)\n\n而扭蛋，非洲人什么话都不想说 QAQ，虽然还不到一个月，但游戏里已然氪了接近 3000 的软妹币了，更别说花费的时间与精力了，然而即便如此生存依旧苦难。\n下面是目前正开着的池子的一些数据\n\n![池子的 XUR 公主](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229215444.png)\n![详情 1](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229215604.png)\n![详情 2](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229215617.png)\n![详情 3](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229215624.png)\n\n可以看到，除了第一次，后面每次的抽奖都要 `1w` 星星，而抽到 XUR 公主的概率。。。不过是 `0.01%`。那么，1w 星星到底相当于多少软妹币呢？\n\n![官方商店](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229215910.png)\n\n可以看到，即便现在有着额外送 30% 的活动，1w 星星仍然需要接近 1w 日元左右，让我们来计算一下星星的单价吧\n\n```js\n11000 / 15431 / 15.64 === 0.045578692773257934\n```\n\n看起来似乎并不多，我们计算一下总价\n\n```js\n0.045578692773257934 * (10000 * 5 + 5000) === 2506.8281025291863\n```\n\n那么抽 6 次得到 XUR 的概率是？\n\n```js\n3 + 5 * 4 + 10 === 33\n```\n\n哦，看起来有点不妙了，仅仅为了一张卡抽 6 次池子，便如此大动干戈，即便如此，获得 XUR 的概率也只有 `33%`，这。。。(╯‵□′)╯︵┻━┻\n\n## 感想\n\n唉，不管怎样，都无法找到曾经为了游戏肝了几天时间，甚至为此压缩睡眠，看到获得了自己想要的公主之后便很快乐的感觉 -- 一切都无法回到从前了！\n","createdTime":1580652937781,"updatedTime":1624275907989,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"f7d449caae624527b5ed6fa00031b164","title":"JavaScript 使用 Promise","body":"## 场景\n\n为什么要使用 Promise？\n\nJavaScript 异步发展史：`回调函数 -> Promise -> async/await`\n\n传统异步使用回调函数，回调意味着嵌套，当你需要使用很多异步函数时，那你需要非常多的回调函数，可能形成回调地狱。\\\n有问题就有人解决，js 没有多线程，所以天生就是异步的。正是因为异步的广泛性，所以很早之前就有人着力于解决异步回调的问题，github 上有很多已经废弃的库就是用于解决这个问题的。\\\n然而现在，es6 出现了 `Promise`，它能把嵌套回调压平为一层的链式调用，并且写进了 js 标准里。es7 甚至出现了更加优雅的方式，`async/await`，能以同步的方式写异步的代码。当然，本质上只是 Promise 的一个语法糖，但其重要性也是不言而喻的——异步回调地狱已经不存在了！\\\n说了这么多，那么平常我们应该怎么使用 Promise 呢？\n\n## 使用 Promise\n\n一般而言，我们作为使用者是无需创建 Promise 的，支持 Promise 的函数会返回一个 Promise 对象给我们，然后我们使用它的方法 `then/catch` 即可。\n\n-   `then()`：当前的 JavaScript 已经完成，要进行下一步的同步/异步操作了\n-   `catch()`：用于捕获 Promise 链式调用中可能出现的错误\n\n> 注：`then/catch` 均返回一个新的 Promise\n\n例如我们有这样一个需求\n\n1.  等待资源 A 加载完成\n1.  在 A 资源加载完成之后等待 B 资源加载完成\n\n之前使用回调函数，我们的代码可能是这样的\n\n```js\n/**\r\n * 等待指定的时间/等待指定表达式成立\r\n * @param {Number|Function} param 等待时间/等待条件\r\n * @param {Function} callback 回调函数\r\n */\r\nfunction wait(param, callback) {\r\n  if (typeof param === 'number') {\r\n    setTimeout(callback, param)\r\n  } else if (typeof param === 'function') {\r\n    var timer = setInterval(() => {\r\n      if (param()) {\r\n        clearInterval(timer)\r\n        callback()\r\n      }\r\n    }, 100)\r\n  } else {\r\n    callback()\r\n  }\r\n}\r\n\r\nwait(\r\n  () => document.querySelector('#a'),\r\n  () => {\r\n    wait(\r\n      () => document.querySelector('#b'),\r\n      () => {\r\n        console.log('a, b 两个资源已经全部加载完成')\r\n      },\r\n    )\r\n  },\r\n)\r\n// 结果\r\n// a, b 两个资源已经全部加载完成\n```\n\n可以看到，上面如果还需要等待 `c,d,e,f...` 资源，那么回调函数的层级将是无法接受的。\\\n现在，我们使用 Promise 改造一下代码\n\n```js\n// 先不要管这个函数的具体实现，下面再说如何自己封装 Promise\r\n/**\r\n * 等待指定的时间/等待指定表达式成立\r\n * @param {Number|Function} param 等待时间/等待条件\r\n * @returns {Promise} Promise 对象\r\n */\r\nfunction wait(param) {\r\n  return new Promise((resolve) => {\r\n    if (typeof param === 'number') {\r\n      setTimeout(resolve, param)\r\n    } else if (typeof param === 'function') {\r\n      var timer = setInterval(() => {\r\n        if (param()) {\r\n          clearInterval(timer)\r\n          resolve()\r\n        }\r\n      }, 100)\r\n    } else {\r\n      resolve()\r\n    }\r\n  })\r\n}\r\n\r\nwait(() => document.querySelector('#a'))\r\n  // 注意这里的 wait(() => document.querySelector('#b')) 同样是一个异步函数，返回了一个 Promise\r\n  // 接下来，有趣的地方来了\r\n  // 很明显，wait 是一个异步函数。wait 函数的 then 函数调用了另一个异步函数，然而 then 会等待异步执行完成，才继续执行后面的函数\r\n  .then(() => wait(() => document.querySelector('#b')))\r\n  // 这里仍然会等待上面的 Promise 完成之后才执行下面的内容\r\n  .then(() => console.log('a, b 两个资源已经全部加载完成'))\r\n// 结果\r\n// a, b 两个资源已经全部加载完成\n```\n\n下面我们尝试使用一下 `catch`\n\n```js\nwait(() => document.querySelector('#a'))\r\n  .then(() => wait(() => document.querySelector('#b')))\r\n  .then(() => {\r\n    throw new Error('执行了某些操作发生了异常')\r\n  })\r\n  // 上面抛出了异常并且没有使用 catch 处理的话就会继续找下一个调用，直到找到处理的 catch，或者调用结束为止\r\n  .then(() => console.log('a, b 两个资源已经全部加载完成'))\r\n  // 捕获上面的 then() 发生的异常，保证后面的调用正常执行\r\n  .catch((error) => console.log('使用 catch 捕获的异常: ', error))\r\n  .then(() => console.log('测试异步函数结束'))\r\n\r\n// 结果\r\n// 使用 catch 捕获的异常:  Error: 执行了某些操作发生了异常\r\n//     at wait.then.then (<anonymous>:4:11)\r\n// VM272:9 测试异步函数结束\n```\n\n> 可以参考 MDN 上的教程 [使用 Promises](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises)\n\n## 封装 Promise\n\n那么，你是否也对上面自定义的 `wait` 函数感到好奇呢？我们来详细的了解一下具体如何做到的吧！\n\n```js\n/**\r\n * 等待指定的时间/等待指定表达式成立\r\n * @param {Number|Function} param 等待时间/等待条件\r\n * @returns {Promise} Promise 对象\r\n */\r\nfunction wait(param) {\r\n  // 这里返回了一个 Promise 对象，Promise 的构造函数要求一个函数参数\r\n  // 函数的参数实际上有两个，resolve 和 reject，分别代表 [已经完成] 和 [出现错误]\r\n  // 注：这个函数是立刻执行的，当 resolve 或 reject 执行时，这个 Promise 算是结束了，将进入下一个 then/catch 调用\r\n  return new Promise((resolve) => {\r\n    if (typeof param === 'number') {\r\n      setTimeout(resolve, param)\r\n    } else if (typeof param === 'function') {\r\n      var timer = setInterval(() => {\r\n        if (param()) {\r\n          clearInterval(timer)\r\n          // 这里执行了代码，如果有什么结果需要传递给下一个调用，则直接放到 resolve 函数内即可\r\n          resolve()\r\n        }\r\n      }, 100)\r\n    } else {\r\n      resolve()\r\n    }\r\n  })\r\n}\n```\n\n同样的，我们也可以使用 Promise 封装其他函数\n\n-   `timeout`：一个简单的 `setTimeout()` 的封装\n-   `readLocal`：读取本地浏览器选择的文件\n-   `timing`：测试函数执行的时间，不管是同步还是异步的(Promise)\n\n```js\n/**\r\n * 使用 Promise 简单封装 setTimeout\r\n * @param {Number} ms 等待时间\r\n * @returns {Promise} Promise 对象\r\n */\r\nconst timeout = (ms) => new Promise((resolve) => setTimeout(resolve, ms))\r\n/**\r\n * 读取本地浏览器选择的文件\r\n * @param {File} file 选择的文件\r\n * @param {{String}} init 一些初始选项，目前只有 type 一项\r\n * @returns {Promise} 返回了读取到的内容（异步）\r\n */\r\nconst readLocal = (() => {\r\n  const result = (file, { type = 'readAsDataURL' } = {}) =>\r\n    new Promise((resolve, reject) => {\r\n      if (!file) {\r\n        reject('file not exists')\r\n      }\r\n      const fr = new FileReader()\r\n      fr.onload = (event) => {\r\n        resolve(event.target.result)\r\n      }\r\n      fr.onerror = (error) => {\r\n        reject(error)\r\n      }\r\n      fr[type](file)\r\n    })\r\n  result.DataURL = 'readAsDataURL'\r\n  result.Text = 'readAsText'\r\n  result.BinaryString = 'readAsBinaryString'\r\n  result.ArrayBuffer = 'readAsArrayBuffer'\r\n  return result\r\n})()\r\n\r\n/**\r\n * 测试函数的执行时间\r\n * 注：如果函数返回 Promise，则该函数也会返回 Promise，否则直接返回执行时间\r\n * @param {Function} fn 需要测试的函数\r\n * @returns {Number|Promise} 执行的毫秒数\r\n */\r\nfunction timing(fn) {\r\n  const begin = performance.now()\r\n  const result = fn()\r\n  if (!(result instanceof Promise)) {\r\n    return performance.now() - begin\r\n  }\r\n  return result.then(() => performance.now() - begin)\r\n}\n```\n\n吾辈建议你也可以封装一些常用的异步函数，下面会展示 JavaScript 中如何更简单的使用异步！\n\n## 使用 async/await\n\n-   `async`：用于标识一个函数是异步函数，默认这个函数将返回一个 Promise 对象\n-   `await`：用于在 async 函数内部使用的关键字，标识一个返回 Promise 的异步函数需要等待\n\n使用 `async/await` 重构上面的代码\n\n```js\nasync function init() {\r\n  // await 等待异步函数执行完成\r\n  await wait(() => document.querySelector('#a'))\r\n  await wait(() => document.querySelector('#b'))\r\n  console.log('a, b 两个资源已经全部加载完成')\r\n}\r\n// 注：init() 函数将返回一个 Promise，我们可以继续追加下一步的操作\r\ninit()\n```\n\n是的，就是如此简单，直接在异步函数添加 `await` 关键字就好了！\n\n***\n\n最后，如果你要使用这些特性，请务必使用 babel 转换器。毕竟，有太多的人就是不肯升级浏览器。。。\n\n> 可以参考\n>\n> -   [babeljs 官方文档](https://babeljs.io/docs/en/)\n> -   [在传统项目中使用 babel 编译 ES6](:/8c57648407fa4b72ac30c3a61b1c1fef)\n","createdTime":1580652937864,"updatedTime":1624275903615,"resources":[],"tags":[{"id":"1de1ff51140a44d5a2c223459dabcc37","title":"异步","parent_id":""},{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"75e5e30a5ee3410e89cc5dcf74c579e3","title":"liuli-cli TS JS SDK CLI 工具","body":"## 场景\n\n吾辈最初尝试写 JS SDK 发布到 NPM 上，过程中遇到了很多问题，也因此消耗了大量的时间。\n包括但不限于以下这些\n\n-   折腾 Rollup 打包\n-   折腾 JS 的模块（umd/esm）\n-   折腾单元测试\n-   折腾 ES6 怎么通过 Babel 编译\n-   使用 JS 编写，没有提供类型定义\n-   没有进行打包\n-   没有编译成 ES5\n-   没有单元测试\n-   没有 API 文档\n-   没有 Linter 和 Prettier 统一格式化\n\n> 具体的过程可以参考 [使用 rollup 打包 JavaScript SDK](:/53148ce0792e49b6b18bc68ea4eb6b8e)\n\n吾辈在过程中遇到的一些问题\n\n-   [使用 Rollup + Babel 打包出错](https://segmentfault.com/q/1010000018386874/)\n-   [npm 发布后的包安装后无法引用？](https://segmentfault.com/q/1010000018914964)\n-   [为什么上传到 GitHub Pages 的静态资源会 404 了呢？有人遇到过么？](https://segmentfault.com/q/1010000019587945)\n\n吾辈目前所在的公司中的 NPM 库也存在这些问题，内部的 npm 库几乎不能称为一个合格的库，以上的问题基本都存在。所以为了重构公司的 npm 包（主要是为了提供类型定义），就想是否能够把这部分单独抽离成一个脚手架，因而便开发了 SDK cli 供公司的前端 dev 创建一个标准（包含打包、编译、测试、文档、发布）的 SDK，并希望以此抹平不同 NPM 库配置的不一致性。\n\n## 解决\n\n所以吾辈后来创造了 [liuli-cli](https://www.npmjs.com/package/liuli-cli)，用于简化和统一创建 JS/TS SDK 的步骤。\n\n目前实现的功能如下\n\n-   [x] 基本打包支持\n-   [x] 模块化 umd/es\n-   [x] jest 单元测试支持\n-   [x] 代码压缩支持\n-   [x] babel 支持\n-   [x] ts 支持\n-   [x] linter 支持\n-   [x] prettier 格式化支持\n-   [x] git 钩子支持\n-   [x] esdoc\n-   [x] typedoc\n-   [x] 许可证选择支持\n\n使用的话也很简单\n\n全局安装 liuli-cli\n\n```sh\nnpm i -g liuli-cli\n```\n\n然后便可以使用命令 `li` 创建项目\n\n```sh\nli create <project-name>\n```\n\n目前支持以下三种类型（强烈推荐库的作者使用 TypeScript）\n\n-   `JavaScript 模板`\n-   `TypeScript 模板`\n-   `命令行工具模板`\n\n之后根据引导即可创建一个开箱即用的项目了\n\n## 反例\n\n让我们看看那些大公司云服务的 JS SDK 是怎样的。\n\n腾讯：提供的 SDK 大多是一个 JS 文件，需要在项目里手动引入，甚至有些是依赖了开源依赖，导致开源依赖使用 npm 管理，而私有服务的 SDK 仍然使用 JS 的方式引入。\n\n-   [对象存储](https://cloud.tencent.com/document/product/436)\n-   [腾讯云点播](https://cloud.tencent.com/document/product/266)\n-   [即时通信 IM](https://cloud.tencent.com/document/product/269)\n\n讯飞：web 版 demo 明明有 package.json 这种版本控制工具，但却仍然是在一个 HTML 里直接 script 脚本引入，而非使用 npm/yarn 进行依赖管理，而 package.json 里面只是一个 http-server 用以开启一个静态服务器看 demo 罢了。\n\n-   [语音听写](https://www.xfyun.cn/doc/asr/voicedictation/API.html)\n-   [语音转写](https://www.xfyun.cn/doc/asr/lfasr/API.html)\n-   [实时语音转写](https://www.xfyun.cn/doc/asr/rtasr/API.html)\n\n或许在大公司的这些 SDK 的开发者看来，会使用他们这些服务的公司都是小公司，以及一些没有接触过现代前端的开发者，所以都以这种方式提供 SDK。更不要说文档与类型定义，这两项几乎是 JS SDK 标准的需求，他们都没有做好。而且，明明他们的 SDK 也有版本号，甚至给出的 JS SDK 本身便是 umd 的，但实际上却未发布在 npm 或是其他公开的仓库中（作为库的使用者吾辈没有找到）。这些开发者宁愿用户提工单询问，并浪费了大量的沟通时间解决问题也不愿意最开始就将这些做的好一点。\n\n> Pass1：文档可能过时，但 Demo 一定是最新的。\n> Pass2：这行代码不知道做什么的，但没有了就会出错，先放在这里。\n\n当然，或许创建第三方组织可以解决部分这个问题，像是 [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped) 那个 ts 的开源项目一样，但问题仍然很多\n\n1.  目标对象不同：DefinitelyTyped 的目标是为了没有 types 的 js 库定义类型，它的目标对象也是开源（大多数时候也是）免费的库。而像是腾讯这些内部服务的 SDK 是收费、不开源的，很难让人免费为其做贡献。\n1.  各家都有类似的云服务：提供这种云服务的公司并不止一家，难道要为每一家都添加创建类似的组织么？\n1.  安全性问题：第三方组织不能保证每一行贡献的内容一定就和官方的一模一样，就算引入了恶意代码也很难立刻发现。\n1.  法律风险：这样做的话是否会被官方发律师函也是未知之数。\n\n当然，也有一些个人为某些云服务创建的 NPM 库\n\n-   <https://www.npmjs.com/package/xunfeisdk>\n-   <https://www.npmjs.com/package/xfy-node>\n\n但更多的服务是没有的，而且个人创建的这些库很难保证一直不过时（大多数都是某个项目用了一下罢了）。如果能简化项目的初始化流程，不知是否能让官方发布到 NPM 组织下。\n\n## 总结\n\n关于使用 CLI 会阻碍人接触更**底层**的知识这点，属于仁者见仁智者见智的事情。毕竟，CLI 能够简化重复的劳动自然是会受到欢迎，前端三大框架也都有自己的 CLI 用于快速创建项目，降低框架的使用门槛，避免接触到一些琐碎的细节而专注于自己的需求开发。\n\n> webpack/babel 真的不能说底层，尤其是 webpack，复杂性太高、知识的时效性太短导致现在它的风评并不好。。。\n\n最后，这个项目才写出来没多久，欢迎任何人使用、批评和建议！\n","createdTime":1582444266254,"updatedTime":1624275894685,"resources":[],"tags":[{"id":"95ddbbd925aa4358a46bfcbce4c3fb46","title":"工具","parent_id":""},{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"3a7307f6d7354c95ad735831f8ee73b9","title":"Windows 上 Maven 安装与使用","body":"> [官网](https://maven.apache.org), [GitHub](https://github.com/apache/maven)\n\n## 介绍\n\nMaven 已经是 Java 事实上的依赖管理标准工具了，所以学习使用 maven 有益无害。\n\n## 前置要求\n\n-   [x] 必须已经安装了 JDK 并设置了环境变量，如果还没有安装，请参考 [Windows 上安装 JDK 并设置环境变量](:/7fefb689b04840dc92ff85a703128115) 进行安装\n\n## 下载\n\n在官网 [下载页面](https://maven.apache.org/download.cgi) 找到 **Binary zip archive** 下载二进制数据。\n\n![Maven 下载页面](https://img.rxliuli.com/20181109124211.png)\n\n> 这里不使用二进制安装包的原因是绿色版更容易迁移，而且是跨平台的。\n\n## 设置环境变量\n\n将文件夹解压到某个位置，然后在环境变量 **Path** 中添加 */bin/* 目录\n\n![Maven 设置环境变量](https://img.rxliuli.com/20181109124557.png)\n\n## 验证安装\n\n使用 cmd 打开命令行，输入 `mvn --version`，你应该得到了类似于下面的输出\n\n![查看 Maven 的版本](https://img.rxliuli.com/20181109124924.png)\n\n## 基本使用\n\n1.  创建一个普通的项目\n\n    直接使用命令行根据模板创建项目在实际中极为罕见，这里只是演示一下 maven 可以使用命令行创建项目而已\n\n    ```sh\n    mvn archetype:generate -DgroupId=com.rxliuli.maven.example -DartifactId=HelloWorld -DarchetypeArtifactId\n    =maven-archetype-quickstart -DinteractiveMode=false\n    ```\n\n    应该会得到如下输出\n\n    ![Maven 使用命令行创建模板项目](https://img.rxliuli.com/20181109130243.png)\n\n1.  进入项目\n\n    项目目录结构\n\n    ```sh\n    HelloWorld\n    └─src\n    ├─main\n    │  └─java\n    │      └─com\n    │          └─rxliuli\n    │              └─maven\n    │                  └─example\n    └─test\n        └─java\n            └─com\n                └─rxliuli\n                    └─maven\n                        └─example\n    ```\n\n    maven 项目的配置文件是 `pom.xml`，而 **源码** 与 **测试** 代码则分离到了两个单独的文件夹\n\n1.  maven 基本命令\n    -   package(mvn package): 打包项目\n    -   clean(mvn clean): 清理打包目录\n    -   test(mvn test): 执行 test 目录下的测试\n    -   install(mvn install): 打包项目并安装到本地\n\n其实原生 maven 了解多少并没有什么，因为 IDE 基本都集成了这些开源的工具，并不需要我们手动输入 maven 命令了。嘛，多少了解一些也是挺好的啦ヽ(=^･ω･^=)丿\n","createdTime":1587219249396,"updatedTime":1624275888469,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"0a924f166b48497e9d1d19048967e880","title":"Java 微信公众号开发","body":"-   [Java 微信公众号开发](#java-微信公众号开发)\n    -   [场景](#场景)\n    -   [注册微信公众号](#注册微信公众号)\n    -   [基本配置](#基本配置)\n    -   [使用测试账号](#使用测试账号)\n    -   [服务端编码](#服务端编码)\n        -   [初始化项目](#初始化项目)\n        -   [内网穿透](#内网穿透)\n        -   [微信服务器认证](#微信服务器认证)\n        -   [消息处理](#消息处理)\n        -   [创建菜单](#创建菜单)\n\n## 场景\n\n公司需要做一个微信的公众号，以前没有玩过结果踩了一堆坑，也是无奈了，便在这里记录一下\n\n## 注册微信公众号\n\n首先在 [微信公众平台](https://mp.weixin.qq.com/) 注册一个账号，这里选择了 *订阅号*，填写一堆乱七八糟的信息后就得到了一个微信公众号（订阅号）了。之后登录的话却是要进行扫码操作（反人类操作）。\n\n## 基本配置\n\n在【开发 > 基本配置】中设定好相关的信息，主要有\n\n-   开发者 ID(AppID)：自动生成\n-   开发者密码(AppSecret)：修改完之后记录下来，一会还要用到\n-   IP 白名单：可以公网访问的服务器 IP 地址（没有也行，后面会说到 **内网穿透**）\n-   服务器地址(URL)：用于给微信校验的服务器地址，没有公网服务器也行\n-   令牌(Token)：自定义，随机字符串即可，可以在 [LastPass](https://www.lastpass.com/zh/password-generator) 生成一个\n-   消息加解密密钥(EncodingAESKey)：点击随机生成即可\n-   消息加解密方式：目前选择明文模式\n\n> 配置服务器地址时会报错，先不管了就行，后面会再回来配置的。\n\n## 使用测试账号\n\n有了自己的微信公众号当然很好，但不可能每次都直接修改真正的公众号吧，修改挂了怎么办？所以就有了测试公众号，而且测试公众号的权限是要高于普通的未认证订阅号的。\n\n在【开发 > 公众平台测试帐号 > 公众平台测试帐号】中申请一个测试账号，如 [基本配置](#基本配置) 所述中配置一下。\n\n> 安全域名设置：如果你有的自己的域名和服务器的话就配置，否则就先不管。\n\n## 服务端编码\n\n### 初始化项目\n\n为了简化配置这里使用 SpringBoot Web 项目作为例子（注意勾上 web 模块依赖）\n\n### 内网穿透\n\n使用内网穿透工具 serveo 实现将本地内网服务映射到外网的 80 端口上\n\n> 下面的命令要求系统已经安装了 SSH 客户端，Linux 已经默认安装了，如果是 Windows 可以使用 Cmder 或 Git For Windows 之类的。\n\n```sh\nssh -o ServerAliveInterval=60 -R rx:80:localhost:8080 serveo.net\n```\n\n> 具体可以参考 [官网](https://serveo.net/) 或 [使用 Serveo 进行内网穿透](:/baff72b44ada421e8a5c28f1d4102110)\n\n现在，访问 <https://rx.serveo.net/>，是不是已经可以啦（出现的 `Whitelabel Error Page` 不用管，因为我们本来也没有处理 `/` 路径的访问）\n\n### 微信服务器认证\n\n引入额外的依赖（SpringBoot Web 项目默认引入 `spring-boot-starter`，`spring-boot-starter-web` 和 `spring-boot-starter-test` 模块）\n\n```xml\n<!--微信的公众号依赖-->\n<dependency>\n    <groupId>com.github.binarywang</groupId>\n    <artifactId>weixin-java-mp</artifactId>\n    <version>3.1.0</version>\n</dependency>\n```\n\n添加配置文件 `application.yml`\n\n```yml\n# 非必需，但这里还是设定一下端口，方便后面写启动脚本\nserver:\n  port: 8080\ncustom:\n  wx:\n    mp:\n      # 基本上都是微信公众号那边的设置（这里是测试的）\n      appId: appId\n      secret: secret\n      token: token\n      aesKey: aesKey\n```\n\n将配置读取到 Java Bean 对象上方便在程序中使用 `WxMpPropertiesConfig`\n\n```java\n/**\n * 微信公众号属性配置\n *\n * @author rxliuli\n */\n@ConfigurationProperties(prefix = \"custom.wx.mp\")\npublic class WxMpPropertiesConfig {\n    private String appId;\n    private String secret;\n    private String token;\n    private String aesKey;\n    // getter() and setter()\n}\n```\n\n添加微信相关的主配置类 `WxMpMainConfig`\n\n```java\n/**\n * 微信公众号主要的配置类\n *\n * @author rxliuli\n */\n@Configuration\n@EnableConfigurationProperties(WxMpPropertiesConfig.class)\npublic class WxMpMainConfig {\n    private final WxMpPropertiesConfig wxMpPropertiesConfig;\n\n    /**\n     * 微信公众号的服务对象\n     * 用户调用微信的各种 API, 例如获取 access_token\n     */\n    private WxMpService wxMpService;\n\n    @Autowired\n    public WxMpMainConfig(WxMpPropertiesConfig wxMpPropertiesConfig) {\n        this.wxMpPropertiesConfig = wxMpPropertiesConfig;\n    }\n\n    /**\n     * 初始化路由列表和微信服务 api 对象\n     */\n    @PostConstruct\n    public void init() {\n        //配置微信 api 对象的策略（目前在内存中）\n        final WxMpInMemoryConfigStorage storage = new WxMpInMemoryConfigStorage();\n        storage.setAppId(wxMpPropertiesConfig.getAppId());\n        storage.setSecret(wxMpPropertiesConfig.getSecret());\n        storage.setAesKey(wxMpPropertiesConfig.getAesKey());\n        storage.setToken(wxMpPropertiesConfig.getToken());\n        //设置策略到服务对象中\n        wxMpService = new WxMpServiceImpl();\n        wxMpService.setWxMpConfigStorage(storage);\n    }\n\n    @Bean\n    public WxMpService wxMpService() {\n        return wxMpService;\n    }\n}\n```\n\n添加一个窗口 api 用于给微信调用 `WxMpPortalApi`\n\n```java\n/**\n * 微信服务窗口 api\n *\n * @author rxliuli\n */\n@RestController\n@RequestMapping(\"/wx/portal\")\npublic class WxMpPortalApi {\n    private final WxMpService wxMpService;\n\n    @Autowired\n    public WxMpPortalApi(WxMpService wxMpService) {\n        this.wxMpService = wxMpService;\n    }\n\n    /**\n     * 微信认证当前服务可用\n     *\n     * @param signature 微信加密签名，signature 结合了开发者填写的 token 参数和请求中的 timestamp 参数、nonce 参数\n     * @param timestamp 时间戳\n     * @param nonce     随机数\n     * @param echostr   成功后回传的随机字符串\n     * @return {@code echostr}\n     */\n    @GetMapping\n    public String authGet(\n            String signature,\n            String timestamp,\n            String nonce,\n            String echostr\n    ) {\n        if (StringUtils.isAnyEmpty(signature, timestamp, nonce, echostr)) {\n            throw new IllegalArgumentException(\"请求非法参数!\");\n        }\n        if (wxMpService.checkSignature(timestamp, nonce, signature)) {\n            return echostr;\n        }\n        return \"非法请求\";\n    }\n}\n```\n\n重启项目，将 <https://rx.serveo.net/wx/portal> 填到服务器配置中的 url 里面，点击 **提交**，应该可以看到 \\[修改成功] 的提示了。\n\n### 消息处理\n\n很显然，如果我们只让微信认证我们的服务器的话是做不了什么的，所以我们需要监听并处理用户在微信公众号中的操作并返回结果。\n\n修改微信服务窗口 api `WxMpPortalApi`，添加对 `post` 请求的处理\n\n```java\n/**\n * 微信服务窗口 api\n *\n * @author rxliuli\n */\n@RestController\n@RequestMapping(\"/wx/portal\")\npublic class WxMpPortalApi {\n    private final Logger log = LoggerFactory.getLogger(getClass());\n\n    private final WxMpService wxMpService;\n    private final WxMpMessageRouter router;\n\n    @Autowired\n    public WxMpPortalApi(WxMpService wxMpService, WxMpMessageRouter router) {\n        this.wxMpService = wxMpService;\n        this.router = router;\n    }\n\n    /**\n     * 微信认证当前服务可用\n     *\n     * @param signature 微信加密签名，signature 结合了开发者填写的 token 参数和请求中的 timestamp 参数、nonce 参数\n     * @param timestamp 时间戳\n     * @param nonce     随机数\n     * @param echostr   成功后回传的随机字符串\n     * @return {@code echostr}\n     */\n    @GetMapping\n    public String authGet(\n            String signature,\n            String timestamp,\n            String nonce,\n            String echostr\n    ) {\n        if (StringUtils.isAnyEmpty(signature, timestamp, nonce, echostr)) {\n            throw new IllegalArgumentException(\"请求非法参数!\");\n        }\n        if (wxMpService.checkSignature(timestamp, nonce, signature)) {\n            return echostr;\n        }\n        return \"非法请求\";\n    }\n\n    /**\n     * 对所有来自微信服务器的消息进行预处理\n     *\n     * @param requestBody 请求体（xml 格式）\n     * @return 明文消息\n     */\n    @PostMapping\n    public String authPost(\n            @RequestBody String requestBody,\n            @RequestParam(\"signature\") String signature,\n            @RequestParam(\"timestamp\") String timestamp,\n            @RequestParam(\"nonce\") String nonce,\n            @RequestParam(name = \"encrypt_type\", required = false) String encType,\n            @RequestParam(name = \"msg_signature\", required = false) String msgSignature\n    ) throws JsonProcessingException {\n        if (!wxMpService.checkSignature(timestamp, nonce, signature)) {\n            throw new IllegalArgumentException(\"非法请求, 并非微信发来的\");\n        }\n\n        WxMpXmlMessage inMessage = null;\n        if (encType == null) {\n            //明文传输\n            inMessage = WxMpXmlMessage.fromXml(requestBody);\n        } else if (\"aes\".equals(encType)) {\n            //aes 加密\n            inMessage = WxMpXmlMessage.fromEncryptedXml(requestBody, wxMpService.getWxMpConfigStorage(), timestamp, nonce, msgSignature);\n        }\n        WxMpXmlOutMessage outMessage = router.route(inMessage);\n        log.info(\"客户端发送的消息: {}\", new ObjectMapper().writeValueAsString(outMessage));\n        return outMessage == null ? \"\" : outMessage.toXml();\n    }\n}\n```\n\n添加一个用户消息处理器\n\n```java\n/**\n * 基础微信消息处理器\n *\n * @author rxliuli\n */\npublic abstract class BaseHandler implements WxMpMessageHandler {\n    final Logger log = LoggerFactory.getLogger(getClass());\n\n    /**\n     * 默认空实现\n     *\n     * @param wxMessage      微信的消息\n     * @param context        上下文环境(用于在 handler 中传递信息)\n     * @param wxMpService    微信 api 服务\n     * @param sessionManager 会话管理\n     * @return xml 格式的消息, 异步可返回 null\n     */\n    @Override\n    public WxMpXmlOutMessage handle(WxMpXmlMessage wxMessage, Map<String, Object> context, WxMpService wxMpService, WxSessionManager sessionManager) {\n        return null;\n    }\n}\n\n/**\n * 用户发送消息的处理器\n *\n * @author rxliuli\n */\n@Component\npublic class MsgHandler extends BaseHandler {\n    @Override\n    public WxMpXmlOutMessage handle(WxMpXmlMessage wxMessage, Map<String, Object> context, WxMpService wxMpService, WxSessionManager sessionManager) {\n        log.info(\"接收到消息: {}\", wxMessage.getMsg());\n        final String content = \"您发送的消息为: \" + wxMessage.getContent();\n        return WxMpXmlOutMessage.TEXT().content(content)\n                .fromUser(wxMessage.getToUser())\n                .toUser(wxMessage.getFromUser())\n                .build();\n    }\n}\n```\n\n修改微信公众号主要的配置类 `WxMpMainConfig`，添加路由管理器\n\n```java\n/**\n * 微信公众号主要的配置类\n *\n * @author rxliuli\n */\n@Configuration\n@EnableConfigurationProperties(WxMpPropertiesConfig.class)\npublic class WxMpMainConfig {\n    private final WxMpPropertiesConfig wxMpPropertiesConfig;\n    private final MsgHandler msgHandler;\n    /**\n     * 微信公众号监听管理路由映射表\n     * 其实就是监听用户在公众号的操作罢了, 比如点击了某个菜单, 发送了一些消息\n     */\n    private WxMpMessageRouter wxMpMessageRouter;\n    /**\n     * 微信公众号的服务对象\n     * 用户调用微信的各种 API, 例如获取 access_token\n     */\n    private WxMpService wxMpService;\n\n    @Autowired\n    public WxMpMainConfig(WxMpPropertiesConfig wxMpPropertiesConfig, MsgHandler msgHandler) {\n        this.wxMpPropertiesConfig = wxMpPropertiesConfig;\n        this.msgHandler = msgHandler;\n    }\n\n    /**\n     * 初始化路由列表和微信服务 api 对象\n     */\n    @PostConstruct\n    public void init() {\n        //配置微信 api 对象的策略（目前在内存中）\n        final WxMpInMemoryConfigStorage storage = new WxMpInMemoryConfigStorage();\n        storage.setAppId(wxMpPropertiesConfig.getAppId());\n        storage.setSecret(wxMpPropertiesConfig.getSecret());\n        storage.setAesKey(wxMpPropertiesConfig.getAesKey());\n        storage.setToken(wxMpPropertiesConfig.getToken());\n        //设置策略到服务对象中\n        wxMpService = new WxMpServiceImpl();\n        wxMpService.setWxMpConfigStorage(storage);\n        //添加路由\n        wxMpMessageRouter = this.newRouter(wxMpService);\n    }\n\n    /**\n     * 根据微信 api 服务对象创建一个微信监听路由\n     *\n     * @param wxMpService 微信 api 服务\n     * @return 微信监听路由对象\n     */\n    private WxMpMessageRouter newRouter(WxMpService wxMpService) {\n        WxMpMessageRouter router = new WxMpMessageRouter(wxMpService);\n        //发送消息(默认)\n        router.rule().async(false).handler(this.msgHandler).end();\n        return router;\n    }\n\n    @Bean\n    public WxMpService wxMpService() {\n        return wxMpService;\n    }\n\n    @Bean\n    public WxMpMessageRouter wxMpMessageRouter() {\n        return wxMpMessageRouter;\n    }\n}\n```\n\n现在向公众号发送消息，就可以得到回复了（简单的）。还有日志，菜单，关注，取消关注等处理器这里就不赘述了\n\n### 创建菜单\n\n创建一个简单的公众号菜单 Api 对象\n\n```java\n/**\n * 微信公众号菜单\n *\n * @author rxliuli\n */\n@RestController\n@RequestMapping(\"/wx/menu/\")\npublic class WxMpMenuApi extends WxMpBaseApi {\n    /**\n     * 创建一个默认的菜单\n     *\n     * @return 菜单 id\n     */\n    @GetMapping(\"create\")\n    public String createDefault() throws WxErrorException {\n        final WxMenu wxMenu = new WxMenu();\n        final WxMenuButton buttonLeft = new WxMenuButton();\n        buttonLeft.setType(WxConsts.MenuButtonType.CLICK);\n        buttonLeft.setName(\"点击\");\n        buttonLeft.setKey(IdWorker.getIdStr());\n\n        final WxMenuButton buttonRight = new WxMenuButton();\n        buttonRight.setType(WxConsts.MenuButtonType.VIEW);\n        buttonRight.setName(\"链接\");\n        buttonRight.setUrl(\"https://blog.rxliuli.com\");\n        buttonRight.setKey(IdWorker.getIdStr());\n        wxMenu.getButtons().add(buttonLeft);\n        wxMenu.getButtons().add(buttonRight);\n        return wxMpService.getMenuService().menuCreate(wxMenu);\n    }\n}\n```\n\n访问 <https://rx.serveo.net/wx/menu/create> 就可以为微信公众号创建一个简单的菜单了。点击左边的“点击\"按钮会回复文字说点击了什么，右边的链接则会跳转到一个网页。\n\n> 其他的功能就放到后面再实现吧，更多公众号开发相关的内容可以参考 [微信官方文档](https://mp.weixin.qq.com/wiki) 和 [微信开发工具包](https://github.com/Wechat-Group/weixin-java-tools)。当然，所有的示例代码吾辈都已经放到了 [GitHub](https://github.com/rxliuli/wx-mp-example)，却是可以参考一下的呢\n","createdTime":1587219249393,"updatedTime":1624275878284,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"95eaa7c43d9545afb1865646bb46839d","title":"SpringBoot 进行测试","body":"## 概略\n\nSpringBoot 中进行测试比 Spring 项目中更加简单，想了解 Spring 项目中测试的可以参考 [使用 Spring 时进行测试](:/9413f341bc2e46ca844d6914b99349d4)。\n\n## 普通测试\n\n假设要测试一个工具类 `StringUtil`（`com.rxliuli.example.springboottest.util.StringUtil`）\n\n```java\n/**\n * 用于测试的字符串工具类\n *\n * @author rxliuli\n */\npublic class StringUtil {\n    /**\n     * 判断是否为空\n     *\n     * @param string 要进行判断的字符串\n     * @return 是否为 null 或者空字符串\n     */\n    public static boolean isEmpty(String string) {\n        return string == null || string.isEmpty();\n\n    }\n\n    /**\n     * 判断是否为空\n     *\n     * @param string 要进行判断的字符串\n     * @return 是否为 null 或者空字符串\n     */\n    public static boolean isNotEmpty(String string) {\n        return !isEmpty(string);\n    }\n\n    /**\n     * 判断是否有字符串为空\n     *\n     * @param strings 要进行判断的一个或多个字符串\n     * @return 是否有 null 或者空字符串\n     */\n    public static boolean isAnyEmpty(String... strings) {\n        return Arrays.stream(strings)\n                .anyMatch(StringUtil::isEmpty);\n    }\n\n    /**\n     * 判断字符串是否全部为空\n     *\n     * @param strings 要进行判断的一个或多个字符串\n     * @return 是否全部为 null 或者空字符串\n     */\n    public static boolean isAllEmpty(String... strings) {\n        return Arrays.stream(strings)\n                .allMatch(StringUtil::isEmpty);\n    }\n}\n```\n\n需要添加依赖 `spring-boot-starter-test` 以及指定 `assertj-core` 的最新版本\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.assertj</groupId>\n            <artifactId>assertj-core</artifactId>\n            <version>3.9.1</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n\n> 这里指定 `assertj-core` 的版本是为了使用较新的一部分断言功能（例如属性 `lambda` 断言）\n\n```java\n/**\n * @author rxliuli\n */\npublic class StringUtilTest {\n    private String strNull = null;\n    private String strEmpty = \"\";\n    private String strSome = \"str\";\n\n    @Test\n    public void isEmpty() {\n        //测试 null\n        assertThat(StringUtil.isEmpty(strNull))\n                .isTrue();\n        //测试 empty\n        assertThat(StringUtil.isEmpty(strEmpty))\n                .isTrue();\n        //测试 some\n        assertThat(StringUtil.isEmpty(strSome))\n                .isFalse();\n    }\n\n    @Test\n    public void isNotEmpty() {\n        //测试 null\n        assertThat(StringUtil.isNotEmpty(strNull))\n                .isFalse();\n        //测试 empty\n        assertThat(StringUtil.isNotEmpty(strEmpty))\n                .isFalse();\n        //测试 some\n        assertThat(StringUtil.isNotEmpty(strSome))\n                .isTrue();\n    }\n\n    @Test\n    public void isAnyEmpty() {\n        assertThat(StringUtil.isAnyEmpty(strNull, strEmpty, strSome))\n                .isTrue();\n        assertThat(StringUtil.isAnyEmpty())\n                .isFalse();\n    }\n\n    @Test\n    public void isAllEmpty() {\n        assertThat(StringUtil.isAllEmpty(strNull, strEmpty, strSome))\n                .isFalse();\n        assertThat(StringUtil.isAnyEmpty(strNull, strEmpty))\n                .isTrue();\n    }\n}\n```\n\n这里和非 SpringBoot 测试时没什么太大的区别，唯一的一点就是引入 Jar 不同，这里虽然我们只引入了 `spring-boot-starter-test`，但它本身已经帮我们引入了许多的测试相关类库了。\n\n## Dao/Service 测试\n\n从这里开始就和标准的 Spring 不太一样了\n\n首先，我们需要 Dao 层，这里使用 H2DB 和 SpringJDBC 做数据访问层（比较简单）。\n\n依赖\n\n```xml\n<dependency>\n    <groupId>com.h2database</groupId>\n    <artifactId>h2</artifactId>\n    <scope>runtime</scope>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n```\n\n添加两个初始化脚本\n\n数据库结构 `db_schema.sql`（`db/db_schema.sql`）\n\n```sql\ndrop table if exists user;\ncreate table user (\n  id   int auto_increment not null\n  comment '编号',\n  name varchar(20)        not null\n  comment '名字',\n  sex  boolean            null\n  comment '性别',\n  age  int                null\n  comment '年龄'\n);\n```\n\n数据库数据 `db_data.sql`（`db/db_data.sql`）\n\n```sql\ninsert into user (id, name, sex, age)\nvalues\n  (1, '琉璃', false, 17),\n  (2, '月姬', false, 1000);\n```\n\n为 SpringBoot 配置一下数据源及初始化脚本\n\n```yaml\nspring:\n  datasource:\n    driver-class-name: org.h2.Driver\n    platform: h2\n    schema: classpath:db/db_schema.sql\n    data: classpath:db/db_data.sql\n```\n\n然后是实体类与 Dao\n\n用户实体类 `User`（`com.rxliuli.example.springboottest.entity.User`）\n\n```java\n/**\n * @author rxliuli\n */\npublic class User implements Serializable {\n    private Integer id;\n    private String name;\n    private Boolean sex;\n    private Integer age;\n\n    public User() {\n    }\n\n    public User(String name, Boolean sex, Integer age) {\n        this.name = name;\n        this.sex = sex;\n        this.age = age;\n    }\n\n    public User(Integer id, String name, Boolean sex, Integer age) {\n        this.id = id;\n        this.name = name;\n        this.sex = sex;\n        this.age = age;\n    }\n    //getter() and setter()\n}\n```\n\n用户 Dao `UserDao`（`com.rxliuli.example.springboottest.dao.UserDao`）\n\n```java\n/**\n * @author rxliuli\n */\n@Repository\npublic class UserDao {\n    private final RowMapper<User> userRowMapper = (rs, rowNum) -> new User(\n            rs.getInt(\"id\"),\n            rs.getString(\"name\"),\n            rs.getBoolean(\"sex\"),\n            rs.getInt(\"age\")\n    );\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    /**\n     * 根据 id 获取一个对象\n     *\n     * @param id id\n     * @return 根据 id 查询到的对象，如果没有查到则为 null\n     */\n    public User get(Integer id) {\n        return jdbcTemplate.queryForObject(\"select * from user where id = ?\", userRowMapper, id);\n    }\n\n    /**\n     * 查询全部用户\n     *\n     * @return 全部用户列表\n     */\n    public List<User> listForAll() {\n        return jdbcTemplate.query(\"select * from user\", userRowMapper);\n    }\n\n    /**\n     * 根据 id 删除用户\n     *\n     * @param id 用户 id\n     * @return 受影响行数\n     */\n    public int deleteById(Integer id) {\n        return jdbcTemplate.update(\"delete from user where id = ?\", id);\n    }\n}\n```\n\n接下来才是正事，测试 Dao 层需要加载 Spring 容器，自动回滚以避免污染数据库。\n\n```java\n/**\n * {@code @SpringBootTest} 和 {@code @RunWith(SpringRunner.class)} 是必须的，这里貌似一直有人误会需要使用 {@code @RunWith(SpringJUnit4ClassRunner.class)}，但其实并不需要了\n * 下面的 {@code @Transactional} 和 {@code @Rollback}则是开启事务控制以及自动回滚\n *\n * @author rxliuli\n */\n@SpringBootTest\n@RunWith(SpringRunner.class)\n@Transactional\n@Rollback\npublic class UserDaoTest {\n    @Autowired\n    private UserDao userDao;\n\n    @Test\n    public void get() {\n        int id = 1;\n        User result = userDao.get(id);\n        //断言 id 和 get id 相同\n        assertThat(result)\n                .extracting(User::getId)\n                .contains(id);\n    }\n\n    @Test\n    public void listForAll() {\n        List<User> userList = userDao.listForAll();\n        //断言不为空\n        assertThat(userList)\n                .isNotEmpty();\n    }\n\n    @Test\n    public void deleteById() {\n        int result = userDao.deleteById(1);\n        assertThat(result)\n                .isGreaterThan(0);\n    }\n}\n```\n\n## Web 测试\n\n与传统的 SpringTest 一样，SpringBoot 也分为两种。\n\n-   独立安装测试：\\\n    手动加载单个 Controller，所以测试其他 Controller 中的接口会发生异常。但测试速度上较快，所以应当优先选择。\n-   集成 Web 环境测试：\\\n    将启动并且加载所有的 Controller, 所以效率上之于 BaseWebUnitTest 来说非常低下, 仅适用于集成测试多个 Controller 时使用。\n\n### 独立安装测试\n\n主要是设置需要使用的 Controller 实例，然后用获得 MockMvc 对象进行测试即可。\n\n```java\n/**\n * @author rxliuli\n */\n@SpringBootTest\n@RunWith(SpringRunner.class)\n@Transactional\n@Rollback\npublic class UserControllerUnitTest {\n    @Autowired\n    private UserController userController;\n    /**\n     * 用于测试 API 的模拟请求对象\n     */\n    private MockMvc mockMvc;\n\n    @Before\n    public void before() {\n        //模拟一个 Mvc 测试环境，获取一个 MockMvc 实例\n        mockMvc = MockMvcBuilders.standaloneSetup(userController)\n                .build();\n    }\n\n    @Test\n    public void testGet() throws Exception {\n        //测试能够正常获取\n        Integer id = 1;\n        mockMvc.perform(\n                //发起 get 请求\n                get(\"/user/\" + id)\n        )\n                //断言请求的状态是成功的(200)\n                .andExpect(status().isOk())\n                //断言返回对象的 id 和请求的 id 相同\n                .andExpect(jsonPath(\"$.id\").value(id));\n    }\n\n    @Test\n    public void listForAll() throws Exception {\n        //测试正常获取\n        mockMvc.perform(\n                //发起 post 请求\n                post(\"/user/listForAll\")\n        )\n                //断言请求状态\n                .andExpect(status().isOk())\n                //断言返回结果是数组\n                .andExpect(jsonPath(\"$\").isArray())\n                //断言返回数组不是空的\n                .andExpect(jsonPath(\"$\").isNotEmpty());\n    }\n}\n```\n\n### 集成 Web 环境测试\n\n```java\n/**\n * @author rxliuli\n */\n@SpringBootTest\n@RunWith(SpringRunner.class)\n@Transactional\n@Rollback\npublic class UserControllerIntegratedTest {\n    @Autowired\n    private WebApplicationContext context;\n    /**\n     * 用于测试 API 的模拟请求对象\n     */\n    private MockMvc mockMvc;\n\n    @Before\n    public void before() {\n        //这里把整个 WebApplicationContext 上下文都丢进去了，所以可以测试所有的 Controller\n        mockMvc = MockMvcBuilders.webAppContextSetup(context)\n                .build();\n    }\n\n    @Test\n    public void testGet() throws Exception {\n        //测试能够正常获取\n        Integer id = 1;\n        mockMvc.perform(\n                //发起 get 请求\n                get(\"/user/\" + id)\n        )\n                //断言请求的状态是成功的(200)\n                .andExpect(status().isOk())\n                //断言返回对象的 id 和请求的 id 相同\n                .andExpect(jsonPath(\"$.id\").value(id));\n    }\n\n    @Test\n    public void listForAll() throws Exception {\n        //测试正常获取\n        mockMvc.perform(\n                //发起 post 请求\n                post(\"/user/listForAll\")\n        )\n                //断言请求状态\n                .andExpect(status().isOk())\n                //断言返回结果是数组\n                .andExpect(jsonPath(\"$\").isArray())\n                //断言返回数组不是空的\n                .andExpect(jsonPath(\"$\").isNotEmpty());\n    }\n}\n```\n\n### 总结\n\n其实上面的测试类的注解感觉都差不多，我们可以将一些普遍的注解封装到基类，然后测试类只要继承基类就能得到所需要的环境，吾辈自己的测试基类在 `src/test/common` 下面，具体使用方法便留到下次再说吧\n\n> 以上代码已全部放到 [GitHub](https://github.com/rxliuli/springboot-test) 上面，可以直接 *clone* 下来进行测试\n","createdTime":1587219249395,"updatedTime":1624275873499,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"86acfc702cbc4855ac917047f8c88e96","title":"vue data 属性中的 this 指向问题","body":"## 场景\n\n之前在封装 table 组件 [Vue 表格封装 BasicTableVue](:/90548a371a16435799bcbfae3e4dbfb6) 的时候遇到的问题，在 `data` 属性中无法使用 `this.**` 调用 `methods` 中的函数。\r\n例如下面的代码\n\n```js\nclass BasicTableData {\r\n  constructor({\r\n    user = {\r\n      name: 'rx',\r\n      age: 17,\r\n    },\r\n  } = {}) {\r\n    this.user = user\r\n  }\r\n}\r\nclass Table extends Vue {\r\n  constructor({ data, methods, mounted, computed }) {\r\n    super({\r\n      data: _.merge(new BasicTableData(), data),\r\n      methods,\r\n      mounted,\r\n      computed,\r\n    })\r\n  }\r\n}\r\n\r\nconst table = new Table({\r\n  data: {\r\n    user: {\r\n      birthday: new Date(),\r\n      birthdayFormatter: this.calcTime,\r\n    },\r\n  },\r\n  methods: {\r\n    calcTime(time) {\r\n      return time.toISOString()\r\n    },\r\n  },\r\n})\r\n\r\n// 将输出 undefined\r\nconsole.log(table.user.birthdayFormatter)\n```\n\n吾辈尝试了一下原生的 vuejs，发现这样的 data 仍然不能用。\n\n## 解决\n\n后来在官方文档找到了 [这里](https://cn.vuejs.org/v2/api/#data)，data 如果是一个对象或者箭头函数时，不会绑定 `this`，仅当 `data` 是一个普通函数（使用 `function` 声明）时，才会被绑定 `this`。\n\n那么，知道了原因，解决方案就很简单了。\n\n1.  如果需要使用在 `data` 中使用 `this` 调用 `methods` 中的函数，则 `data` 必须声明为普通函数\n1.  如果需要默认 `data` `defaultData`，则 `Table` 可以将合并后的 `data` 声明为函数，并将 `defaultData` 与 `data`（使用 `Table` 创建实例时传入的）的返回值合并\n\n修改后的代码如下\n\n```js\nclass BasicTableData {\r\n  constructor({\r\n    user = {\r\n      name: 'rx',\r\n      age: 17,\r\n    },\r\n  } = {}) {\r\n    this.user = user\r\n  }\r\n}\r\nclass Table extends Vue {\r\n  constructor({ data, methods, mounted, computed }) {\r\n    super({\r\n      // 关键是这里将 data 声明为普通函数\r\n      data() {\r\n        // 此处为了简洁使用 lodash 的深度合并\r\n        return _.merge(\r\n          new BasicTableData(),\r\n          // 此处判断 data 是否为函数,是的话就绑定 this 计算结果\r\n          typeof data === 'function' ? data.call(this) : data,\r\n        )\r\n      },\r\n      methods,\r\n      mounted,\r\n      computed,\r\n    })\r\n  }\r\n}\r\n\r\nconst table = new Table({\r\n  data: function () {\r\n    return {\r\n      user: {\r\n        birthday: new Date(),\r\n        birthdayFormatter: this.calcTime,\r\n      },\r\n    }\r\n  },\r\n  methods: {\r\n    calcTime(time) {\r\n      return time.toISOString()\r\n    },\r\n  },\r\n})\r\n\r\n// 打印的结果是\r\n// ƒ calcTime(time) {\r\n//   return time.toISOString()\r\n// }\r\nconsole.log(table.user.birthdayFormatter)\n```\n\n## 思考\n\n现在问题解决了，那么，为什么 `vuejs` 就能够在传入 `data` 函数时就能调用 `methods` 中的函数了呢？吾辈稍微 debug 进入源码看了一下\n\n1.  创建 `Table` 进入构造函数\r\n    ![构造函数](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190327085616.png)\n\n1.  因为继承了 Vue，所以进入 Vue 的构造函数中\r\n    ![进入 Vue 的构造函数中](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190327085734.png)\n\n1.  因为当前实例属于 Vue，所以进入 `_init` 进行初始化\r\n    ![进入 \\_init 初始化](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190327085948.png)\n\n1.  跳转到 `initState(vm);` 处，该函数将对 data 属性进行初始化（至于为什么是 state 可能是因为最初就是模仿 react 写的？）\r\n    ![跳转到 initState()](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190327090323.png)\n\n1.  进入到 `initState()`，跳转到 `initData(vm);` 处\r\n    ![initData(vm) 处](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190327090559.png)\n\n1.  进入到 `initData()` 函数，看到了判断逻辑\r\n    ![判断逻辑](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190327090946.png)\n\n    ```js\n    var data = vm.$options.data\r\n    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {}\n    ```\n\n    注意看，这里的 vue 内部判断了 data 是否为函数，如果是就去 `getData(data, vm)`\n\n1.  进入 `getData()` 函数看看，发现了关键代码\r\n    ![关键代码](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190327091155.png)\n\n    ```js\n    return data.call(vm, vm)\n    ```\n\n    是的，data 调用时使用 `call` 绑定 `this` 为 vm，而此时 `vm.calcTime` 已经有值了。\n\n1.  那么，`vm.calcTime` 是什么时候被初始化的呢？\r\n    其实也在 `initState` 函数中，可以看到，vue 的初始化顺序是\n\n    1.  `props`: 外部传递的属性\n    1.  `methods`: 组件的函数\n    1.  `data`: 组件的属性\n    1.  `computed`: 计算属性\n    1.  `watch`: 监听函数\n\n    ![初始化顺序](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190327091843.png)\n\n## 总结\n\n相比于 react，vue 做了更多的 **黑魔法** 呢！就像 this 指向问题，react 是交由用户自行解决的，而 vue 则在后面偷偷的为函数绑定 this 为 vue 实例本身。\n","createdTime":1580652937910,"updatedTime":1624275863506,"resources":[],"tags":[{"id":"d86454b85c8f4c38aef6fa1575487e7f","title":"vue","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"8c1360df14d44ff2a033c044f77effb9","title":"IDEA 创建和运行一个简单的 maven web 项目","body":"## 场景\n\n本文是为了帮助刚接触 IDEA 的萌新快速了解如何创建与运行一个 Maven Web 项目，但由于 [知识的诅咒](https://en.wikipedia.org/wiki/Curse_of_knowledge)（#笑），如果有什么不太明白或者发现了什么问题，欢迎在最下方进行留言哦\n\n## 创建\n\n首先打开 IDEA，进入到了 IDEA 欢迎页，点击 **Create New Project**\\\n![IDEA 欢迎页](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204181531.png)\n\n来到项目创建面板\n\n1.  选择 Maven\n1.  勾选上 **Create from archetype**（根据原型创建）\n1.  选择 `org.apche.maven.archetypes:maven-archetype-webapp` 原型\n    > 这里可以输入 webapp，就可以通过 Top/Bottom 键来快速找到原型了\n\n![创建面板](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204182057.png)\n\n接下来设定一下 Maven 的基本配置\n\n-   GroupId：代表该项目的实体或组织。例如 `com.rxliuli.example` 就是一个组织 id。\n    > 如果你对 maven 没有任何基础，可以直接使用 `com.{你的英文名}` 作为组织 id\n-   ArtifactId：实际的工件名称。例如 `idea-maven-webapp-example` 就指明了该项目就是一个 idea 创建的 maven webapp 案例项目\n-   Version：该项目的版本号，没什么好说的。\n\n![Maven 基本配置](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204183441.png)\n\n然后是使用的 Maven 程序，IDEA 内置了 Maven，所以如果你不怎么了解 Maven 可以直接 Next 过去\\\n![使用的 Maven 程序](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204183409.png)\n\n最后一步是创建 IDEA 项目，基本上不需要修改什么，直接 FINISH 即可\\\n![创建 IDEA 项目](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204183707.png)\n\n## 配置项目\n\n### 项目初始配置\n\n创建完成后会提示是否选择自动引入依赖，这里选择 **Enable Auto import**。当然，另一个要我们去配置 Web 框架的提示就不用管了，IDEA 已经自动完成了这一切。\\\n![创建完成提示](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204184028.png)\n\n### 配置 Tomcat 容器\n\n项目搭建好了，然而我们还需要一个 Web 容器，这里以 Tomcat 作为演示\n\n1.  使用快捷键 `CS-A` 打开 IDEA 结构化设置搜索\n1.  输入 `edit config`，找到 `edit configurations...` 项\n1.  回车打开 IDEA 运行配置面板\\\n    ![IDEA 结构化设置搜索](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204185414.png)\n1.  添加一个新的 Tomcat 容器运行配置项\\\n    ![Tomcat 容器运行配置](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204185728.png)\n1.  配置 Application server，点击 CONFIGURETION 按钮\\\n    ![配置 Application server](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204190023.png)\n1.  选择本地 Tomcat 的目录并确定\\\n    ![选择本地 Tomcat 的目录](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204190127.png)\n1.  选择要运行的 war 包\\\n    配置完成会发现下面多了一条警告 `Warning:No artifacts marked for deployment`，意思是没有 jar/war 包需要被部署，这里我们只要点一下 Fix，并且选择 `war exploded`，之后 IDEA 会自动完成剩余的事\\\n    ![部署 war 项目](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204190459.png)\n    > 注：有人觉得每次都要配置 Tomcat 真的挺麻烦的，这里吾辈坚决声明这是误解，只有第一次才需要配置各种环境，后面 IDEA 是能够**记住**的。\n1.  最后，修改一下运行配置的名字，然后点击 OK 按钮\\\n    ![修改运行配置的名字](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204191042.png)\n1.  在右上角的运行配置里应该已经显示出刚才添加的运行配置项 Tomcat 了，这是点击右边的 Debug 按钮，一切就开始了\\\n    ![Debug 开始](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204191242.png)\n1.  运行完成后会自动打开浏览器 <http://localhost:8080/>，显示出这个项目的首页了呢\\\n    ![浏览器](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204200454.png)\n\n至此，我们已经使用 IDEA 运行起来了一个基本的 Web 项目了呢！\n\n## 其他\n\n### 配置项目目录结构\n\n项目的文件菜单树大概长这样，初始只有这么几个文件，稍微解释一下用途\n\n-   `pom.xml`：Maven 的配置文件，所有 Maven 搭建的项目都会有，记录着项目所有的依赖\n-   `web.xml`：Web 项目所需要的一个配置文件。主要用来配置 `Servlet`, `Filter`, `Listene`。\n-   `index.jsp`：Maven webapp 原型自带的一个初始的 jsp 首页\n\n![项目文件结构](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204184248.png)\n\n### 配置 java/resources 目录\n\n现在，我们已经可以写 jsp 了，那么 `Servlet` 之类的 java 文件应该写到哪里呢？\n\n1.  在 *src/main* 新建 *java* 和 *resources* 目录\\\n    ![新建 java/resources 目录](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204194615.png)\n1.  点击 *File > Project Structure* 打开项目结构配置面板（或者使用快捷键 `CSA-S`）\\\n    ![Project Structure](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204194742.png)\n1.  标识目录\n\n    1.  点击 Module 项\n    1.  选择需要的项目\n    1.  选中 java 文件夹\n    1.  点击 Source 使 java 目录变为蓝色\n    1.  选中 resources 目录\n    1.  点击 Resources 使 resources 目录变为紫色\n    1.  完成后点击下方的 OK\n\n    ![标识目录](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204195327.png)\n\n### 修改 web.xml 的 servlet 版本为 3.1\n\n其实就是把 `web.xml` 的内容修改为下面这样\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"\r\n         version=\"3.1\">\r\n\r\n</web-app>\n```\n\n### 添加 servlet/jsp 依赖\n\n虽然 tomcat 本身就有 servlet/jsp 的实现，但那是在项目运行时才会有的，而我们需要在代码中使用 Servlet 的类时，则需要添加对应的依赖。\n\n找到 `pom.xml` maven 配置文件，在 dependencies 中添加 `javax.servlet` 和 `javax.servlet.jsp` 两项依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n  <!-- 其他内容 -->\r\n  <dependencies>\r\n    <dependency>\r\n      <groupId>javax.servlet</groupId>\r\n      <artifactId>javax.servlet-api</artifactId>\r\n      <version>3.1.0</version>\r\n    </dependency>\r\n    <dependency>\r\n      <groupId>javax.servlet.jsp</groupId>\r\n      <artifactId>javax.servlet.jsp-api</artifactId>\r\n      <version>2.3.1</version>\r\n    </dependency>\r\n    <!-- 其他依赖 -->\r\n  </dependencies>\r\n  <!-- 其他内容 -->\r\n</project>\n```\n\n### 创建 Servlet\n\n接下来，我们的 Java 源码就全部放到 */src/main/java* 下即可\n\n新建一个简单的 Servlet 类 `HomeServlet` (path: `com.rxliuli.example.ideamavenwebappexample.HomeServlet`)\n\n```java\npackage com.rxliuli.example.ideamavenwebappexample;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.IOException;\r\nimport java.io.PrintWriter;\r\n\r\n/**\r\n * @author rxliuli\r\n */\r\n@WebServlet(name = \"HomeServlet\", urlPatterns = \"/home\")\r\npublic class HomeServlet extends HttpServlet {\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        doPost(req, resp);\r\n    }\r\n\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        resp.setCharacterEncoding(\"utf-8\");\r\n        resp.setContentType(\"text/html;charset=utf-8\");\r\n        final PrintWriter out = resp.getWriter();\r\n        out.println(\"这里是首页哦\");\r\n    }\r\n}\n```\n\n最后，再次点击 Debug 按钮重新运行项目，在浏览器中访问 <http://localhost:8080/home>，可以看到我们的 Servlet 已经生效了呢\\\n![访问 home Servlet](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181204202042.png)\n\n## 总结\n\n-   这个演示项目吾辈也放到了 [GitHub](https://github.com/rxliuli/idea-maven-webapp-example) 上，如果需要可以随便下载\n-   如果你还不了解 maven 的话强烈建议稍微了解一下 maven 的基本概念。可以参照吾辈 blog 上的教程 [Windows 上 Maven 安装与使用](:/3a7307f6d7354c95ad735831f8ee73b9) 进行安装\n-   如果你还不了解 IDEA（废话，这不是当然的嘛！#打），推荐阅读 [IntelliJ IDEA 简体中文专题教程](https://github.com/judasn/IntelliJ-IDEA-Tutorial) 进行入门\n\n那么，这篇教程到这里便结束啦，希望我们都能愉快地使用 IDEA 呢 o(〃＾ ▽ ＾〃)o\n","createdTime":1580652938005,"updatedTime":1624275857427,"resources":[],"tags":[{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"a2386a0617524ad9970062258470fce3","title":"JavaScript 异步时序问题","body":"## 场景\n\n> 死后我们必升天堂，因为活时我们已在地狱。\n\n不知你是否遇到过，向后台发送了多次异步请求，结果最后显示的数据却并不正确 -- 是旧的数据。\n\n具体情况:\n\n1.  用户触发事件，发送了第 1 次请求\n1.  用户触发事件，发送了第 2 次请求\n1.  第 2 次请求成功，更新页面上的数据\n1.  第 1 次请求成功，更新页面上的数据\n\n嗯？是不是感觉到异常了？这便是多次异步请求时会遇到的异步回调顺序与调用顺序不同的问题。\n\n## 思考\n\n-   为什么会出现这种问题？\n-   出现这种问题怎么解决？\n\n### 为什么会出现这种问题？\n\nJavaScript 随处可见异步，但实际上并不是那么好控制。用户与 UI 交互，触发事件及其对应的处理函数，函数执行异步操作（网络请求），**异步操作得到结果的时间（顺序）是不确定的**，所以响应到 UI 上的时间就不确定，**如果触发事件的频率较高/异步操作的时间过长**，就会造成前面的异步操作结果覆盖后面的异步操作结果。\n\n关键点\n\n-   异步操作得到结果的时间（顺序）是不确定的\n-   如果触发事件的频率较高/异步操作的时间过长\n\n### 出现这种问题怎么解决？\n\n既然关键点由两个要素组成，那么，只要破坏了任意一个即可。\n\n-   手动控制异步返回结果的顺序\n-   降低触发频率并限制异步超时时间\n\n## 手动控制返回结果的顺序\n\n根据对异步操作结果处理情况的不同也有三种不同的思路\n\n1.  后面异步操作得到结果后**等待**前面的异步操作返回结果\n1.  后面异步操作得到结果后**放弃**前面的异步操作返回结果\n1.  依次处理每一个异步操作，等待上一个异步操作完成之后再执行下一个\n\n这里先引入一个公共的 `wait` 函数\n\n```js\n/**\r\n * 等待指定的时间/等待指定表达式成立\r\n * 如果未指定等待条件则立刻执行\r\n * 注: 此实现在 nodejs 10- 会存在宏任务与微任务的问题，切记 async-await 本质上还是 Promise 的语法糖，实际上并非真正的同步函数！！！即便在浏览器，也不要依赖于这种特性。\r\n * @param param 等待时间/等待条件\r\n * @returns Promise 对象\r\n */\r\nfunction wait(param) {\r\n  return new Promise((resolve) => {\r\n    if (typeof param === 'number') {\r\n      setTimeout(resolve, param)\r\n    } else if (typeof param === 'function') {\r\n      const timer = setInterval(() => {\r\n        if (param()) {\r\n          clearInterval(timer)\r\n          resolve()\r\n        }\r\n      }, 100)\r\n    } else {\r\n      resolve()\r\n    }\r\n  })\r\n}\n```\n\n### 1. 后面异步操作得到结果后**等待**前面的异步操作返回结果\n\n1.  为每一次的异步调用都声称一个唯一 id\n1.  使用列表记录所有的异步 id\n1.  在真正调用异步操作后，添加一个唯一 id\n1.  判断上一个正在执行的异步操作是否完成\n1.  如果未完成等待上一个异步操作完成，否则直接跳过\n1.  从列表中删除掉当前的 id\n1.  最后等待异步操作然后返回结果\n\n```js\n/**\r\n * 将一个异步函数包装为具有时序的异步函数\r\n * 注: 该函数会按照调用顺序依次返回结果，后面的调用的结果需要等待前面的，所以如果不关心过时的结果，请使用 {@link switchMap} 函数\r\n * @param fn 一个普通的异步函数\r\n * @returns 包装后的函数\r\n */\r\nfunction mergeMap(fn) {\r\n  // 当前执行的异步操作 id\r\n  let id = 0\r\n  // 所执行的异步操作 id 列表\r\n  const ids = new Set()\r\n  return new Proxy(fn, {\r\n    async apply(_, _this, args) {\r\n      const prom = Reflect.apply(_, _this, args)\r\n      const temp = id\r\n      ids.add(temp)\r\n      id++\r\n      await wait(() => !ids.has(temp - 1))\r\n      ids.delete(temp)\r\n      return await prom\r\n    },\r\n  })\r\n}\n```\n\n[测试一下](https://codepen.io/rxliuli/pen/orXpEY)\n\n```js\n;(async () => {\r\n  // 模拟一个异步请求，接受参数并返回它，然后等待指定的时间\r\n  async function get(ms) {\r\n    await wait(ms)\r\n    return ms\r\n  }\r\n  const fn = mergeMap(get)\r\n  let last = 0\r\n  let sum = 0\r\n  await Promise.all([\r\n    fn(30).then((res) => {\r\n      last = res\r\n      sum += res\r\n    }),\r\n    fn(20).then((res) => {\r\n      last = res\r\n      sum += res\r\n    }),\r\n    fn(10).then((res) => {\r\n      last = res\r\n      sum += res\r\n    }),\r\n  ])\r\n  console.log(last)\r\n  // 实际上确实执行了 3 次，结果也确实为 3 次调用参数之和\r\n  console.log(sum)\r\n})()\n```\n\n### 2. 后面异步操作得到结果后**放弃**前面的异步操作返回结果\n\n1.  为每一次的异步调用都声称一个唯一 id\n1.  记录最新得到异步操作结果的 id\n1.  记录最新得到的异步操作结果\n1.  执行并等待返回结果\n1.  判断本次异步调用后面是否已经有调用出现结果了\n    1.  是的话就直接返回后面的异步调用结果\n    1.  否则将本地异步调用 id 及其结果最为\\[最后的]\n    1.  返回这次的异步调用结果\n\n```js\n/**\r\n * 将一个异步函数包装为具有时序的异步函数\r\n * 注: 该函数会丢弃过期的异步操作结果，这样的话性能会稍稍提高（主要是响应比较快的结果会立刻生效而不必等待前面的响应结果）\r\n * @param fn 一个普通的异步函数\r\n * @returns 包装后的函数\r\n */\r\nfunction switchMap(fn) {\r\n  // 当前执行的异步操作 id\r\n  let id = 0\r\n  // 最后一次异步操作的 id，小于这个的操作结果会被丢弃\r\n  let last = 0\r\n  // 缓存最后一次异步操作的结果\r\n  let cache\r\n  return new Proxy(fn, {\r\n    async apply(_, _this, args) {\r\n      const temp = id\r\n      id++\r\n      const res = await Reflect.apply(_, _this, args)\r\n      if (temp < last) {\r\n        return cache\r\n      }\r\n      cache = res\r\n      last = temp\r\n      return res\r\n    },\r\n  })\r\n}\n```\n\n[测试一下](https://codepen.io/rxliuli/pen/BgNJbq)\n\n```js\n;(async () => {\r\n  // 模拟一个异步请求，接受参数并返回它，然后等待指定的时间\r\n  async function get(ms) {\r\n    await wait(ms)\r\n    return ms\r\n  }\r\n  const fn = switchMap(get)\r\n  let last = 0\r\n  let sum = 0\r\n  await Promise.all([\r\n    fn(30).then((res) => {\r\n      last = res\r\n      sum += res\r\n    }),\r\n    fn(20).then((res) => {\r\n      last = res\r\n      sum += res\r\n    }),\r\n    fn(10).then((res) => {\r\n      last = res\r\n      sum += res\r\n    }),\r\n  ])\r\n  console.log(last)\r\n  // 实际上确实执行了 3 次，然而结果并不是 3 次调用参数之和，因为前两次的结果均被抛弃，实际上返回了最后一次发送请求的结果\r\n  console.log(sum)\r\n})()\n```\n\n### 3. 依次处理每一个异步操作，等待上一个异步操作完成之后再执行下一个\n\n1.  为每一次的异步调用都声称一个唯一 id\n1.  使用列表记录所有的异步 id\n1.  向列表中添加一个唯一 id\n1.  判断上一个正在执行的异步操作是否完成\n1.  如果未完成等待上一个异步操作完成，否则直接跳过\n1.  真正调用异步操作\n1.  从列表中删除掉当前的 id\n1.  最后等待异步操作然后返回结果\n\n```js\n/**\r\n * 将一个异步函数包装为具有时序的异步函数\r\n * 注: 该函数会按照调用顺序依次返回结果，后面的执行的调用（不是调用结果）需要等待前面的，此函数适用于异步函数的内里执行也必须保证顺序时使用，否则请使用 {@link mergeMap} 函数\r\n * 注: 该函数其实相当于调用 {@code asyncLimiting(fn, {limit: 1})} 函数\r\n * 例如即时保存文档到服务器，当然要等待上一次的请求结束才能请求下一次，不然数据库保存的数据就存在谬误了\r\n * @param fn 一个普通的异步函数\r\n * @returns 包装后的函数\r\n */\r\nfunction concatMap(fn) {\r\n  // 当前执行的异步操作 id\r\n  let id = 0\r\n  // 所执行的异步操作 id 列表\r\n  const ids = new Set()\r\n  return new Proxy(fn, {\r\n    async apply(_, _this, args) {\r\n      const temp = id\r\n      ids.add(temp)\r\n      id++\r\n      await wait(() => !ids.has(temp - 1))\r\n      const prom = Reflect.apply(_, _this, args)\r\n      ids.delete(temp)\r\n      return await prom\r\n    },\r\n  })\r\n}\n```\n\n[测试一下](https://codepen.io/rxliuli/pen/xoGYxq)\n\n```js\n;(async () => {\r\n  // 模拟一个异步请求，接受参数并返回它，然后等待指定的时间\r\n  async function get(ms) {\r\n    await wait(ms)\r\n    return ms\r\n  }\r\n  const fn = concatMap(get)\r\n  let last = 0\r\n  let sum = 0\r\n  await Promise.all([\r\n    fn(30).then((res) => {\r\n      last = res\r\n      sum += res\r\n    }),\r\n    fn(20).then((res) => {\r\n      last = res\r\n      sum += res\r\n    }),\r\n    fn(10).then((res) => {\r\n      last = res\r\n      sum += res\r\n    }),\r\n  ])\r\n  console.log(last)\r\n  // 实际上确实执行了 3 次，然而结果并不是 3 次调用参数之和，因为前两次的结果均被抛弃，实际上返回了最后一次发送请求的结果\r\n  console.log(sum)\r\n})()\n```\n\n### 小结\n\n虽然三个函数看似效果都差不多，但还是有所不同的。\n\n1.  是否允许异步操作并发？否: `concatMap`, 是: 到下一步\n1.  是否需要处理旧的的结果？否: `switchMap`, 是: `mergeMap`\n\n## 降低触发频率并限制异步超时时间\n\n思考一下第二种解决方式，本质上其实是 **限流 + 自动超时**，首先实现这两个函数。\n\n-   限流: 限制函数调用的频率，如果调用的频率过快则不会真正执行调用而是返回旧值\n-   自动超时: 如果到了超时时间，即便函数还未得到结果，也会自动超时并抛出错误\n\n下面来分别实现它们\n\n### 限流实现\n\n> 具体实现思路可见: [JavaScript 防抖和节流](:/f308ebf560c94282807032feccb94586)\n\n```js\n/**\r\n * 函数节流\r\n * 节流 (throttle) 让一个函数不要执行的太频繁，减少执行过快的调用，叫节流\r\n * 类似于上面而又不同于上面的函数去抖, 包装后函数在上一次操作执行过去了最小间隔时间后会直接执行, 否则会忽略该次操作\r\n * 与上面函数去抖的明显区别在连续操作时会按照最小间隔时间循环执行操作, 而非仅执行最后一次操作\r\n * 注: 该函数第一次调用一定会执行，不需要担心第一次拿不到缓存值，后面的连续调用都会拿到上一次的缓存值\r\n * 注: 返回函数结果的高阶函数需要使用 {@link Proxy} 实现，以避免原函数原型链上的信息丢失\r\n *\r\n * @param {Number} delay 最小间隔时间，单位为 ms\r\n * @param {Function} action 真正需要执行的操作\r\n * @return {Function} 包装后有节流功能的函数。该函数是异步的，与需要包装的函数 {@link action} 是否异步没有太大关联\r\n */\r\nconst throttle = (delay, action) => {\r\n  let last = 0\r\n  let result\r\n  return new Proxy(action, {\r\n    apply(target, thisArg, args) {\r\n      return new Promise((resolve) => {\r\n        const curr = Date.now()\r\n        if (curr - last > delay) {\r\n          result = Reflect.apply(target, thisArg, args)\r\n          last = curr\r\n          resolve(result)\r\n          return\r\n        }\r\n        resolve(result)\r\n      })\r\n    },\r\n  })\r\n}\n```\n\n### 自动超时\n\n> 注: `asyncTimeout` 函数实际上只是为了避免一种情况，异步请求时间超过节流函数最小间隔时间导致结果返回顺序错乱。\n\n```js\n/**\r\n * 为异步函数添加自动超时功能\r\n * @param timeout 超时时间\r\n * @param action 异步函数\r\n * @returns 包装后的异步函数\r\n */\r\nfunction asyncTimeout(timeout, action) {\r\n  return new Proxy(action, {\r\n    apply(_, _this, args) {\r\n      return Promise.race([\r\n        Reflect.apply(_, _this, args),\r\n        wait(timeout).then(Promise.reject),\r\n      ])\r\n    },\r\n  })\r\n}\n```\n\n### 结合使用\n\n[测试一下](https://codepen.io/pen/?editors=1112)\n\n```js\n;(async () => {\r\n  // 模拟一个异步请求，接受参数并返回它，然后等待指定的时间\r\n  async function get(ms) {\r\n    await wait(ms)\r\n    return ms\r\n  }\r\n  const time = 100\r\n  const fn = asyncTimeout(time, throttle(time, get))\r\n  let last = 0\r\n  let sum = 0\r\n  await Promise.all([\r\n    fn(30).then((res) => {\r\n      last = res\r\n      sum += res\r\n    }),\r\n    fn(20).then((res) => {\r\n      last = res\r\n      sum += res\r\n    }),\r\n    fn(10).then((res) => {\r\n      last = res\r\n      sum += res\r\n    }),\r\n  ])\r\n  // last 结果为 10，和 switchMap 的不同点在于会保留最小间隔期间的第一次，而抛弃掉后面的异步结果，和 switchMap 正好相反！\r\n  console.log(last)\r\n  // 实际上确实执行了 3 次，结果也确实为第一次次调用参数的 3 倍\r\n  console.log(sum)\r\n})()\n```\n\n起初吾辈因为好奇实现了这种方式，但原以为会和 `concatMap` 类似的函数却变成了现在这样 -- 更像倒置的 `switchMap` 了。不过由此看来这种方式的可行性并不大，毕竟，没人需要旧的数据。\n\n## 总结\n\n其实第一种实现方式属于 [rxjs](https://github.com/ReactiveX/rxjs) 早就已经走过的道路，目前被 Angular 大量采用（类比于 React 中的 Redux）。但 rxjs 实在太强大也太复杂了，对于吾辈而言，仅仅需要一只香蕉，而不需要拿着香蕉的大猩猩，以及其所处的整个森林（此处原本是被人吐槽面向对象编程的隐含环境，这里吾辈稍微藉此吐槽一下动不动就上库的开发者）。\n\n> 可以看到吾辈在这里大量使用了 `Proxy`，那么，原因是什么呢？这个疑问就留到下次再说吧！\n","createdTime":1580652937872,"updatedTime":1624275851123,"resources":[],"tags":[{"id":"1de1ff51140a44d5a2c223459dabcc37","title":"异步","parent_id":""},{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"12d6248652964180bc11b3ae387a9fa1","title":"读书 [黑客与画家]","body":"## 简介\n\n> 黑客新想法的最佳来源，并非那些名字里有［计算机］三个字的理论领域，而是来自于其他创作领域。\n\n这是一篇读书感悟的文章，来源于最近阅读的书籍 [黑客与画家](https://book.douban.com/subject/6021440/)。\n\n> 摘抄自豆瓣\r\n> **书籍简介**：\r\n>     本书是硅谷创业之父 Paul Graham 的文集，主要介绍黑客即优秀程序员的爱好和动机，讨论黑客成长、黑客对世界的贡献以及编程语言和黑客工作方法等所有对计算机时代感兴趣的人的一些话题。书中的内容不但有助于了解计算机编程的本质、互联网行业的规则，还会帮助读者了解我们这个时代，迫使读者独立思考。\r\n>     本书适合所有程序员和互联网创业者，也适合一切对计算机行业感兴趣的读者。\r\n> **作者简介**:\r\n>     保罗・格雷厄姆，《黑客与画家》一书的作者，硅谷创业之父。1964 年，出生于匹兹堡郊区的一个中产阶级家庭。父亲是设计核反应堆的物理学家，母亲在家照看他和他的妹妹。青少年时代，格雷厄姆就开始编程。但是，他还喜欢许多与计算机无关的东西，这在编程高手之中是很少见的。\r\n>     保罗・格雷厄姆在康奈尔大学读完本科，然后在哈佛大学获得计算机科学博士学位。1995 年，他创办了 Viaweb，帮助个人用户在网上开店，这是世界上第一个互联网应用程序。1998 年夏天，Yahoo! 公司收购了 Viaweb，收购价约为 5000 万美元。\r\n>     此后，他架起了个人网站 paulgraham.com，在上面撰写了许许多多关于软件和创业的文章，以深刻的见解和清晰的表达而著称，迅速引起了轰动。2005 年，他身体力行，创建了风险投资公司 Y Combinator，将自己的理论转化为实践，目前已经资助了 80 多家创业公司。现在，他是公认的互联网创业权威。\n\n![书籍照片](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190713024824.png)\n\n## 起因\n\n之前吾辈也曾经坚信电子书籍（**Epub/PDF**）要比纸质书籍更好，方便携带，随时都能阅读。直到遇到了一位 dalao 的指点 -- **只要买了书，放在那里，总有机会去看看的。** 之后，吾辈便尝试买了一些实体书，晚上回来闲暇片刻便会看看。\n\n![书架图片](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190713024216.jpg)\n\n最近一周，吾辈便把黑客与画家看完了。当然，之前已经看过电子版的了。作者真的很厉害，既是第一个互联网程序的开发者，也是一个画家，更是一个顶级**黑客**（非**骇客**）。然后，他写完这本书之后，还变成了作者。当然，译者也同样是位知名人物 -- [阮一峰](https://www.ruanyifeng.com)。\n\n## 感想\n\n读这本书的时候，才发现**真-大佬**的想法真的很厉害，尤其是关于创造财富那一章，有许多思想值得吾辈深思。\r\n下面摘抄一些内容并谈谈吾辈的想法\n\n> 书呆子不受欢迎的真正原因，是他们脑子里都在想着别的事情，他们的注意力都放在读书或者观察世界上面，而不是穿衣打扮、开晚会上面。\n\n嗯，吾辈想这大抵是作者的亲身体会：作为一个聪明人却不受欢迎 #笑 不过就吾辈经历而言，读书好的人一般也不会太受排挤，或许这是因为国情不同的原因吧 -- 国内不论如何都把成绩作为第一位，而据作者所说美国的中学生并不会特别对待学习，至少，不会拼命去学，也不会因此自杀。\n\n> 黑客与画家的共同之处，在于他们都是创作者。与作曲家、建筑师、作家一样，黑客和画家都是试图创作出优秀的作品。他们本质上都不是在做研究，虽然在创作过程中，他们可能会发现一些新技术（那样当然更好）。\n\n想想国内的大环境，吾辈瞬间心酸得落下了眼泪。说是创作者，但实际上，开发者被称为**码农**不是没有道理的 -- 只是实现经理所要求的功能，而不是决定功能应该如何设计 -- 这被交给了其他人！当然，拥有/参与开源项目可以减少这个问题，因为可以决定功能如何设计而非实现。但本质上还是在代码的圈子里打转，并没有创造出人们真正需要用到的东西。\n\n> 程序写出来是给人看的，附带能在机器上运行。\n\n这不是吾辈第一次看见这句话了，但在工作过程中，吾辈发现实际上这句话并没有多少开发者真的在意过 -- 包括一些 dalao。为了性能死扣算法，没错吾辈就是在吐槽一些公司任何职位都要面试算法，简直成 [leetcode](https://leetcode.com/) 算法面试公司了。大部分场景实际上并不需要开发者手写算法进行优化，因为现在的计算机已经足够快了。手写算法再加上耦合业务，只会让代码变得无比丑陋，难以维护 -- 仅仅是为了在某个地方稍微快一点。\n\n> 在某些地方，自行其道，完全不替读者着想，被看成是高水平、高智商的表现，甚至都发展成了一种风尚。\n\n是的，有些人就是为了炫技而写出来各种*奇葩*的代码，导致其他人再看代码时，纷纷惊呼：“**这是什么神仙代码？！**”。在他们看来，写出来的代码让别人看不懂，自己说的话让别人听不懂，是一种*高水准*的表现，甚至于说：“**这降低了 SB 来烦我的概率**”。甚至于刻意不写注释，然后辩解说：“**类型系统就是最好的注释**”\r\n关于这点，作者也在后面进一步评论了。\n\n> 但是，我不觉得 “换位思考” 与智商之间存在任何联系。在数学和自然科学领域，你用学习怎么向别人表达自己，也能却得很好的成就。而那些领域的人普遍很聪明，所以人们很自然地就把 “聪明” 与 “不懂得换位思考” 联系了起来。但是，世界上还有许许多多很笨的人，也同样不懂得 “换位思考”。\n\n最后一句真是说出了大实话 -- **伪-大佬**。\n\n> 我家附近，一辆汽车的保险杠贴着一张粘纸，上面写着 “太麻烦，不如死”（death before inconvenience）。大多数人，在大多数时候，总是选择最省事的做法。如果互联网软件能够击败桌面软件，一定是赢在更方便这一优势上。无论从用户的角度还是从开发者的角度来看都是如此。\n\n是的，现在浏览器已经击败了客户端软件，甚至在原本必须要使用客户端的地方使用 Web 技术进行了入侵（[Electron](https://electronjs.org/)，[React Native](https://facebook.github.io/react-native/)）。但这并不意味人们知道这件事就会真的对用户更友好，尤其是对于免费的开源程序而言。用户不再是首位要素，动辄要求使用者去看源码，吐槽就会被说 “**爱用用不用滚，You can you do？**”。你敢相信？但这就是国内开源现状。\n\n> 开发软件需要的程序员人数减少，不仅意味着省下更多的钱。正如《人月神话》一书中所指出的，向一个项目增加人手，往往会拖慢项目进程。随着参与人数的增加，人与人之间需要的沟通呈现指数式增长。人数越来越多，开会讨论各个部分如何协同工作所需要的时间越来越长，无法预见的互相影响越多越大，产生的 bug 也越来越多。幸运的是，这个过程的逆向也成立：人数越来越少，软件开发的效率将指数式增长。\n\n所以说这就是小公司能生存下来的原因么？#笑 想到之前项目实际上只有 3 个人全职开发就发现，其实也不是那么奇怪呢\n\n> 桌面软甲迫使用户变成系统管理员，互联网软件则是迫使程序员变成系统管理员：用户的压力变小了，程序员的压力变大了。\n\n唉，小公司别说系统管理员了，就连前端，后端，运维，测试都要会一点才行，必须是 **多面手/万金油** 才能生存下去。\n\n> 许多人从小就认定世界上的财富总额是固定不变的，这样想的人数多的惊人。\r\n> 小时候我就对这一点深信不疑：如果夫人拿走了所有的钱，那么其他人就变得更穷了。许多成年人至今都是类似看法的信徒。每当有人提到 *x%* 的人口占有了 *y%* 的财富，他的言下之意往往就包含了这种错误的观点。\n\n嘛，吾辈也曾经是这样想的人之一（一个普通的不能再普通的人）。但这个观点在看完本书后刷新了，财富在净增长 -- 代价是地球本身。\n\n> 确实有一些 CEO 的收入太高，不合理，但是有没有 CEO 的收入不足以体现他所创造的财富的呢？乔布斯就是这样的例子。他拯救了濒临崩溃的苹果公司，扭转了危机，削减了成本，成功决策了下一代产品。他的收入就低于他的工作所创造的价值。\n\n是的，这点确实很厉害，尤其是吾辈正在看的 [浪潮之巅](https://book.douban.com/subject/26792439/) 一书也谈及了他，确实是个 **真-大佬**。\n\n> 在垃圾邮件业中，如果发送销售类垃圾邮件受到限制，那么整个行业将不可避免地受到重创。“行业”这个词是很准确的，发送垃圾邮件的人其实都是商人，他们这么做只是因为这招很有效。虽然垃圾邮件的回应率低到不能再低了（不超过百万分之 15，相比之下，传统的邮寄商品目录的回应率是百万分之 3000），但是发送垃圾邮件的成本实际上为零，所以它还是有效的。但是对于收到垃圾邮件的人来说，成本却很高昂，假定有 100 万人分别收到一封垃圾邮件，每人花一秒钟删除，累计起来就相当于一个人 5 个星期的工作量，而发送人连一分钱也不用付出。\r\n> 不过，虽然接近于零，发送垃圾邮件还是有成本的^。所以，只要我们把垃圾邮件的回应率降得很低（不管手段是直接过滤，还是让垃圾邮件被迫掩盖它们的销售意图），商家就会发现，发送垃圾邮件是一件经济上不值得的事情。\n\n这让吾辈想到了现在的广告过滤行业，嗯，没错是行业 -- [Adblock Plus](https://adblockplus.org/) 把这事做成了生意。广告屏蔽插件流行了起来之后，广告受益者就会烦恼，会提示让用户关闭广告过滤以支持网站，或者，直接关闭页面拒绝使用 -- 直到关闭了广告过滤为止。后来，开始出现了屏蔽那些网页上检测广告的脚本 -- 反屏蔽广告脚本。这个斗争其实可以一直进行下去，终究是收益与代价的权衡罢了。\n\n> 好设计是简单的设计。从数学领域到绘画领域，你都可以听到这种说法。在数学中，它表示简短的证明往往是更好的证明。特别是对于数学公理来说，少即是多。在编程中，这种说法也基本适用。\n\n**少即是多**，能满足这一点的库/框架并不多，[Lodash](https://www.lodashjs.com/) 是一个正例，[React](https://reactjs.org/) 某种程度上来说是个反例。不管是程序（[三国杀](https://web.sanguosha.com)），还是库（[rx-util](https://github.com/rxliuli/rx-util)），开发者总是喜欢增加功能，逐渐提高复杂度，最后让人难以接受。这里吐槽一下国产程序，只会逐渐增加功能，永远学不会什么叫**减法**。\n\n> 高级语言比汇编语言更接近人类语言，而某些高级语言又比其他语言更进一步。举例来说，C 语言是一种低层次语言，很接近硬件，几乎堪称可移植的汇编语言，而 Lisp 语言的层次则是相当高。\n\n`Lisp` 之前一直有听闻过，但吾辈还从未真正使用过。在编程语言领域，吾辈接触过 `Java`, `JavaScript`, `Scala`, `C#`，然而他们都不能支持 `Lisp` 中一些非常高级的功能（宏）。\n\n下面作者列出了 Lisp 的创新功能\n\n1.  条件结构（即 if-then-else 结构）。现在大家都觉得这是理所当然的，但是 FortranI 就没有这个结构，它只有基于底层机器指令的 goto 结构。\n1.  函数也是一种数据类型。在 Lisp 语言中，函数与整数或字符串一样，也属于数据类型的一种。它有自己的字面表示形式（literal representation），能够存储在变量中，也能当作参数传递。一种数据类型应该有的功能，它都有。\n1.  递归。Lisp 是第一种支持递归函数的高级语言^。\r\n    ^「Lisp 语言的许多特性（比如，把程序写成列表形式以及实现某种形式的递归）都在 20 世纪 50 年代的 IPL-V 语言中出现过。但是，IPL-V 更像是汇编语言，它的程序中充满了操作码/地址对。参见 Alien Newell 等人编著的《IPL-V 语言操作手册》（Information Processing Language-V Manual），Prentice-Hail，1961 年出版。」\n1.  变量的动态类型。在 Lisp 语言中，所有变量实际上都是指针，所指向的值有类\r\n    型之分，而变量本身没有。复制变量就相当于复制指针，而不是复制它们指向的数据。\n1.  垃圾回收机制。\n1.  程序由表达式组成。Lisp 程序是一些表达式树的集合，每个表达式都返回一个值。这与 Fortran 和大多数后来的语言都截然不同，它们的程序由表达式和语句组成。区分表达式和语句在 Fortran I 中是很自然的，因为它不支持语句嵌套。所以，如果你需要用数学式子计算一个值，那就只有用表达式返回这个值，没有其他语法结构可用，否则就无法处理这个值。\r\n    后来，新的编程语言支持块结构，这种限制当然也就不存在了。但是为时已晚，表达式和语句的区分已经根深蒂固。它从 Fortran 扩散到 Algol 语言，接着又扩散到它们两者的后继语言。\n1.  符号类型。符号实际上是一种指针，指向存储在散列表中的字符串。所以，比较\r\n    两个符号是否相等，只要看它们的指针是否一样就行了，不用逐个字符地比较。\n1.  代码使用符号和常量组成的树形表示法。\n1.  无论什么时候，整个语言都是可用的。Lisp 并不真正区分读取期、编译期和运行期。你可以在读取期编译或运行代码，也可以在编译期读取或运行代码，还可以在运行期读取或者编译代码。\n\nLisp 确实开创了许多功能，成功引起了吾辈的兴趣，以后有机会会去看一下作者写的 Lisp 的书籍吧\n\n> 大多数程序员也许无法分辨语言的好坏。但是，这不代表优秀的编程语言会被埋没，专家级黑客一眼就能认出它们，并且会拿来使用。虽然他们人数很少，但就是这样一小群人写出了人类所有优秀软件。他们有着巨大的影响力，他们使用什么语言，其他程序员往往就会跟着使用。老实说，很多时候这种影响力更像是一种命令，对于其他程序员来说，专家级黑客就像自己的老板或导师，他们说哪种语言好用，自己就会乖乖地跟进。\r\n> 编程语言的最高境界一直在发展之中。虽然语言的核心功能就像大海的深处，很少有变化，但是函数库和开发环境之类的东西就像大海的表面，一直在汹涌澎湃。\n\n是啊，所以现在流行 react，流行 webpack，流行 typescript，甚至曾经有人吐槽 [2016 年里做前端是怎样一种体验](:/333051b25bd047e8864d161a9a6982de)。各种各样的框架和库，说不定过不了一段时间就死掉了（前车之鉴），这些都是浪潮的表面。不过总有人喜欢折腾代码，而不是完成一个真正可以给其他人用的东西。疯狂造一堆~~没人用的~~轮子，美其名曰不做调参工程师。当然，尝试实现便于了解深层原理，然而如果不加节制什么东西都觉得自己造才好就是典型的浪费时间。\n\n> 先做出原型，再逐步加工做出成品，这种方式有利于鼓舞士气，因为它使得你随时都可以看到工作的成效。开发软件的时候，我有一条规则：任何时候，代码都必须能够运行。如果你正在写的代码一个小时之后就可以看到运行结果，这好比让你看到不远处就是唾手可得的奖励，你因此会受到激励和鼓舞。\r\n> 跟你说实话吧，画家之间甚至流传着一句谚语：“画作永远没有完工的一天，你只是不再画下去而已。”这种情况对于第一线的程序员真是再熟悉不过了。\n\n是啊，能看到效果的原型很重要，看不到效果的开发是艰苦而烦躁的。而且出现错误了都无法进行调试，实在是不能更糟糕了。有些开源项目目标很大，花费的时间过长，长期做不出来一个可用版本，久而久之，就半路放弃了。\n\n## 总结\n\n总而言之，上面是一些看书的想法以及吐槽，这本书籍吾辈强烈推荐 -- 即便不是 IT 行业。\n","createdTime":1580652938081,"updatedTime":1624275848329,"resources":[],"tags":[{"id":"cb9e3139d6c445159b47d8f26528445d","title":"读书","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"69eedef48bf54c3ca692b43a115a118f","title":"JavaScript 规范整理","body":"## 场景\n\n> 圣人走过的道路，荆棘遍布，火焰片片焚烧……\n\n日常 `review` 代码时看到一些奇怪的代码，这里记录一下重构方案以及原因。\n\n## 命名规范\n\n### 不要使用拼音命名\n\n如果不熟悉英语，可以使用 [Codelf](https://unbug.github.io/codelf/) 或者 [Google 翻译](https://translate.google.com)，避免使用拼音命名。\n\n错误示例\n\n```js\n// 这里是用户状态\r\nconst yongHuZhuangTai = 1\n```\n\n正确示例\n\n```js\nconst userStatus = 1\n```\n\n### 函数中的变量\n\njs 中普通变量使用 [小写开头驼峰命名法](https://en.wikipedia.org/wiki/Camel_case)，而非不区分大小写，或使用下划线命名等等。\n\n错误示例\n\n```js\n// 用户操作日志备注\r\nconst useroperatinglogremark = '新增用户'\n```\n\n正确示例\n\n```js\nconst userOperatingLogRemark = '新增用户'\n```\n\n### 内部变量\n\n如果需要不想让使用者使用的属性（能够看到），需要使用下划线开头。例如 `_value`，代表内部的值，外部不应该直接访问（实际上可以做到）。\n\n```js\nclass DateFormat {\r\n  constructor(fmt) {\r\n    // 不想让外部使用\r\n    this._fmt = fmt\r\n  }\r\n  format(date) {\r\n    // 具体格式化代码\r\n  }\r\n  parse(str) {\r\n    // 具体解析代码\r\n  }\r\n}\n```\n\n### 不要使用无意义的前缀命名\n\n如果一个对象的变量名已经很好的标识了该对象，那么内部的属性就不能使用对象名作为前缀！\n\n错误示例\n\n```js\n// 活跃的日志信息\r\nconst activeLog = {\r\n  activeUserId: 'rx',\r\n  activeTime: new Date(),\r\n}\n```\n\n正确示例\n\n```js\nconst activeLog = {\r\n  userId: 'rx',\r\n  time: new Date(),\r\n}\n```\n\n## ES6\n\n### 优先使用 const/let\n\n一般情况下，使用 `const/let` 声明变量，而不是使用 `var`。因为使用 `var` 声明的变量会存在变量提升。\n\n示例代码\n\n```js\n;(function () {\r\n  // 使用 var 声明的变量（初始值为 undefined）\r\n  console.log(i)\r\n  i = 1\r\n  console.log(i)\r\n  // 此时使用 var 声明的变量 i 相当于在 function 顶部声明，然后在此处进行了赋值操作\r\n  var i = 0\r\n\r\n  // 使用 const 声明的变量（抛出异常 k is not defined）\r\n  // console.log(k)\r\n  k = 1\r\n  const k = 0\r\n})()\n```\n\n关于可以参考 [let 与 var 在 for 循环中的区别](:/88c96ca913764189a7670c31af966d6e)\n\n### 使用新的函数声明方式\n\nES6 推出了一种更简洁的函数声明方式，不需要在写 `function`，只要 **名字 + ()** 即可在 `class` 或 `Object` 中声明函数。\n\n错误示例\n\n```js\nconst user = {\r\n  name: 'rx',\r\n  hello: function () {\r\n    console.log('hello' + this.name)\r\n  },\r\n}\n```\n\n正确示例\n\n```js\nconst user = {\r\n  name: 'rx',\r\n  hello() {\r\n    console.log('hello' + this.name)\r\n  },\r\n}\n```\n\n### 优先使用箭头函数而非 function\n\n优先使用 **箭头函数** 而不是使用传统的函数，尤其是使用 **匿名函数** 时，更应如此。\n\n错误示例\n\n```js\nconst sum = [1, 2, 3, 4]\r\n  // 过滤出偶数\r\n  .filter(function (i) {\r\n    return i % 2 === 0\r\n  })\r\n  // 将偶数翻倍\r\n  .map(function (i) {\r\n    return i * 2\r\n  })\r\n  // 计算总和\r\n  .reduce(function (res, i) {\r\n    return (res += i)\r\n  })\r\n\r\nconsole.log(sum)\n```\n\n正确示例\n\n```js\nconst sum = [1, 2, 3, 4]\r\n  // 过滤出偶数\r\n  .filter((i) => i % 2 === 0)\r\n  // 将偶数翻倍\r\n  .map((i) => i * 2)\r\n  // 计算总和\r\n  .reduce((res, i) => (res += i))\r\n\r\nconsole.log(sum)\n```\n\n### 不要使用 if 判断再赋予默认值\n\n如果函数需要对参数做默认值处理，请不要使用 `if` 判空之后再修改参数，而是使用 ES6 的 [默认参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters) 和 [解构赋值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)。\n\n主要优点\n\n-   减少代码，JavaScript 是动态语言，维护起来较为麻烦，代码越少，错误越少\n-   清晰明了，可以让人一眼就能看出这个参数的默认值，而不需要关心函数内部的逻辑\n-   IDE 大多对此进行了支持，代码提示时便会告诉我们参数是可选的并且有默认值\n\n错误示例\n\n```js\n/**\r\n * 格式化日期\r\n * @param {Date} [date] 日期对象。默认为当前时间\r\n * @return {String} 格式化日期字符串\r\n */\r\nfunction formatDate(date) {\r\n  if (date === undefined) {\r\n    date = new Date()\r\n  }\r\n  return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`\r\n}\n```\n\n正确示例\n\n```js\nfunction formatDate(date = new Date()) {\r\n  return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`\r\n}\n```\n\n这里如果展开来讲实在太多，请参考 [JavaScript 善用解构赋值](:/50a0376f73294d13af86032050a465b8)\n\n### 优先使用 Map 做键值对映射而非传统的对象\n\n如果需要 **键值映射**，不要使用一般的对象，而是用 ES6 的 [Map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)。它不仅可以使用 **任意类型的键**，另外 Map 本身也是 **有序** 的哦\n\n错误示例\n\n```js\nconst obj = {\r\n  2: '琉璃',\r\n  1: 'rx',\r\n  1: 'liuli',\r\n}\r\n// 结果为 true，因为属性 1 实际上会被转换为 '1'\r\nconsole.log(obj[1] === obj['1'])\r\n// 结果为 [ '1', '2']，因为是按照属性字符串排序的\r\nconsole.log(Object.keys(obj))\n```\n\n正确示例\n\n```js\nconst map = new Map().set(2, '琉璃').set(1, 'rx').set('1', 'liuli')\r\n// 结果为 false\r\nconsole.log(map.get(1) === map.get('1'))\r\n// 结果为 [ 2, 1, '1' ]，因为是按照插入顺序排序的\r\nconsole.log(Array.from(map.keys()))\n```\n\n### 优先使用模板字符串拼接多个字符串变量\n\n如果需要拼接多个对象以及字符串时，不要使用 `+` 进行拼接，使用 es6 的 [模板字符串](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings) 会更好一点。一般而言，如果需要拼接的变量超过 3 个，那么就应该使用模板字符串了。\n\n错误示例\n\n```js\nfunction hello(name, age, sex) {\r\n  return 'name: ' + name + ', age: ' + age + ', sex: ' + sex\r\n}\n```\n\n正确示例\n\n```js\nfunction hello(name, age, sex) {\r\n  return `name: ${name}, age: ${age}, sex: ${sex}`\r\n}\n```\n\n### 当独立参数超过 3 个时使用对象参数并解构\n\n错误示例\n\n```js\nfunction hello(name, age, sex) {\r\n  return `name: ${name}, age: ${age}, sex: ${sex}`\r\n}\n```\n\n正确示例\n\n```js\nfunction hello({ name, age, sex }) {\r\n  return `name: ${name}, age: ${age}, sex: ${sex}`\r\n}\n```\n\n### 不要写多余的 await\n\n如果 `await` 是不必要的（在返回语句时，那么就不要用 `async` 标识函数），这是没有必要的 -- 除非，你需要在这个函数内异步操作完成后有其他操作。\n\n错误示例\n\n```js\nconst login = async ({ username, password }) => {\r\n  if (!useranme) {\r\n    console.log('用户名不能为空')\r\n    return\r\n  }\r\n  if (!password) {\r\n    console.log('密码不能为空')\r\n    return\r\n  }\r\n  // 真正发起登录请求\r\n  return await userApi.login(user)\r\n}\n```\n\n正确示例\n\n```js\nconst login = ({ username, password }) => {\r\n  if (!useranme) {\r\n    console.log('用户名不能为空')\r\n    return\r\n  }\r\n  if (!password) {\r\n    console.log('密码不能为空')\r\n    return\r\n  }\r\n  // 真正发起登录请求\r\n  return userApi.login(user)\r\n}\n```\n\n### 不要使用 == 进行比较\n\n在 js 中使用 `==` 比较相当危险，你永远不知道 js 到底是按照什么类型比较的，因为 js 会做各种隐式转换。而如果使用 `===` 比较，则会同时比较 **值** 和 **类型** 是否都相同，避免了各种不确定的问题。\n\n错误示例\n\n```js\nconsole.log(1 == true) // true\r\nconsole.log(1 == '1') // true\r\nconsole.log('1' == true) // true\r\nconsole.log('0' == true) // false\r\nconsole.log([] == []) // false\n```\n\n扪心自问，你真的知道上面为什么会出现这种结果么？即便知道，对于其他人而言仍然是难以预测的，所以抛弃掉 `==` 吧，学会使用更好的 `===` 最好\n\n```js\nconsole.log(1 == true) // false\r\nconsole.log(1 == '1') // false\r\nconsole.log('1' == true) // false\r\nconsole.log('0' == true) // false\r\nconsole.log([] == []) // false\n```\n\n### 使用计算属性名替代使用方括号表示法赋值\n\n目前而言已经有了 [计算属性名](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Object_initializer#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%90%8D) 用以在初始化时计算属性名，所以不需要再先声明对象再使用 [方括号表示法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_Accessors#%E6%96%B9%E6%8B%AC%E5%8F%B7%E8%A1%A8%E7%A4%BA%E6%B3%95) 进行赋值了。\n\nES5 写法\n\n```js\nconst state = {\r\n  'user.username': function () {},\r\n}\r\n\r\nstate[Date.now()] = new Date()\r\n\r\nconsole.log(state)\n```\n\nES6 写法\n\n```js\nconst state = {\r\n  'user.username'() {},\r\n  [Date.now()]: new Date(),\r\n}\r\n\r\nconsole.log(state)\n```\n\n### 简单的选项列表优先使用 Map 而非数组\n\n对于复选框，想必很多人相当熟悉。下面使用 js 模拟一个复选框\n\n```js\nconst item = {\r\n  id: 1,\r\n  role: ['1', '2'],\r\n  name: '',\r\n}\r\nconst options = [\r\n  {\r\n    roleid: '1',\r\n    label: '黄金糕',\r\n  },\r\n  {\r\n    roleid: '2',\r\n    label: '双皮奶',\r\n  },\r\n  {\r\n    roleid: '3',\r\n    label: '蚵仔煎',\r\n  },\r\n]\n```\n\n现在的需求是根据 `role` 计算显示值 `name` 的值\n\n```js\nitem.name = item.role\r\n  .map((role) => options.find((op) => op.roleid === role))\r\n  .filter((s) => s)\r\n  .join(',')\n```\n\n但实际上这里应该使用 `Map` 替代数组，因为数组的 `find` 其实非常低效，也需要进行遍历，使用 `Map` 的实现\n\n```js\nconst item = {\r\n  id: 1,\r\n  role: [1, 2],\r\n  name: '',\r\n}\r\nconst options = new Map().set(1, '黄金糕').set(2, '双皮奶').set(3, '蚵仔煎')\r\n\r\nfunction calcName(role) {\r\n  return role\r\n    .map((k) => options.get(k))\r\n    .filter((s) => s)\r\n    .join(',')\r\n}\r\n\r\nitem.name = calcName(item.role)\n```\n\n可以看到，获取时使用了 `Map#get`，在效率上应该是极好的。\n\n> 附: 该问题来自 <https://segmentfault.com/q/1010000019426996>\n\n### 存放 id 标识列表使用 Set 而非数组\n\n还是上面的例子，当你需要存取当前选中复选框的值 `role` 使用数组时，有可能遇到 id 重复的问题，实际上导致每次添加前需要使用 `Array#includes` 判断是否已存在。这里可以使用 `Set` 从数据结构层面避免掉可能重复的问题。\n\n修改后的实现\n\n```js\nconst item = {\r\n  id: 1,\r\n  role: new Set([1, 2]),\r\n  name: '',\r\n}\r\nconst options = new Map().set(1, '黄金糕').set(2, '双皮奶').set(3, '蚵仔煎')\r\n\r\nfunction calcName(role) {\r\n  return Array.from(role)\r\n    .map((k) => options.get(k))\r\n    .filter((s) => s)\r\n    .join(',')\r\n}\r\n\r\nitem.name = calcName(item.role)\n```\n\n先判断是否存在执行某些操作也非常方便，可以使用 `Set#has` 进行判断，当然时间复杂度时 O1。\n\n## 逻辑代码\n\n### 不要判断一个 Boolean 值并以此返回 Boolean 值\n\n不要在得到一个 `Boolean` 的值后使用 `if-else` 进行判断，然后根据结果返回 `true` 或 `false`，这真的显得非常非常蠢！\n\n错误示例\n\n```js\n// 模拟登录异步请求\r\nconst login = async ({ username, password }) => {\r\n  const res = username === 'rx' && password === 'rx'\r\n  if (res) {\r\n    return true\r\n  } else {\r\n    return false\r\n  }\r\n}\n```\n\n正确示例\n\n```js\n// 模拟登录异步请求\r\nconst login = async ({ username, password }) =>\r\n  username === 'rx' && password === 'rx'\n```\n\n### 不要使用多余的变量\n\n如果一个表达式立刻被使用并且只会被使用一次，那就不要使用变量声明，直接在需要的地方使用好了。\n\n错误示例\n\n```js\n// 模拟登录异步请求\r\nconst login = async ({ username, password }) => {\r\n  const res = username === 'rx' && password === 'rx'\r\n  return res\r\n}\n```\n\n正确示例\n\n```js\n// 模拟登录异步请求\r\nconst login = async ({ username, password }) => {\r\n  return username === 'rx' && password === 'rx'\r\n}\n```\n\n### 不要使用嵌套 if\n\n不要使用多级的 `if` 嵌套，这会让代码变得丑陋且难以调试，应当优先使用 **提前 return** 的策略。\n\n错误示例\n\n```js\n// 模拟登录异步请求\r\nconst login = async ({ username, password }) =>\r\n  username === 'rx' && password === 'rx'\r\n\r\nasync function submit(user) {\r\n  const { username, password } = user\r\n  if (username) {\r\n    if (password) {\r\n      const res = await login(user)\r\n      if (res) {\r\n        console.log('登录成功，即将跳转到首页')\r\n      } else {\r\n        console.log('登录失败，请检查用户名和密码')\r\n      }\r\n    } else {\r\n      console.log('用户密码不能为空')\r\n    }\r\n  } else {\r\n    console.log('用户名不能为空')\r\n  }\r\n}\n```\n\n正确示例\n\n```js\n// 模拟登录异步请求\r\nconst login = async ({ username, password }) =>\r\n  username === 'rx' && password === 'rx'\r\n\r\nasync function submit(user) {\r\n  const { username, password } = user\r\n  if (!username) {\r\n    console.log('用户名不能为空')\r\n    return\r\n  }\r\n  if (!password) {\r\n    console.log('用户密码不能为空')\r\n    return\r\n  }\r\n  const res = await login(user)\r\n  if (!res) {\r\n    console.log('登录失败，请检查用户名和密码')\r\n    return\r\n  }\r\n  console.log('登录成功，即将跳转到首页')\r\n}\n```\n\n### 不要先声明空对象然后一个个追加属性\n\n有时候会碰到这种情况，先声明一个空对象，然后在下面一个个追加属性，为什么创建对象与初始化不放到一起做呢？\n\n错误示例\n\n```js\n// 模拟登录异步请求\r\nconst login = async ({ username, password }) =>\r\n  username === 'rx' && password === 'rx'\r\n\r\nasync function submit(username, password) {\r\n  // 数据格式校验处理。。。\r\n\r\n  const user = {}\r\n  user.username = username.trim()\r\n  user.password = password.trim()\r\n\r\n  const res = await login(user)\r\n\r\n  // 后续的错误处理。。。\r\n}\n```\n\n正确示例\n\n```js\n// 模拟登录异步请求\r\nconst login = async ({ username, password }) =>\r\n  username === 'rx' && password === 'rx'\r\n\r\nasync function submit(username, password) {\r\n  // 数据格式校验处理。。。\r\n\r\n  const user = {\r\n    username: username.trim(),\r\n    password: password.trim(),\r\n  }\r\n\r\n  const res = await login(user)\r\n\r\n  // 后续的错误处理。。。\r\n}\n```\n\n### 不要使用无意义的函数包裹\n\n使用函数时，如果你想包裹的函数和原来函数的参数/返回值相同，那就直接应该使用函数作为参数，而非在包裹一层。给人的感觉就像是大夏天穿着棉袄吃雪糕 -- 多此一举！\n\n错误示例\n\n```js\n// 判断是否是偶数的函数\r\nconst isEven = (i) => i % 2 === 0\r\n//过滤出所有偶数\r\nconst res = [1, 2, 3, 4].filter((i) => isEven(i))\n```\n\n正确示例\n\n```js\n// 判断是否是偶数的函数\r\nconst isEven = (i) => i % 2 === 0\r\n//过滤出所有偶数\r\nconst res = [1, 2, 3, 4].filter(isEven)\n```\n\n### 不要使用三元运算符进行复杂的计算\n\n三元运算符适合于替代简单的 `if-else` 的情况，如果碰到较为复杂的情况，请使用 `if + return` 或者解构/默认参数的方式解决。\n\n错误示例\n\n```js\nfunction formatUser(user) {\r\n  return user === undefined\r\n    ? 'username: noname, password: blank'\r\n    : 'username: ' +\r\n        (user.username === undefined ? 'noname' : user.username) +\r\n        ', password: ' +\r\n        (user.password === undefined ? 'blank' : user.password)\r\n}\n```\n\n看到上面的代码就感觉到一股烂代码的味道扑面而来，这实在是太糟糕了！实际上只需要两行代码就好了！\n\n正确示例\n\n```js\nfunction formatUser({ username = 'noname', password = 'blank' } = {}) {\r\n  return `username: ${username}, password: ${password}`\r\n}\n```\n\n### 如果变量有所关联则使用对象而非多个单独的变量\n\n如果变量有所关联，例如一个表单，存储的时候不要使用单独的变量，将之存储到一个表单变量中更好。\n\n错误示例\n\n```js\nfunction login(){\r\n  const username = document.querySelector('#username')\r\n  const password = document.querySelector('#password')\r\n  const remeberMe = document.querySelector('#remeberMe')\r\n\r\n  // 一些校验。。。\r\n  if (!validate(username, password, remeberMe)) {\r\n    return\r\n  }\r\n  // 请求后台\r\n  const res = await userLogin.login(username, password, remeberMe)\r\n  // 后处理。。。\r\n}\n```\n\n正确示例\n\n```js\nfunction login(){\r\n  const user = {\r\n    username : document.querySelector('#username'),\r\n    password : document.querySelector('#password'),\r\n    remeberMe : document.querySelector('#remeberMe'),\r\n  }\r\n  // 一些校验。。。\r\n  if (!validate(user)) {\r\n    return\r\n  }\r\n  // 请求后台\r\n  const res = await userLogin.login(user)\r\n  // 后处理。。。\r\n}\n```\n\n### 应该尽量解决编辑器警告\n\n如果编辑器对我们的代码发出警告，那么一般都是我们代码出现了问题（一般开发人员的能力并不足以比肩编辑器 #MS 那些 dalao 的能力）。所以，如果出现了警告，应该先去解决它 -- 如果你确认发生了错误，则通过注释/配置禁用它！\n\n### 使用类型定义参数对象\n\n如果一个函数需要一个对象参数，最好专门定义一个类型，并在注释上说明，便于在使用时 IDE 进行提示，而不需要去查找文档手册。\n\n错误示例\n\n```js\n/**\r\n * 格式化用户\r\n * @param {Object} user 格式化的用户对象\r\n */\r\nfunction formatUser(user) {\r\n  const { username, password } = user || {}\r\n  return `user, username: ${username}, password: ${password}`\r\n}\r\n\r\n// 此处别人并不知道 User 里面到底有什么属性，只能去查看文档\r\nconst str = formatUser({ username: 'rx', password: '123456' })\r\nconsole.log(str)\n```\n\n正确示例\n\n```js\nclass User {\r\n  constructor(username, password) {\r\n    this.username = username\r\n    this.password = password\r\n  }\r\n}\r\n\r\n/**\r\n * 格式化用户\r\n * @param {User} user 格式化的用户对象\r\n */\r\nfunction formatUser(user) {\r\n  const { username, password } = user || {}\r\n  return `user, username: ${username}, password: ${password}`\r\n}\r\n\r\nconst str = formatUser(new User('rx', '123456'))\r\nconsole.log(str)\n```\n\n### 尽量扁平化代码\n\n尽量将 `a` 调用 `b`, `b` 调用 `c`，然后 `b` 调用 `d`，优化为依次调用 `a, b, c, d`。\n\n> 注意: 这里使用的是**尽量**而非**不要**，深层嵌套不可避免，但在局部上，应该采取扁平化的策略，**提前 return** 避免嵌套 if-else 是个很好的例子。\n\n### 自执行函数前面必须加分号\n\n如果我们需要使用自执行函数，则开头必须加上 `;` 以避免可能出现的歧义。\n\n错误示例\n\n```sh\nfunction returnItself(o) {\r\n  return o\r\n}\r\nreturnItself(() => console.log(1))\r\n(() => {\r\n  console.log(2)\r\n})()\n```\n\n上面这段代码是有问题的，因为后面的自执行函数会被认为是上一句的 `returnItself` 返回函数的参数，最后的括号会被认为又是一次调用，将会抛出错误\n\n```js\nreturnItself(...)(...) is not a function\n```\n\n正确示例\n\n```js\nfunction returnItself(o) {\r\n  return o\r\n}\r\nreturnItself(() => console.log(1))\r\n;(() => {\r\n  console.log(2)\r\n})()\n```\n\n使用分号可以明确告诉 JavaScript 这是一行新的代码，上面的代码已经到此为止了。\n","createdTime":1580652937876,"updatedTime":1624275821489,"resources":[],"tags":[{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"7f70004b2d534dff9d2ddc81abd1ae98","title":"markdown 语法说明","body":"> 已经有更好、更全面的介绍了，此页面将没有太多参考的价值。\n> 参考：[markdown guide](https://www.markdownguide.org/), [中文翻译](https://www.markdown.xyz/)\n\n- [markdown 语法说明](#markdown-语法说明)\n  - [概述](#概述)\n    - [宗旨](#宗旨)\n    - [兼容 HTML](#兼容-html)\n    - [特殊字符自动转换](#特殊字符自动转换)\n  - [区块元素](#区块元素)\n    - [段落和换行](#段落和换行)\n    - [标题](#标题)\n    - [区块引用 Blockquotes](#区块引用-blockquotes)\n    - [列表](#列表)\n    - [代码区块](#代码区块)\n    - [分隔线](#分隔线)\n  - [区段元素](#区段元素)\n    - [链接](#链接)\n    - [强调](#强调)\n    - [删除](#删除)\n    - [代码](#代码)\n    - [图片](#图片)\n  - [其它](#其它)\n    - [自动链接](#自动链接)\n    - [反斜杠](#反斜杠)\n  - [扩展语法](#扩展语法)\n    - [使用 `\\` 换行](#使用--换行)\n    - [语言特定代码块](#语言特定代码块)\n    - [表格](#表格)\n    - [文章目录](#文章目录)\n    - [任务列表](#任务列表)\n  - [Markdown 免费编辑器](#markdown-免费编辑器)\n\n---\n\n## 概述\n\n> 本文引用自 <https://www.appinn.com/markdown/>，吾辈添加/修复了一些内容。  \n> 本文同步部署到为了网站 <https://md-syntax.rxliuli.com/>，如有需要可以收藏（#笑）。\n\n### 宗旨\n\nMarkdown 的目标是实现「易读易写」。\n\n可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 [Setext][1]、[atx][2]、[Textile][3]、[reStructuredText][4]、[Grutatext][5] 和 [EtText][6]，而最大灵感来源其实是纯文本电子邮件的格式。\n\n[1]: http://docutils.sourceforge.net/mirror/setext.html\n[2]: http://www.aaronsw.com/2002/atx/\n[3]: http://textism.com/tools/textile/\n[4]: http://docutils.sourceforge.net/rst.html\n[5]: http://www.triptico.com/software/grutatxt.html\n[6]: http://ettext.taint.org/doc/\n\n总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像**强调**。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。\n\n### 兼容 HTML\n\nMarkdown 语法的目标是：成为一种适用于网络的*书写*语言。\n\nMarkdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想*不是*要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种*发布*的格式，Markdown 是一种*书写*的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。\n\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。\n\n要制约的只有一些 HTML 区块元素――比如 `<div>`、`<table>`、`<pre>`、`<p>` 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 `<p>` 标签。\n\n例子如下，在 Markdown 文件里加上一段 HTML 表格：\n\n    这是一个普通段落。\n\n    <table>\n      <tr>\n        <td>Foo</td>\n      </tr>\n    </table>\n\n    这是另一个普通段落。\n\n请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的`*强调*`会没有效果。\n\nHTML 的区段（行内）标签如 `<span>`、`<cite>`、`<del>` 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 `<a>` 或 `<img>` 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。\n\n和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。\n\n### 特殊字符自动转换\n\n在 HTML 文件中，有两个字符需要特殊处理： `<` 和 `&` 。 `<` 符号用于起始标签，`&` 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 `&lt;` 和 `&amp;`。\n\n`&` 字符尤其让网络文档编写者受折磨，如果你要打「`AT&T`」 ，你必须要写成「`AT&amp;T`」。而网址中的 `&` 字符也要转换。比如你要链接到：\n\n    http://images.google.com/images?num=30&q=larry+bird\n\n你必须要把网址转换写为：\n\n    http://images.google.com/images?num=30&amp;q=larry+bird\n\n才能放到链接标签的 `href` 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。\n\nMarkdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 `&` 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 `&amp`;。\n\n所以你如果要在文档中插入一个版权符号 `©`，你可以这样写：\n\n    &copy;\n\nMarkdown 会保留它不动。而若你写：\n\n    AT&T\n\nMarkdown 就会将它转为：\n\n    AT&amp;T\n\n类似的状况也会发生在 `<` 符号上，因为 Markdown 允许 [兼容 HTML](#html) ，如果你是把 `<` 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：\n\n    4 < 5\n\nMarkdown 将会把它转换为：\n\n    4 &lt; 5\n\n不过需要注意的是，code 范围内，不论是行内还是区块， `<` 和 `&` 两个符号都*一定*会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 `<` 和 `&` 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）\n\n---\n\n## 区块元素\n\n### 段落和换行\n\n一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。\n\n「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 `<br />` 标签。\n\n如果你*确实*想要依赖 Markdown 来插入 `<br />` 标签的话，在插入处先按入两个以上的空格然后回车。\n\n的确，需要多费点事（多加空格）来产生 `<br />` ，但是简单地「每个换行都转换为 `<br />`」的方法在 Markdown 中并不适合， Markdown 中 email 式的 [区块引用][bq] 和多段落的 [列表][l] 在使用换行来排版的时候，不但更好用，还更方便阅读。\n\n[bq]: #blockquote\n[l]: #list\n\n### 标题\n\nMarkdown 支持两种标题的语法，类 [Setext][1] 和类 [atx][2] 形式。\n\n类 Setext 形式是用底线的形式，利用 `=` （最高阶标题）和 `-` （第二阶标题），例如：\n\n    This is an H1\n    =============\n\n    This is an H2\n    -------------\n\n任何数量的 `=` 和 `-` 都可以有效果。\n\n类 Atx 形式则是在行首插入 1 到 6 个 `#` ，对应到标题 1 到 6 阶，例如：\n\n    # 这是 H1\n\n    ## 这是 H2\n\n    ###### 这是 H6\n\n你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 `#`，而行尾的 `#` 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：\n\n    # 这是 H1 #\n\n    ## 这是 H2 ##\n\n    ### 这是 H3 ######\n\n### 区块引用 Blockquotes\n\nMarkdown 标记区块引用是使用类似 email 中用 `>` 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 `>` ：\n\n    > This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n    > consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n    > Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n    >\n    > Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n    > id sem consectetuer libero luctus adipiscing.\n\nMarkdown 也允许你偷懒只在整个段落的第一行最前面加上 `>` ：\n\n    > This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n    consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n    Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n\n    > Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n    id sem consectetuer libero luctus adipiscing.\n\n区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 `>` ：\n\n    > This is the first level of quoting.\n    >\n    > > This is nested blockquote.\n    >\n    > Back to the first level.\n\n引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：\n\n    > ## 这是一个标题。\n    >\n    > 1.   这是第一行列表项。\n    > 2.   这是第二行列表项。\n    >\n    > 给出一些例子代码：\n    >\n    >     return shell_exec(\"echo $input | $markdown_script\");\n\n任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择*增加引用阶层*。\n\n### 列表\n\nMarkdown 支持有序列表和无序列表。\n\n无序列表使用星号、加号或是减号作为列表标记：\n\n    *   Red\n    *   Green\n    *   Blue\n\n等同于：\n\n    +   Red\n    +   Green\n    +   Blue\n\n也等同于：\n\n    -   Red\n    -   Green\n    -   Blue\n\n有序列表则使用数字接着一个英文句点：\n\n    1.  Bird\n    2.  McHale\n    3.  Parish\n\n很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：\n\n    <ol>\n    <li>Bird</li>\n    <li>McHale</li>\n    <li>Parish</li>\n    </ol>\n\n如果你的列表标记写成：\n\n    1.  Bird\n    1.  McHale\n    1.  Parish\n\n或甚至是：\n\n    3. Bird\n    1. McHale\n    8. Parish\n\n你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。\n\n如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。\n\n列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。\n\n要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：\n\n    *   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\n        Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,\n        viverra nec, fringilla in, laoreet vitae, risus.\n    *   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.\n        Suspendisse id sem consectetuer libero luctus adipiscing.\n\n但是如果你懒，那也行：\n\n    *   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\n    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,\n    viverra nec, fringilla in, laoreet vitae, risus.\n    *   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.\n    Suspendisse id sem consectetuer libero luctus adipiscing.\n\n如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 `<p>`\n标签包起来，举例来说：\n\n    *   Bird\n    *   Magic\n\n会被转换为：\n\n    <ul>\n    <li>Bird</li>\n    <li>Magic</li>\n    </ul>\n\n但是这个：\n\n    *   Bird\n\n    *   Magic\n\n会被转换为：\n\n    <ul>\n    <li><p>Bird</p></li>\n    <li><p>Magic</p></li>\n    </ul>\n\n列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：\n\n    1.  This is a list item with two paragraphs. Lorem ipsum dolor\n        sit amet, consectetuer adipiscing elit. Aliquam hendrerit\n        mi posuere lectus.\n\n        Vestibulum enim wisi, viverra nec, fringilla in, laoreet\n        vitae, risus. Donec sit amet nisl. Aliquam semper ipsum\n        sit amet velit.\n\n    2.  Suspendisse id sem consectetuer libero luctus adipiscing.\n\n如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：\n\n    *   This is a list item with two paragraphs.\n\n        This is the second paragraph in the list item. You're\n    only required to indent the first line. Lorem ipsum dolor\n    sit amet, consectetuer adipiscing elit.\n\n    *   Another item in the same list.\n\n如果要在列表项目内放进引用，那 `>` 就需要缩进：\n\n    *   A list item with a blockquote:\n\n        > This is a blockquote\n        > inside a list item.\n\n如果要放代码区块的话，该区块就需要缩进*两次*，也就是 8 个空格或是 2 个制表符：\n\n    *   一列表项包含一个列表区块：\n\n            <代码写在这>\n\n当然，项目列表很可能会不小心产生，像是下面这样的写法：\n\n    1986. What a great season.\n\n换句话说，也就是在行首出现*数字-句点-空白*，要避免这样的状况，你可以在句点前面加上反斜杠。\n\n    1986\\. What a great season.\n\n### 代码区块\n\n和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 `<pre>` 和 `<code>` 标签来把代码区块包起来。\n\n要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：\n\n    这是一个普通段落：\n\n        这是一个代码区块。\n\nMarkdown 会转换成：\n\n    <p>这是一个普通段落：</p>\n\n    <pre><code>这是一个代码区块。\n    </code></pre>\n\n这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：\n\n    Here is an example of AppleScript:\n\n        tell application \"Foo\"\n            beep\n        end tell\n\n会被转换为：\n\n    <p>Here is an example of AppleScript:</p>\n\n    <pre><code>tell application \"Foo\"\n        beep\n    end tell\n    </code></pre>\n\n一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。\n\n在代码区块里面， `&` 、 `<` 和 `>` 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：\n\n        <div class=\"footer\">\n            &copy; 2004 Foo Corporation\n        </div>\n\n会被转换为：\n\n    <pre><code>&lt;div class=\"footer\"&gt;\n        &amp;copy; 2004 Foo Corporation\n    &lt;/div&gt;\n    </code></pre>\n\n代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。\n\n### 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n    * * *\n\n    ***\n\n    *****\n\n    - - -\n\n    ---------------------------------------\n\n---\n\n## 区段元素\n\n### 链接\n\nMarkdown 支持两种形式的链接语法： *行内式*和*参考式*两种形式。\n\n不管是哪一种，链接文字都是用 [方括号] 来标记。\n\n要建立一个*行内式*的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：\n\n    This is [an example](http://example.com/ \"Title\") inline link.\n\n    [This link](http://example.net/) has no title attribute.\n\n会产生：\n\n    <p>This is <a href=\"http://example.com/\" title=\"Title\">\n    an example</a> inline link.</p>\n\n    <p><a href=\"http://example.net/\">This link</a> has no\n    title attribute.</p>\n\n如果你是要链接到同样主机的资源，你可以使用相对路径：\n\n    See my [About](/about/) page for details.\n\n*参考式*的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：\n\n    This is [an example][id] reference-style link.\n\n你也可以选择性地在两个方括号中间加上一个空格：\n\n    This is [an example] [id] reference-style link.\n\n接着，在文件的任意处，你可以把这个标记的链接内容定义出来：\n\n    [id]: http://example.com/  \"Optional Title Here\"\n\n链接内容定义的形式为：\n\n- 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字\n- 接着一个冒号\n- 接着一个以上的空格或制表符\n- 接着链接的网址\n- 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着\n\n下面这三种链接的定义都是相同：\n\n    [foo]: http://example.com/  \"Optional Title Here\"\n    [foo]: http://example.com/  'Optional Title Here'\n    [foo]: http://example.com/  (Optional Title Here)\n\n**请注意：**有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。\n\n链接网址也可以用尖括号包起来：\n\n    [id]: <http://example.com/>  \"Optional Title Here\"\n\n你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：\n\n    [id]: http://example.com/longish/path/to/resource/here\n        \"Optional Title Here\"\n\n网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。\n\n链接辨别标签可以有字母、数字、空白和标点符号，但是并*不*区分大小写，因此下面两个链接是一样的：\n\n    [link text][a]\n    [link text][A]\n\n*隐式链接标记*功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 \"Google\" 链接到 google.com，你可以简化成：\n\n    [Google][]\n\n然后定义链接内容：\n\n    [Google]: http://google.com/\n\n由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：\n\n    Visit [Daring Fireball][] for more information.\n\n然后接着定义链接：\n\n    [Daring Fireball]: http://daringfireball.net/\n\n链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。\n\n下面是一个参考式链接的范例：\n\n    I get 10 times more traffic from [Google] [1] than from\n    [Yahoo] [2] or [MSN] [3].\n\n      [1]: http://google.com/        \"Google\"\n      [2]: http://search.yahoo.com/  \"Yahoo Search\"\n      [3]: http://search.msn.com/    \"MSN Search\"\n\n如果改成用链接名称的方式写：\n\n    I get 10 times more traffic from [Google][] than from\n    [Yahoo][] or [MSN][].\n\n      [google]: http://google.com/        \"Google\"\n      [yahoo]:  http://search.yahoo.com/  \"Yahoo Search\"\n      [msn]:    http://search.msn.com/    \"MSN Search\"\n\n上面两种写法都会产生下面的 HTML。\n\n    <p>I get 10 times more traffic from <a href=\"http://google.com/\"\n    title=\"Google\">Google</a> than from\n    <a href=\"http://search.yahoo.com/\" title=\"Yahoo Search\">Yahoo</a>\n    or <a href=\"http://search.msn.com/\" title=\"MSN Search\">MSN</a>.</p>\n\n下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：\n\n    I get 10 times more traffic from [Google](http://google.com/ \"Google\")\n    than from [Yahoo](http://search.yahoo.com/ \"Yahoo Search\") or\n    [MSN](http://search.msn.com/ \"MSN Search\").\n\n参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。\n\n使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。\n\n### 强调\n\nMarkdown 使用星号（`*`）和底线（`_`）作为标记强调字词的符号，被 `*` 或 `_` 包围的字词会被转成用 `<em>` 标签包围，用两个 `*` 或 `_` 包起来的话，则会被转成 `<strong>`，例如：\n\n    *single asterisks*\n\n    _single underscores_\n\n    **double asterisks**\n\n    __double underscores__\n\n会转成：\n\n    <em>single asterisks</em>\n\n    <em>single underscores</em>\n\n    <strong>double asterisks</strong>\n\n    <strong>double underscores</strong>\n\n你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。\n\n强调也可以直接插在文字中间：\n\n    un*frigging*believable\n\n但是**如果你的 `*` 和 `_` 两边都有空白的话，它们就只会被当成普通的符号**。\n\n如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：\n\n    \\*this text is surrounded by literal asterisks\\*\n\n### 删除\n\nMarkdown 可以在一行中用两个 (~\\~) 符号 包裹一段文字，会被转成 `<del>` 包裹起来的内容，显示为 ~~删除~~。\n\n例如：\n\n    ~~删除~~\n\n会转成：\n\n    <del>删除</del>\n\n如果需要连续使用两个 ~ 符号，则可以使用反斜线：\n\n    ~\\~删除~\\~\n\n### 代码\n\n如果要标记一小段行内代码，你可以用反引号把它包起来（`` ` ``），例如：\n\n    Use the `printf()` function.\n\n会产生：\n\n    <p>Use the <code>printf()</code> function.</p>\n\n如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：\n\n    ``There is a literal backtick (`) here.``\n\n这段语法会产生：\n\n    <p><code>There is a literal backtick (`) here.</code></p>\n\n代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：\n\n    A single backtick in a code span: `` ` ``\n\n    A backtick-delimited string in a code span: `` `foo` ``\n\n会产生：\n\n    <p>A single backtick in a code span: <code>`</code></p>\n\n    <p>A backtick-delimited string in a code span: <code>`foo`</code></p>\n\n在代码区段内，`&` 和尖括号**都**会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：\n\n    Please don't use any `<blink>` tags.\n\n转为：\n\n    <p>Please don't use any <code>&lt;blink&gt;</code> tags.</p>\n\n你也可以这样写：\n\n    `&#8212;` is the decimal-encoded equivalent of `&mdash;`.\n\n以产生：\n\n    <p><code>&amp;#8212;</code> is the decimal-encoded\n    equivalent of <code>&amp;mdash;</code>.</p>\n\n### 图片\n\n很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。\n\nMarkdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： *行内式*和*参考式*。\n\n行内式的图片语法看起来像是：\n\n    ![Alt text](/path/to/img.jpg)\n\n    ![Alt text](/path/to/img.jpg \"Optional title\")\n\n详细叙述如下：\n\n- 一个惊叹号 `!`\n- 接着一个方括号，里面放上图片的替代文字\n- 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上\n  选择性的 'title' 文字。\n\n参考式的图片语法则长得像这样：\n\n    ![Alt text][id]\n\n「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：\n\n    [id]: url/to/image  \"Optional title attribute\"\n\n到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 `<img>` 标签。\n\n---\n\n## 其它\n\n### 自动链接\n\nMarkdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：\n\n    <http://example.com/>\n\nMarkdown 会转为：\n\n    <a href=\"http://example.com/\">http://example.com/</a>\n\n邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：\n\n    <address@example.com>\n\nMarkdown 会转成：\n\n    <a href=\"&#x6D;&#x61;i&#x6C;&#x74;&#x6F;:&#x61;&#x64;&#x64;&#x72;&#x65;\n    &#115;&#115;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6C;e&#x2E;&#99;&#111;\n    &#109;\">&#x61;&#x64;&#x64;&#x72;&#x65;&#115;&#115;&#64;&#101;&#120;&#x61;\n    &#109;&#x70;&#x6C;e&#x2E;&#99;&#111;&#109;</a>\n\n在浏览器里面，这段字串（其实是 `<a href=\"mailto:address@example.com\">address@example.com</a>`）会变成一个可以点击的「address@example.com」链接。\n\n（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）\n\n### 反斜杠\n\nMarkdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 `<em>` 标签），你可以在星号的前面加上反斜杠：\n\n    \\*literal asterisks\\*\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n    \\   反斜线\n    `   反引号\n    *   星号\n    _   底线\n    {}  花括号\n    []  方括号\n    ()  括弧\n    #   井字号\n    +   加号\n    -   减号\n    .   英文句点\n    !   惊叹号\n\n## 扩展语法\n\n### 使用 `\\` 换行\n\n标准 markdown 使用两个空格换行，不仅容易忘记，而且也不够明显。所以 vscode 支持另外一种换行方式，使用反斜杠 `\\`。\n\n例如\n\n```md\n第一行\\\n第二行  \n第三行\n```\n\n会被显示为\n\n第一行\\\n第二行  \n第三行\n\n### 语言特定代码块\n\n虽然上面直接缩进 4 个空格就能得到代码块，但如果想要特定于语言的语法高亮，就不能直接缩进，而是使用 3 个以上的反引号（`） 包裹起来并告诉 markdown 解析器你需要什么语言的语法高亮。\n\n例如\n\n````md\n```js\nfunction foo() {\n  return {\n    name: \"灵梦\",\n    age: 17,\n    sex: false,\n  }\n}\n```\n````\n\n会被显示为\n\n```js\nfunction foo() {\n  return {\n    name: \"灵梦\",\n    age: 17,\n    sex: false,\n  }\n}\n```\n\n在代码显示上会有相当的优势，还是希望尽量使用 ``` 而非缩进 4 个空格。\n\n### 表格\n\nmarkdown 可以制作一些简单的表格\n\n例如\n\n```md\n| name    | age | gender |\n| ------- | --- | ------ |\n| liuli   | 17  | false  |\n| chuxuan | 23  | true   |\n```\n\n会被显示为\n\n| name    | age | gender |\n| ------- | --- | ------ |\n| liuli   | 17  | false  |\n| chuxuan | 23  | true   |\n\n### 文章目录\n\nmarkdown 还可以支持的文章目录（本质上是嵌套的无序列表）\n\n例如\n\n```md\n- [markdown 语法说明](#markdown-语法说明)\n  - [概述](#概述)\n    - [宗旨](#宗旨)\n    - [兼容 HTML](#兼容-html)\n    - [特殊字符自动转换](#特殊字符自动转换)\n  - [区块元素](#区块元素)\n    - [段落和换行](#段落和换行)\n    - [标题](#标题)\n    - [区块引用 Blockquotes](#区块引用-blockquotes)\n    - [列表](#列表)\n    - [代码区块](#代码区块)\n    - [分隔线](#分隔线)\n  - [区段元素](#区段元素)\n    - [链接](#链接)\n    - [强调](#强调)\n    - [删除](#删除)\n    - [代码](#代码)\n    - [图片](#图片)\n  - [其它](#其它)\n    - [自动链接](#自动链接)\n    - [反斜杠](#反斜杠)\n  - [扩展语法](#扩展语法)\n    - [使用 `\\` 换行](#使用--换行)\n    - [语言特定代码块](#语言特定代码块)\n    - [表格](#表格)\n    - [文章目录](#文章目录)\n    - [任务列表](#任务列表)\n  - [Markdown 免费编辑器](#markdown-免费编辑器)\n```\n\n会被显示为\n\n- [markdown 语法说明](#markdown-语法说明)\n  - [概述](#概述)\n    - [宗旨](#宗旨)\n    - [兼容 HTML](#兼容-html)\n    - [特殊字符自动转换](#特殊字符自动转换)\n  - [区块元素](#区块元素)\n    - [段落和换行](#段落和换行)\n    - [标题](#标题)\n    - [区块引用 Blockquotes](#区块引用-blockquotes)\n    - [列表](#列表)\n    - [代码区块](#代码区块)\n    - [分隔线](#分隔线)\n  - [区段元素](#区段元素)\n    - [链接](#链接)\n    - [强调](#强调)\n    - [删除](#删除)\n    - [代码](#代码)\n    - [图片](#图片)\n  - [其它](#其它)\n    - [自动链接](#自动链接)\n    - [反斜杠](#反斜杠)\n  - [扩展语法](#扩展语法)\n    - [使用 `\\` 换行](#使用--换行)\n    - [语言特定代码块](#语言特定代码块)\n    - [表格](#表格)\n    - [文章目录](#文章目录)\n    - [任务列表](#任务列表)\n  - [Markdown 免费编辑器](#markdown-免费编辑器)\n\n### 任务列表\n\n如果你想要写一些任务项，markdown 恰好也是支持的。只要简单的使用 `- [ ]`/`- [x]` 的方式就可以定义未完成/完成的任务项。\n\n例如\n\n```md\n- [ ] 第一项任务\n- [x] 第二项任务\n- [x] 第三项任务\n```\n\n会被显示为\n\n- [ ] 第一项任务\n- [x] 第二项任务\n- [x] 第三项任务\n\n---\n\n## Markdown 免费编辑器\n\n> 如果你是一名 Developer，那吾辈首推 [VSCode](https://code.visualstudio.com/)，免费开源的跨平台编辑器。\n\nWindows 平台\n\n- [MarkdownPad](http://markdownpad.com/)\n- [MarkPad](http://code52.org/DownmarkerWPF/)\n\nLinux 平台\n\n- [ReText](http://sourceforge.net/p/retext/home/ReText/)\n\nMac 平台\n\n- [Mou](http://25.io/mou/)\n\n在线编辑器\n\n- [Dillinger.io](http://dillinger.io/)\n\n浏览器插件\n\n- [Markdown Here](https://chrome.google.com/webstore/detail/markdown-here/elifhakcjgalahccnjkneoccemfahfoa/)\n\n高级应用\n\n- [VSCode](https://code.visualstudio.com/) + [Markdown All in One](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one) / [VSCode 搭建 markdown 写作环境](:/522048077c1343b79eb9f42640c02bd0)\n- [Sublime Text 2](http://www.sublimetext.com/2) + [MarkdownEditing](http://ttscoff.github.com/MarkdownEditing/) / [教程](http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/)\n","createdTime":1580652938034,"updatedTime":1624275677898,"resources":[],"tags":[{"id":"6a9fbee743ec48fa9a4eff9999e11d49","title":"markdown","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"102fd7cc3d3b46f8b2f8767cf7326459","title":"Windows 上强制粘贴","body":"## 场景\n\n前面吾辈曾经写过一篇 [Chrome 强制复制粘贴](:/5a5e606ac8674f139293033f794e9723) 的文章，然而那篇内容仅仅只是针对于 Chrome/Firefox 浏览器。对于 Windows 的客户端软件，例如 QQ、阿里旺旺之类，它们还是不允许粘贴密码。这点对于所有密码都是用密码管理器管理，随机生成的用户而言（吾辈），实在是太过讨厌了一点！\n\n## 解决思路\n\nQQ 这种客户端是如何屏蔽粘贴功能的呢？很显然，QQ 不仅仅是禁用右键/快捷键那么简单，或许是添加键盘驱动了也说不定。但不管怎样，我们都可以从根本的地方下手 -- **模拟键盘输入，将剪切版的文字一个一个的输入进去！**\n\n## 解决方案\n\n虽然不像 Linux 那样任何操作都可以使用脚本去控制（实际上也可以，只不过 Windows 的 `cmd` 脚本实在不怎么样），然而基于 Windows 丰富的生态，还是有人做出了第三方的脚本语言 -- **Autohotkey**。\n\n我们首先去 [官网](https://www.autohotkey.com/) 看一下，介绍只有简单的两句话。\n\n> Powerful. Easy to learn.\\\n> The ultimate automation scripting language for Windows.\n\n翻译过来就是：\n\n> 强大，简单易学\\\n> Windows 上的自动化脚本语言\n\n我们可以写一个 Autohotkey 自动化的脚本，在检测到 QQ 运行并且按下 **CS-V** 时将剪切版的字符逐个输入进去。\n\n## 具体实现\n\n```ahk\n#IfWinActive ahk_exe QQ.exe\r\n{\r\n    ;热键为 Ctrl+Shift+V\r\n    ^+v::\r\n    ;发送剪切版的内容到输入\r\n    SendInput {Raw}%Clipboard%\r\n    Return\r\n}\r\n#IfWinActive\n```\n\n当然，如果不喜欢安装 Autohotkey 的话也没关系，吾辈转换了一个 [.exe 可执行文件](https://raw.githubusercontent.com/rxliuli/blog_binary_file/master/QQForcedPaste.exe)，也可以直接下载使用啦\n\n## 使用效果\n\n![使用示例](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190219214116.gif)\n","createdTime":1580652938027,"updatedTime":1624275388471,"resources":[],"tags":[{"id":"4e00e5550c864473a3f16e4b0698f1c3","title":"windows","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"7fb6a26219c346aeb71cfe3807a50279","title":"IDEA 热部署","body":"在阅读本篇之前至少需要对以下概念有基本的认知：\n\n- Java\n- JetBrains IDEA\n\n---\n\n## **热部署** 是什么？\n\n以下内容引用于度娘百科：https://baike.baidu.com/item/%E7%83%AD%E9%83%A8%E7%BD%B2\n\n> 所谓热部署，就是在应用正在运行的时候升级软件，却不需要重新启动应用。  \n> 对于 Java 应用程序来说，热部署就是在运行时更新 Java 类文件。在基于 Java 的应用服务器实现热部署的过程中，类装入器扮演着重要的角色。大多数基于 Java 的应用服务器，包括 EJB 服务器和 Servlet 容器，都支持热部署。类装入器不能重新装入一个已经装入的类，但只要使用一个新的类装入器实例，就可以将类再次装入一个正在运行的应用程序。\n\n简而言之，就是你在开发 Web 程序时不需要在每次 **修改代码** 之后都要重启 Web 容器再看效果了。\n\n> 修改按文件类型分类大致有：Java 源代码，`src/main/resource` 下的资源文件，`src/main/webapp` 下的前端资源文件，`src/main/webapp` 下的模板文件（例如 JSP/Freemarker），亦或是 `web.xml` 这种 Web 容器的配置文件。\n\n好了，废话就不说了（然而还是要了解一下概念啦）\n\n## 基本配置\n\n1. 在编辑运行配置窗口，配置 Tomcat（其他 Web 容器应该也类似）的页面。\n   ![配置 Tomcat](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210657.png)\n\n2. 点击 Deployment 选项卡，配置要运行的 war，必须要选择 **exploded** 进行部署。\n   ![Deployment 选项卡](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210737.png)\n\n3. 回到 Server 选项卡，配置 IDEA 在发现代码/框架发生变化是执行的动作。\n   ![配置 IDEA 在发现代码](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210756.png)\n\n然后，点击 OK 就可以了，接下来以 `Debug` 默认运行就可以自动帮你更新 Java 源码和 resources 资源文件以及 webapp 下的静态文件/模板文件了，愉快的玩耍吧！\n\n---\n\n## 多模块配置\n\n> 注：如果你还没有接触多模块的话，可以略过下面的内容。\n\n。。。然而不幸的是对于多模块项目以及各种各样的框架和类库，IDEA 本身的热部署实在不够看。所以如果你想要更强大的热部署功能的话，可以使用 **Jrebel** 这个插件。\n\n1. IDEA 的官方 Plugin 商店里面就有这个，点击安装（由于众所周知的原因，下载可能比较慢），安装完成之后重启。\n   > 然后，如果你不愿意支持正版又不打算折腾破解的话，也可以不用看下面的内容了（关于破解方法可以参考 [# IDEA 激活](:/a0b9c67c7c9c460ea59c12603f390f2d)）  \n   > [Google 上的相关内容](https://www.google.lk/search?q=IDEA+Jrebel+%E7%A0%B4%E8%A7%A3&oq=IDEA+Jrebel+%E7%A0%B4%E8%A7%A3)\n2. 在 `help > Jrebel > Activation` 下输入 License\n   ![20181122210822](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210822.png)  \n   ![20181122210839](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210839.png)  \n   ![20181122210910](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210910.png)\n\n3. 接下来如上面那样配置 IDEA 的 Tomcat 运行选项之后（就是没装 Jrebel 的那种热部署方式），然后点击 `View > Tool Windows > JRebel`\n\n   ![20181122210932](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210932.png)\n\n   看到左侧弹出一个面板，选择你要热部署的模块，或者选择第一个以全选所有模块\n\n   ![20181122210941](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210941.png)\n\n   > 你或许发现了 `src/main/resources` 目录下多了一个奇怪的配置文件 `rebel.xml`，然而你并不需要在意，因为它是 Jrebel 的热部署配置文件。\n\n   ![Jrebel 的热部署配置文件](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122210955.png)\n\n4. 最后，点击 Jrebel 的 Debug 按钮即可  \n   ![Jrebel Debug](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122211005.png)\n5. 使用 Jrebel 调试项目即可  \n   ![Jrebel 调试项目](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190325101659.png)\n6. 现在，每当你的焦点离开 IDEA（切换到浏览器），Jrebel 就会自动检测变化的类和资源并帮你重新编译了（状态栏会有提示）\n\n> 附：这里提供吾辈自建的一个激活服务器，请勿滥用：<http://39.108.15.57:8181/947122a0-7e9a-4bea-814d-876525d3767f>  \n> 邮箱的话格式正确即可\n\n那么，IDEA 的热部署配置就到这里了，实际上使用了 `SpringBoot` 之后就自带了热部署相关的类库。。。#贴心\n","createdTime":1580652937998,"updatedTime":1624274871625,"resources":[],"tags":[{"id":"34dfb4608c934c3b8d33e9605a180e39","title":"jetbrains","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"7713263c9158489c95009be721e2c6bc","title":"JavaScript 处理树结构数据","body":"## 场景\n\n前端项目中，有一些需要处理树结构数据的情况，（一年）之前吾辈曾经写过一篇文章，但现在，吾辈有了更好的解决方案。\n\n## 思考\n\n之前吾辈使用 Proxy 的方式抹平树结构数据的差异，然后再处理。后来吾辈发现这完全是多此一举，在使用过 antd 的 [Tree 组件](https://ant.design/components/tree-cn/)、[deepdash](https://deepdash.io/) 之后，确实第一步是完全没有必要的。\n\n> 以下代码均由 TypeScript 实现，最好能了解 [TypeScript 类型操作](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)\n\n其实树结构数据可以抽象出非常简单的 interface（接口）\n\n```ts\ninterface Node {\r\n  id: string\r\n  children: Node[]\r\n}\n```\n\n无非是业务中多了一些字段，这两个字段的名字有所不同罢了。\n\n例如系统菜单与系统权限\n\n```ts\ninterface SysMenu {\r\n  id: number // 菜单 id\r\n  name: string // 显示的名称\r\n  sub: SysMenu[] // 子级菜单\r\n}\r\n\r\ninterface SysPermission {\r\n  uid: string // 系统唯一 uuid\r\n  label: string // 显示的菜单名\r\n  children: SysPermission[] // 子权限\r\n}\n```\n\n可以看到，它们都有 `id` 和 `children` 字段，只是名字不同。那么，根据封装不变的部分，将变化的部分交予外部输入的封装原则，这两个字段便由外部指定了。\n\n## 操作\n\n那么，树结构都有哪些操作呢？\n\n-   `reduce` 归并\n-   `each` 遍历\n-   `map` 映射\n-   `filter` 过滤\n-   `treeToList` 树转换为列表\n-   `listToTree` 列表转换为树\n\n然而，吾辈目前用到的仅有 `each/map/filter/treeToList`，所以先行实现下面几个。\n\n## 定义通用树结构需要的必须参数类型\n\n如果树结构必须包含 `id/children`，那么，便可以以此定义树结构操作的通用参数了。\n\n```ts\nexport interface TreeOption<T extends object> {\r\n  /**\r\n   * 唯一标识的字段\r\n   */\r\n  id: keyof T\r\n  /**\r\n   * 子节点的字段\r\n   */\r\n  children: keyof T\r\n}\n```\n\n上面是一个接口，必须声明 `id/children` 的字段名是什么，便于内部实现读取树节点信息。\n\n> 感谢 TypeScript，没有它就无法定义出类型，就不能检查出代码中的细微错误。例如，Java 就很难定义反射相关的类型，通常只能使用 `String`。\n\n## treeMap\n\n下面实现 treeMap，其实就是一个递归函数。\n\n```ts\nimport { TreeOption } from './treeOption'\r\n\r\n/**\r\n * 树结构映射\r\n * 使用深度优先算法\r\n * @param nodeList\r\n * @param fn\r\n * @param options\r\n */\r\nexport function treeMap<\r\n  T extends object,\r\n  C extends TreeOption<T>,\r\n  F extends (\r\n    t: Omit<T, C['children']> & Record<C['children'], ReturnType<F>[]>,\r\n    path: T[C['id']][],\r\n  ) => object\r\n>(nodeList: T[], fn: F, options: C): ReturnType<F>[] {\r\n  function inner(nodeList: T[], parentPath: T[C['id']][]): any {\r\n    return nodeList.map((node) => {\r\n      const path = [...parentPath, node[options.id]]\r\n      const children = (node[options.children] as any) as T[]\r\n      if (!children) {\r\n        return fn(node as any, path)\r\n      }\r\n      return fn(\r\n        {\r\n          ...node,\r\n          [options.children]: inner(children, path),\r\n        },\r\n        path,\r\n      )\r\n    })\r\n  }\r\n\r\n  return inner(nodeList, [])\r\n}\n```\n\n不过细心的人可能已经发现，这里做了两个奇怪的操作\n\n1.  先处理了所有子节点，然后将处理后子节点传入到 map 函数中，而非反过来。-- 这其实是为了兼容前端框架 react 的 JSX。\n1.  计算了节点的 `path`，并丢到 map 函数中。-- 这是为了能轻松知道当前节点的所有父节点以及层级，便于在有需要时（例如转换为列表）能拿到这个关键信息。\n\n## treeFilter\n\n嗯，下面的函数都将基于 treeMap 实现了（#笑）\n\n```ts\nimport { TreeOption } from './treeOption'\r\nimport { treeMap } from './treeMap'\r\n\r\n/**\r\n * 过滤一个树节点列表\r\n * @param nodeList\r\n * @param fn\r\n * @param options\r\n */\r\nexport function treeFilter<T extends object, C extends TreeOption<T>>(\r\n  nodeList: T[],\r\n  fn: (t: T, path: T[C['id']][]) => boolean,\r\n  options: C,\r\n): T[] {\r\n  return treeMap(\r\n    nodeList,\r\n    (node: any, path) => {\r\n      const children = (node[options.children] as any) as T[] | undefined\r\n      //如果是错误的节点直接炸掉\r\n      if (!fn(node as T, path)) {\r\n        return null\r\n      }\r\n      //如果是叶子节点就返回\r\n      if (!children) {\r\n        return node\r\n      }\r\n      //计算所有子节点中不是 null 的子节点\r\n      const sub = children.filter((node) => node !== null)\r\n      //如果所有子节点为 null 就炸掉\r\n      if (sub.length === 0) {\r\n        return null\r\n      }\r\n      return {\r\n        ...node,\r\n        children: sub,\r\n      }\r\n    },\r\n    options,\r\n  ).filter((node) => node !== null)\r\n}\n```\n\n上面过滤的流程图\n\n![treeFilter 流程图.drawio.svg](:/6a3af88df8204b888564bfce8d1d9e5c)\n\n## treeEach\n\n同样的，也是基于 treeMap，其实这个就有点乏善可陈了。\n\n```ts\nimport { TreeOption } from './treeOption'\r\nimport { treeMap } from './treeMap'\r\n\r\n/**\r\n * 树结构映射\r\n * 使用深度优先算法\r\n * @param nodeList\r\n * @param fn\r\n * @param options\r\n */\r\nexport function treeEach<T extends object, C extends TreeOption<T>>(\r\n  nodeList: T[],\r\n  fn: (t: T, path: T[C['id']][]) => void,\r\n  options: C,\r\n) {\r\n  treeMap(\r\n    nodeList,\r\n    (node, path) => {\r\n      fn(node as T, path)\r\n      return node\r\n    },\r\n    options,\r\n  )\r\n}\n```\n\n## treeToList\n\n同上。。。\n\n```ts\nimport { TreeOption } from './treeOption'\r\nimport { treeEach } from './treeEach'\r\n\r\n/**\r\n * 将一个树节点列表压平\r\n * @param nodeList\r\n * @param options\r\n */\r\nexport function treeToList<\r\n  T extends object,\r\n  C extends TreeOption<T> & { path: string },\r\n  R extends T & { [K in C['path']]: NonNullable<T[C['id']]>[] }\r\n>(nodeList: T[], options: C): R[] {\r\n  const res: R[] = []\r\n  treeEach(\r\n    nodeList,\r\n    (node, path) => {\r\n      res.push({ ...node, [options.path]: path } as R)\r\n    },\r\n    options,\r\n  )\r\n  return res\r\n}\n```\n\n## FAQ\n\n那么，下面是一些泥萌可能存在的一些问题，吾辈在此解答，如有其他问题，可直接在下面评论。\n\n-   问：为什么不使用 [deepdash](https://deepdash.io/)？\n-   答：因为它依赖于 lodash，而且提供的 API 也有点复杂。\n-   问：为什么使用深度优先算法？\n-   答：因为需要兼容 web 框架，例如 react，需要将所有的 JSX 子节点计算完成之后传递给父节点。\n-   问：为什么使用递归而非循环实现？\n-   答：这就是个人纯粹喜好了，循环可以获得更好的性能，但绝大多数情况下，性能并不重要，所以吾辈使用了更为直观的递归。\n-   问：为什么使用 TypeScript 实现？\n-   答：因为 TypeScript 的类型系统对于代码使用者更加友好，也能增强可维护性。-- 不过由于 TypeScript 的类型系统过于复杂，所以对于新手不太友好，参考 [TypeScript 类型编程](:/d101451820354652a932ffe820d9d1c5)\n\n> 最后，我创建了一个模块 [@liuli-util/tree](https://www.npmjs.com/package/@liuli-util/tree) 已经包含了以上功能。\n","createdTime":1580652937867,"updatedTime":1624274647995,"resources":[{"id":"6a3af88df8204b888564bfce8d1d9e5c","title":"treeFilter 流程图.drawio.svg","file_extension":"svg","user_updated_time":1616321918963}],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""},{"id":"eacdf5c68be7453faacc3b87571dab6b","title":"算法","parent_id":""}]},{"id":"1db27f8106cc48218641490889f37793","title":"Git 设置和取消代理","body":"## 设置代理\n\n```bash\ngit config --global http.proxy 'http://127.0.0.1:1080'\ngit config --global https.proxy 'http://127.0.0.1:1080'\n```\n\n> 注：此处设置的代理 ip 和端口号都是本地存在的（**SS/SSR** 默认就是）。\n\n## 取消代理\n\n```bash\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n```\n\n## Git 全局配置文件位置\n\n根配置文件 `/etc/gitconfig`\n\n> Windows 的话在 Git 安装目录下 `/mingw64/etc/gitconfig`，不过最好不要动这个\\\n> 当前用户 Git 配置 `~/.gitconfig`\n\n在配置文件里面添加以下内容也可以添加代理：\n\n```sh\n[https]\n        proxy = socks5://127.0.0.1:1080\n[http]\n        proxy = socks5://127.0.0.1:1080\n```\n\n## 遇到的坑\n\n设置了代理之后很容易碰到一个问题：[Git Push 提示不支持具有 Socks5 方案的代理](:/ea4c1bd6f73d4faeadf389d0bb269bd3)\n\n> 具体 Git 相关的内容建议参考 [Pro Git](https://git-scm.com/book/zh/v2)\n","createdTime":1580652937989,"updatedTime":1624274626909,"resources":[],"tags":[{"id":"0fe3bdc669564a3494e66bc1693d7f3f","title":"git","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"ff25d82d183d44b2b014514c56c986d1","title":"MongoDB 用户认证及操作","body":"> 如果还没有安装 MongoDB 可以参考：[Windows 下 MongoDB 便携版安装与初始化](:/bef08cec63cd48fca96fec5a049ab920)\n\n## 启动 `mongod` 和 `mongo shell` 服务\n\n```bash\n# 启动 mongodb 服务\nmongod --port 27017 --dbpath \"D:\\Program\\mongodb-win32-x86_64-2008plus-ssl-4.0.1\\mongodb_data\\data\" --logpath \"D:\\Program\\mongodb-win32-x86_64-2008plus-ssl-4.0.1\\mongodb_data\\log\\mongodb.log\"\n\n# 启动 mongo shell\nmongo --port 27017\n```\n\n> 注：mongodb 的默认 port 就是 27017，所以也可以省略不写\n\n## 创建管理员用户\n\n```bash\n# 切换到 admin 数据库\nuse admin;\n# 创建用户 root, 密码是 root 的 admin 账号了\ndb.createUser(\n  {\n    user: \"root\",\n    pwd: \"root\",\n    roles: [\n      {role: \"root\", db: \"admin\"}\n    ]\n  }\n)\n```\n\n## 验证用户登录\n\n1.  重启一下 `mongod` 服务\n\n```bash\n# 这里的 --auth 选项就代表着启用身份认证\nmongod --auth --port 27017 --dbpath \"D:\\Program\\mongodb-win32-x86_64-2008plus-ssl-4.0.1\\mongodb_data\\data\" --logpath \"D:\\Program\\mongodb-win32-x86_64-2008plus-ssl-4.0.1\\mongodb_data\\log\\mongodb.log\"\n```\n\n2.  测试 root 用户是否能正常登录\n\n-   使用用户名/密码认证连接 mongodb\n    ```bash\n    # 这里添加了 --authenticationDatabase 设置认证的数据库\n    mongo --port 27017 -u \"root\" -p \"root\" --authenticationDatabase \"admin\"\n    ```\n-   连接到 mongo 客户端后验证\n    ```bash\n    mongo --port 27017\n    use admin;\n    db.auth(\"root\", \"root\");\n    ```\n\n## 创建普通用户\n\n```bash\n# 切换到 test 数据库\nuse test;\n# 创建用户 test, 密码是 test 的普通账号了\n# 主要变化在于 role，修改为对数据库 [test] 拥有 [可读写] 权限\ndb.createUser(\n  {\n    user: \"test\",\n    pwd: \"test\",\n    roles: [\n      { role: \"readWrite\", db: \"yapi\" }\n    ]\n  }\n)\n```\n\n使用 test 这个普通用户在登陆后能看到的也只有自己的数据库呢（如果数据库存在的话）\n\n## 内建权限\n\n下面是一些常用的权限\n\n-   Read：允许用户读取指定数据库\n-   readWrite：允许用户读写指定数据库\n-   dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问 system.profile\n-   userAdmin：允许用户向 system.users 集合写入，可以找指定数据库里创建、删除和管理用户\n-   clusterAdmin：只在 admin 数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。\n-   readAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的读权限\n-   readWriteAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的读写权限\n-   userAdminAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的 userAdmin 权限\n-   dbAdminAnyDatabase：只在 admin 数据库中可用，赋予用户所有数据库的 dbAdmin 权限。\n-   root：只在 admin 数据库中可用。超级账号，超级权限\n\n## 使用 url 访问\n\n```sh\n# 不使用用户认证\nmongodb://ip:port/db\n# 使用用户认证\nmongodb://username:password@ip:port/db\n```\n\n## 查看用户\n\n-   查看全局的所有账号\n\n    ```bash\n    use admin;\n    db.system.users.find().pretty()\n    ```\n\n-   查看当前库下的用户\n\n    ```bash\n    use admin;\n    show users;\n    ```\n\n## 修改权限\n\n-   追加\n\n    ```bash\n    # 给用户 test 追加新的权限\n    db.grantRolesToUser(\n      \"test\",\n      [{role:\"readWrite\", db:\"test\"}]\n    )\n    ```\n\n-   替换\n\n    ```bash\n    # 替换用户 test 的权限\n    db.updateUser(\n      \"test\",\n      {\n        roles: [\n          {role:\"read\", db:\"test\"}\n        ]\n      }\n    )\n    ```\n\n## 删除用户\n\n删除掉名为 test 的用户\n\n```bash\ndb.dropUser('test')\n```\n","createdTime":1587219249413,"updatedTime":1624274083749,"resources":[],"tags":[{"id":"1656d5691cc143f8a555566791858bac","title":"sql","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"cdeb250dd4e04b168bc608cc9a118697","title":"优化 Google Chrome 的使用体验","body":"## 前言\r\n\r\n> 假若我没有看见光明，我本可以忍受黑暗。\r\n\r\n下面是吾辈在使用 Chrome 遇到的一些不舒服的地方，以及对应的解决方法。一切皆是为了一个目标：**提高浏览器的使用体验！**\r\n\r\n## 字体\r\n\r\n在之前吾辈也未曾对字体有过什么注意，直到后来听闻 MacOS 的字体显示比 Windows 上好很多，去看了一下确实如此。想要有一个好看的字体，字体本身极为重要，这里吾辈目前在使用，也很推荐的字体是 [Sarasa Gothic](https://github.com/be5invis/Sarasa-Gothic)。支持 **简中/繁中/英/日** 四种语言，虽然体积稍微庞大，但效果却是相当不错。\r\n\r\nWindows 字体预览\r\n\r\n![更纱黑体](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190527190659.png)\r\n\r\n> 这里也推荐作为编程字体，毕竟程序中同时存在中英文，而一个同时支持中英文的等宽字体实在难得。\r\n\r\n## 设置网页默认字体\r\n\r\n安装完了字体，然而 Chrome 默认并不会使用它，我们还需要 [Stylus](https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne) 进行指定。\r\n\r\n![添加 UserCSS](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190527221308.png)\r\n\r\n添加一个新的样式，内容只需要设置所有元素使用的字体为 **Sarasa Mono CL**\r\n\r\n```css\r\n/* 全局字体设置 */\r\n* {\r\n  font-family: \"Sarasa Mono CL\";\r\n}\r\n/* 强制指定 input 框中的字体 */\r\ninput {\r\n  font-family: \"Sarasa Mono CL\" !important;\r\n}\r\n```\r\n\r\n这时候查看一下字体效果\r\n\r\n![效果](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190527221458.png)\r\n\r\n## 夜间模式\r\n\r\n如果你像吾辈一样，喜欢暗色的主题，可以使用插件 [Dark Reader](https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh)，它能够让网页默认使用暗色模式，看起来和编辑器保持一致：并且，看起来很 **Geek**！\r\n\r\n![暗色模式](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531203702.png)\r\n\r\n看起来标题栏很违和？安装一个 [Dark 主题](https://chrome.google.com/webstore/detail/morpheon-dark/mafbdhjdkjnoafhfelkjpchpaepjknad) 试试看。\r\n现在，是不是变得很和谐了呢？\r\n\r\n![暗色标题栏](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531225833.png)\r\n\r\n## 广告过滤\r\n\r\n目前而言，浏览网站时，没有一个广告过滤插件的话，广告的数量将是难以置信的庞大，而且讨人厌！\r\n吾辈目前在 Chrome 上仅推荐 [uBlock Origin](https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm)，开源免费，不推荐 [Adblock Plus](https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb) 与 [Ublock](https://chrome.google.com/webstore/detail/ublock/epcnnfbjfcgphgdmggkamkmgojdagdnn)。前者将广告拦截做成了生意（参见 [向来以屏蔽互联网广告为己任的 AdBlock Plus，为什么卖起广告了？](https://36kr.com/p/5052897)），后者则是接手开发者的自私接受捐款导致原作者 Fork 并开发了新版本 Ublock Origin（参见 [Wiki uBlock Origin 历史](https://zh.wikipedia.org/zh-hans/UBlock_Origin)）。\r\n\r\n虽然吾辈基本上日常 Google，不过为了比较这里来看一下未进行广告过滤前的百度搜索结果\r\n\r\n搜索**购物**，天啊，第一页全都是**广告**，百度真的丧心病狂。。。\r\n\r\n> 注意每个搜索结果下面的小字 **广告**\r\n\r\n![百度的广告](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531210354.png)\r\n\r\n使用插件后的效果\r\n\r\n![过滤后的百度搜索](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531210454.png)\r\n\r\n嗯，清爽了许多呢 ~ o(\\*￣ ▽ ￣\\*)o\r\n\r\n这里对比一下 Google 的搜索结果，可以明显看出来百度的广告的数量之多。。。\r\n\r\n![对比的 Google 搜索结果](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531210759.png)\r\n\r\n## 自动翻页\r\n\r\n如果你也觉得搜索结果需要翻页好麻烦，那么 [uAutoPagerize](https://chrome.google.com/webstore/detail/uautopagerize/kdplapeciagkkjoignnkfpbfkebcfbpb) 可以一样可以帮到你！\r\n\r\n> 相比于 [AutoPagerize](https://chrome.google.com/webstore/detail/autopagerize/igiofjhpmpihnifddepnpngfjhkfenbp) 万年不更新，uAutoPagerize 仍在积极维护中！\r\n\r\n下面是使用了 uAutoPagerize 后的 Google 搜索结果，会在滚动到接近底部时，自动获取下一页的内容并拼接到最后！\r\n\r\n![使用 uAutoPagerize](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191114123652.png)\r\n\r\n当然，它也支持百度哦\r\n\r\n## 屏蔽 Google 搜索结果\r\n\r\n当你搜索中文技术相关的内容时，一定会遇到一个令人厌恶的社区 -- CSDN 博客。里面的内容基本上都是复制粘贴，甚至作者都并未真实尝试过就发出来了，实在是太烂了！\r\n所以，使用 [Tampermonkey](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo) 油猴插件 + 油猴脚本便可以轻松屏蔽掉它们。\r\n\r\n> 吾辈并不否认 CSDN 有很多有趣的作者，但是啊，相比于这个平台的大多数人，他们实在太少了，简直如同大海捞针一般。\r\n> [油猴脚本](https://zh.wikipedia.org/zh/Greasemonkey): 是一段可以在某个网页自动运行的 JavaScript 脚本，事实上，抛开 Tampermonkey 这个运行容器不说，油猴脚本就是彻头彻尾的 JavaScript 代码，任何了解过 Web 开发的人应该都能写一个简单的油猴脚本。如果你打算尝试玩玩油猴脚本，可以参考吾辈踩过的坑 [Greasemonkey 踩坑之路](:/e55a67646bf546b3900ce270a6fbc6ca)。\r\n\r\n你需要先安装 [Tampermonkey](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo) 插件，然后在 [Greasy Fork](https://greasyfork.org/zh-CN/) 安装脚本 [Google Hit Hider by Domain](https://greasyfork.org/zh-CN/scripts/1682)。\r\n\r\n然后在 Google 搜索 [js 数组去重](https://www.google.com/search?q=js+%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D)，可以看到包含了几个的 CSDN 博客的结果\r\n\r\n![CSND 博客搜索结果](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531213523.png)\r\n\r\n现在，让我们从 Google 搜索中屏蔽 blog.csdn.net 这个域名\r\n\r\n![Block 操作](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531214002.png)\r\n\r\n屏蔽后的搜索结果，CSDN Blog 那些垃圾博客不见了，心情大好！\r\n\r\n![屏蔽后的结果](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531214650.png)\r\n\r\n## 下载增强\r\n\r\n你使用 Chrome 下载过资料么？是否也对 Chrome 单线程下载并且在下载完成后强制检查资源安全性感到不满？那么 [FDM](https://www.freedownloadmanager.org/zh/) 应该是 Windows 上比较好的选择下载工具了，你可以下载并安装到 PC 上，然后安装 Chrome 插件 [Free Download Manager](https://chrome.google.com/webstore/detail/free-download-manager/ahmpjcflkgiildlgicmcieglgoilbfdp) 即可将所有 Chrome 中的下载请求交给 FDM，并且，它携带着 Cookie，所以即使是有权限校验的下载也能够胜任。\r\n\r\nFDM 的优势\r\n\r\n- 多线程下载\r\n- 断点续传\r\n- 支持 BT\r\n- 自动分类\r\n- 下载限速\r\n- 国际化\r\n- 自由免费\r\n\r\n所以，如果经常下载资料的话推荐入坑 FDM，这里放一张首页\r\n\r\n![FDM 首页](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531221709.png)\r\n\r\n## 快捷键\r\n\r\n使用浏览器，一些高频操作的快捷键也是必不可少的。\r\n\r\n- `CS-T`: 重新打开上一个关闭的标签页\r\n- `中键/C-左键`: 强制在新标签页打开链接\r\n- `中键(浏览器标签上)`: 关闭这个标签页\r\n- `A-左键`: 选择链接中的文字（不会触发拖动链接）\r\n- `S-滚轮`: 水平移动滚动条\r\n- `空格`: 翻到下一页\r\n- `F12`: 开启/关闭开发者工具\r\n- `C-R`: 重新加载当前页面\r\n- `CS-R`: 硬性重新加载\r\n- `CS-N`: 打开隐私标签页\r\n- `C-T`: 打开新的标签页\r\n- `C-W`: 关闭当前标签页\r\n\r\n## GitHub 优化\r\n\r\n众所周知，GitHub 作为最大的开源平台，平时访问的频率是相当高的，这里吾辈推荐一些插件/UserCSS 以增强使用体验。\r\n\r\n### 树结构浏览代码\r\n\r\nGitHub 浏览代码侧边栏没有一个文件栏实在难受，所以这里推荐 [Gitako](https://chrome.google.com/webstore/detail/gitako-github-file-tree/giljefjcheohhamkjphiebfjnlphnokk)   这个插件。它能够为 GitHub 添加一个侧边栏，极大的方便了在线代码浏览。\r\n\r\n> 相比于 [Octotree](https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc)，Gitako 的性能更好，而且是完全免费的。\r\n\r\n![Gitako 侧边文件夹](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191114123238.png)\r\n\r\n### 立体化 GitHub 用户活动\r\n\r\n当你查看一个 GitHub 用户的活动概览时，总是平面方块未免有些无聊，而且以颜色深浅区分也尚不明了。\r\n\r\n![GitHub 用户活动平面图](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531223619.png)\r\n\r\n所以，你可以使用 [Isometric Contributions](https://chrome.google.com/webstore/detail/isometric-contributions/mjoedlfflcchnleknnceiplgaeoegien) 插件，让活动变得更有趣一点，变成更直观的 3D 柱状图。\r\n\r\n![GitHub 用户活动 3D 图](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531223909.png)\r\n\r\n### 统计仓库大小\r\n\r\n或许你也有 clone 之前先知道仓库大小的习惯，这在网络稍差的环境中尤为重要，例如 TypeScript 的仓库大小超过 1G，如果没有准备的话直接下载很容易炸！\r\n\r\n> GitHub 下载仓库时并不会给出下载的百分比，所以什么时候下载完成是个玄学。。。\r\n\r\n![统计仓库大小](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190531224452.png)\r\n\r\n## 插件列表\r\n\r\n- [Stylus](https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne)：使用自定义网站样式的插件，比 Stylish 的名声好一些\r\n- [Dark Reader](https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh)：为所有网站加上黑色主题，大部分情况下都还不错\r\n- [uBlock Origin](https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm)：日常上网必须，屏蔽各种广告，比 Adblock 的名声好一些\r\n- [Vue.js devtools](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)：在 DevTool 中添加 Vuejs 选项卡，便于对 Vuejs 进行调试\r\n- [Checker Plus for Gmail™](https://chrome.google.com/webstore/detail/checker-plus-for-gmail/oeopbcgkkoapgobdbedcemjljbihmemj)：对于日常使用 Gmail 的吾辈而言非常有用\r\n- [crxMouse Chrome™ 手势](https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo)：鼠标手势插件，可以使用手势更简单地完成一些事情\r\n- [uAutoPagerize](https://chrome.google.com/webstore/detail/uautopagerize/kdplapeciagkkjoignnkfpbfkebcfbpb)：自动翻页插件，浏览很多网站时不需要手动点击下一页了，可以自动加载出来下一页的结果。\r\n- [Free Download Manager](https://chrome.google.com/webstore/detail/free-download-manager/ahmpjcflkgiildlgicmcieglgoilbfdp)：FDM Chrome 集成插件，将 Chrome 下载链接使用 FDM 多线程下载\r\n- [Enhancer for YouTube™](https://chrome.google.com/webstore/detail/enhancer-for-youtube/ponfpcnoihfmfllpaingbgckeeldkhle)：怎么说呢，Youtube 已经很好了，但吾辈还是觉得需要这个插件来优化播放体验\r\n- [Image Search Options](https://chrome.google.com/webstore/detail/image-search-options/kljmejbpilkadikecejccebmccagifhl)：使用右键以图搜图\r\n- [Isometric Contributions](https://chrome.google.com/webstore/detail/isometric-contributions/mjoedlfflcchnleknnceiplgaeoegien)：GitHub 美化插件，将 GitHub 贡献以 3D 的效果显示出来\r\n- [LastPass: Free Password Manager](https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd)：跨平台的免费密码管理器，有了这个之后再也不用所有网站都使用同一个密码了\r\n- [Gitako](https://chrome.google.com/webstore/detail/gitako-github-file-tree/giljefjcheohhamkjphiebfjnlphnokk)：GitHub 代码树状图插件，方便查看项目文件\r\n- [Tabliss](https://chrome.google.com/webstore/detail/tabliss-a-beautiful-new-t/hipekcciheckooncpjeljhnekcoolahp)：新标签页插件\r\n- [Tampermonkey](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo)：使用自定义网站脚本的插件，可以使用各种 `user.js` 脚本，相当于小型的插件管理器了\r\n\r\n## 总结\r\n\r\nChrome 有很多可以优化体验的地方，这里也只是吾辈所接触到的一部分罢了，欢迎在下面留言补充！\r\n","createdTime":1580652938036,"updatedTime":1624263689744,"resources":[],"tags":[{"id":"95ddbbd925aa4358a46bfcbce4c3fb46","title":"工具","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"b8a95af9134a488e9d94463bd18768c9","title":"编写兼容 nodejs/浏览器的库","body":"## 问题\r\n\r\n兼容问题是由于使用了平台特定的功能导致，会导致下面几种情况\r\n\r\n- 不同的模块化规范：rollup 打包时指定\r\n- 平台限定的代码：例如包含不同平台的适配代码\r\n- 平台限定的依赖：例如在 nodejs 需要填充 `fetch/FormData`\r\n- 平台限定的类型定义：例如浏览器中的 `Blob` 和 nodejs 中的 `Buffer`\r\n\r\n## 不同的模块化规范\r\n\r\n这是很常见的一件事，现在就已经有包括 cjs/amd/iife/umd/esm 多种规范了，所以支持它们（或者说，至少支持主流的 cjs/esm）也成为必须做的一件事。幸运的是，打包工具 rollup 提供了相应的配置支持不同格式的输出文件。\r\n\r\n> [GitHub 示例项目](https://github.com/rxliuli/cross-platform-lib-demo/tree/master/apps/multiple-module-format)\r\n\r\n形如\r\n\r\n```js\r\n// rollup.config.js\r\nexport default defineConfig({\r\n  input: 'src/index.ts',\r\n  output: [\r\n    { format: 'cjs', file: 'dist/index.js', sourcemap: true },\r\n    { format: 'esm', file: 'dist/index.esm.js', sourcemap: true },\r\n  ],\r\n  plugins: [typescript()],\r\n})\r\n```\r\n\r\n然后在 package.json 中指定即可\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/index.js\",\r\n  \"module\": \"dist/index.esm.js\",\r\n  \"types\": \"dist/index.d.ts\"\r\n}\r\n```\r\n\r\n> 许多库都支持 cjs/esm，例如 [rollup](https://github.com/rollup/rollup/blob/master/package.json)，但也有仅支持 esm 的库，例如 [unified.js 系列](https://github.com/unifiedjs)\r\n\r\n## 平台限定的代码\r\n\r\n- 通过不同的入口文件打包不同的出口文件，并通过 `browser` 指定环境相关的代码，例如 `dist/browser.js`/`dist/node.js`：使用时需要注意打包工具（将成本转嫁给使用者）\r\n- 使用代码判断运行环境动态加载\r\n\r\n| 对比 | 不同出口                     | 代码判断                             |\r\n| ---- | ---------------------------- | ------------------------------------ |\r\n| 优点 | 代码隔离的更彻底             | 不依赖于打包工具行为                 |\r\n|      | 最终代码仅包含当前环境的代码 |                                      |\r\n| 缺点 | 依赖于使用者的打包工具的行为 | 判断环境的代码可能并不准确           |\r\n|      |                              | 最终代码包含所有代码，只是选择性加载 |\r\n\r\n> axios 结合以上两种方式实现了浏览器、nodejs 支持，但同时导致有着两种方式的缺点而且有点迷惑行为，参考 [getDefaultAdapter](https://github.com/axios/axios/blob/e9965bfafc82d8b42765705061b9ebe2d5532493/dist/axios.js#L872-L882)。例如在 jsdom 环境会认为是浏览器环境，参考 [detect jest and use http adapter instead of XMLHTTPRequest](https://github.com/axios/axios/issues/1180)\r\n\r\n### 通过不同的入口文件打包不同的出口文件\r\n\r\n> [GitHub 示例项目](https://github.com/rxliuli/cross-platform-lib-demo/tree/master/apps/platform-specific-code-multiple-bundle)\r\n\r\n```js\r\n// rollup.config.js\r\nexport default defineConfig({\r\n  input: ['src/index.ts', 'src/browser.ts'],\r\n  output: [\r\n    { dir: 'dist/cjs', format: 'cjs', sourcemap: true },\r\n    { dir: 'dist/esm', format: 'esm', sourcemap: true },\r\n  ],\r\n  plugins: [typescript()],\r\n})\r\n```\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/cjs/index.js\",\r\n  \"module\": \"dist/esm/index.js\",\r\n  \"types\": \"dist/index.d.ts\",\r\n  \"browser\": {\r\n    \"dist/cjs/index.js\": \"dist/cjs/browser.js\",\r\n    \"dist/esm/index.js\": \"dist/esm/browser.js\"\r\n  }\r\n}\r\n```\r\n\r\n### 使用代码判断运行环境动态加载\r\n\r\n> [GitHub 示例项目](https://github.com/rxliuli/cross-platform-lib-demo/tree/master/apps/platform-specific-code-dynamic-judgment)\r\n\r\n基本上就是在代码中判断然后 `await import` 而已\r\n\r\n```ts\r\nimport { BaseAdapter } from './adapters/BaseAdapter'\r\nimport { Class } from 'type-fest'\r\n\r\nexport class Adapter implements BaseAdapter {\r\n  private adapter?: BaseAdapter\r\n  private async init() {\r\n    if (this.adapter) {\r\n      return\r\n    }\r\n    let Adapter: Class<BaseAdapter>\r\n    if (typeof fetch === 'undefined') {\r\n      Adapter = (await import('./adapters/NodeAdapter')).NodeAdapter\r\n    } else {\r\n      Adapter = (await import('./adapters/BrowserAdapter')).BrowserAdapter\r\n    }\r\n    this.adapter = new Adapter()\r\n  }\r\n  async get<T>(url: string): Promise<T> {\r\n    await this.init()\r\n    return this.adapter!.get(url)\r\n  }\r\n}\r\n```\r\n\r\n```js\r\n// rollup.config.js\r\nexport default defineConfig({\r\n  input: 'src/index.ts',\r\n  output: { dir: 'dist', format: 'cjs', sourcemap: true },\r\n  plugins: [typescript()],\r\n})\r\n```\r\n\r\n> 注: vitejs 无法捆绑处理这种包，因为 nodejs 原生包在浏览器环境确实不存在，这是一个已知错误，参考：[Cannot use amplify-js in browser environment (breaking vite/snowpack/esbuild)](https://github.com/aws-amplify/amplify-js/issues/7499)。\r\n\r\n## 平台限定的依赖\r\n\r\n- 直接 `import` 依赖使用：会导致在不同的环境炸掉（例如 `node-fetch` 在浏览器就会炸掉）\r\n- 在代码中判断运行时通过 `require` 动态 引入依赖：会导致即便用不到，也仍然会被打包加载\r\n- 在代码中判断运行时通过 `import()` 动态引入依赖：会导致代码分割，依赖作为单独的文件选择性加载\r\n- 通过不同的入口文件打包不同的出口文件，例如 `dist/browser.js`/`dist/node.js`：使用时需要注意（将成本转嫁给使用者）\r\n- 声明 `peerDependencies` 可选依赖，让使用者自行填充：使用时需要注意（将成本转嫁给使用者）\r\n\r\n| 对比               | require | import |\r\n| ------------------ | ------- | ------ |\r\n| 是否一定会加载     | 是      | 否     |\r\n| 是否需要开发者注意 | 否      | 否     |\r\n| 是否会多次加载     | 否      | 是     |\r\n| 是否同步           | 是      | 否     |\r\n| rollup 支持        | 是      | 是     |\r\n\r\n## 在代码中判断运行时通过 `require` 动态引入依赖\r\n\r\n> [GitHub 项目示例](https://github.com/rxliuli/cross-platform-lib-demo/tree/master/apps/platform-specific-lib-require)\r\n\r\n```ts\r\n// src/adapters/BaseAdapter.ts\r\nimport { BaseAdapter } from './BaseAdapter'\r\n\r\nexport class BrowserAdapter implements BaseAdapter {\r\n  private static init() {\r\n    if (typeof fetch === 'undefined') {\r\n      const globalVar: any =\r\n        (typeof globalThis !== 'undefined' && globalThis) ||\r\n        (typeof self !== 'undefined' && self) ||\r\n        (typeof global !== 'undefined' && global) ||\r\n        {}\r\n      // 关键在于这里的动态 require\r\n      Reflect.set(globalVar, 'fetch', require('node-fetch').default)\r\n    }\r\n  }\r\n\r\n  async get<T>(url: string): Promise<T> {\r\n    BrowserAdapter.init()\r\n    return (await fetch(url)).json()\r\n  }\r\n}\r\n```\r\n\r\n![1624018106300](:/1a7d05ea9c1e4978bcc540c2eb8cca6f)\r\n\r\n## 在代码中判断运行时通过 `import()` 动态引入依赖\r\n\r\n> [GitHub 项目示例](https://github.com/rxliuli/cross-platform-lib-demo/tree/master/apps/platform-specific-lib-import)\r\n\r\n```ts\r\n// src/adapters/BaseAdapter.ts\r\nimport { BaseAdapter } from './BaseAdapter'\r\n\r\nexport class BrowserAdapter implements BaseAdapter {\r\n  // 注意，这里变成异步的函数了\r\n  private static async init() {\r\n    if (typeof fetch === 'undefined') {\r\n      const globalVar: any =\r\n        (typeof globalThis !== 'undefined' && globalThis) ||\r\n        (typeof self !== 'undefined' && self) ||\r\n        (typeof global !== 'undefined' && global) ||\r\n        {}\r\n      Reflect.set(globalVar, 'fetch', (await import('node-fetch')).default)\r\n    }\r\n  }\r\n\r\n  async get<T>(url: string): Promise<T> {\r\n    await BrowserAdapter.init()\r\n    return (await fetch(url)).json()\r\n  }\r\n}\r\n```\r\n\r\n打包结果\r\n\r\n![1624018026889](:/a5134edf1c7b4742aed1a0914faa45ad)\r\n\r\n### 遇到的一些子问题\r\n\r\n- 怎么判断是否存在全局变量\r\n\r\n  ```ts\r\n  typeof fetch === 'undefined'\r\n  ```\r\n\r\n- 怎么为不同环境的全局变量写入 ployfill\r\n\r\n  ```ts\r\n  const globalVar: any =\r\n    (typeof globalThis !== 'undefined' && globalThis) ||\r\n    (typeof self !== 'undefined' && self) ||\r\n    (typeof global !== 'undefined' && global) ||\r\n    {}\r\n  ```\r\n\r\n- `TypeError: Right-hand side of 'instanceof' is not callable`: 主要是 axios 会判断 `FormData`，而 `form-data` 则存在默认导出，所以需要使用 `(await import('form-data')).default`（吾辈总有种在给自己挖坑的感觉）\r\n  ![1622828175546](:/2085a6a480124ea8b0fdddf4877f75c7)\r\n\r\n使用者在使用 rollup 打包时可能会遇到兼容性的问题，实际上就是需要选择内联到代码还是单独打包成一个文件，参考：<https://rollupjs.org/guide/en/#inlinedynamicimports>\r\n\r\n内联 => 外联\r\n\r\n```js\r\n// 内联\r\nexport default {\r\n  output: {\r\n    file: 'dist/extension.js',\r\n    format: 'cjs',\r\n    sourcemap: true,\r\n  },\r\n}\r\n```\r\n\r\n```js\r\n// 外联\r\nexport default {\r\n  output: {\r\n    dir: 'dist',\r\n    format: 'cjs',\r\n    sourcemap: true,\r\n  },\r\n}\r\n```\r\n\r\n## 平台限定的类型定义\r\n\r\n以下解决方案本质上都是多个 bundle\r\n\r\n- 混合类型定义。例如 axios\r\n- 打包不同的出口文件和类型定义，要求使用者自行指定需要的文件。例如通过 `module/node`/`module/browser` 加载不同的功能（其实和插件系统非常接近，无非是否分离多个模块罢了）\r\n- 使用插件系统将不同环境的适配代码分离为多个子模块。例如 remark.js 社区\r\n\r\n| 对比 | 多个类型定义文件   | 混合类型定义 | 多模块                                           |\r\n| ---- | ------------------ | ------------ | ------------------------------------------------ |\r\n| 优点 | 环境指定更明确     | 统一入口     | 环境指定更明确                                   |\r\n| 缺点 | 需要使用者自行选择 | 类型定义冗余 | 需要使用者自行选择                               |\r\n|      | dependencies 冗余  |              | 维护起来相对麻烦（尤其是维护者不是一个人的时候） |\r\n\r\n### 打包不同的出口文件和类型定义，要求使用者自行指定需要的文件\r\n\r\n> [GitHub 项目示例](https://github.com/rxliuli/cross-platform-lib-demo/tree/master/apps/platform-specific-type-definition-multiple-bundle)\r\n\r\n主要是在核心代码做一层抽象，然后将平台特定的代码抽离出去单独打包。\r\n\r\n```ts\r\n// src/index.ts\r\nimport { BaseAdapter } from './adapters/BaseAdapter'\r\n\r\nexport class Adapter<T> implements BaseAdapter<T> {\r\n  upload: BaseAdapter<T>['upload']\r\n\r\n  constructor(private base: BaseAdapter<T>) {\r\n    this.upload = this.base.upload\r\n  }\r\n}\r\n```\r\n\r\n```js\r\n// rollup.config.js\r\n\r\nexport default defineConfig([\r\n  {\r\n    input: 'src/index.ts',\r\n    output: [\r\n      { dir: 'dist/cjs', format: 'cjs', sourcemap: true },\r\n      { dir: 'dist/esm', format: 'esm', sourcemap: true },\r\n    ],\r\n    plugins: [typescript()],\r\n  },\r\n  {\r\n    input: ['src/adapters/BrowserAdapter.ts', 'src/adapters/NodeAdapter.ts'],\r\n    output: [\r\n      { dir: 'dist/cjs/adapters', format: 'cjs', sourcemap: true },\r\n      { dir: 'dist/esm/adapters', format: 'esm', sourcemap: true },\r\n    ],\r\n    plugins: [typescript()],\r\n  },\r\n])\r\n```\r\n\r\n使用者示例\r\n\r\n```ts\r\nimport { Adapter } from 'platform-specific-type-definition-multiple-bundle'\r\n\r\nimport { BrowserAdapter } from 'platform-specific-type-definition-multiple-bundle/dist/esm/adapters/BrowserAdapter'\r\nexport async function browser() {\r\n  const adapter = new Adapter(new BrowserAdapter())\r\n  console.log('browser: ', await adapter.upload(new Blob()))\r\n}\r\n\r\n// import { NodeAdapter } from 'platform-specific-type-definition-multiple-bundle/dist/esm/adapters/NodeAdapter'\r\n// export async function node() {\r\n//   const adapter = new Adapter(new NodeAdapter())\r\n//   console.log('node: ', await adapter.upload(new Buffer(10)))\r\n// }\r\n```\r\n\r\n### 使用插件系统将不同环境的适配代码分离为多个子模块\r\n\r\n简单来说，如果你希望将运行时依赖分散到不同的子模块中（例如上面那个 `node-fetch`），或者你的插件 API 非常强大，那么便可以将一些**官方**适配代码分离为插件子模块。\r\n\r\n## 选择\r\n\r\n![兼容 nodejs 与浏览器的库的技术方案选择.drawio.svg](:/1fb8606dac2c487eafca45ecc4e3a9a3)\r\n","createdTime":1622822645510,"updatedTime":1624077582555,"resources":[{"id":"1a7d05ea9c1e4978bcc540c2eb8cca6f","title":"1624018106300","file_extension":"png","user_updated_time":1624018106637},{"id":"1fb8606dac2c487eafca45ecc4e3a9a3","title":"兼容 nodejs 与浏览器的库的技术方案选择.drawio.svg","file_extension":"svg","user_updated_time":1624077829787},{"id":"2085a6a480124ea8b0fdddf4877f75c7","title":"1622828175546","file_extension":"png","user_updated_time":1622828176962},{"id":"a5134edf1c7b4742aed1a0914faa45ad","title":"1624018026889","file_extension":"png","user_updated_time":1624018027494}],"tags":[{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"0ea89fe3feb84dd4b36a2378729423ac","title":"Android 常用 App 清单","body":"## 简介\r\n\r\n该清单只是吾辈所用，使用工具因人而异，若是你对清单中的内容有何异议，可以在下方进行留言，吾辈会尽快阅读并回复！\r\n\r\n> 附：列出的 Google Drive 链接是因为某些第三方 App 不在 Play Store 之中，而且在可预期的很长时间内都不可能在（Youtube 第三方客户端）\r\n\r\n## Google 全家桶\r\n\r\n这里首先说明使用 Google 全家桶的原因：虽然 Google 最近声名狼藉，然而相比于 _国内肆无忌惮的获取数据，甚至百度明目张胆地说出“中国人就是喜欢拿隐私换方便”_，Google 还是显得像一朵 **白百合**。而且 Google 也确实不会明目张胆的找人要隐私，它只会偷偷摸摸的去做（#笑哭）。而多个的 App 都使用同一家公司的优势是巨大的：**一切数据皆在云端，后台服务体贴之至**。更何况 Google 的服务大多数都是全端跨平台的，对于同时使用 PC/Mobile 的使用者而言优势巨大。\r\n\r\n- Play Store：Google 家的应用商店，主要可以强制替代国内系统自带的应用商店（**垃圾商店，遍地广告**），而且国内应用相对于国内版本要干净一些（例如 QQ/WeChat）。\r\n- GMail：跨平台的电子邮件。如果需要经常使用电子邮件（订阅内容/公司同事交流/GreasyFork 反馈/GitHub Issue/各种网络服务），那么 Gmail 是当之无愧的首选。在 Web 版本上在所有电子邮件中都是首屈一指的，在 Android 上的表现也是相当不错，毕竟是在自家的系统上。\r\n- Google 通讯录：跨平台的联系人功能。不仅仅是电话号码，甚至于 **Email/IM/网站** 都能作为一个 **联系人**。更有趣的是在 Android 上通过联系人打电话，在 Web 上却可以通过邮件（Gmail）进行联系了呢！\r\n- Google 翻译：跨平台的多语言翻译。目前应该是最好的翻译了，Google Chrome 自带的翻译可是为 Google 积累了巨大的原始数据，对于翻译质量的提升也是理所当然的。\r\n- Google 相册：支持云同步的相册，虽然不够简洁，但同步并且有网页版的优势足以掩盖这个问题。\r\n- Google Chrome：Google 家的浏览器，使用它很大的一部分原因是翻译功能真的太香了。。。\r\n\r\n## 上网\r\n\r\n### SSR：上网必须\r\n\r\n> [官方](https://github.com/HMBSbige/ShadowsocksR-Windows)\r\n\r\n为了正常浏览网络折腾与支付一些代价都是微不足道的。\r\n\r\n> 附：最近网络盛传 V2Ray 更好，然而对于吾辈（使用者）而言，却是并未看到特别明显的优势，所以暂未切换过去。。。\r\n\r\n### Kiwi：Android 上扩展性最好的类 Chrome 浏览器\r\n\r\n> 参考：[Android 上最好的浏览器 Kiwi browser](:/253e3c2202a24fefbf6f6249ea472626)\r\n\r\n在 PC 上，Google Chrome 是当之无愧的 `Number One`。然而，在 Android 上，Chrome for Android 并不支持插件。虽然 Google 宣称定位是 **简洁高效的浏览体验**，然而是不是为了推广使用 App 却并未可知，所以在 Android 上能使用附加组件（插件）的类 Chrome 浏览器 Kiwi 就是扩展性最好的浏览器（类似的还有 Firefox，但速度真的太慢了）。\r\n\r\n常用 Plugin 列表\r\n\r\n- [uBlock Origin](https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm)：广告过滤插件\r\n- [Dark Reader](https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh)：全局黑色主题\r\n- [Tampermonkey](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo)：UserJS 脚本\r\n- [LastPass](https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd)：密码管理器\r\n\r\n常用 UserJS 列表\r\n\r\n- [Mobile 上知乎自动展开答案](https://greasyfork.org/zh-CN/scripts/375653)：在 Mobile 上自动展开知乎问题的答案\r\n- [Text To link](https://greasyfork.org/zh-CN/scripts/342)：网页上的文字转换为链接\r\n- [网盘自动填写密码](https://greasyfork.org/zh-CN/scripts/29762)：百度网盘自动填入提取码\r\n- [网页限制解除](https://greasyfork.org/zh-CN/scripts/391193)：解除网页的复制粘贴限制\r\n\r\n## 系统\r\n\r\n### Nova 启动器：Nova 桌面\r\n\r\n> [Pro 破解版](https://drive.google.com/open?id=1EMcoMet27dN-ptsAG7yypTUqOO_Ip2pC)\r\n\r\n还不错的第三方桌面，在很早之前就已经出现了。有一些自定义手势相当方便，长按 Home 搜索应用，双击屏幕锁屏。并支持第三方图标库，例如下面的 Pixel Icon Pack。\r\n\r\n### Pixel Icon Pack：全而大 App 图标库\r\n\r\n虽然吾辈最喜欢的是 material 风格，然而 material 主题的图标数量实在不够。而 Pixel 这款图标库的数量足够庞大，包含了 6910+ 个图标，覆盖了绝大多数的 App，统一了桌面 App 的图标。\r\n\r\n### Shizuku\r\n\r\n为其他应用程序提供更高层的系统 API，有点类似于 root，但其实是 adb 权限级别，只需要在该应用操作一次，其他支持的应用就能使用系统 API 了，不需要每个应用单独设置一次。\r\n\r\n> 以下两个 App 均需要 Shizuku\r\n\r\n### 小黑屋\r\n\r\n专制流氓后台应用，可以通过 [Android 的工作模式](https://support.google.com/work/android/answer/7029561?hl=zh-Hant) 禁用掉乱七八糟的后台，支持在锁屏后自动杀死小黑屋的应用，很方便。\r\n\r\n### App Ops\r\n\r\n如果某些应用程序仍然得不到某些权限就不给运行的话，可以尝试使用 App Ops 给予空的权限 -- **“授予”应用权限，但是应用会得到空数据或操作不会被执行**。\r\n\r\n## 社交\r\n\r\n### Telegram：安全私密的 IM\r\n\r\n相比于 Twitter 是个社区，Telegram 则专注于用户之间的交流。开源（客户端）免费可端对端加密通讯，使得它受到许多推油的喜爱。Telegram 最新版的官方客户端已经做得足够好了，`Plus/TelegramX` 什么的基本上也不需要了呢\r\n\r\n### QQ：国内广泛使用的 IM\r\n\r\n> [第三方](https://drive.google.com/open?id=1bSd3jtUgqo_o7Nl_E5xl__0QnmdKg4FA)\r\n\r\n国内广泛使用的 IM，曾经的同学什么的都在这里了（虽然吾辈曾经为了转型 Twitter 而清空过 QQ 就是了 #中二病）。这里吾辈使用了第三方修改版，主要是为了去除 QQ 的广告以及功能增强。\r\n\r\n- 去除无用的侧边栏\r\n- 界面上稍微皮了一下\r\n- 破解撤回\r\n- 破解闪照\r\n- 破解口令红包\r\n\r\n### WeChat：国内不得不用联系工具\r\n\r\n国内不得不用的 IM，名为微信，实为**巨信**。不仅安装包极其巨大，而且连基本的数据同步，都没有做好－－以安全之名。然而 WeChat 究竟有没有保留原始数据，又有没有把数据交给政府审查，相信大家心里自然明白。\r\n\r\n> 已加入小黑屋，彻底不允许后台运行。\r\n\r\n### FastHub：GitHub 第三方客户端\r\n\r\n> [GitHub](https://github.com/k0shk0sh/FastHub)\r\n\r\n2020-07-14 更新\r\n\r\nFastHub 才是最好的，虽然已经有官方客户端了，但功能上还比不上 FastHub。\r\n\r\n---\r\n\r\n虽然 GitHub 是全世界最大的同性社交网站（代码托管平台），然而并没有官方的 Mobile 客户端。OpenHub 正是 GitHub 的一个第三方客户端，可以方便的在 Mobile 上使用 GitHub。\r\n\r\n## 本地\r\n\r\n### MXPlayer：本地视频播放器\r\n\r\nMxPlayer 应该算是 Android 上最强的本地播放器了吧？拥有相当多的解码器，对绝大多数的视频都能正常播放，对字幕的支持也相当不错，同时也能当作本地音乐播放器使用。\r\n\r\n### 静读天下：本地书籍阅读器\r\n\r\n非常好用的电子书阅读器，对多种格式的文档都支持的非常好。  \r\n包括但不限于以下格式\r\n\r\n- `Txt`：传统纯文本小说格式\r\n- `HTML`：巨大网页小说，一般为二次导出\r\n- `Epub`：新的电子书籍标准\r\n- `Mobi`：亚马逊 Kindle 阅读器支持的专有格式\r\n- `PDF`：Adobe 发行的一种电子书籍格式\r\n- `umd`：常见的请小说格式\r\n- `chm`：常见的电子文档格式\r\n\r\n交互友好，界面优雅，全能的本地阅读器。\r\n\r\n### CX 文件管理器：简单的文件管理器\r\n\r\n讨厌 [ES 文件浏览器](http://www.estrongs.com/) 的广告和自动更新，而且实际上也用不到那么多的功能，吾辈只想简单的浏览、分类文件，同时在手机上访问局域网内的电脑文件罢了。\r\n\r\n## 其他\r\n\r\n### 淘宝 Lite：淘宝海外版\r\n\r\n你是否也曾厌恶淘宝的臃肿，是否讨厌淘宝的强制升级？现在，我们有了新的选择：淘宝 Lite，名副其实的精简版。主要面向国外用户，我们在地区中选择 **全球** 即可正常使用淘宝进行购物啦  \r\n主要优点\r\n\r\n- 没有各种广告\r\n- 没有各种看似强大然并卵的功能\r\n- 不强制升级\r\n- 没有强制索取权限\r\n- 包含完整的购物体验\r\n\r\n### 支付宝：国内通用移动支付\r\n\r\n国内广泛使用的移动支付工具，在一线城市（广州）基本上带个 Mobile 就能到处走了。相比于 WeChat，支付宝给吾辈的感觉更好。。。WeChat 总让吾辈觉得是只想在国内发展的一个毒瘤 App，而支付宝是有志于开拓世界的（无论影响好坏）。\r\n\r\n### PxView：Pixiv 第三方客户端\r\n\r\nPixiv 第三方客户端。相比于官方客户端有很多收费功能。  \r\n主要特点如下\r\n\r\n- 无广告\r\n- 开源\r\n- 支持黑暗模式\r\n- 允许查看排行\r\n- 保存图片\r\n\r\n### Weawow：天气 App\r\n\r\n一个天气应用，使用它纯粹是不喜欢系统自带的天气应用。简单纯粹，不强制弹窗提醒升级，桌面的小部件也很简洁，最重要的是天气预报还算准确！\r\n\r\n### InoReader：RSS 阅读器\r\n\r\n一个跨平台的 RSS 阅读器，相比于大名鼎鼎的 [Feedly](https://feedly.com/) 有着更多的免费功能，而且对于用户的支持非常棒！\r\n\r\n> 附：吾辈之前就有遇到过 RSS 只有一部分内容，需要在浏览器打开才能看到全文的情况，InoReader 快速回答了呢！\r\n\r\n### YMusic：Youtube 的第三方音乐客户端\r\n\r\nYoutube 虽然好用，但 Android 版的广告实在实在实在太多了！因为很重要，所以说三遍。吾辈日常使用 Youtube 听音乐，然而 Youtube 不能后台播放，不能下载到本地的特性导致单纯的听音乐真的很麻烦。  \r\n而 YMusic 不仅能下载 Youtube 上的内容，而且还能登录 Google 账号同步 Youtube 的内容。这，便是使用 YMusic 的理由！\r\n\r\n### LastPass：全端密码管理器\r\n\r\n跨平台的密码管理器。基本上吾辈在 Google Chrome 上使用 Plugin，在 Mobile 上也使用它。虽然 Google Chrome 自带了密码管理/同步功能，然而对于某些两步验证的网站并未能很好的支持，而且也不支持跨浏览器！而 LastPass 基本上免费版本对于个人使用算是绰绰有余了，支持密码同步，跨平台/跨浏览器支持，复杂密码一键生成。\r\n\r\n> 注：吾辈在 PC 上使用 Google Chrome，Mobile 上却使用 Mozilla Firefox。\r\n\r\n### Sleep Cycle：睡眠分析和智能闹钟\r\n\r\n一个睡眠分析 App，能帮助我了解睡眠状况，以此来找寻解决方案。\r\n\r\n## 总结\r\n\r\n那么，关于吾辈在 mobile 上使用的 App 清单便到此结束了。如果你有什么有趣的 App，也可以推荐给吾辈哦\r\n","createdTime":1580652937985,"updatedTime":1623584671400,"resources":[],"tags":[{"id":"99c5001ffe5b42a6995369049b5f5aa9","title":"待更新","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"1cc0a366faf84858b7de600f56da7cb5","title":"为什么有那么多笔记工具","body":"真是疯了，吾辈发现网络上有太多的笔记工具了。\r\n\r\n## 起因\r\n\r\n吾辈在大约半年前选择开始使用笔记工具，记录自己的日常知识碎片，并最终选择了 [Joplin](https://joplinapp.org/)，也花费了许多时间为其编写 [VSCode 插件](https://github.com/rxliuli/joplin-vscode-plugin)。就在今天，吾辈在编写插件的一个功能时，需要查看类似插件是如何实现的时候，发现了许多类似的插件存在，甚至包括吾辈想在 VSCode 中管理和编辑笔记的想法也已然有人实现。\r\n\r\n让我们看一下玩家有哪些\r\n\r\n老牌产品\r\n\r\n- Evernote\r\n- OneNote\r\n- Apple Notes\r\n\r\n基于 Web/Electron/较新型工具\r\n\r\n- Notion\r\n- Joplin\r\n- Roam\r\n- Bear\r\n- Obsidian\r\n- RemNote\r\n- Zettelkasten\r\n- Typora\r\n- marktext\r\n- Standard Notes\r\n- Google Keep\r\n\r\n基于 VSCode\r\n\r\n- Foam\r\n- dendron\r\n\r\n国产\r\n\r\n- 有道云笔记\r\n- 语雀\r\n- 思源笔记\r\n\r\n还有更多。。。\r\n\r\n吾辈列一下其中几个吾辈已经用过的，横向对比\r\n\r\n| 产品        | Web | PC 跨平台 | 移动端 | 数据库/文件 | 搜索速度 | VSCode 集成 | Markdown 支持 | 支持全量导出 | UI   |\r\n| ----------- | --- | --------- | ------ | ----------- | -------- | ----------- | ------------- | ------------ | ---- |\r\n| Evernote    | -   | -         | -      | 数据库      | 快       | 否          | 不完全        | 否           | 一般 |\r\n| OneNote     | 是  | 是        | 是     | 数据库      | 快       | 否          | 否            | 否           | 清新 |\r\n| Notion      | 是  | 是        | 是     | 数据库      | 慢       | 否          | 否            | 否           | 漂亮 |\r\n| Joplin      | 是  | 是        | 是     | 数据库      | 快       | 是          | 是            | 是           | 一般 |\r\n| Typora      | 否  | 是        | 否     | 文件        | 快       | 否          | 是            | 是           | 简洁 |\r\n| marktext    | 否  | 是        | 否     | 文件        | 快       | 否          | 是            | 是           | 漂亮 |\r\n| Google Keep | 是  | 否        | 是     | 数据库      | 慢       | 否          | 否            | 是           | 简洁 |\r\n\r\n这真的有那么重要么？为什么有这么多的工具，或者说，为什么有这么多的人、这么多的公司愿意花费那么多的时间去编写各种各样的工具，难道最终不是只会出现一个或几个优胜者么？\r\n这太糟糕了，吾辈感觉自己在为一件注定失败的事情浪费时间，相比之下更应该等到出现胜者之后再进行选择。\r\n\r\n有人说\r\n\r\n- 因为需求不一致\r\n- 说明这个市场很大\r\n- 说明知识焦虑在扩散 终生学习的需求越来越大，不迭代就会被淘汰\r\n- 因为笔记软件好多年都没什么大发展了吧，最近一段时间开始风起云涌\r\n- 都好多年了吧……如果从 org 开始算，就更久了\r\n\r\n> 在做一件事上，应该只有一个工具是最好的。\r\n\r\n吾辈对于笔记的主要关注点\r\n\r\n- [x] 基于 Markdown: 不基于任何特定格式的富文本是最容易长期保存的\r\n- [x] 支持全量导出: 任何公司都有可能倒闭，所以全量导出可以容易的迁出\r\n- [x] 编辑器足够好用，最好支持 VSCode 直接编辑: 作为一个程序员实在难以离开强大的编辑器\r\n- [x] 搜索速度要快: 笔记如果无法快速找到，就失去了知识管理的意义\r\n- [ ] 移动端基本查看支持: 有时候可能要在移动端分享一下\r\n- [ ] WebClipper 浏览器插件支持\r\n- [ ] 图片等二进制资源支持\r\n- [ ] 多平台同步支持\r\n- [ ] 基本的 wiki 功能（笔记之间互相引用）\r\n\r\n## 参考\r\n\r\n- [The 11 Best Note-Taking Apps in 2020 – Evernote, Notion, and More](https://collegeinfogeek.com/best-note-taking-apps/)\r\n","createdTime":1605445583721,"updatedTime":1623583381328,"resources":[],"tags":[{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""},{"id":"f5172282f275485bab67f712ba1b1bcf","title":"个人","parent_id":""}]},{"id":"4a6736bffd064ed9b46d2021870039ec","title":"如何看待新事物","body":"## 前言\n\n- 以使用者的角度看待问题\n- 包含技术和一些工具\n\n## 新的事物一定会更好么？\n\n> 历史是螺旋上升的，新事物总是解决一些问题，然后带来新的问题。\n\n- 工具软件：[小众软件](https://meta.appinn.net/)，[异次元软件世界](https://www.iplaysoft.com/)，[善用佳软](https://xbeta.info/)\n- 大而全还是小而美: 应该选择 IDE 还是库提供的功能？: eslint/prettier/git hooks\n\n技术\n\n- babel: 在 v5 可以一次引入全部，在 v6 划分为许多零碎的小模块，由于对开发者使用及其不友好，v7 又支持了类似 v5 的使用方式\n- husky: v4 支持在 package.json 中定义 git hooks，v5 突发奇想使用原生 git hooks 语法，v6 又撤销回去了\n- mobx: 在 v5 使用装饰器，v6 再次回到了高阶函数\n- tailwind css: 几年前就有 atomic css 的概念了，不过那时候被喷，但最近似乎又流行了\n- vscode: 开源的 eclipse 被 JetBrains IDE 干掉之后，后面 vscode 又流行了起来\n- 客户端: 原生程序(windows/qt) => web(react/vue) => web 技术跨平台(electron/react-native) => 非 web 技术跨平台(flutter/kotlin desktop)\n- 虚拟 dom: 模板引擎 => react/vue => svelte\n- 状态管理: 可变 ng => 不可变 react/redux/immer => 可变 vue/mobx\n\n## 工具\n\n对比\n\n| 类型 | 基于 DSL                    | 所见即所得                  |\n| ---- | --------------------------- | --------------------------- |\n| 文档 | markdown                    | word/google docs            |\n| 绘图 | mermaid/uml/c4model         | drawio/思维导图/google 绘图 |\n| 笔记 | vscode/基于 markdown 的工具 | notion/印象笔记             |\n| PPT  | revealjs/slidev             | PPT                         |\n\n问题：如何平衡自由度和易用性？\n\n### 文档\n\n问题\n\n- 是否使用富文本？\n- 是否支持所见即所得？\n\n选择\n\n- markdown 限制了富文本的功能，并将允许的功能做到最好。\n- 然而 markdown 抛弃了富文本而使用纯文本，所以也衍生出 UI 是富文本，底层是 markdown 的思路所见即所得编辑器，例如 Typora、Notion 这些。\n- word/google docs 这种富文本工具有个痛苦的点是布局非常烦人，想要实现精美的布局需要非常高的熟练度和大量的时间，甚至可以做到 markdown 无法做的效果。但话又说回来，很多人并不能把 word 玩的非常熟，只能制作简单的文档罢了。\n\n下图为在 vscode 中编辑 markdown\n\n![1622211928274](:/b4963c306548404b867137d261c19e36)\n\n### 绘图\n\n问题\n\n- 是否要使用 DSL 渲染绘图？\n- 是否使用自动布局算法？\n\n选择\n\n- mermaid/uml/c4model：通过 DSL 渲染各种图表，但通常编辑能力非常有限。由于实际数据是文本，所以能够非常方便的编程式处理。\n- drawio/google 绘图：完全自由的一块画布，可以任意拖拽自由布局，但为了减轻调整细节的麻烦，所以都实现了自动对齐的功能。扩展性方面取决于官方支持，如果有 sdk 就还好。\n- 思维导图：比较好的平衡了布局的自由和便利，可以拖拽控制位置，但布局仍然是自动的，这是吾辈认为绘图工具中最好的一种实现。\n\n下面是使用 drawio 绘制流程图和使用百度脑图绘制思维导图的区别\n\n````md\n```mermaid\ngraph TD;\nid1[start]\nid2[step 1]\nid3[step 2]\nid4[end]\nid1 --> id2 --> id3 --> id4\n```\n````\n\n![1622643314587](:/5ae6c3b90e464d75975cb492a123d98b)\n\n![使用 drawio 绘制流程图](:/0dd48273156a4cf18ceb7753a004f3b7)\n\n![使用百度脑图绘制思维导图](:/b6e75d38e1974b06b1d95a70e6417a30)\n\n一些需求\n\n- 所见即所得\n- 实际存储的是文本（或提供 sdk 支持）\n- 支持控制相对位置，但仍然自动布局\n\n## 技术\n\n| 类型     | 新兴技术 | 相对传统的技术 |\n| -------- | -------- | -------------- |\n| 打包工具 | esbuild  | rollup/webpack |\n| 框架     | svelte   | react/vue      |\n\n### 打包工具\n\n问题\n\n- 是否使用 js 编写？\n- 是否灵活优先于用户体验？\n\n选择\n\nesbuild、rollup、webpack 它们的选择其实很有意思。\n\n- webpack：生来就以强大的灵活性自居，在 2018 年尝试接触 webpack 时感觉很麻烦，转而使用不需要 webpack 的 vue。但由于其它打包工具的影响（rollup/parcel），后来也声称支持了零配置，但实际上还是有非常非常多的配置，甚至衍生出了 [webpack 配置工程师](https://www.zhihu.com/question/267908710) 这个梗。正因如此，create-react-app/vue-cli 都以 webpack 作为底层二次封装 cli。\n- rollup: rollup 本身相比于 webpack 没有那么多配置，复杂度要低得多。尤其是它的许多插件都是真正意义上的支持开箱即用，默认不需要配置即可使用。而且它没有什么难懂的概念，基本上就是指定 input 和 output 就打包好了。但它仍然是使用 js 实现，所以性能方面有一些提升，但不是质的变化。\n- esbuild: 完全采取了新的做法，使用 golang 编写，利用多线程加速，导致它比基于 js 的方案快 10-100 倍，实测单独使用时也确实可以做到。而且 vite/snowpack 这些新型的脚手架都使用它去编译 ts/js 以提高性能，最近更是出现了爆发式的生态建设（吾辈之前也在 [@liuli-util/cli](https://www.npmjs.com/package/@liuli-util/cli) 中尝试过）。但这样做也不是全无问题，首先它脱离了现有生态重新实现，导致打包功能并不完善，所以 vite 仅利用它去编译 ts/js 而非整个打包，参考：[为何不用 ESBuild 打包？](https://cn.vitejs.dev/guide/why.html#why-not-bundle-with-esbuild)。\n\n总的来说，rollup 是目前最好用的基于 js 的打包工具，而 esbuild 则非常值得观望 -- 如果社区生态能够成熟起来，则打包性能会飞速提升，前端开发也可能不得不多学一两门其它语言了（golang/rust）。\n\n### 框架\n\n问题\n\n- 是否基于虚拟 dom？\n- 生态是否成熟？\n- 官方的设计理念是怎么样的？\n\n选择\n\n> 关于这三个框架 vue 作者曾经也做过一些对比，参考 [dotJS 2019 - Evan You - State of Components](https://youtu.be/bOdfo5SmQc8)\n> 吾辈曾经从 vue => react 的一些想法：[面相 vue 开发者的 react 入坑指南](:/f7599ffb024149e1a8928b61e8fdcd42)\n\n- react: 最流行的前端框架，生态非常成熟，但官方更倾向于无为而治，强调哲学与设计理念而非开发者体验。\n- svelte: 去年非常火的一个前端框架，倾向于使用编译器在编译阶段做更多的事，避免虚拟 dom 运行时的存在。生态上还非常小，jetbrains 目前没有官方支持它。\n\n### 前端那些曾经流行过的技术\n\n> 参考：[2015 有哪些目前流行的前端框架？](https://www.zhihu.com/question/35069742)\n\n看看还认识几个\n\n![1622214639959](:/64440cbe1f2943e2ab20067b09150b0f)\n\n- 模块加载方案：CommonJS、AMD、UMD、System\n- 打包工具：Gulp、Grunt、browserify\n- 框架：jQuery、Prototype、AngularJS、BootStrap、Underscore.js\n\n正在衰落的技术\n\n- Webpack：Vue 作者的脚手架工具已经彻底放弃，这带来了非常大的变化，参考：<https://twitter.com/TheLarkInn/status/1255686575121330176>\n- Redux：同样的，redux 作者也表示 redux 过度灵活和复杂化了，参考：<https://twitter.com/dan_abramov/status/1039570011986321408>\n\n## 总结\n\n新事物不断出现，有些是更好的，但有更多会湮没在历史中。选择合适的新事物去学习和使用，比单纯的东做一点、西做一点更有效果（选择比努力更重要）。\n","createdTime":1620882215771,"updatedTime":1623583368982,"resources":[{"id":"0dd48273156a4cf18ceb7753a004f3b7","title":"使用 drawio 绘制流程图","file_extension":"gif","user_updated_time":1620884740191},{"id":"5ae6c3b90e464d75975cb492a123d98b","title":"1622643314587","file_extension":"png","user_updated_time":1622643315112},{"id":"64440cbe1f2943e2ab20067b09150b0f","title":"1622214639959","file_extension":"png","user_updated_time":1622214640449},{"id":"b4963c306548404b867137d261c19e36","title":"1622211928274","file_extension":"png","user_updated_time":1622211929301},{"id":"b6e75d38e1974b06b1d95a70e6417a30","title":"使用百度脑图绘制思维导图","file_extension":"gif","user_updated_time":1620884935872}],"tags":[{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"624ba71c53634ea591de1338111da396","title":"electron 开发经验之谈系列-简介","body":"> 注: 该系列博客存在前后顺序依赖，请尽量从前往后通读一遍。\n> [GitHub 项目](https://github.com/rxliuli/electron_example)\n\n这是一个关于如何使用 React + Electron 开发桌面应用的一些经验之谈，可能包含一些主观意见，但或许仍然能对你有所帮助。\n\n## 目的\n\n那么，吾辈到底是想写一些什么呢？前端工程化？electron 项目的怪癖？还是其他什么？\n吾辈想完成一个使用 electron 开发的的系列文章，说明开发 electron 的基本流程、各种选择、以及涉及到的工程化的内容，并在说明这些的过程中完成一个桌面应用程序。\n\n![Electron 开发概略.km.svg](:/fa1667ac96664ab195e487221b3244eb)\n\n> 在这个系列中，会使用到一些额外的技术，如果你不了解可能也没太大问题，但了解之后才能更顺畅的阅读，参考: [技术栈简介及选择](:/6edf2cfaf7ec46f0bfb659d8c7246c52)\n\n## 目录\n\n- [简介](:/624ba71c53634ea591de1338111da396)\n- [技术栈简介及选择](:/6edf2cfaf7ec46f0bfb659d8c7246c52)\n- [基本项目搭建](:/23ec4673a06f41b59bfaf5a7da6d98db)\n- [使用 electron-builder 打包](:/33dd9a3fccaf4666b04935237f885772)\n- [渲染、主进程通信](:/76393a60949c47c7add910df0206734c)\n- [在渲染、主进程间共享数据](:/5ce7d75fe2dc46838b49f9e5e14ac738)\n- [自定义窗口顶栏](:/85f539d2cc4e4ae89093df537111cec8)\n- [自动更新](:/bf7621c04d9f45098fb0ecf2acad336e)\n- [常见问题](:/c68829779f5449d0afe0e67806dc7fc1)\n- [自定义协议](:/0a4259c97ca440d1b5375f4e21eaaace)\n- [开发环境优化](:/5cc9156517484576a64b4d253ae28af8)\n","createdTime":1609295694190,"updatedTime":1622646311688,"resources":[{"id":"fa1667ac96664ab195e487221b3244eb","title":"Electron 开发概略.km.svg","file_extension":"svg","user_updated_time":1616321708956}],"tags":[{"id":"b50c8282004d48edae677ecdfb933e9f","title":"electron","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"0391e85b82f5465cb1ab0ff962a50ea7","title":"为什么要用现代前端","body":"## 背景\r\n\r\n前端近两年来发展迅速，随着 [nodejs](https://nodejs.org) 的广泛使用，大批 [npm](https://npmjs.com) 的框架/库层出不穷，npm 上 JavaScript 库的数量甚至超过了 [Maven 中央仓库](https://mvnrepository.com/)。  \r\n然而即便如此，仍然有很多公司固守在传统的前端切 UI，后端通过模板视图填充视图的技术。一方面固然是为了避免新技术踩坑，另一方面，居然有人在 [deno](https://github.com/denoland/deno) 下说出了：[求不要更新了，老子学不动了](https://github.com/denoland/deno/issues/25)，并引发了大量讨论。\r\n\r\n> deno 是 nodejs 的作者开发的下一代 JavaScript 运行时。\r\n\r\n## 现代前端\r\n\r\n前端发展史\r\n\r\n> 1. 1996 年，样式表标准 `CSS` 第一版发布。\r\n> 2. 2001 年，微软公司时隔 5 年之后，发布了 IE 浏览器的下一个版本 `Internet Explorer 6`。这是当时最先进的浏览器，它后来统治了浏览器市场多年。\r\n> 3. 2002 年，Mozilla 项目发布了它的浏览器的第一版，后来起名为 `Firefox`。\r\n> 4. 2003 年，苹果公司发布了 `Safari` 浏览器的第一版。\r\n> 5. 2004 年，Google 公司发布了 `Gmail`，促成了互联网应用程序（`Web Application`）这个概念的诞生。由于 Gmail 是在 4 月 1 日发布的，很多人起初以为这只是一个玩笑。\r\n> 6. 2004 年，`WHATWG` 组织成立，致力于加速 HTML 语言的标准化进程。\r\n> 7. 2005 年，`Ajax` 方法（Asynchronous JavaScript and XML）正式诞生，Jesse James Garrett 发明了这个词汇。它开始流行的标志是，2 月份发布的 Google Maps 项目大量采用该方法。它几乎成了新一代网站的标准做法，促成了 `Web 2.0` 时代的来临。\r\n> 8. 2006 年，`jQuery` 函数库诞生，作者为 John Resig。jQuery 为操作网页 `DOM` 结构提供了非常强大易用的接口，成为了使用最广泛的函数库，并且让 JavaScript 语言的应用难度大大降低，推动了这种语言的流行。\r\n> 9. 2008 年，`V8` 编译器诞生.\r\n> 10. 2009 年，`Node.js` 项目诞生，创始人为 Ryan Dahl，它标志着 JavaScript 可以用于 `服务器端编程`，从此网站的前端和后端可以使用同一种语言开发。并且，Node.js 可以承受很大的并发流量，使得开发某些互联网大规模的实时应用变得容易。\r\n> 11. 2013 年 5 月，Facebook 发布 UI 框架库 `React`，引入了新的 `JSX` 语法，使得 UI 层可以用组件开发。\r\n> 12. 2015 年 3 月，Facebook 公司发布了 `React Native` 项目，将 React 框架移植到了手机端，可以用来开发手机 `App`。它会将 JavaScript 代码转为 `iOS` 平台的 `Objective-C` 代码，或者 `Android` 平台的 `Java` 代码，从而为 JavaScript 语言开发高性能的原生 App 打开了一条道路。\r\n> 13. 2015 年 `vuejs` 发布 1.0 版本\r\n> 14. 2016 年 `vuejs2.x` 版本发布\r\n> 15. 新生事物仍在不断涌现...\r\n\r\n上面就是前端的大概发展史，看完之后，不难发现，有一些关键的历史时刻，对前端开发产生了重大影响。例如 IE6 的发布（统治了浏览器市场很多年），JQuery 的诞生，Ajax 的流行。而现在，新的拐点出现了 -- nodejs 的流行。现代前端仍然在快速发展中，前后端分离，SSR，PWA 都是近两年才出现的概念。如果没有上车，后面就再难追上了。例如像十年前不使用 Spring 开发的应用，在现代 Java Web 后端的环境中，没有 Spring 简直寸步难行。\r\n\r\n上面说了一些现代前端的历史，那么使用它具体有什么好处呢？\r\n\r\n### JavaScript 模块化\r\n\r\n仔细想想，我们的 HTML, CSS 和 JavaScript 是如何结合使用的？\r\n\r\n是的，我们按照规范分离了 HTML, CSS 和 JavaScript，并在 HTML 中使用 `<link />` 和 `<scirpt></script>` 标签引入 CSS 和 JavaScript。那么，不同的 JavaScript 之间如何交互呢？我们只能通过暴露顶级变量（`window 作用域`）来进行交互。\r\n是呀，稍有经验的 JavaScript 开发者都会 **抽取函数**，然而一个 JavaScript 中太多的函数仍然容易产生混乱。\r\n\r\n例如下面这段代码，点击不同的按钮，显示不同的面板。\r\n\r\n```html\r\n<!-- index.html -->\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\r\n    <title>JavaScript 避免使用 if-else</title>\r\n  </head>\r\n  <body>\r\n    <main>\r\n      <div id=\"tab\">\r\n        <label>\r\n          <input type=\"radio\" data-index=\"1\" name=\"form-tab-radio\" />\r\n          第一个选项卡\r\n        </label>\r\n        <label>\r\n          <input type=\"radio\" data-index=\"2\" name=\"form-tab-radio\" />\r\n          第二个选项卡\r\n        </label>\r\n        <label>\r\n          <input type=\"radio\" data-index=\"3\" name=\"form-tab-radio\" />\r\n          第三个选项卡\r\n        </label>\r\n      </div>\r\n      <form id=\"extends-form\"></form>\r\n    </main>\r\n    <script src=\"./js/if-else.js\"></script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n```js\r\n// js/if-else.js\r\ndocument.querySelectorAll('#tab input[name=\"form-tab-radio\"]').forEach((el) => {\r\n  el.addEventListener(\"click\", () => {\r\n    const index = el.dataset.index\r\n    const header = el.parentElement.innerText.trim()\r\n    // 如果为 1 就添加一个文本表单\r\n    if (index === \"1\") {\r\n      document.querySelector(\"#extends-form\").innerHTML = `\r\n            <header><h2>${header}</h2></header>\r\n            <div>\r\n              <label for=\"name\">姓名</label>\r\n              <input type=\"text\" name=\"name\" id=\"name\" />\r\n            </div>\r\n            <div>\r\n              <label for=\"age\">年龄</label>\r\n              <input type=\"number\" name=\"age\" id=\"age\" />\r\n            </div>\r\n            <div>\r\n              <button type=\"submit\">提交</button> <button type=\"reset\">重置</button>\r\n            </div>\r\n          `\r\n    } else if (index === \"2\") {\r\n      document.querySelector(\"#extends-form\").innerHTML = `\r\n        <header><h2>${header}</h2></header>\r\n        <div>\r\n          <label for=\"avatar\">头像</label>\r\n          <input type=\"file\" name=\"avatar\" id=\"avatar\" />\r\n        </div>\r\n        <div><img id=\"avatar-preview\" src=\"\" /></div>\r\n        <div>\r\n          <button type=\"submit\">提交</button> <button type=\"reset\">重置</button>\r\n        </div>\r\n      `\r\n      function readLocalFile(file) {\r\n        return new Promise((resolve, reject) => {\r\n          const fr = new FileReader()\r\n          fr.onload = (event) => {\r\n            resolve(event.target.result)\r\n          }\r\n          fr.onerror = (error) => {\r\n            reject(error)\r\n          }\r\n          fr.readAsDataURL(file)\r\n        })\r\n      }\r\n      document.querySelector(\"#avatar\").addEventListener(\"change\", (evnet) => {\r\n        const file = evnet.target.files[0]\r\n        if (!file) {\r\n          return\r\n        }\r\n        if (!file.type.includes(\"image\")) {\r\n          return\r\n        }\r\n        readLocalFile(file).then((link) => {\r\n          document.querySelector(\"#avatar-preview\").src = link\r\n        })\r\n      })\r\n    } else if (index === \"3\") {\r\n      const initData = new Array(100).fill(0).map((v, i) => `第 ${i} 项内容`)\r\n      document.querySelector(\"#extends-form\").innerHTML = `\r\n        <header><h2>${header}</h2></header>\r\n        <div>\r\n          <label for=\"search-text\">搜索文本</label>\r\n          <input type=\"text\" name=\"search-text\" id=\"search-text\" />\r\n          <ul id=\"search-result\"></ul>\r\n        </div>\r\n      `\r\n      document\r\n        .querySelector(\"#search-text\")\r\n        .addEventListener(\"input\", (evnet) => {\r\n          const searchText = event.target.value\r\n          document.querySelector(\"#search-result\").innerHTML = initData\r\n            .filter((v) => v.includes(searchText))\r\n            .map((v) => `<li>${v}</li>`)\r\n            .join()\r\n        })\r\n    }\r\n  })\r\n})\r\n```\r\n\r\n使用现代前端的 JavaScript 模块化重构如下\r\n\r\n```js\r\n// common.js\r\n/**\r\n * 状态机\r\n * 用于避免使用 if-else 的一种方式\r\n */\r\nclass StateMachine {\r\n  static getBuilder() {\r\n    const clazzMap = new Map()\r\n    /**\r\n     * 状态注册器\r\n     * 更好的有限状态机，分离子类与构建的关系，无论子类如何增删该都不影响基类及工厂类\r\n     */\r\n    return new class Builder {\r\n      // noinspection JSMethodCanBeStatic\r\n      /**\r\n       * 注册一个 class，创建子类时调用，用于记录每一个 [状态 => 子类] 对应\r\n       * @param state 作为键的状态\r\n       * @param clazz 对应的子类型\r\n       * @returns {*} 返回 clazz 本身\r\n       */\r\n      register(state, clazz) {\r\n        clazzMap.set(state, clazz)\r\n        return clazz\r\n      }\r\n\r\n      // noinspection JSMethodCanBeStatic\r\n      /**\r\n       * 获取一个标签子类对象\r\n       * @param {Number} state 状态索引\r\n       * @returns {QuestionType} 子类对象\r\n       */\r\n      getInstance(state) {\r\n        const clazz = clazzMap.get(state)\r\n        if (!clazz) {\r\n          return null\r\n        }\r\n        //构造函数的参数\r\n        return new clazz(...Array.from(arguments).slice(1))\r\n      }\r\n    }()\r\n  }\r\n}\r\n\r\nexport StateMachine\r\n```\r\n\r\n```js\r\n// TabBuilder.js\r\nexport default StateMachine.getBuilder()\r\n```\r\n\r\n```js\r\n// Tab.js\r\nclass Tab {\r\n  // 基类里面的初始化方法放一些通用的操作\r\n  init(header) {\r\n    const html = `\r\n      <header><h2>${header}</h2></header>\r\n      ${this.initHTML()}\r\n    `\r\n    document.querySelector(\"#extends-form\").innerHTML = html\r\n  }\r\n\r\n  // 给出一个方法让子类实现，以获得不同的 HTML 内容\r\n  initHTML() {}\r\n}\r\n\r\nexport default Tab\r\n```\r\n\r\n```js\r\n// Tab1.js\r\nimport builder from \"./TabBuilder.js\"\r\nimport Tab from \"./Tab\"\r\n\r\nconst Tab1 = builder.register(\r\n  1,\r\n  class Tab1 extends Tab {\r\n    // 实现 initHTML，获得选项卡对应的 HTML\r\n    initHTML() {\r\n      return `\r\n        <div>\r\n          <label for=\"name\">姓名</label>\r\n          <input type=\"text\" name=\"name\" id=\"name\" />\r\n        </div>\r\n        <div>\r\n          <label for=\"age\">年龄</label>\r\n          <input type=\"number\" name=\"age\" id=\"age\" />\r\n        </div>\r\n        <div>\r\n          <button type=\"submit\">提交</button> <button type=\"reset\">重置</button>\r\n        </div>\r\n      `\r\n    }\r\n  }\r\n)\r\n```\r\n\r\n```js\r\n// Tab2.js\r\nimport builder from \"./TabBuilder.js\"\r\nimport Tab from \"./Tab\"\r\n\r\nconst Tab2 = builder.register(\r\n  2,\r\n  class Tab2 extends Tab {\r\n    initHTML() {\r\n      return `\r\n      <div>\r\n        <label for=\"avatar\">头像</label>\r\n        <input type=\"file\" name=\"avatar\" id=\"avatar\" />\r\n      </div>\r\n      <div><img id=\"avatar-preview\" src=\"\" /></div>\r\n      <div>\r\n        <button type=\"submit\">提交</button> <button type=\"reset\">重置</button>\r\n      </div>\r\n      `\r\n    }\r\n    // 重写 init 初始化方法，并首先调用基类通用初始化的方法\r\n    init(header) {\r\n      super.init(header)\r\n      document.querySelector(\"#avatar\").addEventListener(\"change\", (evnet) => {\r\n        const file = evnet.target.files[0]\r\n        if (!file) {\r\n          return\r\n        }\r\n        if (!file.type.includes(\"image\")) {\r\n          return\r\n        }\r\n        this.readLocalFile(file).then((link) => {\r\n          document.querySelector(\"#avatar-preview\").src = link\r\n        })\r\n      })\r\n    }\r\n    // 子类独有方法\r\n    readLocalFile(file) {\r\n      return new Promise((resolve, reject) => {\r\n        const fr = new FileReader()\r\n        fr.onload = (event) => {\r\n          resolve(event.target.result)\r\n        }\r\n        fr.onerror = (error) => {\r\n          reject(error)\r\n        }\r\n        fr.readAsDataURL(file)\r\n      })\r\n    }\r\n  }\r\n)\r\n```\r\n\r\n```js\r\n// Tab2.js\r\nimport builder from \"./TabBuilder.js\"\r\nimport Tab from \"./Tab\"\r\n\r\nconst Tab3 = builder.register(\r\n  3,\r\n  class Tab3 extends Tab {\r\n    initHTML() {\r\n      return `\r\n      <div>\r\n        <label for=\"search-text\">搜索文本</label>\r\n        <input type=\"text\" name=\"search-text\" id=\"search-text\" />\r\n        <ul id=\"search-result\" />\r\n      </div>\r\n    `\r\n    }\r\n    init(header) {\r\n      super.init(header)\r\n      const initData = new Array(100).fill(0).map((v, i) => `第 ${i} 项内容`)\r\n      document\r\n        .querySelector(\"#search-text\")\r\n        .addEventListener(\"input\", (evnet) => {\r\n          const searchText = event.target.value\r\n          document.querySelector(\"#search-result\").innerHTML = initData\r\n            .filter((v) => v.includes(searchText))\r\n            .map((v) => `<li>${v}</li>`)\r\n            .join()\r\n        })\r\n    }\r\n  }\r\n)\r\n```\r\n\r\n```js\r\n// main.js\r\nimport builder from \"./TabBuilder.js\"\r\nimport \"./Tab1\"\r\nimport \"./Tab2\"\r\nimport \"./Tab3\"\r\n\r\ndocument.querySelectorAll('#tab input[name=\"form-tab-radio\"]').forEach((el) => {\r\n  el.addEventListener(\"click\", () =>\r\n    // 调用方式不变\r\n    builder\r\n      .getInstance(Number.parseInt(el.dataset.index))\r\n      .init(el.parentElement.innerText.trim())\r\n  )\r\n})\r\n```\r\n\r\n虽然看起来代码/文件变得更多了，然而实际上不同的状态区分更加明显，代码也更容易维护了。\r\n\r\n### 兼容性\r\n\r\n如果我们想要让传统前端项目兼容 `IE11`，那么恐怕不得不使用 `JQuery` 以及 `ES5` 以前的语法（ES5 也支持的不完全）。如果想要使用 `ES6/ES7/ES8` 的话恐怕不仅在 IE11 上无法保证兼容性，既便 Web 标准的前沿实现者 Google Chrome，它的旧版本对新特性的支持恐怕也不算好（Google Chrome 开发团队的实力毋庸置疑，然而如果一个标准是在浏览器发布之后才出现的话，旧版本浏览器却是不可能兼容了）。\r\n\r\n> 附: 最近两年 JavaScript 的标准几乎是一年一个版本，不过都没有再像 `ES6` 如此激进了\r\n\r\n那么，如果使用现代前端就能解决这个问题了么？是的，它现代前端项目基本上都会引入的一个库 -- [Babel](https://babeljs.io/)。\r\n\r\nBabel 官网首页用一句话说明了 Babel 的定位\r\n\r\n> Babel is a JavaScript compiler.  \r\n> Use next generation JavaScript, today.\r\n\r\n意为：  \r\n**Babel 是一个 JavaScript 编译器。**  \r\n**立刻使用下一代 JavaScript。**\r\n\r\n是的，你没听错，Babel 给自身的定义是 JavaScript 编译器。众所周知，JavaScript 是运行在浏览器上（现在也可以运行在 NodeJS）的解释型弱类型的脚本语言，是没有编译器的。而 Babel 就是帮我们将 ES6 之后的 JavaScript 代码编译成 ES5 的代码，以兼容较旧版本的浏览器。\r\n\r\n例如下面的代码\r\n\r\n```js\r\nfor (let i = 0; i < 3; i++) {\r\n  setTimeout(() => console.log(i), 0)\r\n}\r\n```\r\n\r\n会被转换成\r\n\r\n```js\r\nfor (var i = 0; i < 3; i++) {\r\n  ;((_i) => {\r\n    setTimeout(() => console.log(_i), 0)\r\n    i = _i\r\n  })(i)\r\n}\r\n```\r\n\r\n当然，传统前端不能使用 Babel 了么？答案是可以的，然而因为是在浏览器端编译 JavaScript，所以速度比较慢，具体可以参考吾辈写的 [在传统项目中使用 babel 编译 ES6](:/8c57648407fa4b72ac30c3a61b1c1fef)。\r\n\r\n### MVVM\r\n\r\n> [Wiki](https://zh.wikipedia.org/zh-cn/MVVM)\r\n\r\n`MVVM`（`Model–view–viewmodel`）是一种软件架构模式。\r\n\r\nMVVM 有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来，这是通过置标语言或 GUI 代码实现的。MVVM 的视图模型是一个值转换器，这意味着视图模型负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。视图模型可以实现中介者模式，组织对视图所支持的用例集的后端逻辑的访问。\r\n\r\n说人话就是 MVVM 能让我们不再关心 DOM 的更改，专注于操作数据，DOM 会根据数据自动渲染，我们不再需要关心它。\r\n\r\n事实上，我们的不同的代码虽然分离了，但逻辑上却不然，JavaScript 仍然需要操作 DOM 和 Style，而这项工作是非常繁琐而且易错的。  \r\n曾经我们使用 JQuery 来进行 DOM 交互，同时保证兼容性，以及更好的 Ajax 工具。现在，现代前端的很多框架就是为了解决数据与 DOM 同步的，不管是 `React` 的 `JSX`，还是 `VueJS` 的 `单文件组件`。\r\n\r\n`JSX`：React 的理念是 既然 JavaScript 能够操作 HTML/CSS，那就把所有的控制权交给 JavaScript 就好了，在 React JSX 中，一切都是 JavaScript，即便是 JSX 的 DSL 也只是一个看起来像 HTML 的 JavaScript 代码而已。像下面的代码，事实上就是 JavaScript，直接写 `<div>Hello {this.props.name}</div>` 只是语法糖，背后真正运行的还是 JavaScript。\r\n\r\n```jsx\r\nclass HelloMessage extends React.Component {\r\n  render() {\r\n    return <div>Hello {this.props.name}</div>\r\n  }\r\n}\r\n\r\nReactDOM.render(<HelloMessage name=\"Taylor\" />, mountNode)\r\n```\r\n\r\n假如使用 vuejs 的话写起来大概是这样\r\n\r\n```vuejs\r\n<template>\r\n  <div>Hello {name}</div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'HelloWord',\r\n  props: {\r\n    name: {\r\n      type: String\r\n    }\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n```js\r\nimport Vue from \"vue\"\r\nimport HelloMessage from \"./HelloMessage\"\r\n\r\nnew Vue({\r\n  el: \"#app\",\r\n  components: { HelloMessage },\r\n  template: \"<App/>\",\r\n})\r\n```\r\n\r\n它们之间的思想有许多共同之处，都推崇组件化开发，把 `HTML/CSS/JavaScript` 混合起来形成组件（类似于 Java 中将属性和函数封装为类），然后组合成更大的组件，形成组件树，并最终构成 WebApp。吾辈目前推荐先看 VueJS，毕竟是国人开发，中文文档最为完善，在三大前端框架中也属于最简单的一个（ReactJS 是最困难也是生态最好的一个）。\r\n\r\n### 生态丰富\r\n\r\nNPM 的生态相当丰富，现代前端几乎所有的库都通过 NPM 发布。至今，NPM 上已经有超过 70W+ 的包，在数量上甚至远超了 Maven 中央仓库。正是因为 NPM 发布包相当简单（吾辈都发布了几个），造成了如今无比繁荣的生态（想想 Maven 感觉都是泪。。。）\r\n\r\n> 包管理器对比数据可以参考 <http://www.modulecounts.com/>\r\n\r\n使用 NPM 安装和使用包相当简单，使用 `npm i [package]` 就能直接安装一个包，使用 ES6 `import` 语法就能在自己的 JavaScript 文件中快速引用一个包。\r\n\r\n下面列出一些常用的 NPM 库\r\n\r\n- [yarn](https://yarnpkg.com/): Facebook 家的前端包管理器\r\n- [babel](https://babeljs.io/): 现代前端的 JQuery，解决兼容性\r\n- [vuejs](https://vuejs.org/): 华人开发的前端 MVVM 框架\r\n- [stylus](http://stylus-lang.com/): CSS 预处理器\r\n- [eslint](https://eslint.org/): 前端代码规范检查\r\n- [webpack](https://webpack.js.org): 现代前端必备的打包工具\r\n- [rollup](https://www.rollupjs.com/): JavaScript SDK 打包工具\r\n- [lodashjs](https://lodash.com/): 流行的函数式工具库\r\n- [axios](https://www.axios.com/): 符合 ES6 Promise 风格的 Ajax 库\r\n- [vuetify](https://vuetifyjs.com/): 基于 vuejs 的前端 `material` 风格的 UI 库\r\n- [js-xlsx](https://github.com/SheetJS/js-xlsx): 前端 Excel 处理工具\r\n- [debug](https://www.npmjs.com/package/debug): debug 日志辅助工具\r\n- [uglifyjs](https://www.npmjs.com/package/uglify-js): JavaScript 压缩工具\r\n- [http-server](https://www.npmjs.com/package/http-server): 静态 http 服务器\r\n- [hexo](https://hexo.io/): 现代前端开发的博客系统\r\n- [highcharts](https://www.highcharts.com/): 丰富强大的图表库\r\n- [masonry](https://masonry.desandro.com/): 无限滚动瀑布流\r\n- [highlightjs](https://highlightjs.org/): 代码高亮\r\n- [rx-util](https://www.npmjs.com/package/rx-util): 写 Greasemonkey 脚本时自定义的工具库\r\n- 还有更多。。。\r\n\r\n### 工程化\r\n\r\n现代前端已经和后端类似，将原本混沌的 HTML/CSS/JavaScript 细分为了许多的内容。\r\n\r\n```js\r\n├── dist // 打包后的静态文件\r\n├── .editorconfig // 编辑器配置\r\n├── .eslintrc.js // eslint 配置格式\r\n├── .git // git 仓库\r\n├── .gitignore // git 忽略文件\r\n├── babel.config.js // babel 配置\r\n├── LICENSE // 许可证\r\n├── node_module // 项目依赖\r\n├── package.json // npm 定义文件\r\n├── public // 一些公共的资源\r\n│   ├── favicon.ico\r\n│   └── index.html\r\n├── README.md // 项目说明\r\n├── src // 源代码目录\r\n│   ├── App.vue // 根组件\r\n│   ├── main.js // 项目入口\r\n│   ├── api // api 接口，和 views 中的文件夹对应\r\n│   ├── components // 公共的组件\r\n│   ├── plugins // vuejs 插件\r\n│   │   └── vuetify.js\r\n│   ├── router // vuejs 路由管理\r\n│   │   └── index.js\r\n│   ├── store // vuejs 状态管理\r\n│   │   └── index.js\r\n│   ├── utils // 工具函数\r\n│   └── views // 各个页面\r\n├── tests\r\n│   └── unit // 单元测试\r\n│       ├── .eslintrc.js\r\n│       └── example.spec.js\r\n├── vue.config.js // vuejs 的配置\r\n└── yarn.lock // yarn 配置文件\r\n```\r\n\r\n当初第一次看到这个目录时真是被吓到了，使用 `yarn` 一下子 20000 个依赖文件就下载下来了。然而其实这只是将传统前端分的更细一点而已，对后期维护的好处也是不言而喻的。\r\n\r\n## 总结\r\n\r\n总而言之，现代前端流行之后，前后端分离已然是大势所趋，前端开发如果还仅仅是 **切图仔** 的话，迟早会因为跟不上时代而被淘汰。就吾辈而言，亦希望有更多人入坑现代前端，体会现代前端的强大!\r\n\r\n> 附：吾辈个人而言认为现代前端主要的优势 [模块化](#JavaScript-模块化)/[工程化](工程化) 和 [MVVM](#MVVM)。前者使大型 WebApp 的开发变成可能，后者则改变了数据与 DOM 之间的交互方式。\r\n","createdTime":1580652937693,"updatedTime":1622261605155,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"e241d9845dda448c8a1d9e5d2b100790","title":"使用 SSH 连接 Linux 服务器","body":"## 首先我们要在客户端（本机）生成密钥对\r\n\r\n> 这里的密钥对是 `Public key`，具体请参考 [公开密钥加密](https://zh.wikipedia.org/zh/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)\r\n\r\n使用命令\r\n\r\n```bash\r\nssh-keygen -t rsa\r\n```\r\n\r\n接下来会提示让你输入一个路径来保存密钥对，默认在 `~/.ssh/id_rsa` 下面生成 `id_rsa`（私钥）和 `id_rsa.pub`（公钥），如果没什么特殊需求就直接默认就好。\r\n\r\n然后提示你输入密码（即本机使用 `SSH` 连接时的密码 #和服务器密码无关），也是直接回车默认为空即可。\r\n\r\n## 将公钥上传到服务器上\r\n\r\n这里以使用 `SCP` 为例，上传公钥 `id_rsa.pub` 到服务器上\r\n\r\n```bash\r\nscp ~/.ssh/id_rsa.pub root@139.59.22.131:~\r\n```\r\n\r\n## 将公钥追加到服务器的认证密钥中\r\n\r\n将上传到服务器上的 `id_rsa.pub` 公钥追加到 `authorized_keys` 文件中，命令是\r\n\r\n```bash\r\ncat ~/id_rsa.pub >> ~/.ssh/authorized_keys\r\n```\r\n\r\n## 修改服务器的配置以启用公钥认证\r\n\r\n修改 `vi /etc/ssh/sshd_config` 配置文件（如果有的话就进行修改，没有的话就添加进来）\r\n\r\n```sh\r\nRSAAuthentication yes        # 启用 RSA 认证（默认是注释掉的，将注释去掉，如果不是 yes，改为 yes）\r\nPubkeyAuthentication yes     # 启用公钥认证（默认是注释掉的，将注释去掉，如果不是 yes，改为 yes）\r\nPasswordAuthentication no    # 禁止密码认证 (改为 no, 默认为 yes 是用密码认证)\r\nStrictModes no               # 修改为 no, 默认为 yes. 如果不修改用 key 登陆是出现 server refused our key(如果 StrictModes 为 yes 必需保证存放公钥的文件夹的拥有与登陆用户名是相同的.“StrictModes” 设置 ssh 在接收登录请求之前是否检查用户家目录和 rhosts 文件的权限和所有权。这通常是必要的，因为新手经常会把自己的目录和文件设成任何人都有写权限。)\r\n```\r\n\r\n## 重启 `SSH` 服务\r\n\r\n```bash\r\nservice sshd restart\r\n# 或者\r\n/etc/init.d/ssh restart\r\n```\r\n\r\n## 最后验证一下\r\n\r\n连接服务器，这里以 `SSH` 客户端为例\r\n\r\n```bash\r\nssh root@139.59.22.131\r\n```\r\n\r\n然后，就直接连上了，不需要输入密码了呢 Ｏ(≧▽≦)Ｏ\r\n","createdTime":1580652937968,"updatedTime":1618596369673,"resources":[],"tags":[{"id":"a80cb55379124c29b853b54da9597447","title":"linux","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"9bbb456a93a8410e9d2313dcd20dc07c","title":"使用 GreaseMonkey 解除网页复制粘贴限制","body":"> 吾辈发布了一个油猴脚本，可以直接安装 [解除网页限制](https://greasyfork.org/zh-CN/scripts/391193) 以获得更好的使用体验。\r\n\r\n## 场景\r\n\r\n在浏览网页时经常会出现的一件事，当吾辈想要复制，突然发现复制好像没用了？（[知乎禁止转载的文章](https://www.zhihu.com/question/23994286)）亦或者是复制的最后多出了一点内容（[简书](https://www.jianshu.com/p/0a85e4c7d3d3)），或者干脆直接不能选中了（[360doc](http://www.360doc.cn)）。粘贴时也有可能发现一直粘贴不了（[支付宝登录](https://auth.alipay.com/login/index.htm)）。\r\n\r\n## 问题\r\n\r\n欲先制敌，必先惑敌。想要解除复制粘贴的限制，就必须要清楚它们是如何实现的。不管如何，浏览器上能够运行的都是 JavaScript，它们都是使用 JavaScript 实现的。实现方式大致都是监听相应的事件（例如 `onkeydown` 监听 `Ctrl-C`），然后做一些特别的操作。\r\n\r\n例如屏蔽复制功能只需要一句代码\r\n\r\n```js\r\ndocument.oncopy = event => false;\r\n```\r\n\r\n是的，只要返回了 false，那么 copy 就会失效。还有一个更讨厌的方式，直接在 `body` 元素上加行内事件\r\n\r\n```html\r\n<body oncopy=\"javascript: return false\" />\r\n```\r\n\r\n## 解决\r\n\r\n可以看出，一般都是使用 JavaScript 在相应事件中返回 false，来阻止对应事件。那么，既然事件都被阻止了，是否意味着我们就束手无策了呢？吾辈所能想到的解决方案大致有三种方向\r\n\r\n- 使用 JavaScript 监听事件并自行实现复制/剪切/粘贴功能\r\n  - 优点：实现完成后不管是任何网站都能使用，并且不会影响到监听之外的事件，也不会删除监听的同类型事件，可以解除浏览器本身的限制（密码框禁止复制）\r\n  - 缺点：某些功能自行实现难度很大，例如选择文本\r\n- 重新实现 `addEventListener` 然后删除掉网站自定义的事件\r\n  - 优点：事件生效范围广泛，通用性高，不仅 _复制/剪切/粘贴_，其他类型的事件也可以解除\r\n  - 缺点：实现起来需要替换 `addEventListener` 事件**够早**，对浏览器默认操作不会生效（密码框禁止复制），而且某些网站也无法破解\r\n- 替换元素并删除 DOM 上的事件属性\r\n  - 优点：能够确保网站 js 的限制被解除，通用性高，事件生效范围广泛\r\n  - 缺点：可能影响到其他类型的事件，复制节点时不会复制使用 `addEventListener` 添加的事件\r\n    > 注：此方法不予演示，缺陷实在过大\r\n\r\n总之，如果真的想解除**限制**，恐怕需要两种方式并用才可以呢\r\n\r\n## 使用 JavaScript 监听事件并自行实现复制/剪切/粘贴功能\r\n\r\n### 实现强制复制\r\n\r\n思路\r\n\r\n1. 冒泡监听 `copy` 事件\r\n2. 获取当前选中的内容\r\n3. 设置剪切版的内容\r\n4. 阻止默认事件处理\r\n\r\n```js\r\n// 强制复制\r\ndocument.addEventListener(\r\n  \"copy\",\r\n  event => {\r\n    event.clipboardData.setData(\r\n      \"text/plain\",\r\n      document.getSelection().toString()\r\n    );\r\n    // 阻止默认的事件处理\r\n    event.preventDefault();\r\n  },\r\n  true\r\n);\r\n```\r\n\r\n### 实现强制剪切\r\n\r\n思路\r\n\r\n1. 冒泡监听 `cut` 事件\r\n2. 获取当前选中的内容\r\n3. 设置剪切版的内容\r\n4. 如果是可编辑内容要删除选中部分\r\n5. 阻止默认事件处理\r\n\r\n> 可以看到唯一需要增加的就是需要额外处理可编辑内容了，然而代码量瞬间爆炸了哦\r\n\r\n```js\r\n/**\r\n * 字符串安全的转换为小写\r\n * @param {String} str 字符串\r\n * @returns {String} 转换后得到的全小写字符串\r\n */\r\nfunction toLowerCase(str) {\r\n  if (!str || typeof str !== \"string\") {\r\n    return str;\r\n  }\r\n  return str.toLowerCase();\r\n}\r\n\r\n/**\r\n * 判断指定元素是否是可编辑元素\r\n * 注：可编辑元素并不一定能够进行编辑，例如只读的 input 元素\r\n * @param {Element} el 需要进行判断的元素\r\n * @returns {Boolean} 是否为可编辑元素\r\n */\r\nfunction isEditable(el) {\r\n  var inputEls = [\"input\", \"date\", \"datetime\", \"select\", \"textarea\"];\r\n  return (\r\n    el && (el.isContentEditable || inputEls.includes(toLowerCase(el.tagName)))\r\n  );\r\n}\r\n\r\n/**\r\n * 获取输入框中光标所在位置\r\n * @param  {Element} el 需要获取的输入框元素\r\n * @returns {Number} 光标所在位置的下标\r\n */\r\nfunction getCusorPostion(el) {\r\n  return el.selectionStart;\r\n}\r\n\r\n/**\r\n * 设置输入框中选中的文本/光标所在位置\r\n * @param {Element} el 需要设置的输入框元素\r\n * @param {Number} start 光标所在位置的下标\r\n * @param {Number} {end} 结束位置，默认为输入框结束\r\n */\r\nfunction setCusorPostion(el, start, end = start) {\r\n  el.focus();\r\n  el.setSelectionRange(start, end);\r\n}\r\n\r\n/**\r\n * 在指定范围内删除文本\r\n * @param {Element} el 需要设置的输入框元素\r\n * @param {Number} {start} 开始位置，默认为当前选中开始位置\r\n * @param {Number} {end} 结束位置，默认为当前选中结束位置\r\n */\r\nfunction removeText(el, start = el.selectionStart, end = el.selectionEnd) {\r\n  // 删除之前必须要 [记住] 当前光标的位置\r\n  var index = getCusorPostion(el);\r\n  var value = el.value;\r\n  el.value = value.substr(0, start) + value.substr(end, value.length);\r\n  setCusorPostion(el, index);\r\n}\r\n\r\n// 强制剪切\r\ndocument.addEventListener(\r\n  \"cut\",\r\n  event => {\r\n    event.clipboardData.setData(\r\n      \"text/plain\",\r\n      document.getSelection().toString()\r\n    );\r\n    // 如果是可编辑元素还要进行删除\r\n    if (isEditable(event.target)) {\r\n      removeText(event.target);\r\n    }\r\n    event.preventDefault();\r\n  },\r\n  true\r\n);\r\n```\r\n\r\n### 实现强制粘贴\r\n\r\n1. 冒泡监听 `focus/blur`，以获得最后一个获得焦点的可编辑元素\r\n2. 冒泡监听 `paste` 事件\r\n3. 获取剪切版的内容\r\n4. 获取最后一个获得焦点的可编辑元素\r\n5. 删除当前选中的文本\r\n6. 在当前光标处插入文本\r\n7. 阻止默认事件处理\r\n\r\n```js\r\n/**\r\n * 获取到最后一个获得焦点的元素\r\n */\r\nvar getLastFocus = (lastFocusEl => {\r\n  document.addEventListener(\r\n    \"focus\",\r\n    event => {\r\n      lastFocusEl = event.target;\r\n    },\r\n    true\r\n  );\r\n  document.addEventListener(\r\n    \"blur\",\r\n    event => {\r\n      lastFocusEl = null;\r\n    },\r\n    true\r\n  );\r\n  return () => lastFocusEl;\r\n})(null);\r\n\r\n/**\r\n * 字符串安全的转换为小写\r\n * @param {String} str 字符串\r\n * @returns {String} 转换后得到的全小写字符串\r\n */\r\nfunction toLowerCase(str) {\r\n  if (!str || typeof str !== \"string\") {\r\n    return str;\r\n  }\r\n  return str.toLowerCase();\r\n}\r\n\r\n/**\r\n * 判断指定元素是否是可编辑元素\r\n * 注：可编辑元素并不一定能够进行编辑，例如只读的 input 元素\r\n * @param {Element} el 需要进行判断的元素\r\n * @returns {Boolean} 是否为可编辑元素\r\n */\r\nfunction isEditable(el) {\r\n  var inputEls = [\"input\", \"date\", \"datetime\", \"select\", \"textarea\"];\r\n  return (\r\n    el && (el.isContentEditable || inputEls.includes(toLowerCase(el.tagName)))\r\n  );\r\n}\r\n\r\n/**\r\n * 获取输入框中光标所在位置\r\n * @param  {Element} el 需要获取的输入框元素\r\n * @returns {Number} 光标所在位置的下标\r\n */\r\nfunction getCusorPostion(el) {\r\n  return el.selectionStart;\r\n}\r\n\r\n/**\r\n * 设置输入框中选中的文本/光标所在位置\r\n * @param {Element} el 需要设置的输入框元素\r\n * @param {Number} start 光标所在位置的下标\r\n * @param {Number} {end} 结束位置，默认为输入框结束\r\n */\r\nfunction setCusorPostion(el, start, end = start) {\r\n  el.focus();\r\n  el.setSelectionRange(start, end);\r\n}\r\n\r\n/**\r\n * 在指定位置后插入文本\r\n * @param {Element} el 需要设置的输入框元素\r\n * @param {String} value 要插入的值\r\n * @param {Number} {start} 开始位置，默认为当前光标处\r\n */\r\nfunction insertText(el, text, start = getCusorPostion(el)) {\r\n  var value = el.value;\r\n  el.value = value.substr(0, start) + text + value.substr(start);\r\n  setCusorPostion(el, start + text.length);\r\n}\r\n\r\n/**\r\n * 在指定范围内删除文本\r\n * @param {Element} el 需要设置的输入框元素\r\n * @param {Number} {start} 开始位置，默认为当前选中开始位置\r\n * @param {Number} {end} 结束位置，默认为当前选中结束位置\r\n */\r\nfunction removeText(el, start = el.selectionStart, end = el.selectionEnd) {\r\n  // 删除之前必须要 [记住] 当前光标的位置\r\n  var index = getCusorPostion(el);\r\n  var value = el.value;\r\n  el.value = value.substr(0, start) + value.substr(end, value.length);\r\n  setCusorPostion(el, index);\r\n}\r\n\r\n// 强制粘贴\r\ndocument.addEventListener(\r\n  \"paste\",\r\n  event => {\r\n    // 获取当前剪切板内容\r\n    var clipboardData = event.clipboardData;\r\n    var items = clipboardData.items;\r\n    var item = items[0];\r\n    if (item.kind !== \"string\") {\r\n      return;\r\n    }\r\n    var text = clipboardData.getData(item.type);\r\n    // 获取当前焦点元素\r\n    // 粘贴的时候获取不到焦点？\r\n    var focusEl = getLastFocus();\r\n    // input 居然不是 [可编辑] 的元素？\r\n    if (isEditable(focusEl)) {\r\n      removeText(focusEl);\r\n      insertText(focusEl, text);\r\n      event.preventDefault();\r\n    }\r\n  },\r\n  true\r\n);\r\n```\r\n\r\n### 总结\r\n\r\n脚本全貌\r\n\r\n```js\r\n(function() {\r\n  \"use strict\";\r\n\r\n  /**\r\n   * 两种思路：\r\n   * 1. 自己实现\r\n   * 2. 替换元素\r\n   */\r\n\r\n  /**\r\n   * 获取到最后一个获得焦点的元素\r\n   */\r\n  var getLastFocus = (lastFocusEl => {\r\n    document.addEventListener(\r\n      \"focus\",\r\n      event => {\r\n        lastFocusEl = event.target;\r\n      },\r\n      true\r\n    );\r\n    document.addEventListener(\r\n      \"blur\",\r\n      event => {\r\n        lastFocusEl = null;\r\n      },\r\n      true\r\n    );\r\n    return () => lastFocusEl;\r\n  })(null);\r\n\r\n  /**\r\n   * 字符串安全的转换为小写\r\n   * @param {String} str 字符串\r\n   * @returns {String} 转换后得到的全小写字符串\r\n   */\r\n  function toLowerCase(str) {\r\n    if (!str || typeof str !== \"string\") {\r\n      return str;\r\n    }\r\n    return str.toLowerCase();\r\n  }\r\n\r\n  /**\r\n   * 字符串安全的转换为大写\r\n   * @param {String} str 字符串\r\n   * @returns {String} 转换后得到的全大写字符串\r\n   */\r\n  function toUpperCase(str) {\r\n    if (!str || typeof str !== \"string\") {\r\n      return str;\r\n    }\r\n    return str.toUpperCase();\r\n  }\r\n\r\n  /**\r\n   * 判断指定元素是否是可编辑元素\r\n   * 注：可编辑元素并不一定能够进行编辑，例如只读的 input 元素\r\n   * @param {Element} el 需要进行判断的元素\r\n   * @returns {Boolean} 是否为可编辑元素\r\n   */\r\n  function isEditable(el) {\r\n    var inputEls = [\"input\", \"date\", \"datetime\", \"select\", \"textarea\"];\r\n    return (\r\n      el && (el.isContentEditable || inputEls.includes(toLowerCase(el.tagName)))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * 获取输入框中光标所在位置\r\n   * @param  {Element} el 需要获取的输入框元素\r\n   * @returns {Number} 光标所在位置的下标\r\n   */\r\n  function getCusorPostion(el) {\r\n    return el.selectionStart;\r\n  }\r\n\r\n  /**\r\n   * 设置输入框中选中的文本/光标所在位置\r\n   * @param {Element} el 需要设置的输入框元素\r\n   * @param {Number} start 光标所在位置的下标\r\n   * @param {Number} {end} 结束位置，默认为输入框结束\r\n   */\r\n  function setCusorPostion(el, start, end = start) {\r\n    el.focus();\r\n    el.setSelectionRange(start, end);\r\n  }\r\n\r\n  /**\r\n   * 在指定位置后插入文本\r\n   * @param {Element} el 需要设置的输入框元素\r\n   * @param {String} value 要插入的值\r\n   * @param {Number} {start} 开始位置，默认为当前光标处\r\n   */\r\n  function insertText(el, text, start = getCusorPostion(el)) {\r\n    var value = el.value;\r\n    el.value = value.substr(0, start) + text + value.substr(start);\r\n    setCusorPostion(el, start + text.length);\r\n  }\r\n\r\n  /**\r\n   * 在指定范围内删除文本\r\n   * @param {Element} el 需要设置的输入框元素\r\n   * @param {Number} {start} 开始位置，默认为当前选中开始位置\r\n   * @param {Number} {end} 结束位置，默认为当前选中结束位置\r\n   */\r\n  function removeText(el, start = el.selectionStart, end = el.selectionEnd) {\r\n    // 删除之前必须要 [记住] 当前光标的位置\r\n    var index = getCusorPostion(el);\r\n    var value = el.value;\r\n    el.value = value.substr(0, start) + value.substr(end, value.length);\r\n    setCusorPostion(el, index);\r\n  }\r\n\r\n  // 强制复制\r\n  document.addEventListener(\r\n    \"copy\",\r\n    event => {\r\n      event.clipboardData.setData(\r\n        \"text/plain\",\r\n        document.getSelection().toString()\r\n      );\r\n      event.preventDefault();\r\n    },\r\n    true\r\n  );\r\n\r\n  // 强制剪切\r\n  document.addEventListener(\r\n    \"cut\",\r\n    event => {\r\n      event.clipboardData.setData(\r\n        \"text/plain\",\r\n        document.getSelection().toString()\r\n      );\r\n      // 如果是可编辑元素还要进行删除\r\n      if (isEditable(event.target)) {\r\n        removeText(event.target);\r\n      }\r\n      event.preventDefault();\r\n    },\r\n    true\r\n  );\r\n\r\n  // 强制粘贴\r\n  document.addEventListener(\r\n    \"paste\",\r\n    event => {\r\n      // 获取当前剪切板内容\r\n      var clipboardData = event.clipboardData;\r\n      var items = clipboardData.items;\r\n      var item = items[0];\r\n      if (item.kind !== \"string\") {\r\n        return;\r\n      }\r\n      var text = clipboardData.getData(item.type);\r\n      // 获取当前焦点元素\r\n      // 粘贴的时候获取不到焦点？\r\n      var focusEl = getLastFocus();\r\n      // input 居然不是 [可编辑] 的元素？\r\n      if (isEditable(focusEl)) {\r\n        removeText(focusEl);\r\n        insertText(focusEl, text);\r\n        event.preventDefault();\r\n      }\r\n    },\r\n    true\r\n  );\r\n\r\n  function selection() {\r\n    var dom;\r\n    document.onmousedown = event => {\r\n      dom = event.target;\r\n      // console.log('点击: ', dom)\r\n      debugger;\r\n      console.log(\"光标所在处: \", getCusorPostion(dom));\r\n    };\r\n    document.onmousemove = event => {\r\n      console.log(\"移动: \", dom);\r\n    };\r\n    document.onmouseup = event => {\r\n      console.log(\"松开: \", dom);\r\n    };\r\n  }\r\n})();\r\n```\r\n\r\n## 重新实现 `addEventListener` 然后删除掉网站自定义的事件\r\n\r\n> 该实现来灵感来源自 <https://greasyfork.org/en/scripts/41075>，几乎完美实现了解除限制的功能\r\n\r\n原理很简单，修改原型，重新实现 `EventTarget` 和 `docuement` 的 `addEventListener` 函数\r\n\r\n```js\r\n// ==UserScript==\r\n// @name         解除网页限制\r\n// @namespace    http://github.com/rxliuli\r\n// @version      1.0\r\n// @description  破解禁止复制/剪切/粘贴/选择/右键菜单的网站\r\n// @author       rxliuli\r\n// @include      https://www.jianshu.com/*\r\n// @grant        GM.getValue\r\n// @grant        GM.setValue\r\n// 这里的 @run-at 非常重要，设置在文档开始时就载入脚本\r\n// @run-at       document-start\r\n// ==/UserScript==\r\n\r\n(() => {\r\n  /**\r\n   * 监听所有的 addEventListener, removeEventListener 事件\r\n   */\r\n  var documentAddEventListener = document.addEventListener;\r\n  var eventTargetAddEventListener = EventTarget.prototype.addEventListener;\r\n  var documentRemoveEventListener = document.removeEventListener;\r\n  var eventTargetRemoveEventListener =\r\n    EventTarget.prototype.removeEventListener;\r\n  var events = [];\r\n\r\n  /**\r\n   * 用来保存监听到的事件信息\r\n   */\r\n  class Event {\r\n    constructor(el, type, listener, useCapture) {\r\n      this.el = el;\r\n      this.type = type;\r\n      this.listener = listener;\r\n      this.useCapture = useCapture;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 自定义的添加事件监听函数\r\n   * @param {String} type 事件类型\r\n   * @param {EventListener} listener 事件监听函数\r\n   * @param {Boolean} {useCapture} 是否需要捕获事件冒泡，默认为 false\r\n   */\r\n  function addEventListener(type, listener, useCapture = false) {\r\n    var _this = this;\r\n    var $addEventListener =\r\n      _this === document\r\n        ? documentAddEventListener\r\n        : eventTargetAddEventListener;\r\n    events.push(new Event(_this, type, listener, useCapture));\r\n    $addEventListener.apply(this, arguments);\r\n  }\r\n\r\n  /**\r\n   * 自定义的根据类型删除事件函数\r\n   * 该方法会删除这个类型下面全部的监听函数，不管数量\r\n   * @param {String} type 事件类型\r\n   */\r\n  function removeEventListenerByType(type) {\r\n    var _this = this;\r\n    var $removeEventListener =\r\n      _this === document\r\n        ? documentRemoveEventListener\r\n        : eventTargetRemoveEventListener;\r\n    var removeIndexs = events\r\n      .map((e, i) => (e.el === _this || e.type === arguments[0] ? i : -1))\r\n      .filter(i => i !== -1);\r\n    removeIndexs.forEach(i => {\r\n      var e = events[i];\r\n      $removeEventListener.apply(e.el, [e.type, e.listener, e.useCapture]);\r\n    });\r\n    removeIndexs.sort((a, b) => b - a).forEach(i => events.splice(i, 1));\r\n  }\r\n\r\n  function clearEvent() {\r\n    var eventTypes = [\r\n      \"copy\",\r\n      \"cut\",\r\n      \"select\",\r\n      \"contextmenu\",\r\n      \"selectstart\",\r\n      \"dragstart\"\r\n    ];\r\n    document.querySelectorAll(\"*\").forEach(el => {\r\n      eventTypes.forEach(type => el.removeEventListenerByType(type));\r\n    });\r\n  }\r\n\r\n  (function() {\r\n    document.addEventListener = EventTarget.prototype.addEventListener = addEventListener;\r\n    document.removeEventListenerByType = EventTarget.prototype.removeEventListenerByType = removeEventListenerByType;\r\n  })();\r\n\r\n  window.onload = function() {\r\n    clearEvent();\r\n  };\r\n})();\r\n```\r\n\r\n---\r\n\r\n最后，JavaScript hack 技巧是真的很多，果然写 GreaseMonkey 脚本这方面用得很多呢 (๑>ᴗ<๑)\r\n","createdTime":1580652937913,"updatedTime":1618499356215,"resources":[],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""},{"id":"f93505f3e7994607aec7afec41480af3","title":"经验","parent_id":""}]},{"id":"5a5e606ac8674f139293033f794e9723","title":"Chrome 强制复制粘贴","body":"## 场景\r\n\r\n> 如果你是一位开发者，可以看一下另一篇博客 [使用 GreaseMonkey 解除网页复制粘贴限制](:/9bbb456a93a8410e9d2313dcd20dc07c)。或许，你能找到更好的方式\r\n\r\n登录支付宝时突然发现密码框不能 C-V 粘贴，也无法使用右键了。提示说是为了安全，实际上不就是为了让人使用 App 扫码么。。。想尽办法为难 PC 用户，这次 Chrome 的强制复制插件也没能起到作用。然而不管其是如何实现禁用粘贴/禁用右键的，但其一定需要用到 JavaScript，有了这个思路，只要暂时禁用 JavaScript 就好了。\r\n\r\n## 具体步骤\r\n\r\n使用 F12 打开 Chrome 开发者工具，勾选 **Setting -> Preferences -> Debugger -> Disable JavaScript**，临时禁用掉 JavaScript，然后在粘贴密码之后记得要取消勾选哦，因为支付宝的登录还要用到 JavaScript 呢\r\n\r\n1. 打开 Chrome 开发者工具  \r\n   [![打开 Chrome 开发者工具](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190117221230.png)](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190117221230.png)\r\n2. 临时禁用 JavaScript  \r\n   [![临时禁用 JavaScript](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190117221505.png)](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190117221505.png)\r\n\r\n> 快速切换的方法暂且还没有找到 Chrome 插件呢，有什么好推荐的也可以告诉吾辈哦\r\n","createdTime":1580652938020,"updatedTime":1618499187157,"resources":[],"tags":[{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"76393a60949c47c7add910df0206734c","title":"electron 开发经验之谈系列-渲染、主进程通信","body":"## 场景\n\n由于 electron 应用分为主进程、渲染进程，所以它们之间需要通信。而 electron 本身实现了一个简单的 event emitter 通信模型，虽然能用，但并不足够好。\n\n> 参考: <https://www.electronjs.org/docs/api/ipc-renderer>\n\n问题\n\n- 基于字符串和约定进行通信本质上和当下前后端通信差不多，没有利用同构优势\n- 使用起来没有任何限制，意味着很难维护（非强制性的约定基本上都很难生效）\n\n## 思考\n\n那么一共 electron 进程通信有哪些情况呢？\n\n- 渲染进程 => 主进程\n- 主进程 => 渲染进程\n- 渲染进程 => 渲染进程\n\n而其中最常用的便是 `渲染进程 => 主进程`\n\n> 其实吾辈也看过许多 electron 进程通信的 [封装库](https://www.npmjs.com/package/electron-rpc-api) 或者类似场景的 rpc 实现 [comlink](https://www.npmjs.com/package/comlink)，但最终还是决定使用接口 + 主进程实现 + 渲染层根据接口生成 Client 的方式实现。\n\n最终，吾辈选择了接口 + 实现类的基本模式\n\n![设计图.drawio.svg](:/a744f749ef6f4652aa82f5dbcb1e22d8)\n\n## 实现渲染进程 => 主进程\n\n首先在创建 _libs_ 目录用以存放通用模块（非业务），然后创建三个模块\n\n- `electron_ipc_type`: 一些需要引入的类型\n- `electron_ipc_main`: 主进程封装\n- `electron_ipc_renderer`: 渲染层封装\n\n> 此处使用 rollup 进行打包\n\n大致实现\n\nelectron_ipc_type: 通用的基本接口定义，必须包含一个 `namespace` 属性\n\n```ts\nexport interface BaseDefine<T extends string> {\n  namespace: T\n}\n```\n\nelectron_ipc_main: 封装主进程实现相关代码，主要保证类型安全\n\n```ts\ntype FilteredKeys<T, U> = {\n  [P in keyof T]: T[P] extends U ? P : never\n}[keyof T]\n\n/**\n * 转换为一个主进程可以实现的接口\n */\nexport type IpcMainDefine<T> = {\n  [P in FilteredKeys<T, (...args: any[]) => void>]: (\n    e: IpcMainInvokeEvent,\n    ...args: Parameters<T[P]>\n  ) => Promise<ReturnType<T[P]>>\n}\n\nexport class IpcMainProvider {\n  private readonly clazzMap = new Map<string, object>()\n\n  /**\n   * 计算主进程监听的 key\n   * @param namespace\n   * @param method\n   * @private\n   */\n  private static getKey<T>(namespace: string, method: PropertyKey) {\n    return namespace + '.' + method.toString()\n  }\n\n  register<T extends BaseDefine<string>>(\n    namespace: T['namespace'],\n    api: IpcMainDefine<T>,\n  ): IpcMainDefine<T> {\n    const instance = ClassUtil.bindMethodThis(api)\n    const methods = ClassUtil.scan(instance)\n    methods.forEach((method) => {\n      const key = IpcMainProvider.getKey(namespace, method)\n      ipcMain.handle(key, instance[method] as any)\n      console.log('Register ipcMain.handle: ', key)\n    })\n    this.clazzMap.set(namespace, instance)\n    return instance\n  }\n\n  unregister<T extends BaseDefine<string>>(\n    namespace: T['namespace'],\n    api: IpcMainDefine<T>,\n  ): void {\n    const methods = ClassUtil.scan(api)\n    methods.forEach((method) => {\n      const key = IpcMainProvider.getKey(namespace, method)\n      ipcMain.removeHandler(key)\n    })\n    this.clazzMap.delete(namespace)\n  }\n}\n```\n\nelectron_ipc_renderer: 渲染进程\n\n```ts\nexport type FilteredKeys<T, U> = {\n  [P in keyof T]: T[P] extends U ? P : never\n}[keyof T]\n\n/**\n * 转换为一个渲染进程可以调用的 Proxy 对象\n */\nexport type IpcRendererDefine<T> = {\n  [P in FilteredKeys<T, (...args: any[]) => void>]: (\n    ...args: Parameters<T[P]>\n  ) => Promise<ReturnType<T[P]>>\n}\n\nexport class NotElectronEnvError extends Error {}\n\nexport class IpcRendererClient {\n  /**\n   * 生成一个客户端实例\n   * @param namespace\n   */\n  static gen<T extends BaseDefine<string>>(\n    namespace: T['namespace'],\n  ): IpcRendererDefine<T> {\n    return new Proxy(Object.create(null), {\n      get(target: any, api: string): any {\n        const key = namespace + '.' + api\n        return function (...args: any[]) {\n          const ipcRenderer = IpcRendererClient.getRenderer()\n          if (!ipcRenderer) {\n            throw new NotElectronEnvError('当前你不在 electron 进程中')\n          }\n          return ipcRenderer.invoke(key, ...args)\n        }\n      },\n    })\n  }\n\n  /**\n   * 获取 electron ipc renderer 实例\n   */\n  static getRenderer(): IpcRenderer | null {\n    if (!isElectron()) {\n      return null\n    }\n    return window.require('electron').ipcRenderer as IpcRenderer\n  }\n}\n```\n\n---\n\n使用\n\n在 apps 下创建一个模块 `shared_type`，里面包含一些渲染进程与主进程之间共享的类型，下面是一个简单的示例\n\n```ts\n// HelloDefine.ts\nexport interface HelloDefine extends BaseDefine<'HelloApi'> {\n  hello(name: string): string\n}\n```\n\n在主进程中使用 class 实现它并注册\n\n```ts\n// main.ts\n\nclass HelloApi {\n  async hello(e: IpcMainInvokeEvent, name: string) {\n    return `hello ${name}`\n  }\n}\nconst ipcMainProvider = new IpcMainProvider()\n\nipcMainProvider.register<HelloDefine>('HelloApi', new HelloApi())\n```\n\n在渲染进程中创建客户端对象并使用\n\n```ts\nconst helloApi = IpcRendererClient.gen<HelloDefine>('HelloApi')\n\nconst str = await helloApi.hello('liuli')\n```\n\n## 实现主进程 => 渲染进程\n\n由于吾辈的 ui 层框架使用了 react，所以基于 class 的模式在此并不适用，需要使用某种变通的方式（吾辈仍然不愿意放弃将 class 作为命名空间的想法）。\n\n```ts\ntype IpcRendererProviderDefine<\n  T extends BaseDefine<string>,\n  P extends FunctionKeys<T> = FunctionKeys<T>\n> = [\n  type: P,\n  callback: (e: any, ...args: Parameters<T[P]>) => Promise<ReturnType<T[P]>>,\n]\n\ntype IpcRendererProviderHooksDefine<\n  T extends BaseDefine<string>,\n  P extends FunctionKeys<T> = FunctionKeys<T>\n> = [\n  type: P,\n  callback: (e: any, ...args: Parameters<T[P]>) => Promise<ReturnType<T[P]>>,\n  deps?: DependencyList,\n]\n\n/**\n * 在渲染层管理提供者\n */\nexport class IpcRendererProvider<T extends BaseDefine<any>> {\n  private apiMap = new Map<string, (...args: any[]) => any>()\n\n  constructor(private namespace: T['namespace']) {}\n\n  register(...[type, callback]: IpcRendererProviderDefine<T>) {\n    const ipcRenderer = IpcRendererClient.getRenderer()\n    if (ipcRenderer === null) {\n      console.warn('不在 electron 环境，取消注册: ', type)\n      return\n    }\n    const key = this.namespace + '.' + type\n    console.log('IpcRendererProvider.register: ', key)\n    const listener = async (event: any, id: string, ...args: any[]) => {\n      try {\n        console.log('IpcRendererProvider.listener: ', event, id, args)\n        const res = await callback(event, ...(args as any))\n        await ipcRenderer.send(id, null, res)\n      } catch (e) {\n        await ipcRenderer.send(id, e)\n      }\n    }\n    ipcRenderer.on(key, listener)\n    this.apiMap.set(key, listener)\n  }\n\n  unregister(type: IpcRendererProviderDefine<T>[0]) {\n    const ipcRenderer = IpcRendererClient.getRenderer()\n    if (ipcRenderer === null) {\n      return\n    }\n    const key = this.namespace + '.' + type\n    ipcRenderer.off(key, this.apiMap.get(key)!)\n    this.apiMap.delete(key)\n  }\n\n  /**\n   * react 中的注册钩子，自动管理清理的操作\n   * @param type\n   * @param callback\n   * @param deps\n   */\n  useIpcProvider(\n    ...[type, callback, deps = []]: IpcRendererProviderHooksDefine<T>\n  ) {\n    useEffect(() => {\n      this.register(type, callback)\n      return () => this.unregister(type)\n    }, deps)\n  }\n}\n```\n\n```ts\n/**\n * 转换为一个渲染进程可以调用的 Proxy 对象\n */\nexport type IpcClientDefine<T extends object> = {\n  [P in FunctionKeys<T>]: (\n    ...args: Parameters<T[P]>\n  ) => Promise<ReturnType<T[P]>>\n}\n\n/**\n * 客户端\n */\nexport class IpcMainClient {\n  /**\n   * 生成一个客户端实例\n   * @param namespace\n   * @param win\n   */\n  static gen<T extends BaseDefine<string>>(\n    namespace: T['namespace'],\n    win: BrowserWindow,\n  ): IpcClientDefine<T> {\n    return new Proxy(Object.create(null), {\n      get<K extends FunctionKeys<T>>(target: any, api: K): any {\n        const key = namespace + '.' + api\n        return function (...args: any[]) {\n          return new Promise<ReturnType<T[K]>>((resolve, reject) => {\n            const id = Date.now() + '-' + Math.random()\n            ipcMain.once(id, (event, err, res) => {\n              console.log('callback: ', err, res)\n              if (err) {\n                reject(err)\n                return\n              }\n              resolve(res)\n            })\n            console.log('send: ', key, id, args)\n            win.webContents.send(key, id, ...(args as any))\n          })\n        }\n      },\n    })\n  }\n}\n```\n\n---\n\n使用\n\n在渲染进程使用 hooks 注册它\n\n```ts\nconst ipcRendererProvider = new IpcRendererProvider<HelloApiDefine>('HelloApi')\n\nipcRendererProvider.useIpcProvider('hello', async (e, name) => {\n  return `hello ${name}`\n})\n```\n\n在主进程生成客户端实例调用它\n\n```ts\nconst helloApi = IpcMainClient.gen<HelloApiDefine>(\n  'HelloApi',\n  new BrowserWindow(),\n)\nconst str = await helloApi.hello('liuli')\n```\n\n## 约定俗成\n\n- 在 `shared_type` 模块中的接口定义总是 `*Define` 形式，且实现的 `BaseDefine<T>` 泛型参数是 `*Api` 形式\n- 在 `main` 模块中实现的 class 总是 `*Api` 形式\n- 在 `renderer` 模块中获取的 client 实例总是 `*Api` 小写驼峰形式\n- 实现 `BaseDefine<T>` 传入的命名空间参数不应该重复\n\n## 总结\n\nelectron 本身的进程通信 api 在逐渐发展，但目前仍然没有足够好用，所以吾辈不得不进行了封装。\n","createdTime":1609807586398,"updatedTime":1617895696307,"resources":[{"id":"a744f749ef6f4652aa82f5dbcb1e22d8","title":"设计图.drawio.svg","file_extension":"svg","user_updated_time":1616321773385}],"tags":[{"id":"b50c8282004d48edae677ecdfb933e9f","title":"electron","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"b91c8378f6594f2996bc437e587c0420","title":"为什么现在还要选择盗版","body":"> 你可能是一位正版的受害者\n\n## 前言\n\n总的来说，在工作之后力所能及的情况下，对于支持正版，吾辈是举双手赞成的，因为吾辈作为创作者的一类--开发者，确实明白为有价值的事物付费是理所当然的。对于各类服务、软件、App，吾辈并不吝于付费。\n\n简要列出一些\n\n- Steam 游戏：2446 软妹币/去年\n- JetBrains IDE 系列：$199/y\n- Wallaby/Quokka：$150/y\n- Proxifier 透明代理：$39.95\n- BosLife 机场云服务：459 软妹币/y\n- Nexitally 机场云服务：798 软妹币/y\n- 百度网盘：198 软妹币/y\n- GitHub 捐款：$24/y\n- App 购买\n  - 不做手机控（未使用）\n  - Sleep Cycle\n  - 欧路词典\n  - NeatReader\n  - 静读天下\n\n## 思考\n\n但是，这并非代表吾辈不再使用盗版了，不如说，至今为止，在网络小说、日本动画方面，吾辈仍然会优先选择盗版。\n是的，不管是网络小说的订阅也好，网站的会员也罢，它们对于已然工作的人而言成本并不算高 -- 当然，这并不代表成本为 0。\n\n吾辈不想入正的真正原因是：**不想成为正版的受害者。**\n\n1. 事实上，没有一家网站拥有所有小说、动画的版权，这意味着想看的内容分散到各个网站中时，那么必须在不同的平台上多次付费，这点不管是从使用体验上，还是从成本上而言，都是难以接受的。\n2. 动画方面在平台上随时有可能被和谐、下架或整改，而小说，由于数量之多，导致被删除的数不胜数，即便你已经付费了，在删除后仍然无法查看（这里必须顶一下 Steam，至少，吾辈现在还能玩**还愿**）\n\n这里还必须点名批评 bilibili 和 刺猬猫（原名书客）\n\n## bilibili\n\nbilibili 自从某个时期开始，就已经变成了自己最讨厌的样子，有多久没有使用过 b 站了呢？吾辈也忘记了呢\n\n- 新番资源不全\n- 新番存在删减\n- 旧番（没有版权）被删除\n- 整体氛围随着更多人的涌入严重下降\n\n> - [bilibili 相关争议](https://zh.wikipedia.org/wiki/Bilibili%E7%9B%B8%E5%85%B3%E4%BA%89%E8%AE%AE)\n> - 国内任何产品都是用户多了就一定变烂，参考：[第 46 次《中国互联网络发展状况统计报告》](http://www.gov.cn/xinwen/2020-09/29/content_5548176.htm) **网民结构** 一节\n\n## 刺猬猫\n\n刺猬猫的话，相比于起点，令人讨厌之处在于将文字转图片的方式显示，以致于很难找到盗版网站。简而言之，互联网上的信息不再公开，也基本难以长存，人们常说，互联网是有记忆的，那么，像这种事情又算什么呢？\n\n吾辈已经不是第一次遇到查看小说时看到这个页面的情况了\n\n![1617220590795](:/3b4cc0d9ba694947bed9aa224cfc5c04)\n\n起点有时候似乎更聪明了一些，小说首页仍然可见，但无法阅读任何章节。嗯，在封禁了作品之后，仍然使用作品来吸引流量，真是厉害了。\n\n简单列举一些吾辈看过且和谐的作品\n\n- 事象的宏图\n- 逃亡犯报告\n- 永不解密\n- 腹黑三无少女日记\n- 科技超能王\n- 法师伊凡\n- 迷失在星空\n- 细胞渗透\n- 独游\n- 天麻・续章\n- 今夜，爱丽丝加入狩猎\n- 天才麻将少女之岭上雪花\n- 幻想乡玩家\n\n有些小说吾辈甚至没想明白为什么会和谐，毕竟看美少女打超能力麻将会有什么问题呢？\n\n## 替代方案\n\n那么，下面简要列出一些吾辈的替代方案\n\n动画\n\n- 新番 bt 网站：[动漫花园](https://dmhy.org/)\n- 老番百度网盘下载论坛：[天使动漫论坛](https://www.tsdm39.net/)\n- bt 下载工具：[qBittorrent](https://www.qbittorrent.org/)\n\n小说\n\n- 查找方式：[Google](http://google.com/)\n- 阅读器：[静读天下 Pro](https://play.google.com/store/apps/details?id=com.flyersoft.moonreaderp&hl=zh&gl=US)\n\n## 总结\n\n有时候，不是不肯付费，而是即便付费成为正版之后体验比盗版更烂，当然你也可以说吾辈是在找借口就是了。\n","createdTime":1617218851261,"updatedTime":1617430535642,"resources":[{"id":"3b4cc0d9ba694947bed9aa224cfc5c04","title":"1617220590795","file_extension":"png","user_updated_time":1617220591300}],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"f6802ba280a8479abe0cf6f908a2f273","title":"2021 第十二周","body":"## 快速一览\r\n\r\n- 回到老家\r\n- 看望姥姥\r\n- 继续购买睡衣（其实是购物减压啦）\r\n- 饭局 \\* 2\r\n- 算法：尝试理解**高楼扔鸡蛋**的问题\r\n\r\n## 生活\r\n\r\n好吧，这（上）周的记录好像写的有些晚了，不过吾辈今天才离开家里，所以便在高铁上写下了这篇。\r\n这周完全是在老家度过的，本以为现在家里的天气会很冷，为之吾辈还带了一件厚衣服，但实际上仅仅只有早晨和傍晚才会比较冷，白天最高 20+°C 的温度让吾辈仅仅能穿一件薄外套，幸好考虑到从广州出发会不太冷所以带了。这么说吧，回家的时间还是很无聊的，没有网络（虽然可以使用流量）、没有人玩（小孩子也都在上学）。\r\n\r\n---\r\n\r\n虽然仅仅只有 3 年，但家里的样子已然有了许多变化。曾经家乡小伙伴的奶奶死了，房子的围墙也倒掉了。家里的池塘已经变成了肉眼可见的污浊，据说是因为之前有人养猪直接将粪便之类的排入到水中所致。村庄里面的小路已经有许多不再是路，不是被堵住，就是被当成田地种上了油菜花。看到曾经童年时的一大片草地被人用挖土机挖了一个大坑卖土壤，就觉得家乡人真是无药可救了。\r\n\r\n> 感觉从丰富程度上而言，上学时期几乎占据了人生一半的长度\r\n\r\n![1617010201279](:/4b8b5e37ff5b452dba33ffc68d781b3c)\r\n![1617010212626](:/ce0f530357dd4ca3b4a6a3cf06476284)\r\n\r\n---\r\n\r\n比较麻烦的是奶奶，由于她的耳朵不太好，再加上吾辈说的是普通话，所以非常难以交流，而且总是容易出现**表达与行动的错位**，即好心办坏事。下面说一个简单的例子：\r\n\r\n- 吾辈：奶奶你做饭太多了，吃不完。\r\n- 奶奶：不够吃怎么办？\r\n- 吾辈：我能吃多少啊\r\n- 奶奶：你不吃谁吃呢？\r\n- 吾辈（心声）：做多了吾辈也只能吃掉避免浪费，到底如何让她明白合适才是最好的呢？\r\n\r\n虽然和母上也会有类似的情况，但次数少的多，毕竟可以通过交流让她清除吾辈的饭量，但对于难以沟通的奶奶这种方法便没有了效果。\r\n\r\n---\r\n\r\n当吾辈心情有些烦躁时，就会想去购物，是不是向奇怪的方向变化了？\r\n这周主要是买了三件睡衣\r\n\r\n![1617008270263](:/02e2a8b1563c494e8799cc6d753ceac2)\r\n\r\n---\r\n\r\n找到了吾辈曾经的秘密宝箱（开玩笑的），翻出了一些有趣的东西。\r\n\r\n![曾经喜欢的东西](:/15109e9b841d4a7e862f230907335460)\r\n![学习日语的记录](:/498d35a6b71f47fc86fc9fdc6e5d8fd8)\r\n![喜欢二次元萝莉的本子](:/4d86955cfa7746d79e8cbfe69f30a567)\r\n\r\n其实还有一些上个世纪爷爷辈的**东西**，不过这里就不放出来了，毕竟是一些麻烦的东西。\r\n\r\n---\r\n\r\n拍的几张家里的照片，就莫名觉得还不错\r\n\r\n![1617010003098](:/5e3bf3cc18124c0f963b3fbcaef52d0d)\r\n![1617010072110](:/8f2d8b72748a4d6cbd6ca2002f97b662)\r\n![1617010153382](:/8c25384a4b8d467e8228581a01dfd8ec)\r\n![1617010109606](:/a99dac276deb4d68ac8bcd2c181215f8)\r\n![1617010120241](:/234d2e51d52d4547add5852e58769b9f)\r\n![1617010044579](:/4eec707c2eb9407785aa7be74cc85538)\r\n\r\n## 一些认知\r\n\r\n### 亲戚\r\n\r\n因为吾辈的爷爷有许多姐姐，所以从爷爷辈的算起，大概总的亲戚数量超过 100 人。而吾辈能记住的，不过寥寥十数人罢了，可能某些亲戚吾辈几乎没见过。是说，明明可能很久没有见过的人，却说自己是亲戚，然后就自来熟的说起话，吾辈很讨厌。\r\n\r\n经过周六晚上的一顿饭局，吾辈明白了为什么吾辈之前不喜欢参加家乡饭局的原因\r\n\r\n- 铺张浪费的食物\r\n- 吹牛\r\n- 擅自对别人评头论足\r\n- 不分轻重的开玩笑\r\n\r\n无论如何，吾辈回家仅仅是为了看望记忆中的那些人，并不是很在乎别人是怎么想的。\r\n\r\n### 金钱\r\n\r\n不管是吾辈，还是家乡的人，现在真是一切向钱看了。几乎每个吾辈见到的亲戚，在和吾辈聊天时很快就会转到工作，和婚姻上。\r\n\r\n他们对计算机行业的基本认知是\r\n\r\n- 高收入\r\n- 跳槽可以涨薪\r\n\r\n但他们却并不了解这个行业的内卷，吾辈感受到的压力、焦虑和痛苦。\r\n\r\n> 人类的悲欢并不相通\r\n\r\n### 婚姻\r\n\r\n悲剧的螺旋。\r\n\r\n在吾辈看来，在很年轻的时候就去相亲、结婚、生孩子，早早地定下一切，最终不过是让自己的孩子面临着和自己相同的问题。简而言之，就是变成留守儿童。\r\n曾经有句谚语：**龙生龙，凤生凤，老鼠生来会打洞**，那么，有人愿意自己的孩子和自己一样因为各种原因（教育、医疗资源、房贷），导致生活困顿么？\r\n不会，为人父母者，总是期望自己的孩子能比自己过的更好。但是啊，但是呢，如果自己都做不到的事情，为什么会有孩子能够做到的期望呢？\r\n那么破局的方法在哪里？\r\n改变阶层、或者离开，但这些都很难，以至于妥协和放弃反而是一件更容易的事情。\r\n或许在看不到希望的时候死掉也是一种不错的选择吧\r\n\r\n> 你们不肯入教（生韭菜）又不肯去死，我（国家）很为难啊\r\n\r\n### 习俗\r\n\r\n这次回家碰巧遇到了一位亲戚，大抵是吾辈姥姥的姐姐，他们回来过清明节，修坟、扫墓。但老实说，吾辈感觉家里的这些习俗还是声势浩大、铺张浪费了。\r\n\r\n![1617003181100](:/be00fdc1e1434359a23b631e7aba3f0a)\r\n\r\n[audio_2021-03-29_15-39-24.ogg](:/86a75805195648188a93c3a69c42c94d)\r\n\r\n放炮之后，好吵、好难闻\r\n\r\n![1617003644844](:/4052bf77bb3e40d88c358d10d759431b)\r\n\r\n[audio_2021-03-29_15-39-51.ogg](:/f71d62e8084f4288958ece97635aaabd)\r\n\r\n搞得像是打仗了一样 xd\r\n\r\n> 众所周知，土著这东西，一般都与盲目短视，愚昧落后，闭关自守这些美好品德紧密联系在一起。\r\n","createdTime":1617002130494,"updatedTime":1617336458936,"resources":[{"id":"02e2a8b1563c494e8799cc6d753ceac2","title":"1617008270263","file_extension":"png","user_updated_time":1617008271063},{"id":"15109e9b841d4a7e862f230907335460","title":"1617008710523","file_extension":"png","user_updated_time":1617008711183},{"id":"234d2e51d52d4547add5852e58769b9f","title":"1617010120241","file_extension":"png","user_updated_time":1617010120920},{"id":"4052bf77bb3e40d88c358d10d759431b","title":"1617003644844","file_extension":"png","user_updated_time":1617003645593},{"id":"498d35a6b71f47fc86fc9fdc6e5d8fd8","title":"1617008523235","file_extension":"png","user_updated_time":1617008523800},{"id":"4b8b5e37ff5b452dba33ffc68d781b3c","title":"1617010201279","file_extension":"png","user_updated_time":1617010202008},{"id":"4d86955cfa7746d79e8cbfe69f30a567","title":"1617010332150","file_extension":"png","user_updated_time":1617010332854},{"id":"4eec707c2eb9407785aa7be74cc85538","title":"1617010044579","file_extension":"png","user_updated_time":1617010045228},{"id":"5e3bf3cc18124c0f963b3fbcaef52d0d","title":"1617010003098","file_extension":"png","user_updated_time":1617010003826},{"id":"86a75805195648188a93c3a69c42c94d","title":"audio_2021-03-29_15-39-24.ogg","file_extension":"ogg","user_updated_time":1617003663525},{"id":"8c25384a4b8d467e8228581a01dfd8ec","title":"1617010153382","file_extension":"png","user_updated_time":1617010154014},{"id":"8f2d8b72748a4d6cbd6ca2002f97b662","title":"1617010072110","file_extension":"png","user_updated_time":1617010072797},{"id":"a99dac276deb4d68ac8bcd2c181215f8","title":"1617010109606","file_extension":"png","user_updated_time":1617010110200},{"id":"be00fdc1e1434359a23b631e7aba3f0a","title":"1617003181100","file_extension":"png","user_updated_time":1617003183038},{"id":"ce0f530357dd4ca3b4a6a3cf06476284","title":"1617010212626","file_extension":"png","user_updated_time":1617010213488},{"id":"f71d62e8084f4288958ece97635aaabd","title":"audio_2021-03-29_15-39-51.ogg","file_extension":"ogg","user_updated_time":1617003686771}],"tags":[{"id":"7e40798e7aec482f9a0c93ef1bef6673","title":"周报","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""},{"id":"f5172282f275485bab67f712ba1b1bcf","title":"个人","parent_id":""}]},{"id":"66325b0b4b014f038590904b67b65045","title":"JavaScript 异步数组","body":"## 场景\r\n\r\n> 吾辈是一只在飞向太阳的萤火虫\r\n\r\nJavaScript 中的数组是一个相当泛用性的数据结构，能当数组，元组，队列，栈进行操作，更好的是 JavaScript 提供了很多原生的高阶函数，便于我们对数组整体操作。\r\n然而，JavaScript 中的高阶函数仍有缺陷 -- 异步！当你把它们放在一起使用时，就会感觉到这种问题的所在。\r\n\r\n例如现在，有一组 id，我们要根据 id 获取到远端服务器 id 对应的值，然后将之打印出来。那么，我们要怎么做呢？\r\n\r\n```js\r\nconst wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms))\r\n\r\nasync function get(id) {\r\n  // 这里只是为了模拟每个请求的时间可能是不定的\r\n  await wait(Math.random() * id * 100)\r\n  return \"内容: \" + id.toString()\r\n}\r\n\r\nconst ids = [1, 2, 3, 4]\r\n```\r\n\r\n你或许会下意识地写出下面的代码\r\n\r\n```js\r\nids.forEach(async (id) => console.log(await get(id)))\r\n```\r\n\r\n事实上，控制台输出是无序的，而并非想象中的 1, 2, 3, 4 依次输出\r\n\r\n```sh\r\n内容: 2 ​​​​​\r\n内容: 3 ​​​​​\r\n内容: 1 ​​​​​\r\n内容: 4\r\n```\r\n\r\n这是为什么呢？原因便是 JavaScript 中数组的高阶函数并不会等待异步函数的返回！当你在网络上搜索时，会发现很多人会说可以使用 `for-of`, `for-in` 解决这个问题。\r\n\r\n```js\r\n;(async () => {\r\n  for (let id of ids) {\r\n    console.log(await get(id))\r\n  }\r\n})()\r\n```\r\n\r\n或者，使用 `Promise.all` 也是一种解决方案\r\n\r\n```js\r\n;(async () => {\r\n  ;(await Promise.all(ids.map(get))).forEach((v) => console.log(v))\r\n})()\r\n```\r\n\r\n然而，第一种方式相当于丢弃了 Array 的所有高阶函数，再次重返远古 `for` 循环时代了。第二种则一定会执行所有的异步函数，即便你需要使用的是 `find/findIndex/some/every` 这些高阶函数。那么，有没有更好的解决方案呢？\r\n\r\n## 思考\r\n\r\n既然原生的 Array 不支持完善的异步操作，那么，为什么不由我们来实现一个呢？\r\n\r\n实现思路:\r\n\r\n1. 创建异步数组类型 `AsyncArray`\r\n2. 内置一个数组保存当前异步操作数组的值\r\n3. 实现数组的高阶函数并实现支持异步函数顺序执行\r\n4. 获取到内置的数组\r\n\r\n```js\r\nclass AsyncArray {\r\n  constructor(...args) {\r\n    this._arr = Array.from(args)\r\n    this._task = []\r\n  }\r\n  async forEach(fn) {\r\n    const arr = this._arr\r\n    for (let i = 0, len = arr.length; i < len; i++) {\r\n      await fn(arr[i], i, this)\r\n    }\r\n  }\r\n}\r\n\r\nnew AsyncArray(...ids).forEach(async (id) => console.log(await get(id)))\r\n```\r\n\r\n打印结果确实有顺序了，看似一切很美好？\r\n\r\n然而，当我们再实现一个 `map` 试一下\r\n\r\n```js\r\nclass AsyncArray {\r\n  constructor(...args) {\r\n    this._arr = Array.from(args)\r\n  }\r\n  async forEach(fn) {\r\n    const arr = this._arr\r\n    for (let i = 0, len = arr.length; i < len; i++) {\r\n      await fn(arr[i], i, this)\r\n    }\r\n  }\r\n  async map(fn) {\r\n    const arr = this._arr\r\n    const res = []\r\n    for (let i = 0, len = arr.length; i < len; i++) {\r\n      res.push(await fn(arr[i], i, this))\r\n    }\r\n    return this\r\n  }\r\n}\r\n```\r\n\r\n调用一下\r\n\r\n```js\r\nnew AsyncArray(...ids).map(get).forEach(async (res) => console.log(res))\r\n// 抛出错误\r\n// (intermediate value).map(...).forEach is not a function\r\n```\r\n\r\n然而会有问题，实际上 `map` 返回的是 `Promise`，所以我们还必须使用 `await` 进行等待\r\n\r\n```js\r\n;(async () => {\r\n  ;(await new AsyncArray(...ids).map(get)).forEach(async (res) =>\r\n    console.log(res)\r\n  )\r\n})()\r\n```\r\n\r\n是不是感觉超级蠢？吾辈也是这样认为的！\r\n\r\n## 链式调用加延迟执行\r\n\r\n我们可以尝试使用链式调用加延迟执行修改这个 `AsyncArray`\r\n\r\n```js\r\n/**\r\n * 保存高阶函数传入的异步操作\r\n */\r\nclass Action {\r\n  constructor(type, args) {\r\n    /**\r\n     * @field 异步操作的类型\r\n     * @type {string}\r\n     */\r\n    this.type = type\r\n    /**\r\n     * @field 异步操作的参数数组\r\n     * @type {Function}\r\n     */\r\n    this.args = args\r\n  }\r\n}\r\n\r\n/**\r\n * 所有的操作类型\r\n */\r\nAction.Type = {\r\n  forEach: \"forEach\",\r\n  map: \"map\",\r\n  filter: \"filter\",\r\n}\r\n\r\n/**\r\n * 真正实现的异步数组\r\n */\r\nclass InnerAsyncArray {\r\n  constructor(arr) {\r\n    this._arr = arr\r\n  }\r\n  async forEach(fn) {\r\n    const arr = this._arr\r\n    for (let i = 0, len = arr.length; i < len; i++) {\r\n      await fn(arr[i], i, this)\r\n    }\r\n    this._arr = []\r\n  }\r\n  async map(fn) {\r\n    const arr = this._arr\r\n    const res = []\r\n    for (let i = 0, len = arr.length; i < len; i++) {\r\n      res.push(await fn(arr[i], i, this))\r\n    }\r\n    this._arr = res\r\n    return this\r\n  }\r\n  async filter(fn) {\r\n    const arr = this._arr\r\n    const res = []\r\n    for (let i = 0, len = arr.length; i < len; i++) {\r\n      if (await fn(arr[i], i, this)) {\r\n        res.push(arr[i])\r\n      }\r\n    }\r\n    this._arr = res\r\n    return this\r\n  }\r\n}\r\n\r\nclass AsyncArray {\r\n  constructor(...args) {\r\n    this._arr = Array.from(args)\r\n    /**\r\n     * @field 保存异步任务\r\n     * @type {Action[]}\r\n     */\r\n    this._task = []\r\n  }\r\n  forEach(fn) {\r\n    this._task.push(new Action(Action.Type.forEach, [fn]))\r\n    return this\r\n  }\r\n  map(fn) {\r\n    this._task.push(new Action(Action.Type.map, [fn]))\r\n    return this\r\n  }\r\n  filter(fn) {\r\n    this._task.push(new Action(Action.Type.filter, [fn]))\r\n    return this\r\n  }\r\n  /**\r\n   * 终结整个链式操作并返回结果\r\n   */\r\n  async value() {\r\n    const arr = new InnerAsyncArray(this._arr)\r\n    let result\r\n    for (let task of this._task) {\r\n      result = await arr[task.type](...task.args)\r\n    }\r\n    return result\r\n  }\r\n}\r\n```\r\n\r\n使用一下\r\n\r\n```js\r\nnew AsyncArray(...ids)\r\n  .filter(async (i) => i % 2 === 0)\r\n  .map(get)\r\n  .forEach(async (res) => console.log(res))\r\n  .value()\r\n```\r\n\r\n可以看到，确实符合预期了，然而每次都要调用 `value()`，终归有些麻烦。\r\n\r\n## 使用 then 以支持 await 自动结束\r\n\r\n这里使用 `then()` 替代它以使得可以使用 `await` **自动**计算结果\r\n\r\n```js\r\nclass AsyncArray {\r\n  // 上面的其他内容...\r\n  /**\r\n   * 终结整个链式操作并返回结果\r\n   */\r\n  async then(resolve) {\r\n    const arr = new InnerAsyncArray(this._arr)\r\n    let result\r\n    for (let task of this._task) {\r\n      result = await arr[task.type](...task.args)\r\n    }\r\n    // 这里使用 resolve(result) 是为了兼容 await 的调用方式\r\n    resolve(result)\r\n    return result\r\n  }\r\n}\r\n```\r\n\r\n现在，可以使用 `await` 结束这次链式调用了\r\n\r\n```js\r\nawait new AsyncArray(...ids).map(get).forEach(async (res) => console.log(res))\r\n```\r\n\r\n突然之间，我们发现了一个问题，为什么会这么慢？一个个去进行异步操作太慢了，难道就不能一次性全部发送出去，然后有序的处理结果就好了嘛？\r\n\r\n## 并发异步操作\r\n\r\n我们可以使用 `Promise.all` 并发执行异步操作，然后对它们的结果进行有序地处理。\r\n\r\n```js\r\n/**\r\n * 并发实现的异步数组\r\n */\r\nclass InnerAsyncArrayParallel {\r\n  constructor(arr) {\r\n    this._arr = arr\r\n  }\r\n  async _all(fn) {\r\n    return Promise.all(this._arr.map(fn))\r\n  }\r\n  async forEach(fn) {\r\n    await this._all(fn)\r\n    this._arr = []\r\n  }\r\n  async map(fn) {\r\n    this._arr = await this._all(fn)\r\n    return this\r\n  }\r\n  async filter(fn) {\r\n    const arr = await this._all(fn)\r\n    this._arr = this._arr.filter((v, i) => arr[i])\r\n    return this\r\n  }\r\n}\r\n```\r\n\r\n然后修改 `AsyncArray`，使用 `_AsyncArrayParallel` 即可\r\n\r\n```js\r\nclass AsyncArray {\r\n  // 上面的其他内容...\r\n  /**\r\n   * 终结整个链式操作并返回结果\r\n   */\r\n  async then(resolve) {\r\n    const arr = new InnerAsyncArrayParallel(this._arr)\r\n    let result = this._arr\r\n    for (let task of this._task) {\r\n      result = await arr[task.type](...task.args)\r\n    }\r\n    // 这里使用 resolve(result) 是为了兼容 await 的调用方式\r\n    if (resolve) {\r\n      resolve(result)\r\n    }\r\n    return result\r\n  }\r\n}\r\n```\r\n\r\n调用方式不变。当然，由于使用 `Promise.all` 实现，也同样受到它的限制 -- 异步操作实际上全部执行了。\r\n\r\n## 串行/并行相互转换\r\n\r\n现在我们的 `_AsyncArray` 和 `_AsyncArrayParallel` 两个类只能二选一，所以，我们需要添加两个函数用于互相转换。\r\n\r\n```js\r\nclass AsyncArray {\r\n  constructor(...args) {\r\n    this._arr = Array.from(args)\r\n    /**\r\n     * @field 保存异步任务\r\n     * @type {AsyncArrayAction[]}\r\n     */\r\n    this._task = []\r\n    /**\r\n     * 是否并行化\r\n     */\r\n    this._parallel = false\r\n  }\r\n  // 其他内容...\r\n\r\n  parallel() {\r\n    this._parallel = true\r\n    return this\r\n  }\r\n  serial() {\r\n    this._parallel = false\r\n    return this\r\n  }\r\n  async then() {\r\n    const arr = this._parallel\r\n      ? new InnerAsyncArrayParallel(this._arr)\r\n      : new InnerAsyncArray(this._arr)\r\n    let result = this._arr\r\n    for (let task of this._task) {\r\n      result = await arr[task.type](...task.args)\r\n    }\r\n    if (resolve) {\r\n      resolve(result)\r\n    }\r\n    return result\r\n  }\r\n}\r\n```\r\n\r\n现在，我们可以在真正执行之前在任意位置对其进行转换了\r\n\r\n```js\r\nawait new AsyncArray(...ids)\r\n  .parallel()\r\n  .filter(async (i) => i % 2 === 0)\r\n  .map(get)\r\n  .forEach(async (res) => console.log(res))\r\n```\r\n\r\n## 并发执行多个异步操作\r\n\r\n然而，上面的代码有一些隐藏的问题\r\n\r\n1. `await` 之后返回值不是一个数组\r\n\r\n   ```js\r\n   ;(async () => {\r\n     const asyncArray = new AsyncArray(...ids)\r\n     console.log(await asyncArray.map((i) => i * 2)) // InnerAsyncArray { _arr: [ 2, 4, 6, 8 ] }\r\n   })()\r\n   ```\r\n\r\n2. 上面的 `map`, `filter` 调用在 `await` 之后仍会影响到下面的调用\r\n\r\n   ```js\r\n   ;(async () => {\r\n     const asyncArray = new AsyncArray(...ids)\r\n     console.log(await asyncArray.map((i) => i * 2)) // InnerAsyncArray { _arr: [ 2, 4, 6, 8 ] }\r\n     console.log(await asyncArray) // InnerAsyncArray { _arr: [ 2, 4, 6, 8 ] }\r\n   })()\r\n   ```\r\n\r\n3. 并发调用的顺序不能确定，会影响到内部数组，导致结果不能确定\r\n\r\n   ```js\r\n   ;(async () => {\r\n     const asyncArray = new AsyncArray(...ids)\r\n     ;(async () => {\r\n       console.log(\r\n         await asyncArray\r\n           .filter(async (i) => i % 2 === 1)\r\n           .map(async (i) => i * 2)\r\n       ) // InnerAsyncArray { _arr: [ 2, 6 ] }\r\n     })()\r\n     ;(async () => {\r\n       console.log(await asyncArray) // InnerAsyncArray { _arr: [ 2, 6 ] }\r\n     })()\r\n   })()\r\n   ```\r\n\r\n先解决第一个问题，这里只需要判断一下是否为终结操作（`forEach`），是的话就直接返回结果，否则继续下一次循环\r\n\r\n```js\r\nclass AsyncArray {\r\n  // 其他内容...\r\n\r\n  async then(resolve, reject) {\r\n    const arr = this._parallel\r\n      ? new InnerAsyncArrayParallel(this._arr)\r\n      : new InnerAsyncArray(this._arr)\r\n    let result = this._arr\r\n    for (let task of this._task) {\r\n      const temp = await arr[task.type](...task.args)\r\n      if (\r\n        temp instanceof InnerAsyncArray ||\r\n        temp instanceof InnerAsyncArrayParallel\r\n      ) {\r\n        result = temp._arr\r\n      } else {\r\n        // 如果已经是终结操作就返回数组的值\r\n        if (resolve) {\r\n          resolve(temp)\r\n        }\r\n        return temp\r\n      }\r\n    }\r\n    if (resolve) {\r\n      resolve(result)\r\n    }\r\n    return result\r\n  }\r\n}\r\n```\r\n\r\n现在，第一个问题简单解决\r\n\r\n```js\r\n;(async () => {\r\n  const asyncArray = new AsyncArray(...ids)\r\n  console.log(await asyncArray.map((i) => i * 2)) // [ 2, 4, 6, 8 ]\r\n})()\r\n```\r\n\r\n第二、第三个问题看起来似乎是同一个问题？其实我们可以按照常规思维解决第一个问题。既然 `await` 之后仍然会影响到下面的调用，那就在 `then` 中把 `_task` 清空好了，修改 `then` 函数\r\n\r\n```js\r\nclass AsyncArray {\r\n  // 其他内容...\r\n\r\n  async then(resolve, reject) {\r\n    const arr = this._parallel\r\n      ? new InnerAsyncArrayParallel(this._arr)\r\n      : new InnerAsyncArray(this._arr)\r\n    let result = this._arr\r\n    for (let task of this._task) {\r\n      const temp = await arr[task.type](...task.args)\r\n      if (\r\n        temp instanceof InnerAsyncArray ||\r\n        temp instanceof InnerAsyncArrayParallel\r\n      ) {\r\n        result = temp._arr\r\n      } else {\r\n        // 如果已经是终结操作就返回数组的值\r\n        if (resolve) {\r\n          resolve(temp)\r\n        }\r\n        this._task = []\r\n        return temp\r\n      }\r\n    }\r\n    if (resolve) {\r\n      resolve(result)\r\n    }\r\n    this._task = []\r\n    return result\r\n  }\r\n}\r\n```\r\n\r\n现在，第一个问题解决了，但第二个问题不会解决。究其原因，还是异步事件队列的问题，虽然 `async-await` 能够让我们以同步的方式写异步的代码，但千万不可忘记它们本质上还是**异步**的！\r\n\r\n```js\r\n;(async () => {\r\n  await Promise.all([\r\n    (async () => {\r\n      console.log(\r\n        await asyncArray\r\n          .filter(async (i) => i % 2 === 1)\r\n          .map(async (i) => i * 2)\r\n      ) // [ 2, 6 ]\r\n    })(),\r\n    (async () => {\r\n      console.log(await asyncArray) // [ 2, 6 ]\r\n    })(),\r\n  ])\r\n  console.log(await asyncArray) // [ 1, 2, 3, 4 ]\r\n})()\r\n```\r\n\r\n可以看到，在使用 `await` 进行等待之后就如同预期的 `_task` 被清空了。然而，并发执行的没有等待的 `await asyncArray` 却有奇怪的问题，因为它是在 `_task` 清空之前执行的。\r\n\r\n并且，这带来一个副作用: 无法缓存操作了\r\n\r\n```js\r\n;(async () => {\r\n  const asyncArray = new AsyncArray(...ids).map((i) => i * 2)\r\n  console.log(await asyncArray) // [ 2, 4, 6, 8 ]\r\n  console.log(await asyncArray) // [ 1, 2, 3, 4 ]\r\n})()\r\n```\r\n\r\n## 使用不可变数据\r\n\r\n为了解决直接修改内部数组造成的问题，我们可以使用不可变数据解决这个问题。试想：如果我们每次操作都返回一个新的 `AsyncArray`，他们之间没有关联，这样又如何呢？\r\n\r\n```js\r\nclass AsyncArray {\r\n  constructor(...args) {\r\n    this._arr = Array.from(args)\r\n    /**\r\n     * @field 保存异步任务\r\n     * @type {Action[]}\r\n     */\r\n    this._task = []\r\n    /**\r\n     * 是否并行化\r\n     */\r\n    this._parallel = false\r\n  }\r\n  forEach(fn) {\r\n    return this._addTask(Action.Type.forEach, [fn])\r\n  }\r\n  map(fn) {\r\n    return this._addTask(Action.Type.map, [fn])\r\n  }\r\n  filter(fn) {\r\n    return this._addTask(Action.Type.filter, [fn])\r\n  }\r\n  parallel() {\r\n    this._parallel = true\r\n    return this\r\n  }\r\n  serial() {\r\n    this._parallel = false\r\n    return this\r\n  }\r\n  _addTask(type, args) {\r\n    const result = new AsyncArray(...this._arr)\r\n    result._task = [...this._task, new Action(type, args)]\r\n    result._parallel = this._parallel\r\n    return result\r\n  }\r\n  /**\r\n   * 终结整个链式操作并返回结果\r\n   */\r\n  async then(resolve, reject) {\r\n    const arr = this._parallel\r\n      ? new InnerAsyncArrayParallel(this._arr)\r\n      : new InnerAsyncArray(this._arr)\r\n    let result = this._arr\r\n    for (let task of this._task) {\r\n      const temp = await arr[task.type](...task.args)\r\n      if (\r\n        temp instanceof InnerAsyncArray ||\r\n        temp instanceof InnerAsyncArrayParallel\r\n      ) {\r\n        result = temp._arr\r\n      } else {\r\n        // 如果已经是终结操作就返回数组的值\r\n        if (resolve) {\r\n          resolve(temp)\r\n        }\r\n        return temp\r\n      }\r\n    }\r\n    if (resolve) {\r\n      resolve(result)\r\n    }\r\n    return result\r\n  }\r\n}\r\n```\r\n\r\n再次测试上面的那第三个问题，发现已经一切正常了呢\r\n\r\n- 并发调用的顺序不能确定，但不会影响内部数组了，结果是确定的\r\n\r\n```js\r\n;(async () => {\r\n  const asyncArray = new AsyncArray(...ids)\r\n  await Promise.all([\r\n    (async () => {\r\n      console.log(\r\n        await asyncArray\r\n          .filter(async (i) => i % 2 === 1)\r\n          .map(async (i) => i * 2)\r\n      ) // [ 2, 6 ]\r\n    })(),\r\n    (async () => {\r\n      console.log(await asyncArray) // [ 1, 2, 3, 4 ]\r\n    })(),\r\n  ])\r\n  console.log(await asyncArray) // [ 1, 2, 3, 4 ]\r\n})()\r\n```\r\n\r\n- 操作可以被缓存\r\n\r\n```js\r\n;(async () => {\r\n  const asyncArray = new AsyncArray(...ids).map((i) => i * 2)\r\n  console.log(await asyncArray) // [ 2, 4, 6, 8 ]\r\n  console.log(await asyncArray) // [ 2, 4, 6, 8 ]\r\n})()\r\n```\r\n\r\n## 完整代码\r\n\r\n下面吾辈把完整的代码贴出来\r\n\r\n```js\r\n/**\r\n * 保存高阶函数传入的异步操作\r\n */\r\nclass Action {\r\n  constructor(type, args) {\r\n    /**\r\n     * @field 异步操作的类型\r\n     * @type {string}\r\n     */\r\n    this.type = type\r\n    /**\r\n     * @field 异步操作的参数数组\r\n     * @type {Function}\r\n     */\r\n    this.args = args\r\n  }\r\n}\r\n\r\n/**\r\n * 所有的操作类型\r\n */\r\nAction.Type = {\r\n  forEach: \"forEach\",\r\n  map: \"map\",\r\n  filter: \"filter\",\r\n}\r\n\r\n/**\r\n * 真正实现的异步数组\r\n */\r\nclass InnerAsyncArray {\r\n  constructor(arr) {\r\n    this._arr = arr\r\n  }\r\n  async forEach(fn) {\r\n    const arr = this._arr\r\n    for (let i = 0, len = arr.length; i < len; i++) {\r\n      await fn(arr[i], i, this)\r\n    }\r\n    this._arr = []\r\n  }\r\n  async map(fn) {\r\n    const arr = this._arr\r\n    const res = []\r\n    for (let i = 0, len = arr.length; i < len; i++) {\r\n      res.push(await fn(arr[i], i, this))\r\n    }\r\n    this._arr = res\r\n    return this\r\n  }\r\n  async filter(fn) {\r\n    const arr = this._arr\r\n    const res = []\r\n    for (let i = 0, len = arr.length; i < len; i++) {\r\n      if (await fn(arr[i], i, this)) {\r\n        res.push(arr[i])\r\n      }\r\n    }\r\n    this._arr = res\r\n    return this\r\n  }\r\n}\r\n\r\nclass InnerAsyncArrayParallel {\r\n  constructor(arr) {\r\n    this._arr = arr\r\n  }\r\n  async _all(fn) {\r\n    return Promise.all(this._arr.map(fn))\r\n  }\r\n  async forEach(fn) {\r\n    await this._all(fn)\r\n    this._arr = []\r\n  }\r\n  async map(fn) {\r\n    this._arr = await this._all(fn)\r\n    return this\r\n  }\r\n  async filter(fn) {\r\n    const arr = await this._all(fn)\r\n    this._arr = this._arr.filter((v, i) => arr[i])\r\n    return this\r\n  }\r\n}\r\n\r\nclass AsyncArray {\r\n  constructor(...args) {\r\n    this._arr = Array.from(args)\r\n    /**\r\n     * @field 保存异步任务\r\n     * @type {Action[]}\r\n     */\r\n    this._task = []\r\n    /**\r\n     * 是否并行化\r\n     */\r\n    this._parallel = false\r\n  }\r\n  forEach(fn) {\r\n    return this._addTask(Action.Type.forEach, [fn])\r\n  }\r\n  map(fn) {\r\n    return this._addTask(Action.Type.map, [fn])\r\n  }\r\n  filter(fn) {\r\n    return this._addTask(Action.Type.filter, [fn])\r\n  }\r\n  parallel() {\r\n    this._parallel = true\r\n    return this\r\n  }\r\n  serial() {\r\n    this._parallel = false\r\n    return this\r\n  }\r\n  _addTask(type, args) {\r\n    const result = new AsyncArray(...this._arr)\r\n    result._task = [...this._task, new Action(type, args)]\r\n    result._parallel = this._parallel\r\n    return result\r\n  }\r\n  /**\r\n   * 终结整个链式操作并返回结果\r\n   */\r\n  async then(resolve, reject) {\r\n    const arr = this._parallel\r\n      ? new InnerAsyncArrayParallel(this._arr)\r\n      : new InnerAsyncArray(this._arr)\r\n    let result = this._arr\r\n    for (let task of this._task) {\r\n      const temp = await arr[task.type](...task.args)\r\n      if (\r\n        temp instanceof InnerAsyncArray ||\r\n        temp instanceof InnerAsyncArrayParallel\r\n      ) {\r\n        result = temp._arr\r\n      } else {\r\n        // 如果已经是终结操作就返回数组的值\r\n        if (resolve) {\r\n          resolve(temp)\r\n        }\r\n        return temp\r\n      }\r\n    }\r\n    if (resolve) {\r\n      resolve(result)\r\n    }\r\n    return result\r\n  }\r\n}\r\n```\r\n\r\n## 总结\r\n\r\n> 自边写这篇文章以来，吾辈的想法已经发生了许多变化，最新的 AsyncArray 请参考 [实现](https://github.com/rxliuli/liuli-util/blob/master/libs/async/src/AsyncArray.ts)。\r\n\r\n那么，关于 JavaScript 中如何封装一个可以使用异步操作高阶函数的数组就先到这里了，完整的 JavaScript 异步数组请参考吾辈的 [AsyncArray](https://github.com/rxliuli/liuli-util/blob/old/src/module/array/AsyncArray.ts)（使用 TypeScript 编写）。\r\n","createdTime":1580652937871,"updatedTime":1616505318180,"resources":[],"tags":[{"id":"1de1ff51140a44d5a2c223459dabcc37","title":"异步","parent_id":""},{"id":"a3f220fe6f2c4c50a1aa91707edb8741","title":"typescript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"0a4259c97ca440d1b5375f4e21eaaace","title":"electron 开发经验之谈系列-electron 自定义协议","body":"## 场景\n\n有时候需要与其他程序进行交互时，自定义协议是一个不错的选择 -- 它能在程序为启动时启动程序然后处理其它程序的动作，而这是其它解决方案，包括 HTTP 请求、共享数据库不能比的。其实日常生活中也有现成的例子，迅雷的自定义协议下载链接、BitTorrent 协议、百度网盘启动本地客户端等等。\n\n## 使用\n\n> 参考: [将当前可执行文件设置为协议的默认处理程序（注册表级别）](https://www.electronjs.org/docs/api/app#appsetasdefaultprotocolclientprotocol-path-args)\n\n1. 让程序保持单例启动\n2. 设置客户端支持的协议（在 Windows 中会写入到注册表）\n3. 处理命令行参数找到其中需要的 `url` 信息\n4. 监听 `ready` 和 `second-instance` 事件\n\n### 让程序保持单例启动\n\n> 参考: [app.requestSingleInstanceLock()](https://www.electronjs.org/docs/api/app#apprequestsingleinstancelock)\n> 注: 仅在单例模式下才能监听 `second-instance` 事件\n\n```ts\n// 请求单例锁，避免打开多个 electron 实例\nconst gotTheLock = app.requestSingleInstanceLock()\nif (!gotTheLock) {\n  app.quit()\n  return\n}\n```\n\n### 设置客户端支持的协议（在 Windows 中会写入到注册表）\n\n> 参考: [app.setAsDefaultProtocolClient(protocol[, path, args])](https://www.electronjs.org/docs/api/app#appsetasdefaultprotocolclientprotocol-path-args)\n\n```ts\nimport { app } from 'electron'\nimport path = require('path')\n\n/**\n * 客户端默认支持的协议\n */\nexport class DefaultProtocolClient {\n  constructor(public readonly protocol: string) {}\n\n  /**\n   * 注册一个默认支持打开的协议\n   */\n  register() {\n    // 开发模式下在 window 运行需要做兼容\n    if (\n      process.env.NODE_ENV === 'development' &&\n      process.platform === 'win32'\n    ) {\n      // 设置 electron.exe 和 app 的路径\n      app.setAsDefaultProtocolClient(this.protocol, process.execPath, [\n        path.resolve(process.argv[1]),\n      ])\n    } else {\n      app.setAsDefaultProtocolClient(this.protocol)\n    }\n  }\n\n  /**\n   * 从命令行参数中找到 url\n   * @param argv\n   */\n  findUrl(argv: string[]): string | undefined {\n    const regExp = new RegExp(`^${this.protocol}://`)\n    return argv.find((str) => regExp.test(str))\n  }\n}\n\nconst defaultProtocolClient = new DefaultProtocolClient('custom-protocol')\n\nawait defaultProtocolClient.register()\n```\n\n### 处理命令行参数找到其中需要的 `url` 信息\n\n添加函数 `handleDefaultProtocol` 从命令行参数中找到 url 然后处理它。\n\n```ts\n/**\n * 处理客户端支持的默认协议\n * @param argv\n */\nasync function handleDefaultProtocol(argv: string[]) {\n  const url = defaultProtocolClient.findUrl(argv)\n  if (!url) {\n    return\n  }\n  await dialog.showMessageBox({\n    type: 'info',\n    message: 'window protocol 自定义协议打开',\n    detail: ` 链接:${url}`,\n  })\n}\n```\n\n### 监听 `ready` 和 `second-instance` 事件\n\n> 参考: [事件: 'second-instance'](https://www.electronjs.org/docs/api/app#%E4%BA%8B%E4%BB%B6-second-instance)\n\n```ts\napp.addListener('second-instance', async (event, argv) => {\n  await handleDefaultProtocol(argv)\n})\napp.addListener('ready', async () => {\n  await createMainWindow()\n  await handleDefaultProtocol(process.argv)\n})\n```\n\n## 外部调用\n\n既然我们自定义协议的目的是让外部程序调用，那么如何使用外部调用就很重要了。\n\n首先检查注册表中是否已经包含它了，操作 _ctrl+s => 搜索注册表 => 进入注册表 => ctrl+f 查找 `custom-protocol`_\n\n![注册表](:/8445c03f200d46229abaab35ef6c4ea7)\n\n### 浏览器打开\n\n如上图所示，可以简单在浏览器中输入 <custom-protocol://test> 来启动程序。\n\n![自定义协议效果](:/46116b80afd84b45a11b57ac67e1550e)\n\n### nodejs 示例\n\n在 nodejs 中使用 npm 包 [open](https://www.npmjs.com/package/open) 可以轻易打开自定义默认链接。\n\n```ts\nimport * as open from 'open'\n\nopen('custom-protocol://test')\n```\n\n其实本质上就是拼接命令，然后执行系统命令打开 url，参考[它的实现](https://github.com/sindresorhus/open/blob/master/index.js)。\n","createdTime":1610335099598,"updatedTime":1616369777374,"resources":[{"id":"46116b80afd84b45a11b57ac67e1550e","title":"test (1).gif","file_extension":"gif","user_updated_time":1610339693958},{"id":"8445c03f200d46229abaab35ef6c4ea7","title":"20210111125550.png","file_extension":"png","user_updated_time":1610340951269}],"tags":[{"id":"b50c8282004d48edae677ecdfb933e9f","title":"electron","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"72128a195d8f4f45a3d1ed895a50ecb5","title":"2021 第十周","body":"距离提出离职已然过去三周了，但现在仍未找到合适的工作。也不是没有面试过，但确实没有找到合适的 -- 对于吾辈而言，合适指的是优秀的 team，最好是平台而非业务 team。\r\n\r\n吾辈也找到了一些大佬帮忙内推，包括\r\n\r\n- 快手 基础平台建设\r\n- 百度 YY 直播\r\n- 腾讯 微众银行\r\n- 阿里云 DataV 数据可视化\r\n\r\n但最让吾辈感觉难过的不是面试之后因为能力不足而失败，而是即便内推也仍然没有面试的机会。当然吾辈也能理解，毕竟不拘一格降人才确实存在风险，更不用说吾辈只是一个努力的普通人 -- 左耳朵耗子在 [如何超过大多数人](https://coolshell.cn/articles/19464.html) 所说的第四类人。尽管吾辈也逐渐明白低层次的努力收效甚微，也因而离开现在的舒适区，但曾经确实没能制定合理完备的计划，然后实践和改进让自己变得更好。\r\n\r\n之前尝试面试过两家小公司恢复状态，但公司真的是比烂，对比之下反而现在的公司还更好一点\r\n\r\n目前还在面试的是 CVTE，是一个家在招聘网站上邀投然后拒掉简历然后再邀投的神奇公司，大概是不同产品线的 HR 吧。有趣的是，当吾辈问及 leader 对于 team 的评分时，也仍然是只有 6、7 分，这是吾辈第四次听到这个答案了，看来大部分 leader 都觉得自己的 team 不太行 xd\r\n\r\n工作日一边补充公司相关文档以供交接，另一方面则是在看 [算法 4](https://book.douban.com/subject/19952400/) 上的一些内容，练习链表相关的那些问题，但到了算法复杂度分析方面，仍旧看的比较乏味，曾几何时吾辈对数学还算感兴趣，后面放弃确实太糟糕了。\r\n\r\n目前完成进度是 [1.3.34-1.3.49](https://github.com/rxliuli/algorithm/pulse)\r\n\r\n![1615709481022](:/8c59e5f2be54498cb7953eed337338b5)\r\n\r\n个人项目方面，吾辈创建了 [joplin-search-integrated](https://github.com/rxliuli/joplin-search-intergration) chrome 插件，用于将 joplin 的笔记展现在网页搜索中，便于使用同一个搜索引擎搜索到互联网上的内容和自己的笔记，灵感来自 EvenNote Web Clipper。另外一个就是将之前的几个 joplin 相关的工具整合到一个 monorepo 项目 [joplin-utils](https://github.com/rxliuli/joplin-utils) 中，不仅仅是为了可以更简单的复用代码，更是为了继续实践 monorepo 如何管理多个应用模块，例如如何在 release 中发布多个应用，因为 GitHub release 只有一条线。\r\n\r\n> 吾辈因需要而开发的一些 joplin 周边工具，使用 monorepo 进行管理。\r\n>\r\n> - joplin-vscode-plugin: 在 vscode 中管理和编辑 joplin 笔记\r\n> - joplin-search-integration: 在网页搜索中插入相关的 joplin 笔记\r\n> - joplin-blog: 将 joplin 笔记导出为 blog\r\n> - joplin-charts: joplin 一些数据可视化图表\r\n> - joplin-api: joplin ts api\r\n\r\n其他事情\r\n\r\n- 这周利用地铁上的通勤时间把 [《颓废与沉默》](https://book.douban.com/subject/26575643/) 看完了，一些感想在 [读书-\\[颓废与沉默：透视犬儒文化\\]](:/77c1a4a91a354db8abdf747f74a8b300)\r\n- kigurumi 的皮肤到了，照片已发 [立个 Flag，今年入坑 Kigurumi 并出一次漫展](:/9eb819d95b5143c7844cacb6d6650c59)\r\n- 正常作息坚持了 5 天，睡眠质量基本都在 75% 之上，统计使用的是 Sleep Cycle\r\n- 正式购买了 Proxifier，虽然数码荔枝很便宜，但为了避免麻烦吾辈直接去官网购买了，不到 300 软妹币还能接受\r\n- 这周使用了 20+h 的手机，这是个糟糕的信号，吾辈下周要砍掉一半浪费的时间。Pass：其中占用时间最长的 twitter 已卸载\r\n","createdTime":1615706754235,"updatedTime":1615711374514,"resources":[{"id":"8c59e5f2be54498cb7953eed337338b5","title":"1615709481022","file_extension":"png","user_updated_time":1615709481629}],"tags":[{"id":"7e40798e7aec482f9a0c93ef1bef6673","title":"周报","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""},{"id":"f5172282f275485bab67f712ba1b1bcf","title":"个人","parent_id":""}]},{"id":"77c1a4a91a354db8abdf747f74a8b300","title":"读书-[颓废与沉默：透视犬儒文化]","body":"> 当今世界上不同国家社会和国民文化中的犬儒主义可以分为两大类:公开的犬儒主义和戴面具的犬儒主义。它们的基本区别在于,当一个人因为犬儒主义而不相信统治意识形态、制度、权威、信仰体系以及由权力或习俗规定和主导的法律或价值规范时,尤其是怀疑和鄙视政府、政治权力和政治人物的时候,公开的犬儒主义会在公共言论和行为中表示出来,而戴面具的犬儒主义则通常不会,不仅不会表示不相信,而且还会假装成相信的样子。公开的犬儒主义对那些什么都不相信,所以公然怀疑,公然拒绝,不相信就是不相信。戴面具的犬儒主义对那些也是什么都不相信,但正因为对什么都不相信,所以对什么都可以装作相信。他们玩世不恭,随波逐流,最后有的连自己都弄不清到底是相信还是不相信,于是索性不去管相信不相信,\"难得糊涂\"地过一天算一天。当然,这不等于戴面具的犬儒主义在任何情况下都不会摘下面具露出不相信的真面目。他们在私下或在不那么公开的场合中也会有不戴假面的时候。这时候,不加掩饰的犬儒主义就会成为同道者之间互相联络的接头暗号。这使得原本以怀疑和不信任为特征的犬儒主义反倒成为一种人际联系方式,也形成一种有群体特征的社会文化。\r\n\r\n开局王炸。这让吾辈想到了 1984 里面的男女主角的认知和世界观，男主就是怀疑政府，但带上了面具。而（新生代的）女主则一方面装作相信，但背地里却又不在乎，看的时候觉得简直就是精神分裂。\r\n\r\n---\r\n\r\n> 在所有这 13 种\"病态\"中,没有一处提及犬儒,可见犬儒并不是一个普通中国人常用的概念。然而,这些病态中至少有八九种都是犬儒主义的典型表现:（1）娱乐至死（没有目标或信仰,得过且过）；（2）看客心态（看穿、冷漠、围观,管了也没用,不如不管）；（3）习惯性怀疑（上至政府,下至朋友,对谁都不信任,都不相信）；（4）审丑心理（在一个是非不分的环境里,美丑、善恶、真假也无法辨别,何必要坚持真、善、美）；（8）\"鸵鸟心态\"（多一事不如少一事,被宣传的现实反正是假的,不如\"躲进小楼成一统\"）;（9）思考恐惧症（多思多惹事,有的是前车之鉴,你要我怎么说,我就怎么说,这才是安身保命之道）；（11）炫富心态（看穿一些道德、理想、未来展望的虚妄,只有钱才是实在的,才是世人认可的唯一价值）；（12）初老症（没有前途、没有未来、没有追求,过一天算一天,坐吃等死）；（13）自虐心态（这个说法并不确实,因为一般人既非共产党又非体制,不是\"自虐\",这种顾左右而言他的说法,明白人说糊涂话,既不诚实,也不真实,它本身就是犬儒主义的）。\r\n\r\n躺枪，感觉吾辈中了好多枪。过去的经历造就了现今的吾辈，社会的经验和认知中的道理偏差太大了。\r\n\r\n---\r\n\r\n> 假面社会里的犬儒者们揣着明白装糊涂（\"难得糊涂\"）,明明在心里不相信,但却还公开做出相信的样子。他们戴上自己参与制作的假面,顺从地配合统治者的愿望表演。这也是一种将顺从和抵抗合为一体的犬儒主义。波兰诗人米沃什在《被禁锢的头脑》中称此为\"蒙蔽对手\"的策略。他写道,\"有些情况,保持沉默还不够,沉默可能被认为是主动招供,那时候就不应有丝毫犹豫,不仅要公开否认自己真正的观点,而且必须采取一切手段来蒙蔽对手。那时候就得宣布一切能取悦对手的信条,参与所有被认为是最荒唐的仪式 ⋯⋯ 终于,在蒙骗对手后,使对手在其错误中越陷越深的同时,使其承受应得的羞辱和精神痛苦。\"这可能只是一种精神胜利法,但它却能\"让践行它的人感到自豪,因为有了它,践行者才能把自己提升到超越被蒙骗者之上,并持久获得比对手优越的地位,哪怕是部长或有权有势的国王。⋯⋯ 你表面上还在被你巧妙欺骗的强权者脚下颤抖,眼睛却闪闪发亮。你在光明中走在敌人面前,你嘲笑一个愚蠢的家伙,解除了一头危险野兽的武装。这一下获得多少慰藉！\"\r\n\r\n吾辈想到了某段话：“如果尖锐的批评完全消失，温和的批评将会变得刺耳。如果温和的批评也不被允许，沉默将被认为居心叵测。如果沉默也不再允许，赞扬不够卖力将是一种罪行。如果只允许一种声音存在，那么，唯一存在的那个声音就是谎言。”\r\n—— 柏拉图\r\n\r\n---\r\n\r\n> 马基雅维利说,害怕是比爱戴更有效的统治工具,这话很适合今天的犬儒社会。有权者和无权者的犬儒主义总是在恶性循环,形成一种恶吏统治刁民的强制性秩序,稳固这一秩序的唯一办法就是层层加码的所谓\"乱世用重典\"。\r\n\r\n这让吾辈想到刚过完的春节之前返乡政策：\r\n中央要求 “从低风险区返乡持绿码即可”，到一些省份变成 “持核酸检测阴性证明”，到市里就变成 “核酸阴性证明 + 居家隔离”，到镇上变成 “核酸证明 + 集中隔离 + 居家隔离”，最后到村里就成了 “禁止返乡”。\r\n\r\n---\r\n\r\n> 权力随时防范着学术,设置重重障碍。但是,由于\"学术\"对权力有利用价情,所以还会被允许存在,甚至加以鼓励。当然,首要的条件是学术必须无害于权力统治,而最受稿赏的则是有助于或能配合权力统治的学术。权力的咸胁与利诱造就体制性的\"学术义儒\",它往往是一种在清醒状态下的装傻——一面自嘲,一面配合体制,积极自我审査；一面咒骂,一面迎合体制的无理要求；一面鄙视不懂学术的顶头上司,一面顺从他们的领导权威；一面嘲笑,一面参与为官员授予各种真的假学位和假头衔。\r\n\r\n哈哈，这是在指某位小学生么 xd\r\n\r\n---\r\n\r\n> 先入为主（preconception）和刻板印象（stereotype）之间有联系,但又有所区别。先入为主经常是因为某种先例而形成的一种习惯性推断,以为以前曾经发生过的,现在也就一定会发生。\"先例\"是先入为主思维的条件。先入为主又称偏见（prejudice）,也就是在还没有弄清情况之前就下定论（prejudgment）。\r\n\r\n这点吾辈深有感触。在吾辈高二那年活跃于贴吧之中时，曾被人认为是女生，后面与一些人建立了相关的 QQ 同好群，里面的许多人也会这样认为--因为之前有人这样认为了，如果有人怀疑，那么前面已经如此认定的人就会反对。甚至到了现在，吾辈虽然没有刻意伪装，但却也没有主动说明过。\r\n\r\n---\r\n\r\n> 美国的现实民主制度保障了普通美国人讨论\"什么是爱国主义\",\"美国需要怎样的爱国主义\"的权利。政府权力不能垄断在这些问题上的话语权。普通人如果有与政府或主流社会不同的爱国主义看法,可以发表自己的意见,不会因此被当作\"美奸\"或其他国家的\"走狗\"。而且,美国是一个多元民族文化的国家,爱国主义比较容易与文化民族主义区别开来,不容易被民族文化主义所限制或绑架。在美国,爱国主义与民族主义也是有区别的。法国总统戴高乐说过,在爱国主义那里,爱护自己国家的人民是第一位的；在民族主义那里,仇恨其他国家和其他国家的人是第一位的。美国的爱国主义里很少混杂戴高乐所说的那种仇恨性的民族主义。\r\n\r\n那么问题来了，国内现在究竟是爱国主义，还是民族主义呢？\r\n\r\n---\r\n\r\n> 冯小刚在微博里说,\"我是觉得这么多年一部接一部地拍电影,没有其他的生活。在一个特别窄的胡同里,我长跑,还不是短跑。你怎么跑,你感觉两边都是这么一个墙,越跑越窄,越跑越窄。\"他是个会说话的人,一句话同时说给两种不同的人听,让他们各自听出自己想要的意思。你可以认为他是在抱怨拍电影太辛苦,以至于\"没有其他的生活\"；你也可以认为他是在抱怨有\"墙\"不让他自由奔跑,以至于他电影生涯逼仄,只有辛苦而无乐趣。\r\n\r\n好的电影都在上个世纪拍完了，国内电影拍摄在两千年后是逐渐退步的。\r\n或者说，所有的艺术在国内基本都是在退步的？电影、电视剧、音乐、动画这些，虽说过去的回忆有同年加成，但后来者无法居上也是不争的事实。例如新白之后再也没有更好的《白娘子传奇》了，电视剧的发展更是相当迷惑，完全看不懂粉圈喜欢的电视剧。\r\n\r\n---\r\n\r\n> 人们往往从现代社会工作压力大、人际交往频繁、信息更新流通速度快等实用原因来解释\"离不开手机\"的现象,而忽视了一个非常重要的心理因素——无聊。\r\n\r\n是的，吾辈一天玩手机的时间超过两个小时，工作日最长甚至会达到四个小时。\r\n\r\n---\r\n\r\n> 一般来说,有三种无聊,都与难以集中精神注意力有关。一、被阻止去做想做的事情；二、不得不去做不想做的事情；三、没有明确原因,只是对任何事情都没有兴趣,不想去做。一种或不止一种的无聊会让人觉得空虚、抑郁、百无聊赖。无聊不仅是一种此时此刻的心情,而且还是一种对生活状态的看法和生存环境的感受。无聊使人感觉到沉闷、压抑、无可作为、没有出路或希望,因而也焦虑、冷漠、忧虑、不安,甚至惶惶不可终日。人们经常把无聊与太多的闲暇、无所事事、缺乏审美兴趣联系在一起,但是,工作和做事并不一定就是解除无聊的良药。许多的工作对人对有异化作用,人变成了完成某种工作任务的工具。这样的工作机械乏味、没有意义,更让人觉得无聊。\r\n\r\n所以吾辈总是说：“没有变化就是在等死”，而等死它好么？它不好。工作如果一直做自己不感兴趣的或不能做自己感兴趣的事情的话，那么离开便是唯一的选择了。\r\n\r\n---\r\n\r\n> 人们从自己以往的经验发现,再怎么求也不会起作用,所以天大的事也只好忍受,不再有所要求或希望。在心理学里,这叫\"习得性无助\"（learned helplessness）。\r\n\r\n这与现在基本放弃希望混吃等死的咸鱼思想不谋而合，既然卷不过别人，政府也不顾及一般人的死活，那么我为什么还要继续卷下去呢？作为一个加害者和受害者的身份。\r\n\r\n---\r\n\r\n> 如果一个人总是在一项工作上失败。他就会在这项工作上放弃努力。甚至还会因此对自身产生怀疑,觉得自己\"这也不行,那也不行\",彻底无望。典型的例子是,学习成绩经常不好的学生会怪自己\"天生就笨\",所以不再努力；经常失恋的人会责备自己\"天生令人讨厌\",所以干脆放弃找对象的打算。他们都是因为有屡屡受挫的经验,所以陷入了无为无助的绝望之中。\r\n\r\n所以需要做一些有趣的事情，恢复信心，建立信心。吾辈在 joplin 周边生态上的建设便是如此了。\r\n而且，新的一年，新的开始，一切都可以从零算起了呢！\r\n\r\n---\r\n\r\n> 知识分子用\"新理论\"来粉饰和淡化统治者自己都不好意思否认的以往错误,这是一种非常巧妙的\"光天化日之下献媚讨好\",既献媚讨好,又显得不失自己的\"学者\"身份。例如,把\"文革\"时的\"忠字舞\"说成是相当于今天跳迪斯科的\"大众文化\"。毛泽东说的文革每 5 年搞一次,被说成是相当于\"定期的民主选举\"。这是一种非常犬儒的学术话语把戏和游戏。\r\n\r\n哈，总是有人会这样做呢，一本正经的胡说八道，不外如是。\r\n\r\n---\r\n\r\n> 不同的国家有不同的国情,公共知识分子的专业造诣、职业特征和公共活动方式也会有很大的不同。中国大学教授受体制的限制比美国大,升等评级、决定科研项目的权利掌握在领导和人事部门手里,教授被逼着在自己的一亩三分地里小心耕作,巴望着能出一些符合体制规定的\"成果\",所以容易变得思想狭隘,目光短浅,心灵猥琐,浅薄弱智。他们既不能成为\"世界的眼睛\",也不敢站在体制的边缘,扰乱它的安宁。\r\n\r\n对上级负责而不是事情负责，上下五千年的老传统了。\r\n一般（小）公司 996 的形式主义大于实际效益，任何能够量化的事情想想办法总是能够完成，加班未必就是在忙实际负责的事情。话虽如此，这也确实将人局限在公司，严重减小了交际面，绝非长久可为之计。\r\n\r\n---\r\n\r\n> \"文革\"中盛行言辞激烈、慷慨激昂的\"革命歌曲\"或\"诗朗诵\",运用的就是这种非说理话语,形成了具有中国特色的\"标语体\"写作。例如,\"东风吹战鼓擂,现世界上究竟谁怕谁?不是人民怕美帝,而是美帝怕人民, 得道多助失道寡助,历史的规律不可抗拒,不可抗拒……\"标语体写作是口号式思维的产物,二者相辅相成。\r\n\r\n太尬了，让吾辈想到去年的“武汉加油”与“山川异域，日月同天”的事情了。-- 历史不会重演，它只会押韵。\r\n\r\n---\r\n\r\n> \"文革\"高潮时期,人们说话都必须以\"毛主席教导我们\"开始,说上一段语录,然后才言归正传,这是正确的说话规范。王小波在《沉默的大多数》一文中写道:\"古代和近代有两种方法可以壮我的胆。古代的方法是,文章要从‘夫子曰’开始。近代的方法是从‘毛主席教导我们说’开始。\"所谓\"壮胆\",也就是必须这么说才能被别人接受,才不至于出错,因为这就是\"规范\".\r\n\r\n沉默的却是永远都是大多数，就像互联网上的幽灵一样，仅仅消费而不生产内容。另外，吾辈只听说过【吴晓波】\r\n\r\n---\r\n\r\n> 心理学研究早就归纳了人的七种性格缺陷,它们分别是,一、自我贬损（Self-Deprecation）:自甘下流、唾面自干；二、自暴自弃（Self-Destruction）:自我糟践、自我伤害；三、受害者心结（Martyrdom）:老觉得别人在算计和迫害自己；四、顽固和一意孤行（Stubbornness）:拒绝改变自己；五、贪得无厌（Greed）:自我放纵、欲壑难填；六、狂妄自大（Arrogance）:老子天下第一,谁也说不得；七、极不耐烦（Impatience）,像是谁都在跟自己作对,跟自己有仇。这七种性格缺陷在当今中国都不陌生,而其中的自我贬损则直接与一些人在人格上无自尊的\"下流化\"有关。\r\n\r\n躺枪 \\* 2 _(:з)∠)_\r\n\r\n---\r\n\r\n> 我因此想到读过的一篇博文《生活就像被强奸一样,既然不能反抗,那就好好享受吧》。\r\n\r\n生活就是这么糟糕，那么吾辈还是做条安静的咸鱼，躺平吧！\r\n话虽如此，面对现实环境，能做的无非就是三件事\r\n\r\n1. 改变自己\r\n2. 改变世界\r\n3. 离开这儿\r\n\r\n其中，改变自己，做个安静的咸鱼显然是最容易实现的呢\r\n\r\n---\r\n\r\n> 颓废与沉默:透视犬儒文化\r\n\r\n看完了这本书，这是在看了两本这种哲学类型的书之后，终于碰到一本感兴趣的了。里面真是描绘了当下国内的各种问题啊。而且旁征博引，引用了许多现实示例。\r\n另外，这本书似乎已然绝版了。\r\n","createdTime":1615563148277,"updatedTime":1615563710706,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"cb9e3139d6c445159b47d8f26528445d","title":"读书","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"5ce7d75fe2dc46838b49f9e5e14ac738","title":"electron 开发经验之谈系列-在渲染、主进程间共享数据","body":"## 场景\n\n有时候我们需要在主进程和渲染层共享某些数据，而 [electron ipc 通信](:/76393a60949c47c7add910df0206734c) 显然更适合传递消息而不适合共享数据。\n\n## 相关依赖\n\n事实上，我们这个需求已经有人考虑过了，例如 electron-store 就已经实现了可以在渲染层、主进程均可使用。\n\n- [is-electron](https://www.npmjs.com/package/is-electron): 判断是否 electron 环境\n- [electron-store](https://www.npmjs.com/package/electron-store): 在 electron 应用中存储数据\n\n那么，我们直接用 electron-store 有什么问题么？\n是的，electron 仅能在 electron 中使用，所以在浏览器上会报错，而这对于开发环境而言是无法接受的，故而还需要检测环境使用不同的实现。\n\n## 创建浏览器兼容层\n\n使用策略模式实现不同环境下使用不同的存储\n\n- 浏览器使用 localStorage 实现\n- electron 中则使用 electron-store 实现\n\n```ts\nimport type Store from 'electron-store'\nimport isElectron from 'is-electron'\nimport { DeepReadonly } from 'utility-types'\n\ninterface BaseStore {\n  get(key: string): string | null\n\n  set(key: string, value: string): void\n}\n\nclass ElectronStoreImpl implements BaseStore {\n  private store: Store\n\n  constructor() {\n    const Store = window.require('electron-store')\n    this.store = new Store()\n  }\n\n  set(key: string, value: string): void {\n    this.store.set(key, value)\n  }\n\n  get(key: string) {\n    return this.store.get(key) as string\n  }\n}\n\nclass LocalStorageImpl implements BaseStore {\n  get(key: string) {\n    return localStorage.getItem(key)\n  }\n\n  set(key: string, value: string) {\n    localStorage.setItem(key, value)\n  }\n}\n\nconst symbol = Symbol('ElectronStore.store')\n\nexport class ElectronStore {\n  private readonly [symbol]: BaseStore = isElectron()\n    ? new ElectronStoreImpl()\n    : new LocalStorageImpl()\n\n  static getInstance<T extends object>(\n    init?: Partial<T>,\n  ): Partial<{ [P in keyof T]: DeepReadonly<T[P]> }> {\n    const electronStore = new ElectronStore()\n\n    const proxy = new Proxy({} as any, {\n      get(target: any, p: string): any {\n        const text = electronStore[symbol].get(p)\n        try {\n          if (text === null || text === undefined) {\n            return null\n          }\n          return JSON.parse(text)\n        } catch (e) {\n          return null\n        }\n      },\n      set(target: any, p: string, value: any): boolean {\n        electronStore[symbol].set(\n          p,\n          value !== undefined && value !== null ? JSON.stringify(value) : value,\n        )\n        return true\n      },\n    })\n    if (init) {\n      Object.entries(init).forEach(([k, v]) => {\n        const text = electronStore[symbol].get(k)\n        if (text === null || text === undefined) {\n          proxy[k] = v\n        }\n      })\n    }\n    return proxy\n  }\n}\n```\n\n你可能发现了，为了简化使用的 API，这里使用了代理模式拦截了对实例的访问，修改为使用 `get/set` 方法取值和设值。\n\n## 使用\n\n使用起来和一个普通的对象没什么区别，直接通过 `.` 访问或设置属性即可。\n\n```ts\nconst userStore = ElectronStore.getInstance<{ name: string; age: number }>()\nuserStore.name = 'liuli'\nconsole.log(userStore.name === 'liuli')\nuserStore.age = 1\nconsole.log(userStore.age === 1)\n```\n\n> 具体代码在 [electron_example](https://github.com/rxliuli/electron_example/blob/ed158e9d013d7138697c76b52ddefb4748fe1af0/libs/electron-util/src/ElectronStore.ts#L40)，由于是一个浅层封装，所以并未发布，但可以直接将模块复制到项目中使用。\n","createdTime":1614652762958,"updatedTime":1614662039855,"resources":[],"tags":[{"id":"b50c8282004d48edae677ecdfb933e9f","title":"electron","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"6edf2cfaf7ec46f0bfb659d8c7246c52","title":"electron 开发经验之谈系列-技术栈简介及选择","body":"## 技术栈\n\n- [electron](https://electronjs.org/): 跨平台桌面开发\n- [react](https://reactjs.org/): 视图层框架\n- [typescript](https://www.typescriptlang.org/): 强类型的 js\n- [lerna](https://lerna.js.org/): 前端 monorepo 管理工具\n- [yarn](https://classic.yarnpkg.com/): 包管理器，workspace 与 lerna 搭配非常好\n- [create-react-app](https://create-react-app.dev/): react 官方出品的 react 脚手架生成器，社区和活跃度都不是其它工具可比的\n\n## 其他依赖库\n\n> 参考: [前端资源管理](:/664f86d038744a01894699e368cc2708)\n\n- [rollup](https://rollupjs.org/): 前端库打包工具\n- electron-builder: electron 打包工具\n- is-electron: 在渲染层判断是否为 electron 环境的微型库\n- fs-extra: nodejs api 的 Promise 化封装\n- react-use: react 中的通用 hooks 库\n- [@liuli-util/\\*](https://www.npmjs.com/org/liuli-util): 吾辈个人的一系列通用工具库\n- jest: 单元测试工具\n- wallaby.js: 单元测试 IDE 集成\n- gulp: 流式任务管理工具\n- electron-store: 主进程和渲染层通用的 k-v 存储\n- electron-reloader: electron 热更新工具\n- electron-devtools-installer: electron 插件安装工具\n- utility-types: typescript 通用类型库\n\n## 选择动机\n\n- electron: 想必来看到这篇文章的人都无需解释，基于 web 技术的跨平台足以解释一切。\n- react: 吾辈无意争论框架优劣，但 react 确实是目前最流行的解决方案，所以吾辈选择了它。\n- typescript: 由于吾辈有着 Java 后端的经验，所以对强类型情有独钟。\n- lerna: 这个确实需要解释一下，electron 应用分为主进程和渲染层，一般示例中是将它们在一个项目中通过目录区分，但这种隔离性并不好，还会污染 `package.json`。这时候就到了 lerna 出场了，它是由 babel 的作者开发，专门用以解决前端没有多模块工程的问题。\n  > PS1: 老实说，吾辈很想念 Java [maven](https://maven.apache.org/) 多模块的支持，可以非常简单的抽取模块出来。\n  > PS2: 前端有名的 electron-react 示例项目 [electron-react-boilerplate](https://github.com/electron-react-boilerplate/electron-react-boilerplate/) 就是单模块的。\n- electron-builder: electron 官方其实更推荐 [Electron Forge](https://www.electronforge.io/)，但目前而言，electron-builder 更好。\n","createdTime":1609807568702,"updatedTime":1614651123461,"resources":[],"tags":[{"id":"b50c8282004d48edae677ecdfb933e9f","title":"electron","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"c68829779f5449d0afe0e67806dc7fc1","title":"electron 开发经验之谈系列-常见问题","body":"## 突然之间 electron 就不能启动了\n\n删除 node_modules 重新 yarn 看看？\n\n## 打包之后的程序页面空白\n\n实际上是 electron 无法正常加载页面，原因很多\n\n1. 路径问题，解压 asar 查看实际路径（`main.js` 中 `loadUrl` 的路径是否正确）\n2. react router 仅支持 hash 模式\n3. 在从文件系统中读取 html 文件时不能使用 `#` 指定路由，参考: <https://stackoverflow.com/questions/55715384s>\n\n> asar 文件一般在 _win-unpacked/:/app_，参考: <https://github.com/electron/asar>\n\n## electron 程序命令行输出中文乱码\n\n在运行命令前首先运行 `chcp 65001` 修改活动代码页编号，参考：[Using UTF-8 Encoding (CHCP 65001) in Command Prompt / Windows Powershell (Windows 10)](https://stackoverflow.com/questions/57131654)\n\n## 如何不打包成压缩格式 asar\n\n配置 electron-builder `\"asar\": false`。\n\n## `second-instance` 事件监听无效\n\n必须使用 `app.requestSingleInstanceLock()` 保持应用程序单例，才能正常监听到该事件。\n\n示例代码\n\n```ts\nconst gotTheLock = app.requestSingleInstanceLock()\nif (!gotTheLock) {\n  app.quit()\n} else {\n  app.on('second-instance', (event, commandLine, workingDirectory) => {\n    console.log('second-instance')\n  })\n}\n```\n\n> 参考: <https://www.electronjs.org/docs/api/app#apprequestsingleinstancelock>\n\n## 安装浏览器扩展报错\n\n提示安装失败\n\n```sh\n(node:23488) ExtensionLoadWarning: Warnings loading extension at C:\\Users\\rxliuli\\AppData\\Roaming\\Electron\\extensions\\fmkadmapgofadopljbjfkapdkoienihi: Unrecognized manifest key 'browser_action'. Unre\ncognized manifest key 'minimum_chrome_version'. Unrecognized manifest key 'update_url'. Cannot load extension with file or directory name _metadata. Filenames starting with \"_\" are reserved for use by\n the system.\n```\n\n其实答案是：扩展必须在 `app.ready` 之后，创建 BrowserWindow 窗口之前安装。\n","createdTime":1608858363085,"updatedTime":1614069173376,"resources":[],"tags":[{"id":"b50c8282004d48edae677ecdfb933e9f","title":"electron","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"6073fb1fbe584c46a49cfbad6e44901f","title":"JavaScript 中的批处理和缓存","body":"## 场景\n\n最近在生产环境遇到了下面这样一个场景：\n后台在字典表中存储了一些之前需要前后端共同维护的枚举值，并提供根据 `type/id` 获取字典的 API。所以在渲染列表的时候，有很多列表的字段直接就是字典的 id，而没有经过后台的数据拼装。\n\n> 也是吾辈之前写的文章 [react 通用列表组件封装](:/c55a6470683e498f92ba05d7ff710b3a) 中的那个通用列表在实际使用时遇到的问题之一。\n\n起初，吾辈解决问题的流程如下\n\n1. 确定字典字段，添加转换后的对象类型接口\n2. 将对象列表进行转换得到其中字典字段的所有值\n3. 对字典 id 列表进行去重\n4. 根据 id 列表从后台获取到所有的字典数据\n5. 将获得的字典数据转换为 **id => 字典** 的 Map\n6. 遍历最初的列表，对里面指定的字典字段进行转换\n\n可以看到，上面的步骤虽然不麻烦，但却十分繁琐，需要定义额外的类型不说，还很容易发生错误。\n\n## 思路\n\n1. 使用 `异步批处理 + LRU 缓存` 优化性能\n2. 支持异步 `formatter` 获得更好的使用体验\n\n## 实现异步批处理\n\n> 参考实现: [batch](https://github.com/rxliuli/rx-util/blob/dev/src/module/function/batch.ts)\n\n实现批处理的基本思路如下\n\n1. 使用 `Map` `paramCache` 缓存传入的 `参数 => 剩余调用次数`（该参数还需要查询几次结果）\n2. 使用 `Map` `resultCache` 缓存 **参数 => 结果**\n3. 使用 `lock` 标识当前是否有函数正在执行\n4. 满足以下条件需要等待\n   1. Map 中不包含结果\n   2. 目前有其它调用在执行\n   3. 还未满最小等待时长（收集调用的最小时间片段）\n5. 使用 `lock` 标识正在执行\n6. 判断是否已经存在结果\n   1. 如果不存在则执行批处理处理当前所有的参数\n7. 从缓存 Map 中获取结果\n8. 将 `paramCache` 中对应参数的 `剩余调用次数 -1`\n9. 判断是否还需要保留该缓存（该参数对应的剩余调用次数为 0）\n   1. 不需要则删除\n10. 判断缓存的结果是否是 `Error`\n    1. 是的话则 `throw` 抛出错误\n\n## LRU 缓存\n\n> 参考: [Wiki 缓存算法](https://en.wikipedia.org/wiki/Cache_replacement_policies), 实现 [MemoryCache](https://github.com/rxliuli/rx-util/blob/dev/src/module/cache/MemoryCache.ts)\n\n- 问：这里为什么使用缓存？\n- 答：这里的字典接口在大概率上是**幂等**的，所以可以使用缓存提高性能\n- 问：那么缓存策略为什么要选择 LRU 呢？\n- 答：毫无疑问 `FIFO` 是不合理的\n- 问：那为什么不选择 `LFU` 算法呢？它似乎能保留访问最频繁的资源\n- 答：因为字典表并非完全幂等，吾辈希望避免一种可能--**访问最多的字典一直没有删除，而它在数据库已经被更新了**。\n\n大致实现思路如下\n\n1. 使用一个 `Map` 记录 **缓存 key => 最后访问时间**\n2. 每次获取缓存时更新最后访问时间\n3. 添加新的缓存时检查缓存数量\n   1. 如果超过最大数量，则删除最后访问时间距离现在最长的一个缓存\n4. 添加新的缓存\n\n> Pass: 不要吐槽性能很差啦，这个场景下不会缓存特别多的元素啦，最多也就不到 1000 个吧\n\n## 结合高阶函数\n\n现在，我们可以结合这两种方式了，同时使用 `onceOfSameParam/batch` 两个高阶函数来优化 **根据 id 获取字典信息** 的 API 了。\n\n```ts\nconst getById = onceOfSameParam(\n  batch<[number], Dict>(async (idList) => {\n    if (idList.length === 0) {\n      return new Map()\n    }\n    // 一次批量处理多个 id\n    const list = await this.getByIdList(uniqueBy(idList.flat()))\n    return arrayToMap(\n      list,\n      (dict) => [dict.id],\n      (dict) => dict,\n    )\n  }, 100),\n)\n```\n\n## 支持异步 formatter\n\n原本想要支持 ListTable 的异步 `formatter` 函数，但后来想想，如果 `slot` 里也包含字典 id 呢？那是否 `slot` 也要支持异步呢？这可是个比较棘手的问题，所以还是不支持好了。\n\n> 最终，吾辈在组件与 API 之间添加了 `*Service` 中间层负责处理数据转换。\n","createdTime":1593751382932,"updatedTime":1614006687642,"resources":[],"tags":[{"id":"1de1ff51140a44d5a2c223459dabcc37","title":"异步","parent_id":""},{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"6be33848912b4a63bd0bfebe0e99fda1","title":"React 根据状态动态化功能的一些思考","body":"## 场景\n\n> 之前吾辈也在 SF 上询问过 [类似的问题](https://segmentfault.com/q/1010000021851252)。\n\n目前在实际业务中遇到了两种情况\n\n1. 程序的功能在分发给不同组织使用的时候有所差异，即不同的组织都会存在一些定制化的功能。\n   最常见的差异例如\n   - 表单的字段存在差异\n   - 列表展示的字段与相关操作有所不同\n2. 组件内的代码在某个权限下才会执行，但是又依赖于组件内的一些状态，如何将这些代码分割到不同的地方（例如不同的文件）便于之后的维护。\n   - 一些按钮在指定权限下存在\n   - 一些数据在指定权限下展示\n\n## 方案\n\n- 使用动态配置渲染不同的页面(可序列化的配置)\n- 根据状态匹配不同的动态组件\n- 使用 hooks 封装不同的逻辑\n- 使用状态图控制状态和逻辑\n\n## 实际调研结果\n\n### 使用动态配置渲染不同的页面\n\n实际上，之前有看过吾辈写的 [react 通用列表组件封装](:/c55a6470683e498f92ba05d7ff710b3a) 就知道，实际上列表已经被配置化了，可以使用配置的形式去渲染一个完整的列表页面，因此可以根据不同的组织使用不同的配置就好了。但是，事实上并没有这么简单，因为就算是简单的列表，也仍然包含**上下文**，而这，正是配置不能拿到的内容。\n\n上下文主要包括\n\n- 需要异步请求的数据，例如下拉框的选择项\n- 需要从路由上获取的数据，例如搜索条件\n- 需要对页面内的其它组件进行操作时，例如点击按钮有个新增列表项的弹窗\n\n可以有几种解决方案\n\n- 通过函数，而不是单纯的配置，这样，可以通过参数解决一些上下文的依赖情况\n- 通过函数且异步，可以解决 api 请求时，此时的 api 必定是可以用的，但是会依赖于 api。\n\n但这仍然会带来问题\n\n- 数据不再纯粹，无法序列化。\n- 不同配置依赖的数据可能不同，需要配置自己去解决，那么如果这样想的话，那么配置就需要自行获取数据，而不是外部传递数据了\n- 仍然无法使用**状态**\n- 最重要的是，使用函数之后变得不再像是**配置**了\n\n### 根据状态匹配不同的动态组件\n\n- 配置更为灵活，能够获取到组件的上下文\n- 接口请求也没有问题\n- 对不同配置，可以自行对数据进行处理\n\n问题\n\n- 无法如同纯数据配置那样，复用逻辑这么彻底，但是也可以通过 hooks 解决。\n- UI 复用问题\n  先使用组件的方式编写一下，看具体结果如何\n- 无法序列化也意味着无法放到后端，甚至意味着很难做动态加载\n\n使用\n\n- 使用一个 wrapper 组件来讲 UI 和通用逻辑给包裹进去\n- 使用另外一套组件去区分不同租户的配置（因为是在组件内部写配置，所以该配置可以灵活的使用任意接口，组件上下文可能还不太行）也就是用多个组件来解决这个问题。\n\n可以再尝试一下有没有解决方案。\n\n### 使用 hooks 封装不同的代码\n\n- 相比于处理 **是哪一个**，更适合处理 **有或没有** 的代码分割\n- 能够使用 react 的状态\n\n问题\n\n- 使用 hooks 必须放在函数组件最顶层，导致本质上无法 `lazy` 加载。参考：[Hook 规则](https://zh-hans.reactjs.org/docs/hooks-rules.html)\n- 使用 hooks 同样难以序列化存储到后端\n\n### 使用状态图控制状态和逻辑\n\n使用 hooks 封装代码最适合处理元素级的权限控制，但在面对需要根据多个维度的状态决定程序的状态或行为时，就有点力不从心了。而这，也是为什么有限状态机为什么有用的原因。\n\n### 结论\n\n最终，我们选择了最灵活的 **动态组件 + Hooks 共享逻辑** 的形式，虽然使用动态组件会增加一些冗余度，但也可以通过子组件或 hooks 的形式复用逻辑，实际上在工程化减小的复杂度的收益是要高于代码冗余的。\n\n## 使用示例\n\n> 登记相关内容已经使用该方式进行了重构\n\n- `src/pages/register`\n  - `common`: 通用的一些组件和逻辑，例如请求后台接口应该是统一的，但返回的数据类型却应该是单独的\n    - `form`: 表单相关组件，提供给列表/详情页面使用\n    - `detail`: 详情页面\n    - `list`: 列表页面\n  - `organizations`: 不同组织的目录\n    - `org1`: 组织 1\n    - `org2`: 组织 2\n\n吾辈编写了一个简单的示例，代码在 [dynamic_state](https://github.com/rxliuli/example/tree/master/dynamic_state)\n\n![简单示例](https://img.rxliuli.com/20200803203027.png)\n\n## 其他技术问题\n\n- [x] 如何在运行时根据组织切换功能\n  - 可以再包一层组件而非简单的从 `lazy component map` 取出组件\n- [x] 如何在运行时添加新组织的功能\n  - 可能需要插件的实现方式，支持动态加载进来，例如 vscode 的插件体系。\n- [x] 如何使用 hooks 更好的复用逻辑\n  - 使用 hooks 封装逻辑，使用小型组件封装 UI/UX\n- [x] 如何在打包阶段干掉不相关组织的代码\n  - 需要修改 webpack 相关的内容，目前不予考虑\n","createdTime":1596171924460,"updatedTime":1614006655718,"resources":[],"tags":[{"id":"5a7776c036cf46738cb6a729934a1a7b","title":"react","parent_id":""},{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"8c57648407fa4b72ac30c3a61b1c1fef","title":"在传统项目中使用 babel 编译 ES6","body":"## 场景\r\n\r\n> 曾经吾辈以为 ES6 早已推广开来，然而事实上远比想象中更加复杂。传统后台的项目就是要兼容性，兼容 2 年前的浏览器，没有 babel，全程 jQuery 一把梭做到底。\r\n\r\n之前的项目基本上都是前后端分离的模式，最近新公司的项目却是使用的传统的模板视图的模式。  \r\n所以，一些东西发生了变化\r\n\r\n- `thymeleaf` 模板里面直接有 Java 的代码，在服务端直接编译 html 代码而非是纯粹的 API 交互\r\n- 使用最多的库是 `jquery`，主要用于操作 `dom`\r\n- 没有现代前端工具链 `nodejs/npm/webpack/babel/vuejs`\r\n\r\n所以吾辈使用 ES6 的语法就被同事诟病语法太新（还有人连 ES5 的语法都没能完全掌握），浏览器无法正常显示，所以吾辈只能尝试用 babel 来做兼容。众所周知，自 babel6 以来，模块化大行其道，由原先的使用浏览器引入脚本的方式修改为由 npm 等包管理器引入，官方也不推荐使用浏览器引入的方式。\r\n\r\n## 解决\r\n\r\n幸好吾辈找到了一个项目 [babel-standalone](https://github.com/babel/babel-standalone)，它提供了从浏览器中引入 babel 的功能。\r\n\r\n使用方式很简单，只要在你含有 ES6 代码的脚本之前引入，在含有 ES6 代码的 script 标签上加上 `text/babel` 即可。\r\n\r\n```js\r\n<script src=\"https://unpkg.com/babel-standalone@6/babel.min.js\"></script>\r\n<script type=\"text/babel\">\r\nconst getMessage = () => \"Hello World\";\r\ndocument.getElementById('output').innerHTML = getMessage();\r\n</script>\r\n```\r\n\r\n以上，官方是这么说的，然而实际上，吾辈还是遇到了一些问题\r\n\r\n1. 使用 `<script type=\"text/babel\">` 标记需要编译确实很方便，然而 babel 的编译过程是异步的，所以如果想要在后面的脚本中使用这个脚本中的内容则是不可能的\r\n2. 某些语法仍然不能支持，例如 `function*` 生成器\r\n3. 不能直接使用未声明的变量\r\n4. 默认没有编译为 ES5\r\n\r\n这些问题我们下面一一解决\r\n\r\n### 异步编译\r\n\r\n例如有下面三个文件\r\n\r\n```html\r\n<!-- index.html -->\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\r\n    <title>index</title>\r\n  </head>\r\n  <body>\r\n    <h1 id=\"root\"></h1>\r\n    <script src=\"https://unpkg.com/babel-standalone@6/babel.min.js\"></script>\r\n    <script type=\"text/babel\" src=\"./js/common.js\"></script>\r\n    <script src=\"./js/index.js\"></script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n```js\r\n// common.js\r\n/**\r\n * 等待指定的时间/等待指定表达式成立\r\n * @param {Number|Function} param 等待时间/等待条件\r\n * @returns {Promise} Promise 对象\r\n */\r\nfunction wait(param) {\r\n  return new Promise((resolve) => {\r\n    if (typeof param === \"number\") {\r\n      setTimeout(resolve, param)\r\n    } else if (typeof param === \"function\") {\r\n      var timer = setInterval(() => {\r\n        if (param()) {\r\n          clearInterval(timer)\r\n          resolve()\r\n        }\r\n      }, 100)\r\n    } else {\r\n      resolve()\r\n    }\r\n  })\r\n}\r\n```\r\n\r\n```js\r\n// index.js\r\nwait(3000).then(function () {\r\n  document.querySelector(\"#root\").innerHTML = \"等待 3s 结束\"\r\n})\r\n```\r\n\r\n我们会得到一个错误\r\n\r\n```js\r\nUncaught ReferenceError: wait is not defined\r\n```\r\n\r\n为什么会这样呢？原因就是加载 common.js 之后实际上还需要被 babel 编译，然而这并非同步操作，所以我们之后的脚本就无法取得全局函数 `wait()`。那么，如何解决呢？\r\n\r\n我们可以将所有的 `script` 标签都加上 `type=\"text/babel\"`，所有的 script 脚本都是需要编译的，那么就不会有异步的编译的问题了。\r\n\r\n### babel 没有完全支持\r\n\r\n例如在 `common.js` 中添加一个函数 `indexGenerator()`\r\n\r\n```js\r\n/**\r\n * 生成一个索引序列，从 0 开始，每次递增为 1\r\n * @returns {Generator} 一个生成器\r\n */\r\nfunction* indexGenerator() {\r\n  for (let i = 0; true; i++) {\r\n    yield i\r\n  }\r\n}\r\n```\r\n\r\n但我们只会得到一个错误\r\n\r\n```js\r\nUncaught ReferenceError: regeneratorRuntime is not defined\r\n```\r\n\r\n这是因为 babel 基础包并没有实现所有的 ES6 的特性，所以就会出现不支持的情况。我们需要拓展包 `babel-polyfill`，在 `babel-standalone` 下引入即可\r\n\r\n```js\r\n<script src=\"https://unpkg.com/babel-standalone@6/babel.min.js\"></script>\r\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/7.2.5/polyfill.min.js\"></script>\r\n```\r\n\r\n### 不能使用未声明变量\r\n\r\n如果我们在标记为需要编译的 script 脚本中使用了未定义的变量，就会出现错误。例如在 `index.js` 中\r\n\r\n```js\r\nusername = \"rxliuli\"\r\n```\r\n\r\n错误消息\r\n\r\n```js\r\nUncaught (in promise) ReferenceError: username is not defined\r\n```\r\n\r\n所以说编程规范很重要啦\r\n\r\n### 默认不支持 ES7\r\n\r\n是的，babel 默认是不支持 ES7 的，而 `async/await` 便属于 ES7 的内容。例如我们修改 `index.js`\r\n\r\n```js\r\n;(async () => {\r\n  await wait(3000)\r\n  document.querySelector(\"#root\").innerHTML = \"等待 3s 结束\"\r\n})()\r\n```\r\n\r\n错误消息\r\n\r\n```js\r\nUncaught SyntaxError: Unexpected token function\r\n```\r\n\r\n我们可以使用 `data-presets=\"latest\"` 来修复这个问题，永远引入最新版的 `presets`。\r\n\r\n```js\r\n<script type=\"text/babel\" src=\"./js/common.js\"></script>\r\n<script\r\n  type=\"text/babel\"\r\n  data-presets=\"latest\"\r\n  src=\"./js/index.js\"\r\n></script>\r\n```\r\n\r\n### thymeleaf 不能使用模板字符串 HTML\r\n\r\n同时使用 `type=\"text/babel\" data-presets=\"latest\"` 和 `th:inline=\"javascript\"` 的时候，thymeleaf 将无法解析 `<a href=\"#\"/>` 含有 HTML 的模板字符串。\r\n\r\n使用环境\r\n\r\n- spring-boot 2.0.3.RELEASE\r\n- babel 6.26.0\r\n- babel-polyfill 2.6.1\r\n\r\n例如下面这种代码\r\n\r\n```html\r\n<script type=\"text/babel\" data-presets=\"latest\" th:inline=\"javascript\">\r\n  const htmlStr = `<a href=\"#\"/>`\r\n  console.log(`htmlStr: ${htmlStr}`)\r\n</script>\r\n```\r\n\r\n甚至于注释了也没用，只能删除掉才可以\r\n\r\n```html\r\n<script type=\"text/babel\" data-presets=\"latest\" th:inline=\"javascript\">\r\n  // const htmlStr = `<a href=\"#\"/>`\r\n  console.log(`htmlStr: ${htmlStr}`)\r\n</script>\r\n```\r\n\r\n目前的解决方案是分成两个 `script` 标签，分别使用 `type=\"text/babel\" data-presets=\"latest\"` 和 `th:inline=\"javascript\"` 标签\r\n\r\n### 不能使用浏览器较新的 API\r\n\r\n使用一些浏览器较新的 API 时发现不能正常使用，`babel-core` 也没有实现。例如吾辈想要使用 `NodeList.forEach` 遍历 `a` 标签列表，然后打印出来他们的链接\r\n\r\n```js\r\ndocument.querySelectorAll(\"a\").forEach((el) => console.log(el.href))\r\n```\r\n\r\n会得到错误\r\n\r\n```js\r\nUncaught TypeError: document.querySelectorAll(...).forEach is not a function\r\n```\r\n\r\n在旧版浏览器中，`NodeList` 并没有 `forEach` 方法，后来，吾辈找到了另一个库 [core-js](https://github.com/zloirock/core-js)，其最新版 `3.x beta` 实现了 `NodeList.forEach` API，唯一的缺点是我们要手动构建才行。\r\n\r\n引入也很简单，只要在 `babel-standalone` 之后，`babel-polyfill` 之前使用 `script` 标签引入就好了\r\n\r\n```html\r\n<script src=\"https://unpkg.com/core-js-bundle@3.0.0-beta.8/index.js\"></script>\r\n```\r\n\r\n好了，下面我们可以愉快的使用新的浏览器 API 了\r\n\r\n## 总结\r\n\r\n那么，有关在传统项目中使用 babel 编译 ES6/ES7 的问题就到这里了，希望有更多的人使用这些新特性，让我们早日抛弃掉 babel 吧\r\n","createdTime":1580652937921,"updatedTime":1614000139189,"resources":[],"tags":[{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"5f38eae3a61242e698684620e82fb6f7","title":"blog 评论系统推荐","body":"## 场景\r\n\r\n长期以来，吾辈通过 RSS 阅读各种 blog，想要评论时却发现很麻烦，所以来推荐一下 blog 的评论系统。\r\n\r\n评论系统大概有如下几种形式\r\n\r\n- 基于第三方评论服务\r\n- 输入名字邮箱即可发表评论\r\n- 注入博客用户才可以发布评论（没怎么用过，不予置评）\r\n\r\n## 优缺点对比\r\n\r\n基于第三方评论服务这里选择的是吾辈目前正在使用的 disqus，而评论选择是某位博主的评论系统。\r\n\r\n两者截图如下\r\n\r\n![基于第三方评论服务](:/1d7c7c27c4b34f59964dcb5bf964919e)\r\n![输入名字邮箱即可发表评论](:/a0af65b841d3440b95043d3254928518)\r\n\r\n| 对比项        | 基于第三方评论服务 | 输入名字邮箱即可发表评论  |\r\n| ------------- | ------------------ | ------------------------- |\r\n| UI 对比       | 标准 UI            | 与网站更契合的比较萌的 UI |\r\n| 账户系统      | 需要注册 disqus    | 不需要账号                |\r\n| 修改/删除评论 | 是                 | 否                        |\r\n| 需要代理      | 是                 | 取决于博客的部署方式      |\r\n\r\n就吾辈个人而言，最不能忍受的是无法修改评论，即使存在一些错误，例如截图中吾辈的评论中就有一个错别字，但却无法修改。而另一方面，disqus 的 UI 确实不可能和网站整体风格完全一致，这也是自定义博客评论系统更强大的地方。但老实说，相比于 UI，吾辈更在意的是功能性，disqus 已经有许许多多的人注册过，所以有天生的用户群。至于代理的问题，吾辈找不到好的解决方案，国内的类似产品，不是已经死了（多说），就是已经变成垃圾。\r\n\r\n> 实际上代理的问题还是有办法的，虽然还是有点麻烦。参考：[科学使用 Disqus](https://blog.fooleap.org/use-disqus-correctly.html)\r\n","createdTime":1613872287632,"updatedTime":1613875047070,"resources":[{"id":"1d7c7c27c4b34f59964dcb5bf964919e","title":"1613873355258","file_extension":"png","user_updated_time":1613873355645},{"id":"a0af65b841d3440b95043d3254928518","title":"1613873317326","file_extension":"png","user_updated_time":1613873317726}],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"6b5ef22cfbc9438c94db843d199bdcfa","title":"2021 读书计划","body":"## 目标\r\n\r\n由于受到 [木子(读书机器人)](https://blog.k8s.li/2020-booklist.html) 的影响，所以吾辈打算 2021 读更多的书，希望能达到以下几个目标。\r\n\r\n- 将读书变成一个习惯\r\n- 提升自己的认知\r\n- 学习更多计算机基础知识\r\n- 坚持读比较难读的书\r\n\r\n## 清单\r\n\r\n- 这就是投资人\r\n- 这就是保险代理人\r\n- TCP 详解（1）\r\n- 网络是怎么连接的\r\n- 论人类不平等的起源\r\n- 规模\r\n- 爆裂\r\n- 原则\r\n- 金字塔原理\r\n- 上帝造人有多难\r\n- 大学之路\r\n- 女士品茶\r\n- 增长的极限\r\n- 被讨厌的勇气\r\n- 来自新世界\r\n- 异类\r\n- 宇宙-从起源到未来\r\n- 修改代码的艺术\r\n- 解忧杂货铺\r\n- 朝花夕拾\r\n- 地铁\r\n- 家有女友\r\n- 神雕侠侣\r\n- 数学女孩\r\n- 什么是数学\r\n- SICP 计算机程序的构造和解释\r\n- 算法 4(在读)\r\n\r\n> 读书历史将在 [关于页面](https://blog.rxliuli.com/about/) 更新。\r\n\r\n## 实行\r\n\r\n在上下班通勤、中午以及晚上回去时多读点书（当然还是不能影响休息），反正读书总比将时间浪费在 Youtube、小说、游戏上要好，不是么？\r\n","createdTime":1613826448998,"updatedTime":1613872483598,"resources":[],"tags":[{"id":"cb9e3139d6c445159b47d8f26528445d","title":"读书","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"33dd9a3fccaf4666b04935237f885772","title":"electron 开发经验之谈系列-使用 electron-builder 打包","body":"## 前言\n\n在 [基本项目搭建](:/23ec4673a06f41b59bfaf5a7da6d98db) 中，我们已经能够启动一个 electron 应用程序了（开发环境），现在来看如何将之打包为二进制程序便于分发给最终用户。\n\n## 依赖\n\n- [electron-builder](https://www.electron.build/): 打包的主要工具库，负责这个 electron 的跨平台打包工作\n  > 事实上，还有一些其它的打包工具，但目前还没有比它更好的，参考: <https://npmcompare.com/compare/electron-builder,electron-forge,electron-packager>\n\n## 渲染层打包\n\n直接使用 cra 的打包工具即可，没什么大不了的，但确实存在一些注意事项\n\n- 因为 electron 在生产环境会从文件系统中加载静态资源，所以打包出来的静态资源必须支持相对路径，下面是常见的两个设置。\n  - 必须在 _apps/renderer/package.json_ 中声明 `\"homepage\": \".\"`，参考: [Building for Relative Paths](https://create-react-app.dev/docs/deployment/#building-for-relative-paths)\n  - 路由必须是 `hash` 模式\n\n## 主进程打包\n\nelectron-builder 打包需要以下几个步骤\n\n### 更新 package.json 的一些配置\n\n1. 使用 package.json 中的 `build` 字段作为配置项，参考: <https://www.electron.build/>\n2. electron-builder 使用 `main` 字段作为启动脚本文件\n3. electron-builder 要求必须使用固定的版本号，意味着 electron 依赖需要指定为 `\"electron\": \"10.2.0\"`\n\n下面是一个基本的配置示例\n\n```json\n{\n  \"main\": \"dist/main.js\",\n  \"scripts\": {\n    // 一个非常基本的打包脚本\n    \"pkg\": \"electron-builder\"\n  },\n  \"devDependencies\": {\n    \"electron\": \"10.2.0\",\n    \"electron-builder\": \"^22.9.1\",\n    // electron 主进程实际上是 nodejs 环境，所以为了更好的开发体验，安装 nodejs 的类型定义\n    \"@types/node\": \"^12.19.12\"\n  },\n  \"build\": {\n    // 程序的唯一标识符\n    \"appId\": \"com.rxliuli.electron_example\",\n    // 打包出来的 exe 名字\n    \"productName\": \"electron 示例应用\",\n    // 打包的目录\n    \"directories\": {\n      \"output\": \"release\"\n    },\n    \"win\": {\n      // 打包目标，参考: https://www.electron.build/\n      \"target\": [\"nsis\"]\n    }\n  }\n}\n```\n\n### 复制静态资源\n\n现在，我们需要打包静态资源并复制到主进程模块里面\n\n1. `cd apps/renderer` 目录\n2. `yarn build` 打包静态资源\n3. 将静态资源复制到 `build/dist` 目录下\n\n### 修改主进程入口文件 main.ts\n\n还需要修改 _src/main.ts_ 代码，主要修改 BrowserWindow 对象载入的 `url` 地址\n\n```ts\nimport { app, BrowserWindow } from 'electron'\nimport path = require('path')\nimport { URL } from 'url'\n\nasync function createMainWindow() {\n  // 创建新的 electron 窗口\n  const mainWindow = new BrowserWindow()\n  // 载入生产环境的 url\n  await mainWindow.loadURL(\n    new URL(path.join(__dirname, './build/index.html')).href,\n  )\n}\n\n// 其他代码...\n```\n\n> 注意，这个 url 路径是相对于打包后的 `dist/main.js` 而言的，因为最终打包的程序运行时的相对路径也是这样。\n\n### 打包主进程的 exe 程序\n\n> 因为 electron-builder 需要下载基本的 electron 程序，所以请提前设置好透明代理，如果不知道它是什么，参考: [透明网关](https://github.com/rxliuli/haoel.github.io#7-%E9%80%8F%E6%98%8E%E7%BD%91%E5%85%B3)，[Proxifier](http://www.proxifier.com/)\n\n1. 使用 `yarn compile` 编译 ts 代码\n2. 使用 `yarn pkg` 打包 electron 应用\n\n现在，我们应该可以在 _apps/main/release/win-unpacked_ 下看到 exe 程序，双击它即可看到之前在开发环境的首页了。\n\n> 参考: <https://github.com/rxliuli/electron_example/tree/85d398fc2c6ba6c918ad9641dbb5d8bae2d4216b/apps/main>\n\n## 优化打包\n\n虽然打包已经实现，但确实还存在一些问题\n\n- 打包脚本仍然不是一键的\n- 不能兼容开发、生产环境\n\n下面我们来解决这两个问题\n\n### 实现一键打包二进制程序\n\n使用 gulp 复制渲染层的静态资源\n\n1、添加 gulp 相关依赖 `yarn add -D gulp ts-node @types/gulp fs-extra @types/fs-extra`\n\n- `gulp @types/gulp`: gulp 核心依赖\n- `ts-node`: 使用 ts 编写 gulp 脚本必须的依赖\n- `fs-extra @types/fs-extra`: fs 的扩展增强，使用 Promise 包装异步 api\n\n2、添加 gulp 脚本文件\n\n```ts\nimport { copy, remove } from 'fs-extra'\nimport * as path from 'path'\n\nasync function copyByMap(copyMap: [string, string][]) {\n  await Promise.all(\n    copyMap.map(async ([src, destDir]) => {\n      const srcPath = path.resolve(__dirname, src)\n      const destPath = path.resolve(__dirname, destDir, path.basename(srcPath))\n      await copy(srcPath, destPath)\n    }),\n  )\n}\n\n/**\n * 清理最终生成目录\n */\nexport async function clean() {\n  await remove(path.resolve(__dirname, 'dist'))\n  await remove(path.resolve(__dirname, 'release'))\n}\n\n/**\n * 复制一些资源到 dist 目录中\n */\nexport async function copyStatic() {\n  await copyByMap([['../renderer/build', 'dist/']])\n}\n```\n\n3、添加 npm script\n\n> 注: lerna 的好处之一就是可以运行其它模块的 npm script。\n\n```json\n{\n  \"scripts\": {\n    // 打包渲染层的静态资源\n    \"build:web\": \"lerna run --scope renderer build\",\n    // 打包渲染层的静态资源之后复制然后使用 electron-builder 打包 exe 程序\n    \"pkg\": \"gulp clean && yarn compile && yarn build:web && gulp copyStatic && electron-builder\"\n  }\n}\n```\n\n4、修改 tsconfig.json\n\n此时在 _apps/main_ 模块根目录下也有 ts 文件了，所以 tsc 翻译代码会将它们也包含进去，但实际上不需要。\n\n```json\n{\n  \"include\": [\"src\"]\n}\n```\n\n现在，我们可以使用一个命令打包 exe 程序了。\n\n> 参考: <https://github.com/rxliuli/electron_example/blob/3dacff5dc0/apps/main/package.json>\n\n### 使用环境变量来兼容开发、生产环境\n\n解决方案简单来说就一句话：使用环境变量指定开发环境的 URL。\n这里使用 [env-cmd](https://github.com/toddbluhm/env-cmd) 来跨平台写入环境变量（不使用 [dotenv](https://github.com/motdotla/dotenv) 的原因在于自定义环境使用起来有点麻烦，不像 env-cmd 那么直观），而另一个 [cross-env](https://github.com/kentcdodds/cross-env) 并未提供管理环境变量的解决方案。下面说一下使用 env-cmd 的步骤\n\n1. 安装依赖 `yarn add -D env-cmd`\n2. 添加配置文件 _.env-cmdrc.json_\n   基本上是一个键值映射文件，键是环境，值对象是环境变量\n\n   ```json\n   {\n     \"dev\": {\n       \"ELECTRON_START_URL\": \"http://localhost:3000/\"\n     }\n   }\n   ```\n\n3. 在 `dev:electron` 命令之前设定环境变量 `env-cmd -e dev electron ./dist/main.js`\n4. 修改 _src/main.ts_ 读取环境变量\n\n   ```ts\n   await mainWindow.loadURL(\n     process.env.ELECTRON_START_URL ||\n       path.join(__dirname, './build/index.html'),\n   )\n   ```\n\n现在，像 [基本项目搭建](:/23ec4673a06f41b59bfaf5a7da6d98db) 中 **更新 _package.json_ 添加几个 npm script** 说的那样启动开发环境就会显示开发环境的页面，打包后显示的则是打包后的静态资源。\n\n![效果](:/866c4124afe04289b88972507b3f6743)\n\n> 参考: <https://github.com/rxliuli/electron_example/blob/f8b4f94435/apps/main/.env-cmdrc.json>\n\n## 总结\n\n虽然 electron-builder 已经足够好用了，但它仍然不能解决 electron 项目工程上的问题，所以这里结合了 `lerna/gulp/env-cmd` 打包。\n","createdTime":1610020542965,"updatedTime":1613745093922,"resources":[{"id":"866c4124afe04289b88972507b3f6743","title":"20210112130522.png","file_extension":"png","user_updated_time":1610427922838}],"tags":[{"id":"b50c8282004d48edae677ecdfb933e9f","title":"electron","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"23ec4673a06f41b59bfaf5a7da6d98db","title":"electron 开发经验之谈系列-基本项目搭建","body":"## 环境\n\n- Windows 10\n- NodeJS 12\n- WebStorm\n- VSCode（编写 markdown 文档）\n\n## 创建 lerna 项目\n\n创建目录 _electron_example_，然后使用 yarn 初始化\n\n```sh\nmkdir electron_example && cd electron_example\nyarn init -y\n```\n\n修改 _package.json_\n\n```json\n{\n  \"name\": \"electron_example\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"license\": \"MIT\",\n  \"workspaces\": {\n    \"packages\": [\"apps/*\"]\n  }\n}\n```\n\n随后创建 _lerna.json_ 配置文件\n\n```json\n{\n  \"packages\": [\"apps/*\"],\n  \"version\": \"independent\",\n  \"npmClient\": \"yarn\",\n  \"useWorkspaces\": true\n}\n```\n\n初始化目录如下\n\n- _apps_\n  - _main_: 主进程\n  - _renderer_: 渲染进程\n- _node_modules_\n- _lerna.json_\n- _package.json_\n- _yarn.lock_\n\n> 参考: <https://github.com/rxliuli/electron_example/tree/b9628e1fd16bb5b6807e55e9ca72fdf2daf5bfde>\n\n## 初始化渲染层模块\n\n在 renderer 目录中使用 create-react-app 创建一个 react 项目，并添加\n\n```sh\nnpx create-react-app apps/renderer/ --template typescript\n```\n\n不过还需要修改其中部分配置，主要包含\n\n- 删除 _yarn.lock_ 或 _package-lock.json_ 文件\n\n> 参考: <https://github.com/rxliuli/electron_example/tree/8e0920af985e1201fc05ca36302e094532843c2d>\n\n尝试再 yarn 安装依赖，接着再使用 `yarn start` 启动开发环境，应该可以在浏览器中看到默认的页面。\n\n![20210106194304.png](:/9aa685b675a14bf788093f2656ffc4e8)\n\n## 初始化主进程模块\n\n> 参考: <https://github.com/rxliuli/electron_example/tree/a78885b76de9322dfdac82e2c220b7c6e0a9617f>\n> 注：electron 版本选择双数，生命周期更长。\n\n初始化主进程模块，主要包括\n\n### 为主进程创建 package.json\n\n```json\n{\n  \"name\": \"main\",\n  \"version\": \"0.1.0\"\n}\n```\n\n### 添加依赖 `yarn add electron electron-builder typescript`\n\n```json\n// package.json\n{\n  \"devDependencies\": {\n    \"electron\": \"^10.2.0\",\n    \"electron-builder\": \"^22.9.1\",\n    \"typescript\": \"^4.1.3\"\n  }\n}\n```\n\n### 添加 _tsconfig.json_ 配置文件\n\n```json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    // nodejs 生态大多数都支持这种模块\n    \"module\": \"commonjs\",\n    // 优先考虑输出 es5\n    \"target\": \"es5\",\n    // 但不要自缚手脚，仍然使用最新的 es 特性\n    \"lib\": [\"ESNext\"],\n    // 定义源目录与输出目录\n    \"rootDir\": \"src\",\n    \"outDir\": \"dist\",\n    // 生成 sourceMap 方便 IDE 本地调试\n    \"sourceMap\": true,\n    // 禁止 ts 检查 npm 依赖的类型定义（例如 electron 的类型定义就很容易被 ts 检查出错误，毕竟这个项目实在太大了）\n    \"skipLibCheck\": true,\n    \"skipDefaultLibCheck\": true\n  },\n  // 排除依赖目录与输出目录\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n### 添加 _src/main.ts_ 基本的启动文件\n\n```ts\n// src/main.ts\nimport { app, BrowserWindow } from 'electron'\n\nasync function createMainWindow() {\n  // 创建新的 electron 窗口\n  const mainWindow = new BrowserWindow()\n  // 载入开发环境的 url\n  await mainWindow.loadURL('http://localhost:3000/')\n}\n\n/**\n * main 函数\n */\nasync function main() {\n  app.on('ready', createMainWindow)\n}\n\nmain()\n```\n\n### 更新 _package.json_ 添加几个 npm script\n\n```json\n// package.json\n{\n  \"scripts\": {\n    // 编译 ts 代码\n    \"compile\": \"tsc\",\n    // 编译 tsc 代码且启动监听模式\n    \"watch\": \"yarn compile -w\",\n    // 在主进程通过 lerna 启动渲染进程模块的开发环境\n    \"dev:web\": \"lerna run --scope renderer start\",\n    // 启动主进程的开发环境\n    \"dev:electron\": \"electron ./dist/main.js\"\n  }\n}\n```\n\n接下来，我们通过这些 npm script 启动 electron 开发环境\n\n1. 运行 `yarn watch`\n2. 运行 `dev:web`\n3. 等待以上两条命令都运行完成，再继续运行 `dev:electron`\n\n现在，你应该可以看到一个 electron 窗口，其中显示着。\n\n![20210106194102.png](:/be9a61a9bb6c466a86f0fe9c1ea499a6)\n\n## 总结\n\n目前，使用 lerna monorepo 似乎还看不出来明显的优点，不过实际上在后面逐步完善 Electron 程序的过程中我们会发现它的强大之处。\n","createdTime":1609807578437,"updatedTime":1613745091449,"resources":[{"id":"9aa685b675a14bf788093f2656ffc4e8","title":"20210106194304.png","file_extension":"png","user_updated_time":1609933384604},{"id":"be9a61a9bb6c466a86f0fe9c1ea499a6","title":"20210106194102.png","file_extension":"png","user_updated_time":1609933263365}],"tags":[{"id":"b50c8282004d48edae677ecdfb933e9f","title":"electron","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"5cc9156517484576a64b4d253ae28af8","title":"electron 开发经验之谈系列-开发环境优化","body":"## 使用 react devtool 插件调试\n\n<!-- TODO 需要将这两个函数抽离成静态工具类 -->\n\n前言\n\n虽然绝大多数时候，我们都可以也应该在浏览器调试渲染层的功能，但确实也会有需要在 electron 程序中调试的需求，这里就说明一下 electron 如何安装 chrome 插件 react devtool 调试项目。\n\n> 核心依赖: [electron-devtools-installer](https://www.npmjs.com/package/electron-devtools-installer)\n\n步骤\n\n1、安装依赖\n\ncd 到 _apps/main_ 目录\n\n```sh\nyarn add -D electron-devtools-installer @types/electron-devtools-installer\n```\n\n2、添加环境变量 `\"NODE_ENV\": \"development\"` 标识为开发环境\n\n修改 _.env-cmdrc.json_ 配置文件\n\n```json\n{\n  \"dev\": {\n    \"NODE_ENV\": \"development\",\n    \"ELECTRON_START_URL\": \"http://localhost:3000/\"\n  }\n}\n```\n\n3、修改 `main` 函数\n\n```ts\n// main.ts\nasync function main() {\n  app.addListener('ready', async () => {\n    if (process.env.NODE_ENV === 'development') {\n      // 安装 devtool 扩展\n      await installExtension(REACT_DEVELOPER_TOOLS)\n    }\n\n    await createMainWindow()\n  })\n}\n```\n\n4、修改 `createMainWindow` 函数\n\n一般，我们在开发环境还习惯打开控制台，这里也可以在创建窗口后自动打开它。\n\n```ts\n// main.ts\nasync function createMainWindow() {\n  // 创建新的 electron 窗口\n  const mainWindow = new BrowserWindow()\n  // 载入生产环境的 url\n  await mainWindow.loadURL(\n    process.env.ELECTRON_START_URL ||\n      path.join(__dirname, './build/index.html'),\n  )\n  if (process.env.NODE_ENV === 'development') {\n    mainWindow.webContents.openDevTools()\n  }\n}\n```\n\n> 可能的错误参考: [常见问题](:/c68829779f5449d0afe0e67806dc7fc1) **安装浏览器扩展报错**\n\n5、启动 electron 开发环境\n\n启动后可以看到自动打开了控制台，然后可以看到 react devtool\n\n![实际效果](:/4bdfd0cdf55c4e098b1f5b3a92fb7947)\n\n## 让主进程的代码也能热更新\n\n前言\n\n可能你也发现了，渲染层使用 cra 创建的项目默认包含了热更新，这都要得益于 webpack HMR 技术，但主进程并非如此，即便使用 `tsc -w` 监听并编译 ts 代码，但想要生效仍然需要重启 electron，不厌其烦。幸运的是，有人已经实现了这个需求。\n\n> 核心依赖: [electron-reloader](https://www.npmjs.com/package/electron-reloader)\n\n1、安装依赖\n\n```sh\nyarn add -D electron-reloader\n```\n\n2、在主进程入口文件载入 electron-reloader\n\n```ts\n//添加热更新功能\nif (process.env.NODE_ENV === 'development') {\n  require('electron-reloader')(module)\n}\n```\n\n3、启动 electron 开发环境\n\n![效果](:/d2a07efc8ff24354b49289c2d4210b79)\n\n> 注 2: 当修改代码时，重启 electron 应用是由 electron-reloader 负责，即它不在 WebStorm 的控制之下了。\n> 注 2: 目前另一个 [electron-reload](https://www.npmjs.com/package/electron-reload) 还存在一些小问题。\n\n## 使用 esbuild 优化渲染层打包性能\n\n> 如果你还没有感觉到 cra 打包很慢，可以跳过这一节。\n\n### 禁止 ts/babel 将代码编译为 ES5\n\n由于 electron 捆绑的浏览器和 nodejs 版本都比较新，所以实际上渲染层我们基本不需要 babel 转义，可以优化一些配置项。\n\n- 将 `browserslist` 设置为仅支持最后一个 chrome 版本\n\n  ```json\n  {\n    \"browserslist\": [\"last 1 chrome version\"]\n  }\n  ```\n\n- 修改 _tsconfig.json_ 中的配置，将编译目标修改为 `ESNext`\n\n  ```json\n  {\n    \"compilerOptions\": {\n      \"target\": \"ESNext\"\n    }\n  }\n  ```\n\n### 使用 esbuild 编译 typescript 代码\n\n> 核心依赖: [esbuild](https://github.com/evanw/esbuild), [craco](https://github.com/gsoft-inc/craco)\n\nesbuild 是一个使用 golang 编写前端打包工具，官方在性能测试中提出比现有工具快 10-100 倍。\n\n在 cra 创建的项目中，我们可以通过 craco 将 esbuild 仅用作 ts 编译之用（不会检查类型）。\n\n1、安装依赖\n\n```sh\nyarn add -D @craco/craco craco-esbuild\n```\n\n2、修改 npm script，使用 `craco` 替换 `react-scripts`\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"craco start\",\n    \"build:cra\": \"react-scripts build\",\n    \"build\": \"craco build\",\n    \"test\": \"craco test\"\n  }\n}\n```\n\n生产项目中的对比测试结果（6000+ 行 ts 代码）\n\n| 分类                | ESBuild | tsc     |\n| ------------------- | ------- | ------- |\n| 无缓存              | 17.61   | 36.57   |\n| 有缓存（运行 5 次） | 15252.8 | 17095.2 |\n","createdTime":1610020774617,"updatedTime":1613745088761,"resources":[{"id":"4bdfd0cdf55c4e098b1f5b3a92fb7947","title":"1610618120779.png","file_extension":"png","user_updated_time":1610618121187},{"id":"d2a07efc8ff24354b49289c2d4210b79","title":"test (2).gif","file_extension":"gif","user_updated_time":1610623410768}],"tags":[{"id":"b50c8282004d48edae677ecdfb933e9f","title":"electron","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"85f539d2cc4e4ae89093df537111cec8","title":"electron 开发经验之谈系列-自定义窗口顶栏","body":"## 场景\n\n在很多生产项目中，我们希望自定义 electron 窗口顶栏，因为它确实非常简陋。\n\n## 步骤\n\n### 在渲染层实现自定义顶栏\n\n实际上，核心的代码就是添加一个为顶栏的元素添加 css 样式。在 electron 环境，有 `-webkit-app-region: drag;` 属性的元素可以拖动整个窗口。\n\n```css\n.toolbar {\n  -webkit-app-region: drag;\n}\n.toolbar > * {\n  -webkit-app-region: no-drag;\n}\n```\n\n上面的 css 看起来有点奇怪，但这是为了避免子元素（例如关闭按钮）也可以拖动的错误。\n\n> [参考文档](https://www.electronjs.org/docs/api/browser-window#event-system-context-menu-windows), [参考代码](https://github.com/rxliuli/electron_example/blob/18a1a756e5c82e87ef1c8755a0be036b6765f04b/apps/renderer/src/components/router/component/BasicLayout.module.css#L13)\n\n### 使用 electron 通信实现窗口的三个操作\n\n其实，electron 本身支持在渲染层暴露 `remote` 模块，但这里我们选择使用 `ipcRenderer/ipcMain` 手动实现，remote 模块因为安全原因默认被禁用了。\n\n下面的步骤基本和 [渲染、主进程通信](:/76393a60949c47c7add910df0206734c) 所属一样，下面贴一些关键代码\n\n共享类型\n\n```ts\n// WindowDefine.ts\nimport { BaseDefine } from 'electron_ipc_type'\n\nexport interface WindowDefine extends BaseDefine<'WindowApi'> {\n  action(type: 'min' | 'max' | 'close'): void\n}\n```\n\n主进程\n\n```ts\n// main.ts\nclass WindowApi {\n  async action(e: IpcMainInvokeEvent, type: 'min' | 'max' | 'close') {\n    const win = BrowserWindow.fromWebContents(e.sender)\n    switch (type) {\n      case 'min':\n        win.minimize()\n        break\n      case 'max':\n        win.isMaximized() ? win.unmaximize() : win.maximize()\n        break\n      case 'close':\n        win.close()\n        break\n    }\n  }\n}\n```\n\n渲染进程\n\n```ts\n// BasicLayout.tsx\nconst windowApi = IpcRendererClient.gen<WindowDefine>('WindowApi')\n\n/**\n * 封装 electron 的窗口控制 hooks\n */\nfunction useElectronWindowControl() {\n  return {\n    handleMin: () => windowApi.action('min'),\n    handleMax: () => windowApi.action('max'),\n    handleClose: () => windowApi.action('close'),\n  }\n}\n```\n\n> [参考代码](https://github.com/rxliuli/electron_example/tree/3aea837b0c7661e030406a0c20d306694402a26f)\n\n### 隐藏掉默认的顶栏\n\n实际上，只要在创建 electron 的 `BrowserWindow` 实例时配置即可\n\n```ts\nnew BrowserWindow({\n  webPreferences: {\n    nodeIntegration: true,\n  },\n  frame: false,\n  autoHideMenuBar: true,\n})\n```\n\n现在，electron 程序就有自定义顶栏啦\n\n![1611134001681.png](:/92f7aa2fcd894107b05056f5c662e051)\n\n## 问题\n\n虽然自定义窗口顶栏有很多优点，但也并非尽善尽美，已知缺点如下\n\n- 占有了一定高度，导致一些 UI 组件的位置很奇怪，例如顶部的消息提示框和侧边抽屉，会遮挡住窗口顶栏的一部分。\n- 可能随着系统升级与系统风格不搭，早有人吐槽过 Windows 所有程序的自定义顶栏都是不一样的高度和大小，非常丑\n- 需要重新实现窗口菜单相关的快捷键，例如 `ctrl+shift+i` 打开开发者工具\n- 在 mac 上需要进行特别的兼容，否则和其他程序会显得格格不入\n","createdTime":1610021564784,"updatedTime":1613745080765,"resources":[{"id":"92f7aa2fcd894107b05056f5c662e051","title":"1611134001681.png","file_extension":"png","user_updated_time":1611134002177}],"tags":[{"id":"b50c8282004d48edae677ecdfb933e9f","title":"electron","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"bf7621c04d9f45098fb0ecf2acad336e","title":"electron 开发经验之谈系列-自动更新","body":"## 场景\n\n由于生产应用希望在有新版本时，自动为用户推送更新，所以此处便写一下如何让 electron 程序自动更新。\n\n## 安装 npm 包\n\n```sh\ncd apps/main/ && yarn add electron-updater\n```\n\n## 配置 electron-builder\n\n> 参考: <https://www.electron.build/auto-update>\n\n其实本质上就是配置一个网络可以访问到的静态资源目录，这里使用了一个本地的静态资源服务器，指向目录是 _apps/main/release_（即打包而进程程序的目录）\n\n```json\n{\n  \"build\": {\n    \"publish\": [\n      {\n        \"provider\": \"generic\",\n        \"url\": \"http://localhost:8080/\"\n      }\n    ]\n  }\n}\n```\n\n## 启动时检查更新\n\n在主进程添加检查更新的代码，并自定义提示文案。\n\n```ts\nawait autoUpdater.checkForUpdates()\nautoUpdater.addListener('update-downloaded', (info) => {\n  new Notification({\n    title: '更新提醒',\n    body: `新版本 ${info.version} 已经准备好，点击立刻更新！`,\n  })\n    .addListener('click', () => {\n      autoUpdater.quitAndInstall()\n    })\n    .show()\n})\n```\n\n## 效果\n\n现在，你可以启动一个本地静态服务器指向 _apps/main/release_，例如 [live-server](https://www.npmjs.com/package/live-server)，然后打包一个新版本，再启动旧的程序就可以了。\n\n![效果](:/6a33797917e34056b95238471ff0c06b)\n","createdTime":1609807604689,"updatedTime":1613745077298,"resources":[{"id":"6a33797917e34056b95238471ff0c06b","title":"test (3).gif","file_extension":"gif","user_updated_time":1634414451463}],"tags":[{"id":"b50c8282004d48edae677ecdfb933e9f","title":"electron","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"1a01dae8fd924bb6a0d5f4ee7f6847cf","title":"前端与后端的选择（个人理解）","body":"## 前言\r\n\r\n> 吾辈就是一个从 Java Web 后端转到前端的人。\r\n\r\n吾辈今天又在看到人说 **前端很简单，而且还比后端工资高**，这里吾辈还是想做一些澄清的。\r\n\r\n## 对话\r\n\r\n- 后端 A: 我发现这两年前端的工作特别好找，而且工资很高\r\n- 后端 A：后端内卷太严重了。\r\n- 后端 B: #无语\r\n- 后端 B: 前端要会啥啊到底才能称得上前端\r\n- 后端 A: 我们这边。H5+小程序 就行了\r\n- 后端 A: 主要是 CSS 要能处理好。。。\r\n- 后端 A: 设计做出来的东西要不能有折扣的做出来。。而不是向组件找不到妥协。。。。\r\n- 后端 B：我感觉我很合适唉，虽然我没怎么做过小程序\r\n- 后端 B: 有没有 Java 转前端的啊\r\n- 吾辈：吾辈就是 @后端 B\r\n- 吾辈：可能泥萌那是 2c 的业务，像吾辈这边偏向于 2b 的，业务和架构的复杂度相当高，事实上，吾辈这边的前端架构都已经需要微服务化了（即所谓的微前端）\r\n- 后端 C：微前端\r\n- 后端 A：不知道是不是后端的错觉。。感觉前端好简单啊，为啥还要比后端工资高。。\r\n- 吾辈: 这其实有个错觉就是，前端开发岗位多，开发人员多，就一定好找工作。Java 还不是有很多培训班为市场注入了许多后端，而 web 其实也很糟糕，因为似乎所有人都开始觉得前端只要会 vuejs 加点 html/css/js 就可以开始工作了，恰好市场这两年的缺口还很大，所以培训班其实也为市场注入了相当的人员，导致招聘很难招，工作很难找。（不过不吹不黑，吾辈确实因为转到前端发生了发生了很多变化，尤其是在开源项目方面，之前基本不做，现在嘛，有时间就会做一些 #本质原因可能还是因为前端还不够成熟吧）\r\n- 后端 A：不知道是不是后端的错觉。。感觉前端好简单啊，为啥还要比后端工资高。。。@吾辈\r\n- 后端 D: 不是说前端比较抗骂嘛\r\n- 吾辈：你什么时候产生了前端比后端工资高的错觉，就那吾辈的公司来说，前端 10-20，后端 golang 15-20，Java 18-35 (´-ι\\_-｀)\r\n- 吾辈：另外前端技术栈迭代非常快，前后端的边界正在后移，想想之前后端还要负责模板引擎，路由，状态管理，逻辑代码，工程化方面的任务，现在，这些都成为了前端的任务，而且之前的任务 ui 还原还没少，而后端在吾辈看来的一个主要问题在于用户量不够的情况下基本没得折腾，意味着许多 idea 无法在生产环境落地，后端技术栈迭代也很慢（主要是由于风险更高以及成熟度），现在还是 Java 8，而前端，基本都是跟着版本跑（当然这会带来 js 疲劳暂且不说），生产环境吾辈已经上了 ts 4（半年之前更新的大版本）。还有一点我不确定是否是常事，一般后端似乎没有自己维护的开源项目，这很显然是没法在生产之外尝鲜新技术的，一年经验用十年，不外如是。\r\n- 吾辈：另外觉得前端简单的可以看一下这一系列谈话（前后端之间的，2016 年的，现在前端更加复杂化了）[2016 年里做前端是怎样一种体验\r\n  ](:/333051b25bd047e8864d161a9a6982de)\r\n\r\n## 感想\r\n\r\n就吾辈个人的感觉而言，似乎许多后端还不清楚前端领域到底发生了什么，觉得前端还仅仅是 **切图**，而这显然是个错误。\r\n\r\n前端近几年发展迅速，几乎可以说是日新月异，尽管可能大部分都会被扫进历史的垃圾堆，但至少能够切身参与到发展的历史进程中。而且，现在前端要解决的问题域也在发生变化，在传统前端眼里，CSS（UI 还原）和兼容性问题是最重要的，但现在，已然天翻地覆，前端本身的知识领域也在发生割裂，参考: [大分裂](https://css-tricks.com/the-great-divide/)。\r\n\r\n> 当然在很久以前，前端也有独特的「复杂问题」，比如我刚工作那会需要掌握的精确到 1px 的兼容到 IE6 的高保真切图技巧，但这类问题更偏向「手艺人」的工作，而非工程师的技术价值体现，更重要的是，它无法被沉淀为技术人的长期价值。\r\n\r\n而后端，经过几十年的长足发展，已经非常完善，似乎没有太大的变化了。当然，就像 [前端为什么会越来越复杂？](https://www.zhihu.com/question/375448022) 所言，**「后端是在业务方面革自己的命，使劲在平台化、中台化发展，然后把具体业务这块解放给前端」**。\r\n\r\n| 分类         | 前端                     | 后端                             |\r\n| ------------ | ------------------------ | -------------------------------- |\r\n| 发展速度     | 迅速                     | 缓慢                             |\r\n| 发展程度     | 发展中                   | 成熟                             |\r\n| 试错成本     | 低                       | 高（后台服务炸掉是很难被接受的） |\r\n| 知识价值     | 低（发展迅速带来的疲劳） | 高                               |\r\n| 入门难度     | 低（学会三大件就能写）   | 高                               |\r\n| 个人成长机会 | 一般                     | 低（很难有机会应用自己的轮子）   |\r\n\r\n> 注：以上均为吾辈在小公司的一些体会，并不一定意味着**正确**。而且，前端并不一定意味着简单，也有可能是根本没有接触过复杂的应用场景。例如前端工程化、智能化、编辑器、富文本、可视化图表之类的。当然，前后端其实面临着相似的问题：在小公司很多东西并没有使用场景，低层次的工作重复十年也做不出来一个 [设计稿智能生成代码 imgcook](https://juejin.cn/post/6924591257452806152/)\r\n> 注 2：但同时，吾辈也不得不承认两者确实在天花板上有着差异，尤其而且是在大型互联网公司（例如阿里），参考：[漫谈前后端天花板](https://blog.alswl.com/2019/07/frontend-backend-ceiling/)\r\n","createdTime":1610036050576,"updatedTime":1613743730454,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"310a24392e1c4d27a6927c3dc7b34704","title":"读书 [浪潮之巅]","body":"## 简介\r\n\r\n前些时日，吾辈读完了 [浪潮之巅] 这本书。\r\n\r\n![封面](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190823011623.png)\r\n\r\n它是 Google 开发者吴军所写的 IT 行业各个重要公司的兴衰历史，并进一步探讨了其中的原因。那些曾经无比耀眼的新星，压在每个公司头上的庞然大物，是如何一步步变成这样的。\r\n\r\n## 起因\r\n\r\n最初是在一位朋友的推荐下了解到这本书的，当然，那位推荐了不少有趣的书籍: 黑客与画家、浪潮之巅、人月神话等。\r\n\r\n## 感想\r\n\r\n1. 书中最有趣的一个观点是: 公司是由基因决定的，转基因大多都失败了。\r\n\r\n   ![基因](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190823013804.png)\r\n\r\n   > 两年前，我和李开复博士等人多次谈论科技公司的兴衰，我们一致认为一个公司的基因常常决定它今后的命运，比如 IBM 很难成为一个微机公司一样。摩托罗拉也是一样，它的基因决定了它在数字移动通信中很难维持它原来在模拟手机上的市场占有率。摩托罗拉并不是没有看出数字手机将来必将代替模拟手机，而是很不情愿看到这件事发生。作为第一代移动通信的最大收益者，摩托罗拉要尽可能地延长模拟手机的生命期，推迟数字手机的普及，因为它总不希望自己掘自己的墓。如果过早地放弃模拟手机，就等于放弃已经开采出来的金矿，而自降身价和诺基亚的公司一同从零开始。尤其在刚开始时，数字手机的语音质量还远不如摩托罗拉砖头大小的大哥大，更使摩托罗拉高估了模拟手机的生命期。和所有大公司一样，在摩托罗拉也是最挣钱的部门嗓门最大，开发数字手机的部门当然不容易盖过正在挣钱的模拟手机部门，因此，摩托罗拉虽然在数字手机研发上并不落后，但是，进展缓慢。一旦各个竞争对手推出各种各样小巧的数字手机时，摩托罗拉才发现自己慢了半拍。\r\n\r\n   当然，和所有的观点一样，也有人不同意基因决定论: [吴军的公司基因论极其肤浅可笑](https://www.chainnews.com/articles/460655320271.htm)\r\n\r\n2. 曾经，只知道比尔盖茨是世界首富，很强很厉害。具体如何很厉害，吾辈也说不上原因。曾经微软在开源领域骂名昭著，现如今却又大力拥抱开源，不仅开发了开源的 VSCode，甚至在去年收购了开源领域的圣地 -- [GitHub](http://github.com)。甚至于，微软可以说是一直都四面皆敌，然而比尔盖茨还是领导着它一路走了过来，并且，除了近年来的 Google，没有公司真正挑战过微软 -- 包括很多人喜欢的苹果。\r\n\r\n   ![微软标志](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190823022335.png)\r\n\r\n   > 乔布斯和盖茨都意识到了微机及其相关工业将是一个大产业，事实证明这确实是一个万亿美元的大产业。我们在前面已经分析过，计算机工业比任何行业都容易出现垄断公司。乔布斯和盖茨都想做垄断者，但是他们的方式不同。前者是想做原来 IBM 那样的垄断者，从硬件到软件全部垄断，这后来证明是行不通的。而盖茨天才之处在于，它在微机工业刚刚开始的时候，就意识到只要垄断了操作系统，就间接垄断了整个行业，因为操作系统和别的软件不同，是在买计算机时预装好了的，一般用户没有选择权。而其它的软件用户则有选择权。\r\n   > 如果说乔布斯是锋芒毕露，聪明写在脸上；盖茨就是一个平衡木冠军，聪明藏在肚子里。无疑，后者比前者更可怕。\r\n\r\n3. 近来的几十年，对于 IT 行业来说真的是波澜壮阔的时代，**无线通信 => 大型机 => 微机 => 互联网 => 智能手机**，每一次的变化都导致了世界上许多人的命运被改变。\r\n\r\n   - 无线通信: ATT 的贝尔实验室访华成员甚至受到了国家主席的接见\r\n   - 大型机: IBM 成功变成了 **蓝大象**，并统治了企业级市场\r\n   - 微机: 微软和苹果成功统治了操作系统，英特尔则统治了微机的心脏 -- CPU\r\n   - 互联网: 雅虎，Google 成功崛起，实际上挑战了微软系统作为用户入口的统治地位\r\n   - 智能手机: Google Android 再获成功，再次对微机入口的统治地位造成威胁\r\n\r\n   > 如果说基因决定性多少有些宿命论，那么人为的因素也加速了摩托罗拉的衰落。我们在介绍英特尔一章中介绍过，在科技工业发展最快的八九十年代，摩托罗拉的第三代家族领导人卡尔文三世没有能力在这个大时代中纵横捭阖，开拓疆土。摩托罗拉本来在手机、计算机处理器和数字处理器（DSP）三个领域均处于领先地位，前景不可限量。但是卡尔文实在没有能力将三个庞大的部门十几万人管理好，虽然他没有犯什么大的错误，但是他平平庸庸。也许，在五十年前，一个只需要守成的年代他可以坐稳他的位置，但是在上个世纪末那个一个英雄辈出、拒绝平庸的年代，盖茨、乔布斯、郭士纳、格罗夫、钱伯斯和通用电气的杰克·韦尔奇等人都在同场角逐，任何公司都在逆水行舟，不进则退。除了卡尔文，摩托罗拉的整个管理层也有责任，他们低估了摩尔定理的作用。虽然数字手机在一开始还比不上模拟手机，但这并不能说它要很长时间才能威胁模拟手机的地位。事实上，由于半导体技术按指数的速度发展，手机数字化比摩托罗拉高管们想象的时间表来得早得多，使得摩托罗拉几十年来积累的模拟技术变得无关紧要，市场的优势顿失。\r\n\r\n4. IT 行业的发展速度非常之快，传统行业需要几十上百年才能垄断一个产业，在这个领域创造一个产业从形成到垄断只需要短短几年就可以完成。最终形成前面一两家公司占大头吃肉，后面的小公司跟在后面喝汤，例如桌面操作系统中的 Windows(80+%)，MacOS(10+%) 和 Linux (1+%)。\r\n\r\n   ![操作系统比率图](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190823023553.png)\r\n\r\n   > 虽然微软在操作系统市场的优势和高通在 3G 市场的垄断是极端的例子，但是，即使在一般情况下，在一个成熟的市场上占有主导地位的公司仍然能独占 60-70% 的市场。在处理器市场上，英特尔一年有近 400 亿的销售额，而第二名 AMD 仅有 60 亿。在网络设备市场上，思科销售额高达 400 亿，是它的对手华为（ 100 亿）和 Juniper （ 40 亿）总和的三倍。\r\n   > 附: 以下是吾辈的个人观点\r\n   > 虽说很多人鼓吹 Linux，甚至说世界上最快的电脑大多运行 Linux 或类 Unix，但实际上在桌面微机领域 Linux 的份额少得可怜，即便是近年来 Ubuntu，Fedora 这些开箱即用发行版的流行，也并不能改变整个领域已被微软垄断的事实。\r\n   > 一个支撑的证据就是: Linux 下大多数工具没有选择，而 Windows 下同一个功能的程序会有很多类似的，如果不好用，用户可以换另外一种。\r\n\r\n5. 国内的很多公司似乎被很多 IT 技术人员看不起，但这其实也是一种偏见。平心而论，在开源方面，国内公司确实相当糟糕。矮个子里拔高个，要数阿里的开源项目是最好的了。即便如此，仍然会发生很恶心的事情，例如去年圣诞节沸沸扬扬的圣诞彩蛋事件。然而，在商业和技术方面，阿里都是相当领先的。\r\n\r\n   ![圣诞彩蛋事件](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190823024140.png)\r\n\r\n   > 中国的电子商务比实体商务更难做一－没有信用体系，真正意义上的信用卡不普及，没有在线支付手段，没有物流保障。大部分试水电子商务的公司，包括著名的 eBay 公司，都无法逾越这些障碍，很多公司不得不知难而退，很多商家和投资人甚至认定中国的电子商务发展必须再等很长的时间。而阿里巴巴的过人之处就是在于它以积极的态度，解决了大多数人认为无解的难题。没有信用系统，阿里巴巴就自己建立了一个；没有支付手段， 它就利用此契机开发了支付宝，这不仅解决了在阿里巴巴上交易的支付问题，而且扩展到解决中国整个在线甚至离线支付的问题；中小商家管理混乱，阿里巴巴就在它的 B2B 部门开发了面向企业的应用软件；至于物流，它起初并没有进入这个高投资、低回报的部门，而是利用它巨大的交易量，通过与第三方的合作，在保障商家和用户的基础上，规范了整个物流行业的经营 σ 可以毫不夸张地讲，在全世界没有哪家公司，包括 eBay 和亚马逊，像阿里巴巴那样做到了控制住整个电子商务产业链中的所有关键性环节。因此，我可以毫不夸张地预言， 阿里巴巴会在很短的时间里，超过 eBay 和亚马逊的总和，成为全球仅次于 Google 的第二大互联网公司。我甚至还可以进一步预言，如果中国政府对它不加限制，它可以成为中国市值最大的公司。\r\n\r\n## 总结\r\n\r\n最后以一句名言作为结尾: **这是最好的时代，也是最坏的时代**，而我们，正处于这个时代之中。\r\n\r\n---\r\n\r\n刚看完第四版，里面更新了不少内容（据同事说将作者的另一本书 [硅谷之谜](https://book.douban.com/subject/26665230/) 的内容糅合到这本书了），吾辈个人的直观感受是，相比于之前的版本，提出了许多有关国内的见解。例如阿里巴巴、腾讯，还有最近几年的明星公司小米、华为、滴滴等等。\r\n","createdTime":1580652938079,"updatedTime":1612364559600,"resources":[],"tags":[{"id":"cb9e3139d6c445159b47d8f26528445d","title":"读书","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"0e07cf985f5d4437b2e4f90b73612b2b","title":"CSS Grid 与图片共存时的布局问题","body":"## 场景\n\n在生产中遇到的一个 css 问题，css 不正交的问题一直有人吐槽，吾辈今天总算也是遇到了，实在是不吐不快。\n\n> [CSS 为什么这么难学？](https://zhuanlan.zhihu.com/p/29888231)\n\n如下一个简单的二维横向图片列表\n\n```html\n<style>\n  * {\n    padding: 0;\n    margin: 0;\n  }\n  .rows {\n    height: 500px;\n    display: grid;\n    grid-template-rows: repeat(5, 1fr);\n  }\n  .cols {\n    height: 100%;\n    display: flex;\n  }\n  .item {\n    height: 100%;\n  }\n  .item img {\n    max-height: 100%;\n  }\n</style>\n<main class=\"rows\">\n  <div v-for=\"items of list\" class=\"cols\">\n    <div v-for=\"item of items\" class=\"item\">\n      <img :src=\"item.url\" />\n    </div>\n  </div>\n</main>\n\n<!-- 下面是生成一些测试数据，不需要关心 -->\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/faker@5.2.0/dist/faker.js\"></script>\n<script>\n  new Vue({\n    el: '.rows',\n    data: {\n      list: Array(5)\n        .fill(0)\n        .map(() =>\n          Array(faker.random.number({ min: 10, max: 20 }))\n            .fill(0)\n            .map(() => {\n              const getNumber = () =>\n                faker.random.number({ min: 200, max: 300 })\n              return [getNumber(), getNumber()]\n            })\n            .map(([x, y]) => ({\n              width: x,\n              height: y,\n              url: `https://picsum.photos/seed/picsum/${x}/${y}`,\n            })),\n        ),\n    },\n  })\n</script>\n```\n\n但显示的效果却并非预想中那样五等份，而是会超过最大高度 -- 被图片撑高了。\n\n![1611716016173.png](:/ab035c3bd9314c17ad6ec4390a6b00b7)\n\n而在经过一番摸索和讨论后，吾辈找到了这个规范：<https://drafts.csswg.org/css-grid/#algo-terms>\n\ngrid 的 fr 单位实际上是个弹性值，如果内容过大，则会撑开。。。而图片的默认大小就是过大的内容。如果显式声明了最小值，就不受图片尺寸的影响了。\n\n修改 `grid-template-rows: repeat(5, 1fr);` => `grid-template-rows: repeat(5, minmax(0, 1fr));` 就好了。\n\n效果\n\n![1611716716541.png](:/f315fce582304158b1913b4f2c947a84)\n\n## 吐槽\n\n发明 CSS 的人就是一个智障，这么多不正交的规则纯靠经验真的太恶心了（不是每个人都了解或者说希望了解那些奇奇怪怪的规范）。\n","createdTime":1611714991484,"updatedTime":1611716768565,"resources":[{"id":"ab035c3bd9314c17ad6ec4390a6b00b7","title":"1611716016173.png","file_extension":"png","user_updated_time":1634415116032},{"id":"f315fce582304158b1913b4f2c947a84","title":"1611716716541.png","file_extension":"png","user_updated_time":1611716717000}],"tags":[{"id":"8f339224ff5c4b5aa4103e407b04ed0e","title":"css","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"194d8faa9c6248b3ac7f5497ac3b4b3e","title":"有限状态机","body":"> [xstate.js 官网](https://xstate.js.org/), [中文（繁体）教程参考](https://blog.jerry-hong.com/posts/xstate-tutorials-context-actions/)\n\n## 场景\n\n- 为什么要引入状态机？\n- 吾辈希望使用有限状态机管理程序中的状态及状态的流转，以避免使用各种 `flag` + `if/else` 控制程序的运行。\n- 为什么吾辈会突然觉得 `flag` + `if/else` 这种方式不好呢？\n- 原因在于吾辈最近在看设计模式相关的书籍：[JavaScript 设计模式与开发实践](https://book.douban.com/subject/26382780/)，其中涉及到了[状态模式]，里面就提到了[有限状态机]与[状态图]的概念，在经过 Google 一下了解之后，吾辈确实感觉到可以使用它来简化程序的状态流转控制。\n\n例如有一个开关，控制灯泡怎么变化，在指定状态下点击会触发不同的行为，然后改变状态。\n\n## 基本示例\n\n想象以下场景，有一个开关控制着一个灯泡，灯泡有三种状态：关闭、打开弱光和打开强光，轮流变化。\n\n### 使用原生代码实现\n\n首先，我们尝试简单的使用 `if/else` 判断进行实现。\n\n```ts\nclass Light {\n  private state: 'off' | 'weak' | 'strong' = 'off'\n  click() {\n    switch (this.state) {\n      case 'off':\n        console.log('打开弱光')\n        this.state = 'weak'\n        break\n      case 'weak':\n        console.log('打开强光')\n        this.state = 'strong'\n        break\n      case 'strong':\n        console.log('关灯')\n        this.state = 'off'\n        break\n    }\n  }\n}\n\nconst light = new Light()\nlight.click()\nlight.click()\nlight.click()\n```\n\n然而，这种代码充斥着判断，同时代码本身也都耦合在了一起。目前只有一个 `flag` 的时候还没太大问题，如果有更多的 flag（例如典型的用户角色与状态同时控制指定操作的行为），代码将非常混乱。\n\n> 这也是吾辈之前为什么很想要一种支持多个 key 的 Map 的重要原因之一（其实有点类似数据库中索引的概念了）。\n\n### 抽离方法，使用 Map 消除判断\n\n一般来说，我们都会使用下面的方式去简化代码。\n\n1. 将不同的逻辑抽离为单独的方法\n2. 使用 Map 消除条件判断\n\n```ts\nclass Light {\n  private state: 'off' | 'weak' | 'strong' = 'off'\n  private map = {\n    off: this.offClick.bind(this),\n    weak: this.weakClick.bind(this),\n    strong: this.strongClick.bind(this),\n  }\n  click() {\n    this.map[this.state]()\n  }\n\n  private offClick() {\n    console.log('打开弱光')\n    this.state = 'weak'\n  }\n  private weakClick() {\n    console.log('打开强光')\n    this.state = 'strong'\n  }\n  private strongClick() {\n    console.log('关灯')\n    this.state = 'off'\n  }\n}\n\nconst light = new Light()\nlight.click()\nlight.click()\nlight.click()\n```\n\n事实上，第一种方式是卓有成效且任何人都能够无师自通的（分离了实现和控制），但第二种，虽然这里可以简化逻辑的控制，但稍微复杂或是由多个 `flag` 控制的状态流转则无法使用这种方式抽离出来。\n\n### 使用简单的状态模式\n\n下面是用简单的状态模式来简化代码的控制逻辑\n\n```ts\nclass Light {\n  toggle: (light: Light) => void = FSM.off\n  click() {\n    this.toggle(this)\n  }\n}\n\nconst FSM = {\n  off(light: Light) {\n    console.log('打开弱光')\n    light.toggle = FSM.weak\n  },\n  weak(light: Light) {\n    console.log('打开强光')\n    light.toggle = FSM.strong\n  },\n  strong(light: Light) {\n    console.log('关灯')\n    light.toggle = FSM.off\n  },\n}\n\nconst light = new Light()\nlight.click()\nlight.click()\nlight.click()\n```\n\n仔细观察变化\n\n1. 主流程只是做了转发，将操作转发给当前状态的子流程执行\n2. 状态对应的操作都在子流程中修改\n\n其实本质上状态模式是将控制流程分散到了各个子流程中，不再集中在一个地方控制。\n\n### 结合 react 与状态模式\n\n然后，有趣的地方来了：如何结合状态模式与现有框架？\n\n```tsx\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { useState } from 'react'\n\nclass Light {\n  toggle: (light: Light) => void = FSM.off\n  click() {\n    this.toggle(this)\n  }\n}\n\nconst FSM = {\n  off(light: Light) {\n    console.log('打开弱光')\n    light.toggle = FSM.weak\n  },\n  weak(light: Light) {\n    console.log('打开强光')\n    light.toggle = FSM.strong\n  },\n  strong(light: Light) {\n    console.log('关灯')\n    light.toggle = FSM.off\n  },\n}\n\nfunction App() {\n  const [light] = useState(new Light())\n  return (\n    <div>\n      <h2>app</h2>\n      <button onClick={() => light.click()}>灯的开关</button>\n    </div>\n  )\n}\n\nReactDOM.render(<App />, document.querySelector('#app'))\n```\n\n然而，当我们想要即时显示当前状态时，却发现了问题，是的，状态模式中将状态放在 `Light` 类中，而它并不在 react 的控制范围之内！\n\n```tsx\n// 其他代码\n\nclass Light {\n  state: 'off' | 'weak' | 'strong' = 'off'\n  // 其他代码\n}\n\nconst FSM = {\n  off(light: Light) {\n    console.log('打开弱光')\n    light.state = 'weak'\n    light.toggle = FSM.weak\n  },\n  // 其他状态的代码\n}\n\nfunction App() {\n  const [light] = useState(new Light())\n  return (\n    <div>\n      <h2>app</h2>\n      <button onClick={() => light.click()}>灯的开关</button>\n      <p>{light.state}</p>\n    </div>\n  )\n}\n\n// 其他代码\n```\n\n即便这样做，仍然不会发生变化，因为 Light 是个对象，而我们并未使用 `setLight` 修改它，所以自然不会发生变化\n\n### 尝试 react + useReducer\n\n当然，我们可以使用 `useReducer` 试试，毕竟它是专门应对复杂逻辑处理的 hooks。\n\n```ts\ntype LightState = 'off' | 'weak' | 'strong'\nconst FSM: Record<LightState, () => LightState> = {\n  off(): LightState {\n    console.log('打开弱光')\n    return 'weak'\n  },\n  weak(): LightState {\n    console.log('打开强光')\n    return 'strong'\n  },\n  strong(): LightState {\n    console.log('关灯')\n    return 'off'\n  },\n}\n\nconst App: React.FC = () => {\n  const [num, setNum] = useState(0)\n  const [lightState, lightSend] = useReducer<(state: LightState) => LightState>(\n    (state) => {\n      return FSM[state]()\n    },\n    'off',\n  )\n\n  return (\n    <div className=\"App\">\n      <header>\n        <button onClick={() => lightSend()}>切换</button>\n        每次从 off => weak 就改变状态\n      </header>\n      <p>{lightState}</p>\n      <p>当前 useState 的值: {num}</p>\n    </div>\n  )\n}\n```\n\n然而，可以看到，FSM 逻辑代码在 react 组件外部时，想要修改 react 组件内部的状态仍然非常困难，只能维护状态机自身的状态，而这显然是没多大用处的。解决方案很简单，使用回调的形式将具体的实现函数放在 react 组件内部，而这，正是 xstate 集成 react 实现的功能之一。\n\n## 使用 xstate\n\n### react + 状态机 xstate\n\n下面是一个使用状态机控制点击开关控制灯泡的示例\n\n```tsx\nenum LightStateEnum {\n  Off = 'off',\n  Weak = 'weak',\n  Strong = 'strong',\n}\n\nenum LightEventEnum {\n  Click = 'click',\n}\ninterface LightEvent extends EventObject {\n  type: LightEventEnum.Click\n  num: number\n}\n\nenum LightActionEnum {\n  EntryWeak = 'entryWeak',\n}\n\nconst lightStateMachine = Machine<{}, LightEvent>({\n  initial: LightStateEnum.Off,\n  states: {\n    [LightStateEnum.Off]: {\n      on: {\n        [LightEventEnum.Click]: {\n          target: LightStateEnum.Weak,\n          actions: LightActionEnum.EntryWeak,\n        },\n      },\n    },\n    [LightStateEnum.Weak]: {\n      on: {\n        [LightEventEnum.Click]: LightStateEnum.Strong,\n      },\n    },\n    [LightStateEnum.Strong]: {\n      on: {\n        [LightEventEnum.Click]: LightStateEnum.Off,\n      },\n    },\n  },\n})\n\nconst App: React.FC = () => {\n  const [num, setNum] = useState(0)\n  const [lightState, lightSend] = useMachine(lightStateMachine, {\n    actions: {\n      [LightActionEnum.EntryWeak](_context, event) {\n        console.log('entryOff: ', event.num)\n        setNum(num + event.num)\n      },\n    },\n  })\n  return (\n    <div className=\"App\">\n      <header>\n        <button\n          onClick={() =>\n            lightSend({\n              type: LightEventEnum.Click,\n              num: 1,\n            })\n          }\n        >\n          切换\n        </button>\n        每次从 off => weak 就改变状态\n      </header>\n      <p>{lightState.value}</p>\n      <p>当前 useState 的值: {num}</p>\n    </div>\n  )\n}\n```\n\n看的出来，上面多了很多**模板**代码，但状态机的意图我们却能以声明式的形式构造出来，具体 `actions` 的实现细节则被分离在 hooks 中。\n\n## xstate 概述\n\n### 基本概念\n\n> [常用术语](https://statecharts.github.io/concepts.html), [术语参考](https://statecharts.github.io/glossary/)\n\n- 状态: 任何时候总是有且只有一种状态\n- 事件: 对外暴露事件，通过事件（声明式）触发状态的变化\n- 动作: 触发事件时对应的具体行为，可以以编程的形式影响状态的变化\n\n## 问题\n\n- 主要问题还是太大了，xstate 想要把所有的状态都用这种方式管理起来，而非仅限于适合的情况。。。（大而全 ）\n  > [在线示例](https://codesandbox.io/s/dry-worker-hb5ct)\n- [x] 怎么让 TypeScript 提示正确的类型？\n  - 显式声明类型\n- [x] 怎么在 react 里使用它修改状态\n  - 使用 `useMachine` 在 react hooks 组件里添加 `actions`\n","createdTime":1594360188001,"updatedTime":1611072400176,"resources":[],"tags":[{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"3b1502f22ad645b5a6521b39b145e560","title":"使用 React Context 结合 EventEmitter","body":"## 场景\n\nEventEmitter 很适合在不修改组件状态结构的情况下进行组件通信，然而它的生命周期不受 react 管理，需要手动添加/清理监听事件很麻烦。而且，如果一个 EventEmitter 没有使用就被初始化也会有点麻烦。\n\n## 目的\n\n所以使用 react context 结合 event emitter 的目的便是\n\n- 添加高阶组件，通过 react context 为所有子组件注入 em 对象\n- 添加自定义 hooks，从 react context 获取 emitter 对象，并暴露出合适的函数。\n- 自动清理 emitter 对象和 emitter listener。\n\n## 实现\n\n### 实现基本的 EventEmitter\n\n首先，实现一个基本的 EventEmitter，这里之前吾辈曾经就有 [实现过](https://github.com/rxliuli/rx-util/blob/master/src/module/event/EventEmitter.ts)，所以直接拿过来了。\n\n```ts\ntype EventType = string | number\n\nexport type BaseEvents = Record<EventType, any[]>\n\n/**\n * 事件总线\n * 实际上就是发布订阅模式的一种简单实现\n * 类型定义受到 {@link https://github.com/andywer/typed-emitter/blob/master/index.d.ts} 的启发，不过只需要声明参数就好了，而不需要返回值（应该是 {@code void}）\n */\nexport class EventEmitter<Events extends BaseEvents> {\n  private readonly events = new Map<keyof Events, Function[]>()\n\n  /**\n   * 添加一个事件监听程序\n   * @param type 监听类型\n   * @param callback 处理回调\n   * @returns {@code this}\n   */\n  add<E extends keyof Events>(type: E, callback: (...args: Events[E]) => void) {\n    const callbacks = this.events.get(type) || []\n    callbacks.push(callback)\n    this.events.set(type, callbacks)\n    return this\n  }\n  /**\n   * 移除一个事件监听程序\n   * @param type 监听类型\n   * @param callback 处理回调\n   * @returns {@code this}\n   */\n  remove<E extends keyof Events>(\n    type: E,\n    callback: (...args: Events[E]) => void\n  ) {\n    const callbacks = this.events.get(type) || []\n    this.events.set(\n      type,\n      callbacks.filter((fn: any) => fn !== callback)\n    )\n    return this\n  }\n  /**\n   * 移除一类事件监听程序\n   * @param type 监听类型\n   * @returns {@code this}\n   */\n  removeByType<E extends keyof Events>(type: E) {\n    this.events.delete(type)\n    return this\n  }\n  /**\n   * 触发一类事件监听程序\n   * @param type 监听类型\n   * @param args 处理回调需要的参数\n   * @returns {@code this}\n   */\n  emit<E extends keyof Events>(type: E, ...args: Events[E]) {\n    const callbacks = this.events.get(type) || []\n    callbacks.forEach((fn) => {\n      fn(...args)\n    })\n    return this\n  }\n\n  /**\n   * 获取一类事件监听程序\n   * @param type 监听类型\n   * @returns 一个只读的数组，如果找不到，则返回空数组 {@code []}\n   */\n  listeners<E extends keyof Events>(type: E) {\n    return Object.freeze(this.events.get(type) || [])\n  }\n}\n```\n\n### 结合 context 实现一个包裹组件\n\n包裹组件的目的是为了能直接提供一个包裹组件，以及提供 provider 的默认值，不需要使用者直接接触 emitter 对象。\n\n```tsx\nimport * as React from \"react\"\nimport { createContext, PropsWithChildren } from \"react\"\nimport { BaseEvents, EventEmitter } from \"./util/EventEmitter\"\n\nexport const EventEmitterContext = createContext<EventEmitter<any>>(null as any)\n\nexport function EventEmitterRC<T extends BaseEvents>(\n  props: PropsWithChildren<{ value: EventEmitter<T> }>\n) {\n  return (\n    <EventEmitterContext.Provider value={props.value}>\n      {props.children}\n    </EventEmitterContext.Provider>\n  )\n}\n```\n\n### 使用 hooks 暴露 emitter api\n\n我们主要需要暴露的 API 只有三个\n\n- `useListener`: 添加监听器，使用 hooks 是为了能在组件卸载时自动清理监听函数\n- `emit`: 触发监听器，直接调用即可\n- `emitter`: 在当前组件树生效的 emitter 对象\n\n```ts\nimport {\n  DependencyList,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n} from \"react\"\nimport { EventEmitterContext } from \"../EventEmitterRC\"\n// noinspection ES6PreferShortImport\nimport { BaseEvents, EventEmitter } from \"../util/EventEmitter\"\n\nfunction useEmit<Events extends BaseEvents>() {\n  const em = useContext(EventEmitterContext)\n  return useCallback(\n    <E extends keyof Events>(type: E, ...args: Events[E]) => {\n      console.log(\"emitter emit: \", type, args)\n      em.emit(type, ...args)\n    },\n    [em]\n  )\n}\n\nexport function useEventEmitter<Events extends BaseEvents>() {\n  const emit = useEmit<Events>()\n  // 这里使用 useMemo 产生的 emitter 对象的原因是在当前组件树 emitter 仅初始化一次\n  const emitter = useMemo(() => new EventEmitter<Events>(), [])\n  return {\n    useListener: <E extends keyof Events>(\n      type: E,\n      listener: (...args: Events[E]) => void,\n      deps: DependencyList = []\n    ) => {\n      const em = useContext(EventEmitterContext)\n      useEffect(() => {\n        console.log(\"emitter add: \", type, listener.name)\n        em.add(type, listener)\n        return () => {\n          console.log(\"emitter remove: \", type, listener.name)\n          em.remove(type, listener)\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n      }, [listener, type, ...deps])\n    },\n    emit,\n    emitter,\n  }\n}\n```\n\n## 使用\n\n使用起来非常简单，在需要使用的 emitter hooks 的组件外部包裹一个 `EventEmitterRC` 组件，然后就可以使用 `useEventEmitter` 了。\n\n下面是一个简单的 Todo 示例，使用 emitter 实现了 todo 表单 与 todo 列表之间的通信。\n\n目录结构如下\n\n- `todo`\n  - `component`\n    - `TodoForm.tsx`\n    - `TodoList.tsx`\n  - `modal`\n    - `TodoEntity.ts`\n    - `TodoEvents.ts`\n  - `Todo.tsx`\n\nTodo 父组件，使用 `EventEmitterRC` 包裹子组件\n\n```tsx\nconst Todo: React.FC<PropsType> = () => {\n  const { emitter } = useEventEmitter()\n  return (\n    <EventEmitterRC value={emitter}>\n      <TodoForm />\n      <TodoList />\n    </EventEmitterRC>\n  )\n}\n```\n\n在表单组件中使用 `useEventEmitter` hooks 获得 `emit` 方法，然后在添加 todo 时触发它。\n\n```tsx\nconst TodoForm: React.FC<PropsType> = () => {\n  const { emit } = useEventEmitter<TodoEvents>()\n\n  const [title, setTitle] = useState(\"\")\n\n  function handleAddTodo(e: FormEvent<HTMLFormElement>) {\n    e.preventDefault()\n    emit(\"addTodo\", {\n      title,\n    })\n    setTitle(\"\")\n  }\n\n  return (\n    <form onSubmit={handleAddTodo}>\n      <div>\n        <label htmlFor={\"title\"}>标题：</label>\n        <input\n          value={title}\n          onChange={(e) => setTitle(e.target.value)}\n          id={\"title\"}\n        />\n        <button type={\"submit\"}>添加</button>\n      </div>\n    </form>\n  )\n}\n```\n\n在列表组件中使用 `useEventEmitter` hooks 获得 `useListener` hooks，然后监听添加 todo 的事件。\n\n```tsx\nconst TodoList: React.FC<PropsType> = () => {\n  const [list, setList] = useState<TodoEntity[]>([])\n  const { useListener } = useEventEmitter<TodoEvents>()\n  useListener(\n    \"addTodo\",\n    (todo) => {\n      setList([...list, todo])\n    },\n    [list]\n  )\n  const em = { useListener }\n  useEffect(() => {\n    console.log(\"em: \", em)\n  }, [em])\n  return (\n    <ul>\n      {list.map((todo, i) => (\n        <li key={i}>{todo.title}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\n下面是一些 TypeScript 类型\n\n```ts\nexport interface TodoEntity {\n  title: string\n}\n```\n\n```ts\nimport { BaseEvents } from \"../../../components/emitter\"\nimport { TodoEntity } from \"./TodoEntity\"\n\nexport interface TodoEvents extends BaseEvents {\n  addTodo: [entity: TodoEntity]\n}\n```\n\n## 参考\n\n- [Building event emitter using react hooks](https://medium.com/@dominikdosoudil/building-event-emitter-using-react-hooks-650f94a057ea)\n- [NodeJS EventEmitter API](https://nodejs.org/api/events.html)\n","createdTime":1596362348054,"updatedTime":1611072379822,"resources":[],"tags":[{"id":"5a7776c036cf46738cb6a729934a1a7b","title":"react","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"7b0fe35b00b345618a9323977a2e552a","title":"使用 gh-pages 发布前端项目","body":"## 场景\n\n> [gh-pages](https://www.npmjs.com/package/gh-pages)\n\n之前就有在使用 gh-pages 这个库，但由于名字并未想到它如此强大，甚至支持发布代码到任意 git 仓库。换言之，它可以将任意本地文件发布到远端 git 仓库，而不需要自己处理各种乱七八糟的问题。\n\n## 问题\n\n首先说一下我们之前前后端分离项目的发布流程\n\n1. 修改打包的 webpack 脚本以支持引用 cdn 上的资源（本质上是修改路径）\n2. 打包静态资源文件\n3. 找到前端静态资源发布项目，切换到指定分支\n4. 复制静态资源到特定目录\n5. `git commit && git push`\n6. 如果要发布 cdn 则再次对 cdn 仓库同样如此操作\n7. 通知后端发布生产环境，进行验证\n\n这其中涉及到几个重要痛点\n\n1. 修改 webpack 配置，它极高的复杂度甚至产生了 [webpack 配置工程师](https://www.zhihu.com/question/267908710) 这一职业岗位。\n2. 处理文件复制提交 git 信息，有可能操作错误，每次发布生产都是一次心理上的考验\n3. 发布失败难以快速解决，重新发布又需要手动再走一遍流程，所以有了我之前说过的发布一次要半个钟的事实\n\n## 解决\n\n不难看出，这本质上还是因为发布没有自动化带来的问题。但是，在 DevOps 还不存在的情况下，gh-pages 能够自动化下面的两步，同时，像 `create-react-app/vue-cli` 这种基于 webpack 进行高层次封装的工具提供了 `PUBLIC_PATH` 的概念，能够通过环境变量指定 `index.html` 入口引用的其他静态资源的基本路径，即便不去碰 webpack 也可以处理第一个问题了。\n\n> [react](https://create-react-app.dev/docs/using-the-public-folder/), [vue](https://cli.vuejs.org/zh/config/#publicpath)\n\n大致过程如下\n\n1. 在项目中添加依赖 `yarn add -D env-cmd gh-pages`\n2. 在打包生产环境的资源时指定环境变量 `PUBLIC_URL=[cdn 发布后的远端基本路径]`\n3. 添加发布 script 命令\n\n   ```json\n   {\n     \"deploy\": \"yarn build:prod && yarn deploy:cdn && yarn deploy:publish\",\n     \"deploy:publish\": \"gh-pages -d [本地目录] -e [远端 git 目录] -r [远端 git 地址] -b [远端 git 分支]\",\n     \"deploy:cdn\": \"gh-pages -d [本地目录] -e [远端 git 目录] -r [远端 git 地址] -b [远端 git 分支]\"\n   }\n   ```\n\n现在，发布生产环境只需要两个步骤\n\n1. 运行 `deploy` 命令\n2. 通知后端发布 cdn/静态资源目录\n\n虽然仍未能解决前后端不分离的项目，但，至少解决了所有新项目的发布问题了，不是么？\n\n> 这里有一个项目已经如此实现，可以进行参考：[website-static](https://git.code.tencent.com/bingli_front/website-static)\n\n## 总结\n\n还是需要擅用工具，如果能够掌握更好的工具，效率的提高和自己的痛苦程度都能有极大的改善！\n","createdTime":1600999429299,"updatedTime":1611072358022,"resources":[],"tags":[{"id":"5a7776c036cf46738cb6a729934a1a7b","title":"react","parent_id":""},{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"333051b25bd047e8864d161a9a6982de","title":"2016 年里做前端是怎样一种体验","body":"> 本文转载自 [SegmentFault](https://segmentfault.com/a/1190000007083024)，英文原文在 [How it feels to learn JavaScript in 2016](https://hackernoon.com/how-it-feels-to-learn-JavaScript-in-2016-d3a717dd577f)\r\n> 吾辈觉得颇为有趣，便转载了一下（也算是前端开发的悲哀之处了吧）\r\n> 附：吾辈觉得至今为止，前端工具链仍然没有好太多，工具链过多导致配置复杂，入门难度极大。\r\n> 附：现在都 2018 了，然而吾辈的公司现在还是用 `jQuery`，虽然吾辈目前在内部强推了 `VueJS` #笑哭\r\n> 附：吾辈这里对内容添加了一些样式，便于阅读时不那么疲劳。\r\n\r\n问：最近我接手了一个新的 `Web` 项目，不过老实说我已经好久没碰过这方面的代码了。听说前端的技术栈已经发生了极大的变革，不知道你现在是不是仍然处于最前沿的开发者阵列？\r\n答：准确来说，过去俗称的写网页的，现在应该叫做 `Front End Engineer`，我确实属于这所谓的前端工程师。并且我才从 `JSConf` 与 `ReactConf` 面基回来，因此我觉得我觉得我还是了解目前 `Web` 前端领域最新的面貌的。\r\n问：不错不错，我的需求其实也不复杂，就是从后端提供的 `REST` 风格的 `EndPoint` 来获取用户活动数据并且将其展示在前端界面上。并且需要以列表形式展示，同时，列表要支持筛选排序等操作，对了，还要保证前端数据和服务端保持一致。按照我现在的理解，我打算用 `jQuery` 来抓取与展现数据，你觉得咋样？\r\n答：不不不，现在估计已经没多少人使用 `jQuery` 了吧。你可以试试 `React`，毕竟这是 2016 年了啊。\r\n问：额，好吧，那啥是 `React` 啊？\r\n答：这是个非常不错的源自 `Facebook` 的前端库，它能够帮你便捷地响应界面事件，同时保证项目层级的可控性与还说得过去的性能。\r\n问：不错不错，那我是不是就可以用 `React` 来展示数据了呢？\r\n答：话是这么说没错，不过你需要添加 `React` 与 `React DOM` 依赖项到你的页面中去。\r\n问：等等，`React` 不是一个库吗？为啥要添加两个依赖呢？\r\n答：不要急，前者是 `React` 的核心库，后面呢算是 `Facebook` 操作的辅助库，这样就能让你用 `JSX` 来描述你的界面布局了。\r\n问：`JSX`？啥是 `JSX`？\r\n答：`JSX` 是一个类似于 `XML` 的 `JavaScript` 语法扩展，它是另一种描述 `Facebook` 的方式，可以认为是 `HTML` 的替代品。\r\n问：等等，`HTML` 咋啦？\r\n答：都 2016 了，直接用 `HTML` 早就过时了。\r\n问：好吧，那是不是我把两个库添加到项目中我就可以使用 `React` 了？\r\n答：额，还要一些小的工具，你需要添加 `Babel` 到你的项目中，这样你就能用了。\r\n问：又是一个库？`Babel` 又是什么鬼？\r\n答：你可以把 `Babel` 认为是一个转译工具，可以将某个特定版本的 `JavaScript` 转译为任意版本的 `JavaScript`。你可以选择不使用 `Babel`，不过那也就意味着你只能用烦人的 `ES5` 来编写你的项目了。不过既然都是 2016 了，我建议你还是使用最新的 `ES2016+` + 语法吧。\r\n问：`ES5`？`ES2016+`+？我已经迷茫了，`ES5`，`ES2016+` + 又是啥？\r\n答：`ES5` 是 `ECMAScript 2015` 的缩写，也是现在被绝大部分浏览器所支持的 `JavaScript` 语法。\r\n问：`ECMAScript`？\r\n答：是的，你应该知道 `JavaScript` 最早于 1995 年提出，而后在 1999 年第一个正式版本定稿。之后的十数年里 `JavaScript` 的发展一直很凌乱，不过经过七个版本之后已经逐步清晰了。\r\n问：7 个版本？那么 `ES5` 与 `ES2016+` 又是第几个版本呢？\r\n答：是的，分别指第五个版本与第七个版本。\r\n问：等等，那第六个版本呢？\r\n答：你说 `ES6`？估计我刚才没有讲明白，`ECMAScript` 的每个版本都是向前兼容的，当你使用 `ES2016+` + 的时候也就意味着你在使用之前所有版本的所有特性啦。\r\n问：原来是这样啊，那为啥一定要用 `ES2016+` 而不是 `ES6` 呢？\r\n答：是的，你可以使用 `ES6`，不过如果你要使用 `async` 与 `await` 这些特性，你就要去用 `ES2016+` 了。否则你就还不得不去使用 `ES6` 的 `Generator` 来编写异步代码了。\r\n问：我现在彻底迷糊了，我只是想简单地从服务端加载些数据而已，之前只需要从 `CDN` 加载下 `jQuery` 的依赖库，然后用 `Ajax` 方法来获取数据即可，为啥我现在不能这么做呢？\r\n答：别傻了，每个人都知道一味使用 `jQuery` 的后果就是让你的代码变得一团乱麻，这都 2016 了，没人再想去面对这种头疼的代码了。\r\n问：你说的是有道理，那现在我是不是就把这三个库加载进来，然后用 `HTML` 的 `Table` 来展示这些数据？\r\n答：嗯，你可以选择一个模块打包工具将这三个依赖库打包到一个文件中。\r\n问：额，啥是模块打包工具啊？\r\n答：这个名词在不同的环境下指代也不同，不过在 `Web` 开发中我们一般将支持 `AMD` 与 `CommonJS` 的工具称为模块打包工具。\r\n问：`AMD` 与 `CommonJS` 又是？\r\n答：它们是用于描述 `JavaScript` 库与类之间交互的接口标准，你有听过 exports 与 `requires` 吗？你可以根据 AMD 或者 CommonJS 的规范来定义多个 `JavaScript` 文件，然后用类似于 `Browserify` 的工具来打包它们。\r\n问：原来是这样，那 `Browserify` 是啥呢？\r\n答：`Browserify` 最早是为了避免人们把自己的依赖一股脑放到 `NPM Registry` 中构建的，它最主要的功能就是允许人们将遵循 `CommonJS` 规范的模块打包到一个文件中。\r\n问：`NPM Registry`？\r\n答：这是一个很大的在线仓库，允许人们将代码与依赖以模块方式打包发布。\r\n问：就像 `CDN` 一样？\r\n答：还是有很大差异的，它更像一个允许人们发布与下载依赖库的中心仓库。\r\n问：哦，我懂了，就像 `Bower` 一样啊。\r\n答：对哒，不过 2016 年了，同样没啥人用 `Bower` 了。\r\n问：嗯嗯，那我这时候应该从 `npm` 库中下载依赖了是吧？\r\n答：是的，譬如如果你要用 `React` 的话，你可以直接用 `Npm` 命令来安装 `React`，然后导入到你的项目中，现在绝大部分主流的 `JavaScript` 库都支持这种方式了。\r\n问：嗯嗯，就像 `Angular` 一样啊。\r\n答：不过 `Angular` 也是 2015 年的流行了，现在像 `VueJS` 或者 `RxJS` 这样的才是小鲜肉，你想去学习它们吗？\r\n问：不急不急，我们还是先多聊聊 `React` 吧，贪多嚼不烂。我还想确定下，是不是我从 `npm` 下载了 `React` 然后用 `Browserify` 打包就可以了？\r\n答：是的。\r\n问：好的，不过每次都要下载一大堆依赖然后打包，看起来好麻烦啊。\r\n答：是的，不过你可以使用像 `Grunt` 或者 `Gulp` 或者 `Broccoli` 这样的任务管理工具来自动运行 `Browserify`。对了，你还可以用 `Mimosa`。\r\n问：`Grunt`？`Gulp`？`Broccoli`？`Mimosa`？我们到底在讨论啥？\r\n答：不方，我们在讨论任务管理工具，不过同样的，这些工具也是属于 2015 年的弄潮儿。现在我们流行使用 `Webpack` 咯。\r\n问：`Makefiles`? 听起来有点像是一个 `C` 或者 `C++` 项目啊。\r\n答：没错，不过很明显 `Web` 的演变之路就是把所有事情弄复杂，然后再回归到最基础的方式。估计不出几年你就要在 `Web` 中写汇编代码了。\r\n问：额，你刚才好像提到了 `Webpack`？\r\n答：是的，这是一个兼顾了模块打包工具与任务运行器的打包工具，有点像 `Browserify` 的升级版本。\r\n问：嗷嗷，这样啊，那你觉得哪个更好点呢？\r\n答：这个因人而异了，不过我个人是更加偏好于 `Webpack`，毕竟它不仅仅支持 `CommonJS` 规范，还支持 `ES6` 的模块规范。\r\n问：好吧，我已经被 `CommonJS/ES6` 这些东西彻底搞乱了。\r\n答：很多人都是这样，多了，你可能还要去了解下 `SystemJS`。\r\n问：天哪，又是一个新名词，啥是 `SystemJS` 呢？\r\n答：不同于 `Browserify` 与 `Webpack 1.x`，`SystemJS` 是一个允许你将多个模块分封于多个文件的动态模块打包工具，而不是全部打包到一个大的文件中。\r\n问：等等，不过我觉得按照网络优化规范我们应该将所有的库打包到一个文件中。\r\n答：是的，不过 `HTTP/2` 快要来了，并发的 `HTTP` 请求已经不是梦。\r\n问：额，那时候是不是就不需要添加 `React` 的依赖库了？\r\n答：不一定，你可以将这些依赖库从 `CDN` 中加载进来，不过你还是需要引入 `Babel` 的吧。\r\n问：额，我刚才好像说错了话。\r\n答：是的，如果按照你所说的，你需要在生产环境下将所有的 `Babel-core` 引入，这样会无端端增加很多额外的性能消耗。\r\n问：好吧，那我到底应该怎么做呢？\r\n答：我个人建议是用 `TypeScript+Webpack+SystemJS+Babel` 这一个组合。\r\n问：`TypeScript`？我一直以为我们在说的是 `JavaScript`！\r\n答：是的，`TypeScript` 是 `JavaScript` 的超集，基于 ES6 版本的一些封装。你应该还没忘记 `ES6` 吧？\r\n问：我以为我们刚才说到的 `ES2016+` + 就是 `ES6` 的超集了。为啥我们还需要 `TypeScript` 呢？\r\n答：因为 `TypeScript` 允许我们以静态类型语言的方式编写 `JavaScript`，从而减少运行时错误。都 2016 了，添加些强类型不是坏事。\r\n问：原来 `TypeScript` 是做这个的啊！\r\n答：是的，还有一个就是 `Facebook` 出品的 `Flow`。\r\n问：`Flow` 又是啥？\r\n答：`Flow` 是 `Facebook` 出品的静态类型检测工具，基于函数式编程的 `OCaml` 构建。\r\n问：`OCamel`？`函数式编程`？\r\n答：你没听过吗？`函数式编程`？`高阶函数`？`Currying`? 纯函数？\r\n问：我一无所知。\r\n答：好吧，那你只需要记得函数式编程在某些方面是优于 `OOP` 的，并且我们在 2016 年应该多多使用呦。\r\n问：等等，我在大学就学过了 `OOP`，我觉得挺好的啊。\r\n答：是的，`OOP` 确实还有很多可圈可点的地方，不过大家已经认识到了可变的状态太容易引发未知问题了，因此慢慢的所有人都在转向不可变数据与函数式编程。在前端领域我们可以用 `Rambda` 这样的库来在 `JavaScript` 中使用函数式编程了。\r\n问：你是不是专门一字排开名词来了？`Ramda` 又是啥？\r\n答：当然不是啦，`Rambda` 是类似于 `Lambda` 的库，源自 **David Chambers**。\r\n问：**David Chambers**？\r\n答：**David Chambers** 是个很优秀的程序员，他是 `Rambda` 的核心贡献者之一。如果你要学习函数式编程的话，你还应该关注下 **Erik Meijer**。\r\n问：**Erik Meijer**？\r\n答：另一个函数式编程领域的大神与布道者。\r\n问：好吧，还会让我们回到 `React` 的话题吧，我应该怎么使用 `React` 来抓取数据呢？\r\n答：额，`React` 只是用于展示数据的，它并不能够帮你抓取数据。\r\n问：我的天啊，那我怎么来抓取数据呢？\r\n答：你应该使用 `fetch` 来从服务端获取数据。\r\n问：`fetch`？\r\n答：是的，`fetch` 是浏览器原生基于 `XMLHttpRequests` 的封装。\r\n问：那就是 `AJAX` 咯？\r\n答：`AJAX` 一般指仅仅使用 `XMLHttpRequests`，而 `fetch` 允许你基于 `Promise` 来使用 `AJAX`，这样就能够避免 `Callback hell` 了。\r\n问：`Callback hell`?\r\n答：是的，每次你向服务器发起某个异步请求的时候，你必须要添加一个异步回调函数来处理其响应，这样一层又一层地回调的嵌套就是所谓的 `Callback hell` 了。\r\n问：好吧，那 `Promise` 就是专门处理这个哩？\r\n答：没错，你可以用 `Promise` 来替换传统的基于回调的异步函数调用方式，从而编写出更容易理解与测试的代码。\r\n问：那我现在是不是直接使用 `fetch` 就好了啊？\r\n答：是啊，不过如果你想要在较老版本的浏览器中使用 `fetch`，你需要引入 `fetch` `Polyfill`，或者使用 `Request`、`Bluebird` 或者 `Axios`。\r\n问：来啊，互相伤害吧，你还是直接告诉我我还需要了解多少个库吧！\r\n答：这可是 `JavaScript` 啊，可是有成千上万个库的。而且不少库还很大呢，譬如那个嵌了一张 Guy Fieri 图片的库。\r\n问：你是说 Guy Fieri? 我听说过，那 `Bluebird`、`Request`、`Axios` 又是啥呢？\r\n答：它们可以帮你执行 `XMLHttpRequests` 然后返回 `Promise` 对象。\r\n问：难道 `jQuery` 的 `AJAX` 方法不是返回 `Promise` 吗？\r\n答：请忘掉 `jQuery` 吧，用 `fetch` 配合上 `Promise`，或者 `async/await` 能够帮你构造合适的控制流。\r\n问：这是你第三次提到 `await` 了，这到底是个啥啊？\r\n答：`await` 是 `ES7` 提供的关键字，能够帮你阻塞某个异步调用直到其返回，这样能够让你的控制流更加清晰，代码的可读性也能更上一层楼。你可以在 `Babel` 中添加 `stage-3 preset`，或者添加 `syntax-async-functions` 以及 `transform-async-to-generator` 这两个插件。\r\n问：好麻烦啊。\r\n答：是啊，不过更麻烦的是你必须先预编译 `TypeScript` 代码，然后用 `Babel` 来转译 `await`。\r\n问：为啥？难道 `TypeScript` 中没有内置？\r\n答：估计在下一个版本中会添加该支持，不过目前的 1.7 版本的 `TypeScript` 目标是 ES6，因此如果你还想在浏览器中使用 `await`，你必须要先把 `TypeScript` 编译为 ES6，然后使用 `Babel` 转译为 `ES5`。\r\n问：我已经无话可说了。\r\n答：好吧，其实你也不用想太多，首先你基于 `TypeScript` 进行编码，然后将所有使用 `fetch` 的模块转译为 `ES6`，然后再使用 `Babel` 的 `stage-3 preset` 来对 `await` 等进行 `Polyfill`，最后使用 `SystemJS` 来完成加载。如果你打算使用 `fetch` 的话，还可以使用 `Bluebird`、`Request` 或者 `Axios`。\r\n问：好，这样说就清晰多了，是不是这样我就达到我的目标了？\r\n答：额，你的应用需要处理任何的状态变更吗？\r\n问：我觉得不要把，我只是想展示数据。\r\n答：那还行，否则的话你还需要了解 `Flux`、`Redux` 等等一系列的东西。\r\n问：我不想再纠结于这些名词了，再强调一遍，我只是想展示数据罢了。\r\n答：好吧，其实如果你只是想展示数据的话，你并不需要 `React`，你只需要一个比较好的模板引擎罢了。\r\n问：你在开玩笑？\r\n答：不要着急，我只是告诉你你可以用到的东西。\r\n问：停！\r\n答：我的意思是，即使你仅仅打算用个模板引擎，还是建议使用下 `TypeScript`+`SystemJS`+`Babel`。\r\n问：好吧，那你还是推荐一个模板引擎吧！\r\n答：有很多啊，你有对哪种比较熟悉吗？\r\n问：唔，好久之前用了，记不得了。\r\n答：`jTemplates`?`jQote?PURE`?\r\n问：没听过，还有吗？\r\n答：`Transparency`？`JSRender`？`MarkupJS?KnockoutJS`?\r\n问：还有吗？\r\n答：`PlatesJS`?`jQuery-tmpl?Handlebars`?\r\n问：好像最后一个有点印象。\r\n答：`Mustache`?`underscore`？\r\n问：好像更晚一点的。\r\n答：`Jade`?`DustJS`?\r\n问：不。\r\n答：`DotJS`?`EJS`?\r\n问：不。\r\n答：`Nunjucks`?`ECT`?\r\n问：不。\r\n答：`Mah`?`Jade`?\r\n问：额，还不是。\r\n答？难道是 `ES6` 原生的字符串模板引擎。\r\n问：我估计，这货也需要 `ES6` 吧。\r\n答：是啊。\r\n问：需要 `Babel`？\r\n答：是啊。\r\n问：是不是还要从 `npm` 下载核心模块？\r\n答：是啊。\r\n问：是不是还需要 `Browserify`、`Webpack` 或者类似于 `SystemJS` 这样的模块打包工具？\r\n答：是啊。\r\n问：除了 `Webpack`，还需要引入任务管理器。\r\n答：是啊。\r\n问：我是不是还需要某个函数式编程语言，或者强类型语言？\r\n答：是啊。\r\n问：然后如果用到 `await` 的话，还需要引入 `Babel`？\r\n答：是啊。\r\n问：然后就可以使用 `fetch`、`Promise` 了吧？\r\n答：别忘了 `Polyfill` `fetch`，Safari 目前还不能原生支持 `fetch`。\r\n问：是不是，学完这些，就 OK 了？\r\n答：额，目前来看是的，不过估计过几年我们就需要用 `Elm` 或者 `WebAssembly` 咯～\r\n问：我觉得，我还是乖乖去写后端的代码吧。\r\n答：`Python` 大法好！\r\n","createdTime":1580652937853,"updatedTime":1610036778117,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"63ed4e3837634ee1b5c9ddd1e33d18f9","title":"博客迁移","body":"> 注：可能出现博客文章的顺序完全混乱，但随着笔记的修正将逐渐恢复正确的顺序。\n\n这个博客正在从 github + hexo 迁移至 joplin + hexo，将 joplin 笔记作为唯一数据源，结合 hexo 生成一个网站。\n\n---\n\n下面是关于 [joplin-blog 项目](http://github.com/rxliuli/joplin-blog) 的介绍\n\n## 场景\n\n你是否和吾辈一样烦恼同时维护笔记和博客的同步麻烦，如果你使用 joplin 作为笔记工具，而使用 hexo 作为博客生成器的话，你可以选择这个工具来连接它们。\n\n## 使用\n\n方式 1\n\n1. 添加配置文件 `.joplin-blog.json`（具体配置参考 [配置](#配置)）\n2. 使用命令导出笔记为博客 `npx joplin-blog`\n\n方式 2\n\n1. 在命令行导航到 hexo 博客目录\n2. 添加依赖 `yarn add -D joplin-blog`\n3. 添加配置文件 `.joplin-blog.json`（具体配置参考 [配置](#配置)）\n4. 添加一个 npm script 脚本文件 `\"imp\": \"joplin-hexo\"`\n5. 运行命令 `yarn imp`\n6. 可以看到 `source/_posts` 目录下已经包含了所有导出的笔记\n\n## 示例\n\n- [hexo](https://github.com/rxliuli/joplin-blog/tree/master/tutorials/hexo-example)\n- [vuepress](https://github.com/rxliuli/joplin-blog/tree/master/tutorials/vuepress-example)\n\n## 配置\n\n公共\n\n| 配置                | 类型            | 说明                               |\n| ------------------- | --------------- | ---------------------------------- |\n| `type`              | `hexo/vuepress` | 集成博客的类型                     |\n| `rootPath`          | `string`        | hexo/vuepress 目录，一般应该为 `.` |\n| `joplinProfilePath` | `string`        | joplin 个人文件夹                  |\n| `token`             | `string`        | joplin web service 的 token        |\n| `port`              | `number`        | joplin web service 的端口          |\n| `tag`               | `string`        | joplin 的博客标签                  |\n\nhexo\n\n| 配置              | 类型       | 说明                                   |\n| ----------------- | ---------- | -------------------------------------- |\n| `stickyTopIdList` | `string[]` | 置顶的笔记 id（仅在 fluid 主题下生效） |\n","createdTime":1609244626947,"updatedTime":1609384383783,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"edecd47235284480a720873296956f28","title":"漫谈 反乌托邦","body":"## 1984\r\n\r\n最近看完了 **1984** 这本小说，在之后也补了一下电影\r\n\r\nYoutube 正版电影\r\n\r\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/S0WSCZx6R6M\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\r\n\r\n一些设定令人惊奇\r\n\r\n- 真理部：负责新闻、娱乐、教育、艺术\r\n- 和平部：负责战争\r\n- 有爱不：负责维持法律和秩序\r\n- 富裕部：负责经济事务\r\n\r\n一些名言令人印象深刻\r\n\r\n- 过去被禁止，控制过去的人控制未来，控制现在的人控制过去。\r\n- 除了对集体的爱，没有其他的爱，与之竞争的都要被摧毁。\r\n- 无产阶级就像牲口一样，什么办法都没有。\r\n- 现代战争的本质，就是毁灭产品和人类的劳动，保持社会处于饥饿的边缘，一个分等级的社会只可能建立在贫穷和无知的基础上。\r\n- 栗树荫下，我出卖你，你出卖我。\r\n\r\n里面小孩举报父母，被洗脑而不自知，或许，亦是因为一张白纸更容易染上颜色吧。\r\n\r\n- 低效的前进，高效的内斗\r\n\r\n现实场景\r\n\r\n- 这本书可以很容易买到\r\n- 中文网络上没有国人影评/同人小说\r\n- 1984 在微博已经成为非法内容了\r\n- 举报父母已有现实案例（所谓的大义灭亲）\r\n\r\n## 美丽新世界\r\n\r\n- 人工胚胎，设置命运：感觉是个恐怖的极权世界\r\n- 从小开始的 SEX 游戏与索麻，消费/享乐主义至上：或许是个天堂？\r\n- 野人区：旧时代的信仰、肮脏的生活与 **美丽新世界** 对比，让人真不知道哪个是天堂？\r\n- 野人疯了：发现自己苦苦追寻的事物、坚信的认知却一文不值时，疯掉了，**天堂** 对他而言也是地狱了\r\n- `9/10` 的人口供养着 `1/10` 的人口是 **阿尔法**，无论是水上还是水下都会感到快乐，不提高产量的最大原因是为了避免闲暇时间造成资源的浪费\r\n\r\n那种 **美丽新世界** 和 **野人区** 真的很难说哪个更好，活到 60 岁，但一生都能保持年轻，并且 **每个人属于每个人** 的理念确实很厉害。\r\n\r\n- 要求 **不快乐** 的权力\r\n\r\n## 疫情\r\n\r\n花了几年营造出来的中国梦，在一个春节就破碎的不成样子了。\r\n\r\n- 双重思想在现实中确实存在，而且很常见。\r\n  - [所以为歌颂伟大牺牲的时候，就防护服不足，以至于医护人员都不够用，为辟反动谣言的时候，就殡葬人员都必须有防护服。动动脑子想一想的结果就是如此的辩证](https://twitter.com/LiYing_2015/status/1227363930504196096)\r\n  - “我们要自由。我们反对香港游行、台湾独立。”，说这两句话的是同一批人。\r\n    - 或许未曾意识到，香港、台湾他们也是为了自由，甚至于，或许只是跟风发泄一下情绪，并不明白自由是什么。。。\r\n- 没有说 `1 + 1 = 2` 的权利\r\n  - [李文亮](https://zh.wikipedia.org/wiki/%E6%9D%8E%E6%96%87%E4%BA%AE)\r\n  - [武汉「造谣」八君子](https://zh.wikipedia.org/wiki/%E6%AD%A6%E6%BC%A2%E9%80%A0%E8%AC%A0%E5%85%AB%E5%90%9B%E5%AD%90)\r\n- 未曾想过现实中真的有 **新语** 一说\r\n  - [为什么日本人显得比中国人更懂中国文化](https://mp.weixin.qq.com/s/bS_8xCR2bxpwWKcoAeo4pw)\r\n    - “山川异域，风月同天。” 居然比不上 **新语** 的 “武汉加油”。\r\n    - 新世纪笑话：\r\n      > 我举一个例子，比如你是给武汉捐助救灾物资的一位执行者，你在包装箱上写了八个字：山川异域，风月同天。领导看见了，会直接骂你：“你特么神经病吗？写这个干嘛？应该写武汉加油，还要加一个大感叹号。”\r\n      > 为什么不能用这八个字？因为这八个字不在那一套新话系统里面。这就超出了一位领导干部的思维边界。超出思维边界的事物，都是危险的、不可控的，是不可以使用的。\r\n      > 领导还要问你：你听明白了吗？能不能做到？\r\n      > 所以，你只能写个 “武汉加油”。\r\n","createdTime":1609378951022,"updatedTime":1609379002588,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"b83859395d12498784e1658a076c2b8a","title":"JavaScript 使用 fetch 上传文件","body":"`fetch` 是 ES6 的一个新的特性，用来简化处理异步的 Ajax 请求。\r\n\r\n> fetch 可以参考 [MDN](https://developer.mozilla.org) 上的教程：<https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch>\r\n\r\n假设后端（Java）有一个用于上传文件的接口\r\n\r\n```java\r\n/**\r\n  * 上传文件\r\n  * @param imgFile\r\n  * @return\r\n  */\r\n@RequestMapping(value = \"/uploadFile\", method = RequestMethod.POST)\r\n@ResponseBody\r\npublic OperationResult uploadFile(@RequestParam(\"imgFile\") MultipartFile imgFile);\r\n```\r\n\r\n前端中只要使用如下代码即可上传一个文件\r\n\r\n```html\r\n<!-- 这里是用来演示的 html 内容 -->\r\n<input id=\"imgFile\" type=\"file\" />\r\n```\r\n\r\n```js\r\ndocument.querySelector(\"#imgFile\").addEventListener(\"change\", () => {\r\n  // 创建一个 FormData 对象\r\n  const fd = new FormData()\r\n  // 得到 File 对象\r\n  const file = document.querySelector(\"#imgFile\").files[0]\r\n  fd.append(\"imgFile\", file)\r\n  // 这里的 url 是上传链接，此处为 /uploadFile\r\n  fetch(url, {\r\n    method: \"POST\",\r\n    body: fd,\r\n    // 注：此处不需要设置 headers\r\n  }).then((res) => {\r\n    // 之后的处理\r\n  })\r\n})\r\n```\r\n\r\n和 `jquery ajax` 的感觉差不多，不过能实现效果就好啦\r\n","createdTime":1580652937857,"updatedTime":1609332006276,"resources":[],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"cc027c9eecc04ab1ad088855f1ce22ba","title":"在 JavaScript 定义类","body":"## 场景\r\n\r\n在一个新的项目时，需要在 JavaScript 中编写与后端对应的实体类时，因为不想使用下面的方法定义类了，感觉实在不够灵活...\r\n\r\n```js\r\nvar User = {\r\n  //more field and function\r\n}\r\n```\r\n\r\n或者\r\n\r\n```js\r\nfunction User() {\r\n  //more field and function\r\n}\r\n```\r\n\r\n## 解决\r\n\r\n> 目前 ES6 已经完全普及开来，所以如果需要定义类的话，请使用 [ES6 class 关键字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes) 定义类而非下面这几种方式（需要支持 IE 浏览器的读者可以继续往下看）。\r\n\r\n所以去 Google 了一下，大致发现了三种方法：\r\n\r\n1. 构造函数法  \r\n   经典方法，基本上是 JavaScript 书籍上都会说的方法。使用构造函数模拟 `class`，在其内部使用 `this` 关键字指代实例对象。\r\n\r\n   ```js\r\n   function User() {\r\n     //注：这里所有的 property/function 都是对象级别（没错连方法都是。。。）。所以，toJSON() 方法在每个实例中都有一份，比较浪费内存，可以新建两 个 User 对象 user1,user2，然后使用 user1.toJSON === user2.toJSON 验证一下，你会发现为 false...(2333)\r\n     this.name = \"rxliuli\"\r\n     this.toJSON = function () {\r\n       return JSON.stringify(this)\r\n     }\r\n   }\r\n\r\n   //想要定义所有对象都公用的 property/function，需要使用 Object.prototype 属性（原型），例如下面定义一个公用的 toJSON() 方法\r\n   User.prototype.toJSON = function () {\r\n     return JSON.stringify(this)\r\n   }\r\n   ```\r\n\r\n   这种方法的缺陷很明显了，定义起来实在太过麻烦，使用 Object.prototype 让对象的定义实在很不直观。\r\n\r\n2. Object.create() 法  \r\n   为了解决 \"构造函数法\" 的缺点，更方便地生成对象，Javascript 的国际标准 ECMAScript 第五版（目前通行的是第五版），提出了一个新的方法 Object.create()。\r\n\r\n   ```js\r\n   var User = {\r\n     //注：这里所有的 property/function 都是继承得到的（类似于上面的 Object.prototype），所以没有改变的 property/function 只会有一份\r\n     name: \"rxliuli\",\r\n     toJSON: function () {\r\n       return JSON.stringify(this)\r\n     },\r\n   }\r\n   ```\r\n\r\n   调用的话直接使用 `Object.create()` 生成实例，并不需要使用 `new`。\r\n\r\n   ```js\r\n   var user = Object.create(User)\r\n   user.name = \"琉璃\"\r\n   console.log(user.toJSON())\r\n   ```\r\n\r\n   这种方法看起来简洁很多，但不能实现私有属性和私有方法，实例之间没有共享数据，对于模拟 `class` 而言并不是很好。\r\n\r\n3. 极简主义法\r\n   据说是比 Object.create() 更好的方法，此方法不使用 `this` 和 `property`，代码部署起来也比较简单。\r\n\r\n   - 封装  \r\n      `js var User = { createNew: function () { var user = {}; user.name = 'rxliuli'; user.toJSON = function () { return JSON.stringify(this); }; return user; } }`\r\n     使用时调用 `User.createNew()` 即可。\r\n     `js var user = User.createNew(); user.name = '琉璃'; console.log(name);`\r\n     不知道你有没有发现，这里使用 createNew() 创建的对象的方法又是对象级别的了。但这种方法定义好处是，可以实现私有属性/私有方法，能够实现继承，能够在 `class` 之间共享数据，同时允许在构造对象时传入参数。\r\n\r\n   - 继承\r\n     通过第三种方法可以很容易实现，只要子类在创建对象时调用父类的 `createNew()` 方法即可！\r\n     例如下面的 `Person` 和 `Student` 类。\r\n\r\n     ```js\r\n     var User = {\r\n       createNew: function () {\r\n         var user = {}\r\n         user.name = \"rxliuli\"\r\n         user.toJSON = function () {\r\n           return JSON.stringify(this)\r\n         }\r\n         return user\r\n       },\r\n     }\r\n\r\n     var Student = {\r\n       createNew: function () {\r\n         var student = User.createNew()\r\n         /*这里只定义 Student 特有的方法属性和方法即可*/\r\n         student.grade = 1\r\n         return student\r\n       },\r\n     }\r\n     ```\r\n\r\n   - 私有属性和私有方法\r\n\r\n     在 `createNew()` 方法中，只要不是定义在 user 对象上的 property/function，就都是私有的。\r\n\r\n     ```js\r\n     var User = {\r\n         createNew: function () {\r\n             var user = {};\r\n             user.name = 'rxliuli';\r\n             /*私有属性（最好不要问女人的年龄哦）*/\r\n             var age = 17;\r\n             /*这里的变量 age 对于外部而言就是无法读取的，只有通过 user 的公有方*/法 showAge() 读取\r\n             user.showAge = function () {\r\n                 alert(age);\r\n             }\r\n             user.toJSON = function () {\r\n                 return JSON.stringify(this);\r\n             };\r\n             return user;\r\n         }\r\n     }\r\n     ```\r\n\r\n   - 数据共享\r\n     有时候我们需要所有的实例对象都共享一项数据（其实就类似于静态变量/方法啦）。这种情况数据封装到类对象的里面，`createNew()` 方法的外面就好了。\r\n\r\n     ```js\r\n     var User = {\r\n       createNew: function () {\r\n         var user = {}\r\n         user.name = \"rxliuli\"\r\n         user.showAge = function () {\r\n           alert(age)\r\n         }\r\n\r\n         return user\r\n       },\r\n       /**\r\n        * 这个方法便是所有 User 对象公用的方法啦\r\n        * @returns {string}\r\n        */\r\n       toJSON: function () {\r\n         return JSON.stringify(this)\r\n       },\r\n     }\r\n     ```\r\n\r\n     然后生成两个实例对象，这两个实例对象的 `toJSON()` 方法是同一个，如果有个实例对象修改了，那其他所有的对象都会受到影响。\r\n\r\n     ```js\r\n     var user = User.createNew()\r\n     var user2 = User.createNew()\r\n     console.log(user.toJSON === user2.toJSON)\r\n     ```\r\n\r\n     还记得上面提出的发现方法 3 的一个问题么？\r\n\r\n     > 不知道你有没有发现，这里使用 createNew() 创建的对象的方法又是对象级别的了\r\n\r\n   这里其实可以解决一部分的，当然，前提是你的数据不需要修改，然而需要修改的数据也不该使用共享数据了。\r\n\r\n---\r\n\r\n其实也可以直接不使用类来构建对象的，使用 `{}` 也能直接进行构建对象\r\n\r\n```js\r\nvar user = {\r\n  name: \"rxliuli\",\r\n  //注：这里所有的 property/function 都是对象级别（没错连方法都是。。。）。所以，toJSON() 方法在每个实例中都有一份，比较浪费内存\r\n  toJSON: function () {\r\n    return JSON.stringify(this)\r\n  },\r\n}\r\n```\r\n\r\n好了，一个 `user` 对象就构建好了，可以立即使用了。\r\n\r\n```js\r\nuser.name = \"琉璃\"\r\nconsole.log(name)\r\n```\r\n\r\n这种方法快速构建对象对于 function 参数而言很有帮助，然而同样缺陷极大，不适用于大量构造对象（因为每一次构建都要写这么多。。。），而且对象之间没有明显的关联。\r\n\r\n那么，关于 JavaScript 定义类就到这里啦 (〜￣ ▽ ￣)〜\r\n","createdTime":1580652937868,"updatedTime":1609331999277,"resources":[],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"c8da07895dfd430bb074eebf73b6267f","title":"IDEA 设置配置文件的位置","body":"IDEA 虽然有着便携版本，但它的配置文件显然并非如此。默认设置在当前用户目录下，所以为了便携化考虑，还是将配置文件也放到 IDEA 程序的子目录更好一点。\r\n\r\n主要需要修改的文件为：\r\n**IDEAHome/bin/idea.properties**\r\n\r\n找到内容为 `idea.config.path` 与 `idea.system.path` 的选项，放开注释，修改为你想要的路径就好了。\r\n\r\n- `idea.config.path`：IDEA 的配置文件目录，主要有安装的插件，自定义的配置等\r\n- `idea.system.path`：IDEA 的缓存文件目录，主要有各个项目单独的配置，项目的索引等\r\n\r\n> 注：`${idea.home.path}` 代表的是 IDEA 程序的根目录。  \r\n> 例如：IDEA 的文件夹是：`C:/Users/rxliuli/Program/ideaIU-2018.1.6.win/`。 那么，`${idea.home.path}/.IntelliJIdea/` 代表的就是 `C:/Users/rxliuli/Program/ideaIU-2018.1.6.win/.IntelliJIdea/`\r\n\r\n以上便是使用 IDEA 设置配置文件的位置的方法，现在可以将 IDEA 程序和配置一起打包解压即用了呢\r\n","createdTime":1580652938003,"updatedTime":1609331841202,"resources":[],"tags":[{"id":"34dfb4608c934c3b8d33e9605a180e39","title":"jetbrains","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"88286634819248b7956d845b1fadde6b","title":"IDEA 调试技巧","body":"- [IDEA 调试技巧](#idea-调试技巧)\r\n  - [背景](#背景)\r\n  - [基本](#基本)\r\n    - [启动调试](#启动调试)\r\n    - [断点](#断点)\r\n    - [移动](#移动)\r\n    - [忽略所有断点](#忽略所有断点)\r\n    - [执行表达式](#执行表达式)\r\n    - [变量监视](#变量监视)\r\n  - [高级](#高级)\r\n    - [条件断点](#条件断点)\r\n    - [断点管理](#断点管理)\r\n    - [异常断点](#异常断点)\r\n    - [代码回退](#代码回退)\r\n    - [强制返回](#强制返回)\r\n    - [模拟抛出异常](#模拟抛出异常)\r\n\r\n## 背景\r\n\r\nIDEA 最强大的功能之一就是 Debug 了，然而如此强大的工具却有很多人在使用了很久之后依旧只会使用断点，然后一步步的走下来，这里便稍微讲解一下 IDEA 的调试功能。\r\n\r\n## 基本\r\n\r\n### 启动调试\r\n\r\n最简单直观的就是点击工具栏的 Debug 按钮（`S-F9`）即可开始调试当前运行选项，然后便会弹出 Debug 选项卡（`A-5`）。\r\n\r\n启动调试有三种情况：\r\n\r\n- `S-F9` 如果运行选项不为空，调试当前运行选项\r\n- `CS-F9` 如果当前文件可以运行的话，就调试当前文件\r\n- `SA-F9/F9` 显示所有可以调试的运行选项  \r\n  注：`F9` 只有在非调试环境下生效，在调试环境下的作用是运行到下一个断点。\r\n\r\n### 断点\r\n\r\n在左侧边栏上点击一下（亦或是 `A-F8` 添加一个？）就可以为当前可以运行到的代码行添加一个红色的小圆点（断点），当代码运行到断点时会自动停下（并自动跳转过来），然后我们就可以自己的查看运行时的细节了。\r\n\r\n> 注：我们不能为不可能运行到的位置添加断点。例如以下情况：\r\n>\r\n> - 方法右侧大括号单独所在的行（会报错但仍能添加），错误：`No executable code found at line`\r\n> - 类的方法之间的空行，这些地方甚至不能打断点（**因为毫无意义！**）\r\n\r\n### 移动\r\n\r\n- `F7`：跳转到方法内部\r\n- `S-F7`：选择跳转到哪个方法内部\r\n- `F8`：执行到下一行代码，如果没有下一行代码，则跳转到调用者方法（非类库的）。\r\n- `S-F8`：跳转到方法的调用者处，即便代码是类库里面的。\r\n- `F9`：让程序恢复到运行状态（未遇到断点的情况下），想跳到下一个断点或者让程序恢复正常运行状态就用这个吧\r\n- `A-F9`：跳转到当前行，主要用于在想进入方法内部看看时（一般很多人习惯打个断点吧？）\r\n\r\n### 忽略所有断点\r\n\r\n有这么一种情况，我们想要正常运行看一下效果，又不想重启服务器（一会有错误还要调试呢），就可以使用这个功能避免我们无谓的进入断点。\r\n\r\n功能的名字是 `Mute Breakpoints`，但默认没有快捷键。可以使用结构查询 `CS-A` 输入这个名字进行查找，或者在调试选项卡中找到它点击一下就可以了。\r\n\r\n### 执行表达式\r\n\r\nIDEA 调试非常棒的一个功能，有时候想看看某个表达式的值，但又不想真正执行它（例如调用有可能因为参数报错的方法），想先看一下结果，这里就可以使用执行表达式（`A-F8`）这个功能了。  \r\nIDEA 能够自动感知当前调试的环境（例如当前调试代码行能访问到的所有变量执行表达式窗口中都能访问，反之亦然）,也能在弹窗中自动提示代码。\r\n\r\n但请注意，执行表达式中执行的代码是真的执行了，所以例如只能读取一次的流，数据库，文件等等，都是真正被改变的了，所以需要稍微注意一下哦\r\n\r\n### 变量监视\r\n\r\n上面的执行表达式可以查看表达式的值，然而如果我们想要看一个表达式的值在代码运行过程中发生了什么变化怎么办？难道每运行一行代码就使用执行表达式查看一下表达式的值么？那效率也太低了！  \r\n所以这里就需要用到变量监视这个功能了（`Add to Watches`），既可以右键将表达式的值添加到监视变量中，也能够在执行表达式窗口直接将当前表达式的值添加到监视变量中去（`CS-Enter`）。每一次代码走到下一步都会自动刷新值（其实就是执行了一次）。\r\n\r\n## 高级\r\n\r\n### 条件断点\r\n\r\n可以给一个断点添加一个条件，指定在什么情况下会停留到这个断点（例如 if 语句里面的判断表达式为 `true` 时就停留），但断点条件只能是 `true/false`。操作的话在断点代码行使用 `CS-F8` 或者直接右键单击断点，就会弹出一个窗口，在 `Condition` 部分输入需要的条件就可以啦\r\n\r\n### 断点管理\r\n\r\n断点太多了怎么办？调试的时候想要测试某个请求的时候总是进入不相关的断点，这里可以使用断点管理功能。放在任意一个非断点代码行的位置按下 `CS-F8` 就会弹出一个断点管理弹窗，里面列出了所有，你可以在这里对断点进行更加细致的管理（启用/禁用/添加/删除/是否是多线程都有效/条件表达式/执行日志/相关代码修改/双击断点则后面的选项跳转到断点处）。\r\n\r\n### 异常断点\r\n\r\n有一种情况是我们在控制台看到了异常，但很想知道会在什么地方发生某个指定的异常。这时候就可以使用这个功能了。这个功能依赖于断点管理，需要在断点管理弹窗中进行添加断点异常（`A-Ins`）才可以。以后当每次发生指定异常时，都会停留在相应的代码处，以便于查看更加详细的原因。\r\n\r\n### 代码回退\r\n\r\n跳跃到上一个方法调用链处，或者在 `Frames` 选项卡中右键 `Drop Frame` 选择调用链的位置，然后回到这个位置。感觉上就像是回退一样，但其实并没有这么神奇。该功能只能回退到以前的方法调用位置，而且回退后 _未来_ 的记录会被删除，总而言之这也是 IDEA 提供的一个调试的功能之一呢（吾辈个人用的不是很多）\r\n\r\n### 强制返回\r\n\r\n有时执行某个方法时已经发生了错误（例如参数有问题），但又不想继续执行下去（发生异常），所以就可以直接中断指定方法，强制返回指定的值。在方法调用链选项卡中选择一处（一般是当前方法），右键选择 `Force Return` 就可以强制结束该方法并返回指定的值了。\r\n\r\n### 模拟抛出异常\r\n\r\n场景：在需要测试方法在非正常执行时（例如测试数据库关闭发生数据库连接错误时的情况），如果还在手动添加测试异常代码就有点落后了，IDEA 已经为我们提供了优秀的工具！使用方法也很简单，就是在方法调用链选项卡指定位置右键选择 `Throw Exception`。\r\n\r\n<!--\r\n### JavaScript 调试\r\n\r\n#### 1. 单独启动 JavaScript 调试\r\n\r\nJavaScript 调试起来就有点意思了，基本上 IDEA 对 Google Chrome 非常友好（有专门的 Plugini），然而对 FireFox 却支持的并不怎么好。好了，还是先看一下怎么配置 JavaScript 的运行选项进行调试吧\r\n\r\n1. 打开配置运行弹窗\r\n  就在运行选项左边的下拉框的第一项（`Edit Configurations`）\r\n2. 添加一个 JavaScript 运行选项\r\n3. 设置调试的 url\r\n4. 启动调试\r\n\r\n#### 2. Java 与 JavaScript 混合调试\r\n -->\r\n","createdTime":1580652938004,"updatedTime":1609331836121,"resources":[],"tags":[{"id":"34dfb4608c934c3b8d33e9605a180e39","title":"jetbrains","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"9fd160bf747348be8ad4183cd36f680d","title":"自建 Jrebel 反向代理","body":"> 项目位置：https://gitee.com/gsls200808/JrebelLicenseServerforJava\r\n\r\n不喜欢 Gitee 直接 `git clone https://gitee.com/gsls200808/JrebelLicenseServerforJava.git` 然后自己用 `maven` 编译一下就好！  \r\n或者吾辈也编译了一个 [链接](https://github.com/rxliuli/rxliuli.github.io/blob/53bf7d98827eea647822d4c8cf1a04c6c006a8f0/_posts/IDEA/JrebelBrainsLicenseServerforJava/JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar)\r\n\r\n## 普通启动（其中 -p 指的是端口，服务器必须配置该端口可以访问）\r\n\r\n```bash\r\njava -jar JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar -p 8181\r\n```\r\n\r\n## 后台启动 jar（既便退出程序也不会结束）\r\n\r\n```bash\r\nnohup java -jar JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar -p 8181 > log.log &\r\n```\r\n\r\n> `> log.log &` 指的是将程序的控制台输出写入到某个文件中\r\n\r\n## 查看程序\r\n\r\n1. 使用 job 命令\r\n\r\n   ```bash\r\n   jobs\r\n   ```\r\n\r\n   输出可能是下面这样子：  \r\n   `[1]+ Running nohup java -jar JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar -p 8181 > log.log &`\r\n\r\n   想要结束的话使用 `fg 任务 id` 将任务调回前台，然后 `Ctrl+C` 即可。  \r\n   这里使用\r\n\r\n   ```bash\r\n   fg 1\r\n   Ctrl+C\r\n   ```\r\n\r\n2. 使用 Linux 下的 `ps` 命令\r\n\r\n   使用以下命令列出所有含有 **Jrebel** 的进程\r\n\r\n   ```bash\r\n   ps -ef|grep Jrebel\r\n   ```\r\n\r\n   吾辈启动了好几次，所以有 3 条\r\n\r\n   ```bash\r\n   rxliuli   1877  1828  0 23:26 pts/0    00:00:00 java -jar JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar\r\n   rxliuli   1942  1921  0 23:33 pts/1    00:00:00 java -jar JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar -p 8181\r\n   rxliuli   1967  1921  0 23:37 pts/1    00:00:00 grep --color=auto Jrebel\r\n   ```\r\n\r\n   使用 `kill -9 进程 id` 杀死进程  \r\n   例如这里可以使用\r\n\r\n   ```bash\r\n   kill -9 1828\r\n   ```\r\n\r\n   然后再次使用 ps 查看进程就发现已经被杀死了\r\n\r\n## 使用\r\n\r\n激活服务器：`http://{服务器 id}:{服务器端口, 这里是 8181}/947122a0-7e9a-4bea-814d-876525d3767f`  \r\n邮箱随意就好（至少格式要正确。。。）\r\n\r\n有可能 Jrebel 还会让你输入认证信息，吾辈输入了服务器的 username/password 貌似就没问题了呢\r\n","createdTime":1580652938009,"updatedTime":1609331830146,"resources":[],"tags":[{"id":"34dfb4608c934c3b8d33e9605a180e39","title":"jetbrains","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"958b34f761e54046b092594597d866e1","title":"Chrome 踩坑笔记","body":"## Chrome 右键翻译不能使用\r\n\r\n> 2018-10-11\r\n\r\n### 原因\r\n\r\n其实是 SwitchyOmega 这个插件，之前一直没出过问题，结果现在 Chrome69 出现了。Chrome 浏览器右键翻译的 API 和 Google 翻译网页版使用的不是同一个！\r\n\r\n- Google 网页版：<https://translate.google.com>\r\n- Google Chrome：<https://translate.googleapis.com>\r\n\r\n结果就出现了 Google 翻译网页版明明能正常使用，但 Chrome 浏览器右键翻译功能就是不行的奇怪现象。\r\n\r\n### 解决方案\r\n\r\n直接访问 <https://translate.googleapis.com>，嗯，访问失败了。然后设置这个域名使用代理就好了，正常情况下应该显示 404，并不是错误。\r\n","createdTime":1580652938021,"updatedTime":1609331759582,"resources":[],"tags":[{"id":"4e00e5550c864473a3f16e4b0698f1c3","title":"windows","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"574ee52d700a4886947dbb4a5c211634","title":"Xmind 激活","body":"> 转自 [原链](https://github.com/mounui/Xmind)，对文法部分进行了复核。本文仅供参考，如有能力请支持正版！\r\n\r\nXmind 不激活也是可以使用的，那么，你可能会问为什么还要激活？这是因为未激活的 Xmind 少了很多实用的功能。好了，废话不多说了，下面讲如何激活 Xmind。\r\n\r\n## 使用激活补丁\r\n\r\n1. 下载 Xmind 激活补丁 [XMindCrack.jar](https://raw.githubusercontent.com/rxliuli/blog_binary_file/master/XMindCrack.jar)\r\n2. 打开 Xmind 取消检查更新选项 (下面两步可以一起设置)\r\n\r\n   > -> 编辑 -> 首选项 -> 常规 -> 启动 -> 启动时检查更新和消息：取消勾选 (最后确定)\r\n\r\n   取消发送用户数据选项\r\n\r\n   > -> 编辑 -> 首选项 -> 常规 -> 启动 ->发送用户数据: 取消勾选 (最后确定)\r\n   > 最后关闭 Xmind\r\n\r\n3. 将 XMindCrack.jar 复制到 Xmind 的安装目录下，默认安装路径为 C:\\Program Files (x86)\\XMind（如果你是自定义安装的请找到自己的安装目录）\r\n\r\n4. 在 Xmind 的安装目录下找到 XMind.ini 这个文件（部分人隐藏后缀名了，所以显示的是 xmind 这个名字，只要是在 xmind 图标后面的那个就是的）用记事本打开这个文件并在最后添加一行：\r\n\r\n   ```ini\r\n   -javaagent:./XMindCrack.jar\r\n   ; 注意此处-javaagent后面的地址应为补丁文件 XMindCrack.jar 的地址，因为我们把该文件放到了Xmind 的安装目录下，Xmind.ini 和 XMindCrack.jar 在同一目录下，因此这里我们可以使用相对路径，如果这两个文件不在同一个目录下，注意填写正确的路径\r\n   ```\r\n\r\n5. 断开网络，或者使用防火墙阻止 XMind 联网，或者在 hosts 文件中添加一行`127.0.0.1 www.xmind.net`（建议采用断网或者增加 hosts 记录法）。其中 hosts 文件一般在：_C:\\Windows\\System32\\drivers\\etc_ 目录下\r\n\r\n6. 再次启动 Xmind，进行软件激活 -> 帮助 -> 序列号 -> 输入任意邮箱地址及以下序列号：\r\n\r\n   ```sh\r\n   XAka34A2rVRYJ4XBIU35UZMUEEF64CMMIYZCK2FZZUQNODEKUHGJLFMSLIQMQUCUBXRENLK6NZL37JXP4PZXQFILMQ2RG5R7G4QNDO3PSOEUBOCDRYSSXZGRARV6MGA33TN2AMUBHEL4FXMWYTTJDEINJXUAV4BAYKBDCZQWVF3LWYXSDCXY546U3NBGOI3ZPAP2SO3CSQFNB7VVIY123456789012345\r\n   ```\r\n\r\n7. 所有步骤完成之后，即可重新联网。\r\n","createdTime":1580652938033,"updatedTime":1609331754663,"resources":[],"tags":[{"id":"4e00e5550c864473a3f16e4b0698f1c3","title":"windows","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"baff72b44ada421e8a5c28f1d4102110","title":"使用 Serveo 进行内网穿透","body":"> [官网](https://serveo.net/)  \r\n> 这里只是记录一些吾辈需要的常用的命令，官网上虽然很详细但终归是英文（好像也没什么），不过还是记录一下不容易忘记呢\r\n\r\n## 基本使用：\r\n\r\n```bash\r\n# 使用 SSH 将本地的 localhost:3000 映射到到远程的 serveo.net:80\r\nssh -R 80:localhost:3000 serveo.net\r\n```\r\n\r\n## 保持连接不超时\r\n\r\n添加 ssh 连接参数 `-o ServerAliveInterval=60` 就好了，每隔 60s 扫描一次\r\n\r\n```bash\r\nssh -o ServerAliveInterval=60 -R 80:localhost:8888 serveo.net\r\n```\r\n\r\n### 连接到自定义的域名/子域名\r\n\r\n添加 DNS 两条记录就行，吾辈推荐 [cloudflare](https://dash.cloudflare.com) 这个网站，能让 DNS 更改在 1 分钟内生效真的很厉害！\r\n\r\n1. 添加 A 纪录 `A | serveo | 159.89.214.31`\r\n2. 添加 TXT 记录 `TXT | serveo | authkeyfp=SHA256:g6VHWesncgnhwPjvENkhgrC3tkx9SzAKoMOl9xvXgPo`\r\n   > authkeyfp 后面跟的那一串东西其实是 rsa 密钥指纹，使用 `ssh-keygen -l` 可以查看，一般都在 `~/.ssh/id_rsa`，没有的话用 `ssh-keygen` 生成一个就好了\r\n\r\n进行连接（其实也就是在远程端口前面加上自定义域名而已）\r\n\r\n```bash\r\nssh -R serveo.rxliuli.com:80:localhost:3000 serveo.net\r\n```\r\n\r\n然后就可以通过 <https://rxliuli.serveo.net/> 来访问本地部署的项目啦\r\n","createdTime":1580652938038,"updatedTime":1609331748997,"resources":[],"tags":[{"id":"4e00e5550c864473a3f16e4b0698f1c3","title":"windows","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"f97fcb0bc7d747e08ce70de500bf68cb","title":"Cmder 启动报错","body":"## 场景\r\n\r\n每次打开 `Cmder` 时都会出现这么一个错误，虽然貌似对之后的使用没什么影响，但强迫症表示受不了呀\r\n\r\n```txt\r\nWARNING! The MacType's hooks are detected at 0x00007FF8E9D10000 D:\\Program\\MacType\\MacType64.dll Please add ConEmuC.exe and ConEmuC64.exe to the exclusion list to avoid crashes! https://conemu.github.io/en/Installation.html#mactype\r\n```\r\n\r\n其实在初次使用 `Cmder` 时可能会遇到这种情况，因为你的 PC 上肯定是同时安装了 `MacType`，在遇到这种情况时看一下官方的链接就好了（虽然官方也没给出如何将程序添加到排除列表中 23333）\r\n\r\n> [官方链接](https://conemu.github.io/en/Installation.html#mactype)\r\n\r\n官方的解释是：\r\n\r\n```txt\r\nIf you are using MacType you can get crashes when starting any application from a shell started in ConEmu tab.\r\nThat is because MacType tries to hook ConEmuC.exe and ConEmuC64.exe processes. But ConEmuC is a console application and it does not draw any text on graphical canvas at all.\r\n```\r\n\r\n大意就是说 `ConEmuC.exe` 和 `ConEmuC64.exe` 是命令行程序，不在窗口上绘制什么文本，所以在其中打开时可能会发生异常。\r\n\r\n## 解决方案\r\n\r\n### 1. 使用图形编辑器\r\n\r\n详情见下面的 Gif\r\n\r\n![Cmder 启动报错](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122211545.gif)\r\n\r\n### 2. 编辑配置文件\r\n\r\n修改 `MacType` 的配置文件 `MacType.ini`（位于 `${MacType}/MacType.ini`），在 `UnloadDll`（排除的 `DLL`）下添加 `ConEmuC64.exe` 和 `ConEmuC.exe` 即可。\r\n","createdTime":1580652938022,"updatedTime":1609331742437,"resources":[],"tags":[{"id":"4e00e5550c864473a3f16e4b0698f1c3","title":"windows","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"b2a69a4c7578423882c648fd93cc5a1f","title":"Markdown 图片粘贴工具 PicGo","body":"## 场景\r\n\r\n使用 Markdown 的人都知道，想要在 Markdown 文件中插入图片并不是特别容易，因为你必须要先把图片上传到图床才行，一个好的图床能够节省很多时间。吾辈之前使用的是 smms，后来切换到了 GitHub，毕竟 GitHub 作为国外流行的托管网站，但事实上 GitHub 上传图片麻烦一点也不少。_add -> commit -> push -> browser -> copy url_，实在麻烦。直到，遇到了 PicGo。\r\n\r\nPicGo 对于吾辈而言主要解决了下面的问题：\r\n\r\n- 上传之前重命名\r\n- 上传一键就好\r\n- 上传后图片管理\r\n\r\n> [官网](https://molunerfinn.com/PicGo/), [GitHub](https://github.com/rxliuli/PicGo)\r\n\r\n![官网首页截图](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181016231008.png)\r\n\r\n## 基本使用\r\n\r\n在 [GitHub Releases](https://github.com/Molunerfinn/picgo/releases) 下载最新版，然后安装一下即可开箱即用啦！\r\n\r\n> 注：上传图床默认是 [smms](https://sm.ms/)，速度很快，也很稳定\r\n\r\n启动之后会看到一个上传页，将图片拖到这里就可以自动上传，并在完成之后自动将链接复制到剪切板上。  \r\n![图片上传页](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190205233313.png)\r\n\r\n在相册里可以对图片进行管理，方便浏览，复制 `URL`，删除本地记录等操作！  \r\n![上传图片管理](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190205233906.png)\r\n\r\n## GitHub 设置\r\n\r\n> 如果你不玩 GitHub，可以跳过这一节\r\n\r\n这里可以参考 PicGo 的 [官方教程](https://github.com/Molunerfinn/PicGo/wiki/%E8%AF%A6%E7%BB%86%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8#github%E5%9B%BE%E5%BA%8A)\r\n\r\n基本上就是需要以下三个配置\r\n\r\n- 仓库名：准确地说是 [用户名/仓库名]，例如吾辈的 GitHub 帐户名是 rxliuli，作为图床的仓库名是 img-bed，那么这里应该设置为 **rxliuli/img-bed**\r\n- 分支名：默认就是 master 分支，如果没什么特别的需求应该不用修改\r\n- Token：用来操作 GitHub 的钥匙，你可以在 [Token 设置](https://github.com/settings/tokens) 中任意生成，但需要留意权限，默认选择第一个 repo 然后点击 **Generator Token** 按钮生成就行了\r\n\r\n吾辈的配置\r\n\r\n![PicGo 配置](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181016232104.png)\r\n\r\n## VSCode 插件\r\n\r\n> 如果你不玩 VSCode，也可以跳过这一节了\r\n\r\n如果你使用的编辑器是 VSCode 并且不需要管理图片的话，便可以使用 VSCode 插件 [PicGo](https://marketplace.visualstudio.com/items?itemName=Spades.vs-picgo)\r\n\r\n基本上安装完成之后就可以直接使用了，默认使用 [SMMS 图床](https://sm.ms/)。\r\n\r\n常用操作只有三个：\r\n\r\n- 截图上传 `Ctrl-Alt-U`  \r\n  ![截图上传](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181205102050.gif)\r\n- 文件管理器选择上传 `Ctrl-Alt-E`  \r\n  ![文件管理器选择上传](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181205102356.gif)\r\n- 输入文件路径上传 `Ctrl-Alt-O`  \r\n  ![输入文件路径上传](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181205102418.gif)\r\n\r\n> 如果你不想使用 SMMS 图床，也可以配置 GitHub 或者其他的图床，具体参考 [官方文档](https://marketplace.visualstudio.com/items?itemName=Spades.vs-picgo)。\r\n\r\n---\r\n\r\n那么，关于 Markdown 图片粘贴工具到这里便结束了，愉快的使用 Markdown 写作吧 `o(〃＾▽＾〃)o`\r\n","createdTime":1580652938023,"updatedTime":1609331710266,"resources":[],"tags":[{"id":"4e00e5550c864473a3f16e4b0698f1c3","title":"windows","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"aa2a1092e2e94565b1482eb6af0ce194","title":"Windows 下 Cmder 安装 Chocolatey","body":"Chocolatey 是一个 Windows 下的软件包管理系统，追求一切皆可用命令解决。\r\n\r\n> [官网](https://chocolatey.org/) / [GitHub 仓库](https://github.com/chocolatey/chocolatey)\r\n\r\n在 Cmder 的 Admin Bash 环境下输入以下命令：\r\n\r\n```bash\r\nλ powershell -NoProfile -ExecutionPolicy unrestricted -Command \"iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\r\n```\r\n\r\n![安装图示](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122211812.png)\r\n\r\n> 此处千万注意三点：\r\n\r\n1. 使用 **Admin** 权限打开的 Cmder（或者是打开的新选项卡）  \r\n   如果提示你权限不足肯定就是因为这个啦\r\n2. 使用的是 Cmder **Bash** 而非 PowerShell  \r\n   在 powershell 下也能够安装（命令不太一样），然而我们想要在 Cmder Bash 下安装，所以不要搞混淆了哦\r\n3. 命令不要复制错误了（吾辈就错了。。。）  \r\n   如果提示 _使用“1”个参数调用“DownloadString”时发生异常:“不支持给定路径的格式。”_ 的话一般都是下载路径那里多了个空格之类，仔细找找吧\r\n\r\n安装完成之后输入 `choco` 验证一下，得到如下输出即为成功！\r\n![成功的响应](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181122211828.png)\r\nChocolatey 常用的命令如下：\r\n\r\n```bash\r\nλ choco list softwareName //查询软件列表\r\nλ choco install softwareName //安装软件\r\nλ choco list -lo //列出当前使用 choco 所安装的软件\r\nλ choco uninstall softwareName //卸载软件\r\nλ clist softwareName //查询软件列表简写\r\nλ cinst softwareName //安装软件简写\r\n```\r\n\r\n[可安装软件包列表](https://chocolatey.org/packages)\r\n\r\n## Windows 下常用的开发环境软件包\r\n\r\n```bash\r\nλ choco install git.install     #安装 git\r\nλ choco install jdk8            #安装 JDK8\r\nλ choco install google-chrome-x64 #Google Chrome (64-bit only)\r\nλ choco install autohotkey.portable    #安装 AutoHotkey (Portable)\r\nλ choco install googlechrome    #安装 Chrome\r\nλ choco install firefox         #安装 firefox\r\nλ choco install python          #安装 python\r\nλ choco install nodejs.install  #安装 node\r\nλ choco install ruby            #安装 ruby\r\nλ choco install notepadplusplus.install #安装 notepad++\r\nλ choco install Atom                    #安装 Atom\r\nλ choco install SublimeText3            #安装 SublimeText3\r\n```\r\n\r\nCmder 在使用 `Cmd` 原生命令时（例如 `clip` 复制命令），可能会出现乱码，使用命令即可切换默认代码页为 `UTF-8`：\r\n\r\n```bash\r\npowershell -NoProfile -ExecutionPolicy unrestricted -Command \"chcp 65001\"\r\n```\r\n\r\n如果有什么能够一劳永逸的方法就好了，泥萌知道的话可以去 [GitHub](https://github.com/rxliuli/rxliuli.github.io) 提出 [Issues](https://github.com/rxliuli/rxliuli.github.io/issues) 啦\r\n","createdTime":1580652938026,"updatedTime":1609331619393,"resources":[],"tags":[{"id":"4e00e5550c864473a3f16e4b0698f1c3","title":"windows","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"dd432644947d4606a0e34e9b99f957ef","title":"VSCode Markdown All in One 插件不能使用 TOC 命令创建文章目录","body":"## 场景\r\n\r\n使用 VSCode 写 Markdown 文档时，突然发现 VSCode 输入 `toc` 找不到生成文章目录的命令了。。。\r\n\r\n![输入 toc 创建文章目录](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181201211046.png)\r\n\r\n然而输入 `markdown` 时发现仍然有创建文章目录的选项，说明这个功能还存在\r\n\r\n![输入 markdown 创建文章目录](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181201211242.png)\r\n\r\n那么，到底是为什么输入 `toc` 没有匹配到创建文章目录的命令了呢？\r\n\r\n## 原因\r\n\r\n吾辈突然发现一个奇怪的地方，是的，明明是英文状态下，[Markdown All in One](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one) 插件的命令却是中文的，这是什么原因呢？\r\n\r\n于是吾辈在 [Markdown All in One](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one) 插件的 [GitHub](https://github.com/neilsustc/vscode-markdown) 仓库上提出了这个问题。  \r\n[I can't use the command to generate the title of the article, I don't know what happened. . .](https://github.com/neilsustc/vscode-markdown/issues/337)  \r\n作者说有类似的问题  \r\n [中文系统下，无法通过键入 TOC 命令快速创建目录](https://github.com/neilsustc/vscode-markdown/issues/327)。\r\n\r\n[Issues](https://github.com/neilsustc/vscode-markdown/issues/327) 中说是显示语言需要改成 `en`，然而吾辈并没有修改过 VSCode 的显示语言，所以这个解决方案对吾辈没有生效。。。\r\n\r\n![VSCode 显示语言](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181201212334.png)\r\n\r\n## 解决\r\n\r\n不过因此吾辈想到了另一种可能，吾辈之前是安装了 [Chinese (Simplified) Language Pack for Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans) 插件，以让 VSCode 显示中文，后来因为一些原因放弃中文而使用原生 VSCode 了。所以就想会不会是这个原因，于是吾辈尝试重新安装中文语言插件。\r\n\r\n结果，233333，真的是这个原因呢！\r\n\r\n![安装了 VSCode 中文语言插件之后](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181201212821.png)\r\n\r\n这里吾辈的语言仍然为 `en`，仅仅只是安装了中文语言插件，命令由 **创建目录** 变成了 `Create Table of Contents`，插件是在中文系统下默认显示中文命令，在安装完中文语言插件后就变成了全英文（此时 VSCode 语言仍然设置为 `en`）。\r\n\r\n应该是插件本身的问题，吾辈已经提交了 [Issues](https://github.com/neilsustc/vscode-markdown/issues/337)，等待开发者回复。。。\r\n","createdTime":1580652938011,"updatedTime":1609331158013,"resources":[],"tags":[{"id":"2dc486a3eb624e698c76e4512f46af5e","title":"vscode","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"eb2c6801333544e38b570015e8a3965c","title":"VSCode 在 markdown 文档中存在表格时不能格式化文档","body":"## 场景\r\n\r\n在使用 markdown 写文档时突然发现格式化功能失效了。这是个很麻烦的问题，吾辈经常要用 VSCode 写 markdown 文档，如果不能进行格式化真是个大麻烦了。\r\n\r\n## 确认是否为插件问题\r\n\r\n吾辈有关 Markdown 的插件列表\r\n\r\n- [Markdown All in One](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one)\r\n- [markdownlint](https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint)\r\n- [Markdown PDF](https://marketplace.visualstudio.com/items?itemName=yzane.markdown-pdf)\r\n- [Prettier](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)\r\n\r\n不能进行格式化吾辈的第一想法就是 **Markdown All in One** 插件是不是出问题了，毕竟吾辈写 Markdown 文档这么久了，也是第一次遇到这种问题呢  \r\n吾辈尝试禁用了 **Markdown All in One** 插件后，发现文档确实能够正常格式化了。  \r\n然而这并没能解决问题，因为在 VSCode 书写 markdown 文档的话，**Markdown All in One** 插件的功能是必不可少的（更好的语法高亮，自动完成，生成标题等）。\r\n\r\n实际上进行格式化的操作是由 **Prettier** 完成的，所以吾辈觉得应该是 **Markdown All in One** **阻碍** 了 **Prettier** 插件的格式化功能。\r\n\r\n然而吾辈也明白了一件事：**Markdown All in One** 和 **Prettier** 插件居然不兼容！\r\n\r\n## 确认是否是普遍性问题\r\n\r\n之后，吾辈想要确认这是否是一个普遍性的问题。测试了几个 markdown 文档后惊奇的发现有些能够正常格式化，有些就不行。  \r\n这就很奇怪了，吾辈在逐次删减部分 markdown 内容后终于发现了影响格式化的代码 -- 表格。  \r\n这可真是太意外了，毕竟表格这种东西，感觉上不应该会影响到插件本身呀\r\n\r\n## 解决\r\n\r\n吾辈正要打算去 **Markdown All in One** 插件 [GitHub Issues](https://github.com/neilsustc/vscode-markdown/issues) 提出这个问题时，发现上面已经有人遇到了这个问题了。<https://github.com/neilsustc/vscode-markdown/issues/317>\r\n\r\n开发者回复说明了这样的内容\r\n\r\n> Thanks for the detailed description. The problem is vscode implicitly only allows one \"formatter\" per language. Then this extension('s formatter) and that of Prettier cannot co-exist.  \r\n> Related [Microsoft/vscode#41882](https://github.com/Microsoft/vscode/issues/41882).  \r\n> Is there an option of Prettier to format GFM table? If it can do this, you can disable this extension's formatter with `markdown.extension.tableFormatter.enabled`\r\n\r\n大意是在 VSCode 中每种语言的格式化程序默认只能有一种，所以 **Markdown All in One** 的表格格式化 和 **Prettier** 的格式化就产生了冲突。然后他给出了解决方案，禁用掉表格格式化。  \r\n配置如下\r\n\r\n```js\r\n{\r\n  // 禁用表格格式化功能\r\n  \"markdown.extension.tableFormatter.enabled\": false,\r\n}\r\n```\r\n\r\n最后，添加这个配置之后需要重启 VSCode，不然可能不会生效哦\r\n","createdTime":1580652938014,"updatedTime":1609331140709,"resources":[],"tags":[{"id":"2dc486a3eb624e698c76e4512f46af5e","title":"vscode","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"23eba6c654634eabb0b562d00cb26d11","title":"VSCode 自定义模板代码片段","body":"## 场景\r\n\r\nVSCode 时常需要输入一些重复的代码片段，例如创建 vue 文件后总是要写一些类似于下面这样的文件。\r\n\r\n```js\r\n<template>\r\n\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data: () => ({\r\n\r\n  }),\r\n  methods: {\r\n\r\n  },\r\n  mounted () {\r\n\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n能不能有什么办法使用快捷键，或者提示将之快捷打出来呢？VSCode 已经想到了这些并提供了一个名为 **Snippet** 的功能。\r\n\r\n## 使用\r\n\r\n打开**命令面板**（_查看 > 命令面板_，快捷键是 _CS-P_），输入 **Snippet** 找到 **Preferences: Configure User Snippets（配置用户代码片段）**，选择你所需要配置的代码片段生效的语言。\r\n\r\n这里以 **Vue** 为例，回车之后会打开一个名为 _vue.json_ 的文件，初始配置大致如下\r\n\r\n```json\r\n{\r\n  // Place your snippets for vue here. Each snippet is defined under a snippet name and has a prefix, body and\r\n  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:\r\n  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the\r\n  // same ids are connected.\r\n  // Example:\r\n  // \"Print to console\": {\r\n  // \t\"prefix\": \"log\",\r\n  // \t\"body\": [\r\n  // \t\t\"console.log('$1');\",\r\n  // \t\t\"$2\"\r\n  // \t],\r\n  // \t\"description\": \"Log output to console\"\r\n  // }\r\n}\r\n```\r\n\r\n上面那些注释其实就给出了一个配置的例子。放开注释我们研究一些每一行的作用\r\n\r\n```json\r\n{\r\n  // Place your snippets for vue here. Each snippet is defined under a snippet name and has a prefix, body and\r\n  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:\r\n  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the\r\n  // same ids are connected.\r\n  // Example:\r\n  // 代码片段的名字\r\n  \"Print to console\": {\r\n    \"prefix\": \"log\", // 前缀，在 vue 文件中输入这个前缀就会有代码提示\r\n    // 输入前缀回车之后在文件中生成的内容，单行直接用字符串，否则使用数组\r\n    \"body\": [\r\n      //下面是每一行的内容，$1 指的是第一个变量（光标会首先停在这里）\r\n      \"console.log('$1');\",\r\n      // $2 是第二个变量，在输入完第一个变量后按 Tab 就能跳转到第二个变量所在的位置\r\n      \"$2\"\r\n    ],\r\n    // 关于这个代码片段的描述\r\n    \"description\": \"Log output to console\"\r\n  }\r\n}\r\n```\r\n\r\n好了，我们也来模仿写一个自己代码片段吧\r\n\r\n```json\r\n{\r\n  // 在最下方追加\r\n  \"vue teamplte\": {\r\n    \"prefix\": \"vueTemplate\",\r\n    \"body\": [\r\n      \"<template>\",\r\n      \"  $1\",\r\n      \"</template>\",\r\n      \"\",\r\n      \"<script>\",\r\n      \"export default {\",\r\n      \"  data: () => ({\",\r\n      \"\",\r\n      \"  }),\",\r\n      \"  methods: {\",\r\n      \"\",\r\n      \"  },\",\r\n      \"  mounted () {\",\r\n      \"\",\r\n      \"  }\",\r\n      \"}\",\r\n      \"</script>\"\r\n    ],\r\n    \"description\": \"vue 的模板代码\"\r\n  }\r\n}\r\n```\r\n\r\n然后，在 _.vue_ 文件中输入 `vueTemplate` 试试吧\r\n\r\n> 更多的详细信息（英文）可以参考 Microsoft 官方的 [VSCode 创建代码片段](https://code.visualstudio.com/docs/editor/userdefinedsnippets)\r\n","createdTime":1580652938017,"updatedTime":1609331135530,"resources":[],"tags":[{"id":"2dc486a3eb624e698c76e4512f46af5e","title":"vscode","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"020adfee4c8e490098ae0abf408d9410","title":"VSCode 集成 ESLint 和 Prettier","body":"## 情景\r\n\r\nESLint 是一个前端代码质量检测工具，然而配置非常非常非常的麻烦（前端的配置真的是超多呢），所以在吾辈的 VueJS 项目中直接使用了 `standard` 规则。然而问题在于有了代码规则，还需要自动的格式化，否则为了手动格式化是一件极其痛苦的事情。。。\r\n\r\n## 步骤\r\n\r\nVSCode 安装下面三个插件\r\n\r\n- [Vetur](https://marketplace.visualstudio.com/items?itemName=octref.vetur)\r\n- [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)\r\n- [Prettier - Code formatter](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)\r\n\r\n然后在 `User Settings`，添加以下配置\r\n\r\n```json\r\n// 配置 ESlint 和 Prettier\r\n\"eslint.autoFixOnSave\": true, // 每次保存的时候将代码按 eslint 格式进行修复\r\n\"prettier.eslintIntegration\": true, // 让 prettier 使用 eslint 的代码格式进行校验\r\n\"prettier.semi\": false, // 去掉代码结尾的分号\r\n\"prettier.singleQuote\": true, // 使用单引号替代双引号\r\n\"javascript.format.insertSpaceBeforeFunctionParenthesis\": true, // 让函数 (名) 和后面的括号之间加个空格\r\n\"vetur.format.defaultFormatter.html\": \"js-beautify-html\", // 格式化. vue 中 html\r\n\"vetur.format.defaultFormatter.js\": \"vscode-typescript\", // 让 vue 中的 js 按编辑器自带的 ts 格式进行格式化\r\n\"vetur.format.defaultFormatterOptions\": {\r\n  \"js-beautify-html\": {\r\n    \"wrap_attributes\": \"force-aligned\" // 属性强制折行对齐\r\n  }\r\n},\r\n\"eslint.validate\": [\r\n  // 开启对. vue 文件中错误的检查\r\n  \"javascript\",\r\n  \"javascriptreact\",\r\n  {\r\n    \"language\": \"html\",\r\n    \"autoFix\": true\r\n  },\r\n  {\r\n    \"language\": \"vue\",\r\n    \"autoFix\": true\r\n  }\r\n]\r\n```\r\n\r\n好了，现在可以正常使用 VSCode 的格式化功能了，保存时也会进行格式化同时修复 ESLint 发现的错误。\r\n","createdTime":1580652938018,"updatedTime":1609331128185,"resources":[],"tags":[{"id":"2dc486a3eb624e698c76e4512f46af5e","title":"vscode","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"d220fc16727d411da22efde7ec4bd693","title":"Vue 实现一个滚动到顶部的悬浮图标组件","body":"## 场景\r\n\r\n吾辈在写 vuejs 前端项目的时候，需要实现一个下拉文章列表时，出现一个悬浮按钮，用于一键回到文章顶部。\r\n\r\n## 实现\r\n\r\n> 实现源码放到了 [GitHub](https://github.com/rxliuli/vue-scroll-to-top-component)，[Demo 演示](https://vue-scroll-to-top-component.rxliuli.com) 想直接看源码/效果的人可以直接去看，但最好看一下 [注意点](#注意点)\r\n\r\n### 思路\r\n\r\n1. 定义一个 vuejs 组件，抽取出最需要的几个属性（位置，组件的样子）\r\n2. 监听窗口滚动，当滚动到第二屏的时候显示组件\r\n3. 监听组件点击，点击即逐渐减少与顶端的距离\r\n4. 当在滚动中用户手动下拉时终止滚动\r\n5. 引用组件并传递一个 vue 模板\r\n\r\n### 代码\r\n\r\n定义模板 `VxScrollToTop`\r\n\r\n```vuejs\r\n/**\r\n一个 Vue 的滚动到顶部的容器组件（不提供 UI 显示）\r\n使用：\r\n1. 引入自定义文件上传组件: import VxScrollToTop from '@/components/common/VxScrollToTop'\r\n2. 声明它\r\nexport default {\r\n  components: {\r\n    VxScrollToTop: VxScrollToTop\r\n  }\r\n}\r\n3. 在 template 中使用\r\n<vx-scroll-to-top>\r\n  <!-- 这里面的内容随你定义，是上拉按钮要显示的样子 -->\r\n  <v-btn color=\"primary\"\r\n          fab>\r\n    <v-icon>vertical_align_top</v-icon>\r\n  </v-btn>\r\n</vx-scroll-to-top>\r\n */\r\n<template>\r\n  <div :style=\"scrollToTopStyle\"\r\n       v-show=\"showScrollToTop\"\r\n       @click=\"scrollToTop\">\r\n    <slot></slot>\r\n  </div>\r\n</template>\r\n<script>\r\nexport default {\r\n  props: {\r\n    // 定义上拉按钮容器的位置\r\n    top: {\r\n      type: [Number, String],\r\n      default: undefined\r\n    },\r\n    bottom: {\r\n      type: [Number, String],\r\n      default: undefined\r\n    },\r\n    left: {\r\n      type: [Number, String],\r\n      default: undefined\r\n    },\r\n    right: {\r\n      type: [Number, String],\r\n      default: undefined\r\n    }\r\n  },\r\n  data: () => ({\r\n    // 是否显示，初始默认不显示\r\n    showScrollToTop: false,\r\n    // 定时器\r\n    timer: null,\r\n    scrollToTopStyle: {\r\n      position: 'fixed',\r\n      top: '',\r\n      bottom: '',\r\n      left: '',\r\n      right: ''\r\n    }\r\n  }),\r\n  methods: {\r\n    isNumber (str) {\r\n      if (!new RegExp('^[0-9]+([.]{1}[0-9]+)?$').test(str)) {\r\n        return false\r\n      }\r\n      return true\r\n    },\r\n    watchPosition () {\r\n      if (![this.top, this.bottom, this.left, this.right].find(i => i !== undefined)) {\r\n        this.scrollToTopStyle.bottom = this.scrollToTopStyle.right = '14px'\r\n      }\r\n    },\r\n    watchTop () {\r\n      if (this.top !== undefined) {\r\n        this.scrollToTopStyle.top = this.isNumber(this.top) ? parseFloat(this.top) + 'px' : this.top\r\n      }\r\n    },\r\n    watchBottom () {\r\n      if (this.bottom !== undefined) {\r\n        this.scrollToTopStyle.bottom = this.isNumber(this.bottom) ? parseFloat(this.bottom) + 'px' : this.bottom\r\n      }\r\n    },\r\n    watchLeft () {\r\n      if (this.left !== undefined) {\r\n        this.scrollToTopStyle.left = this.isNumber(this.left) ? parseFloat(this.left) + 'px' : this.left\r\n      }\r\n    },\r\n    watchRigth () {\r\n      if (this.right !== undefined) {\r\n        this.scrollToTopStyle.right = this.isNumber(this.right) ? parseFloat(this.right) + 'px' : this.right\r\n      }\r\n    },\r\n    /**\r\n     * 初始化按钮的位置\r\n     */\r\n    initBtnPosition () {\r\n      this.watchTop()\r\n      this.watchBottom()\r\n      this.watchLeft()\r\n      this.watchRigth()\r\n      this.watchPosition()\r\n    },\r\n    initBindScroll () {\r\n      // 监听窗口滚动\r\n      document.onscroll = ((oldScrollTopLength) => {\r\n        const clientHeight = document.documentElement.clientHeight\r\n        return () => {\r\n          const scrollTopLength = document.documentElement.scrollTop || document.body.scrollTop\r\n          // 如果定时器不存在的话就正常计算滚动到顶部的图标是否存在\r\n          if (!this.timer) {\r\n            // 滚动到第二屏就显示\r\n            this.showScrollToTop = scrollTopLength > clientHeight\r\n          }\r\n          // 向下滚动时判断判断是否正在向上滚动，是的话就清除定时器，停在当前位置\r\n          if (scrollTopLength > oldScrollTopLength && this.timer) {\r\n            // 设置这个是因为有时候 clearInterval() 并不能清除这个属性，或许是 vuejs 组件中的属性特殊一点？\r\n            this.timer = clearInterval(this.timer)\r\n          }\r\n          oldScrollTopLength = scrollTopLength\r\n        }\r\n      })(0)\r\n    },\r\n    /**\r\n     * 回到顶部\r\n     */\r\n    scrollToTop () {\r\n      this.timer = setInterval(() => {\r\n        const scrollTopLength = document.documentElement.scrollTop || document.body.scrollTop\r\n        if (scrollTopLength <= 0) {\r\n          this.timer = clearInterval(this.timer)\r\n          this.showScrollToTop = false\r\n        }\r\n        const spend = scrollTopLength / 5\r\n        document.documentElement.scrollTop = document.body.scrollTop = scrollTopLength - spend\r\n      }, 30)\r\n    }\r\n  },\r\n  mounted () {\r\n    this.initBtnPosition()\r\n    this.initBindScroll()\r\n  }\r\n}\r\n</script>\r\n<style scoped>\r\n#vx-scroll-to-top-btn {\r\n  position: fixed;\r\n}\r\n</style>\r\n```\r\n\r\n使用起来就很简单了\r\n\r\n```vuejs\r\n<template>\r\n  <div>\r\n    <h2 v-for=\"i in 100\"\r\n        :key=\"i\">\r\n      第 {{i}} 行文字\r\n    </h2>\r\n    <vx-scroll-to-top>\r\n      <!-- 这里面的内容随你定义，是上拉按钮要显示的样子 -->\r\n      <v-btn color=\"primary\"\r\n             fab>\r\n        <v-icon>vertical_align_top</v-icon>\r\n      </v-btn>\r\n    </vx-scroll-to-top>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport VxScrollToTop from '@/components/common/VxScrollToTop'\r\n\r\nexport default {\r\n  components: {\r\n    VxScrollToTop\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n目前这里只能供了最简单的功能，如果有特别的需求可以在上面继续修改一下就好啦\r\n\r\n### 注意点\r\n\r\n- 组件方法内部必须使用 `箭头函数`，因为使用 `function` 会导致 `this` 发生变化。详情参考 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\r\n- 必须要手动置空 `timer`，例如上文所用的 `this.timer = clearInterval(this.timer)`，关于为什么 `timer` 没有被 `clearInterval` 清空目前吾辈还真不太清楚，但如果把 `timer` 放到组件外部就正常使用，估计是 vuejs 的属性有什么特殊的地方也说不定！\r\n","createdTime":1580652937880,"updatedTime":1609331028525,"resources":[],"tags":[{"id":"d86454b85c8f4c38aef6fa1575487e7f","title":"vue","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"fea6cbbcf50249e2be19548d3514d92e","title":"Vue 打包的静态文件不能直接运行","body":"## 问题\r\n\r\n吾辈使用 **vue-cli** 直接生成的 vue 模板项目，在模板之上继续开发的。然而在使用 `npm run build` 打包项目时，却发现打包好的项目在浏览器中直接打开好像什么都没有？\r\n\r\n## 原因\r\n\r\n查看了一下打包后的 `index.html` 源码，终于发现了一个重要的点：\r\n\r\n![vue-cli 打包的项目 index.html 源码](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181029131219.png)\r\n\r\n_所有涉及到路径的地方全都是以 **/** 开头的_\r\n\r\n下面是吾辈打包后生成的 dist 目录\r\n\r\n```bash\r\ndist:.\r\n│  index.html\r\n│\r\n└─static\r\n    ├─css\r\n    │      app.b7bce283257fbd427fb1dc3fea80cee1.css\r\n    │      app.b7bce283257fbd427fb1dc3fea80cee1.css.map\r\n    │\r\n    ├─fonts\r\n    │      MaterialIcons-Regular.012cf6a.woff\r\n    │      MaterialIcons-Regular.570eb83.woff2\r\n    │      MaterialIcons-Regular.a37b0c0.ttf\r\n    │      MaterialIcons-Regular.e79bfd8.eot\r\n    │\r\n    └─js\r\n            app.58cce746b2fe4ac2f2b9.js\r\n            app.58cce746b2fe4ac2f2b9.js.map\r\n            manifest.2ae2e69a05c33dfc65f8.js\r\n            manifest.2ae2e69a05c33dfc65f8.js.map\r\n            vendor.a32972498ed8de656202.js\r\n            vendor.a32972498ed8de656202.js.map\r\n```\r\n\r\n这下很清楚了，vue-cli 生成的模板项目打包后的文件默认需要放到静态资源服务器上，而且还必须是根目录！这很不好，很糟糕，所以需要修改配置。\r\n\r\n## 解决方案\r\n\r\n1. 修改文件 _/config/index.js_，将 `build.assetsPublicPath` 属性的值由 `/` 改为 `./`\r\n   ![/config/index.js](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181029133603.png)\r\n2. 修改文件 _/build/utils.js_，在插件 `ExtractTextPlugin` 中添加 `publicPath: '../../'`\r\n   ![/build/utils.js](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181029133636.png)\r\n\r\n那么，使用 `npm run build` 重新打包后的静态文件应该就可以直接打开啦\r\n","createdTime":1580652937882,"updatedTime":1609331019804,"resources":[],"tags":[{"id":"d86454b85c8f4c38aef6fa1575487e7f","title":"vue","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"fa669d779a1b44e69d3b864b3fe646f9","title":"Vue 深度监听","body":"## 场景\r\n\r\n吾辈在前端项目中需要监听 Vue 组件中的一个数组的变化，然而没想到这个简单的功能却发现并没有想象中的容易。在废了一波三折之后终于算是实现了效果，所以便在这里记录一下。\r\n\r\n## 代码\r\n\r\n> 吾辈写一个 demo 在 [GitHub](https://github.com/rxliuli/vue-deep-monitoring)，如果需要可以去看下。也有一个 [网站](https://vue-deep-monitoring.rxliuli.com/) 用来演示下面的三种方法的效果\r\n\r\n```js\r\n<template>\r\n  <v-card>\r\n    <v-card-title primary-title>\r\n      <h2>普通监听</h2>\r\n      <v-subheader>不会发生变化</v-subheader>\r\n    </v-card-title>\r\n    <v-card-text>\r\n      <v-list>\r\n        <v-list-tile v-for=\"item in items\" :key=\"item.k\">\r\n          <v-text-field\r\n            :label=\"`输入框 ${item.k}`\"\r\n            v-model=\"item.v\"\r\n          ></v-text-field>\r\n        </v-list-tile>\r\n      </v-list>\r\n      <v-layout row wrap>\r\n        <v-flex md4 xs12>\r\n          <h2>旧值</h2>\r\n          <p>{{ oldVal }}</p>\r\n        </v-flex>\r\n\r\n        <v-flex md4 sm4 xs12>\r\n          <h2>差异</h2>\r\n          <p>{{ difference }}</p>\r\n        </v-flex>\r\n        <v-flex md4 xs12>\r\n          <h2>新值</h2>\r\n          <p>{{ val }}</p>\r\n        </v-flex>\r\n      </v-layout>\r\n      <v-layout row wrap>\r\n        <v-flex xs12>\r\n          <h4>最后更新于：{{ lastUpdateTime }}</h4>\r\n        </v-flex>\r\n      </v-layout>\r\n    </v-card-text>\r\n  </v-card>\r\n</template>\r\n\r\n<script>\r\nimport _ from 'lodash'\r\nexport default {\r\n  data: () => ({\r\n    // 吾辈想要监视这个的变化\r\n    items: [],\r\n    // 下面的两个属性仅用于展示\r\n    oldVal: [],\r\n    val: [],\r\n    difference: [],\r\n    lastUpdateTime: new Date()\r\n  }),\r\n  methods: {\r\n    /**\r\n     * 初始化 items\r\n     */\r\n    init() {\r\n      this.items = _.range(1, 6).map(i => ({\r\n        k: i,\r\n        v: ''\r\n      }))\r\n    }\r\n  },\r\n  mounted() {\r\n    this.init()\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n## 直接使用 `watch` 监听\r\n\r\n最开始吾辈使用 `watch` 直接监听数组 `items` 的变化\r\n\r\n```js\r\nwatch: {\r\n  // 监听 items 的变化（实际上数组内部的值变化监听不到）\r\n  items(val, oldVal) {\r\n    this.val = val\r\n    this.oldVal = oldVal\r\n    this.difference = _.differenceWith(\r\n      val,\r\n      oldVal,\r\n      (i, k) => JSON.stringify(i) === JSON.stringify(k)\r\n    )\r\n    this.lastUpdateTime = new Date().toISOString()\r\n  }\r\n},\r\n```\r\n\r\n结果发现完全没有一点效果，vuejs 居然认为数组没有变化。查了一下官网文档，发现在 [这里](https://cn.vuejs.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9) 有一段话。\r\n\r\n> 由于 JavaScript 的限制，Vue 不能检测以下变动的数组：\r\n>\r\n> 1. 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue\r\n> 2. 当你修改数组的长度时，例如：vm.items.length = newLength\r\n\r\n## 使用 `deep` 属性设置深度监听\r\n\r\n后来，在 [watch 的 API](https://cn.vuejs.org/v2/api/#watch) 里面，吾辈找到了一个属性：`deep` ，使用它就可以对数组等嵌套对象进行深度监听。\r\n\r\n所以，吾辈的监听代码变成了这样\r\n\r\n```js\r\nwatch: {\r\n  items: {\r\n    handler (val, oldVal) {\r\n      this.val = val\r\n      this.oldVal = oldVal\r\n      this.difference = _.differenceWith(val, oldVal, (i, k) => JSON.stringify(i) === JSON.stringify(k))\r\n      this.lastUpdateTime = new Date().toISOString()\r\n    },\r\n    // 这里是关键，代表递归监听 items 的变化\r\n    deep: true\r\n  },\r\n}\r\n```\r\n\r\n然而之后又发现了一个问题，深度监听是能够响应数组里面的元素每一次的变化，但旧的值并没有被记录。原因在 [官网文档](https://cn.vuejs.org/v2/api/#vm-watch) 也有指明。\r\n\r\n> 注意：在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象 / 数组。Vue 不会保留变异之前值的副本。\r\n\r\n## 使用额外的变量保存旧值\r\n\r\n没办法，既然 vuejs 限制如此，引用类型的变量无法保存旧值，那我们就自己保存吧\r\n\r\n```js\r\nwatch: {\r\n  items: {\r\n    handler (val) {\r\n      this.val = val\r\n      // itemOld 就是额外的变量\r\n      this.oldVal = this.itemOld\r\n      this.difference = _.differenceWith(val, this.itemOld, (i, k) => JSON.stringify(i) === JSON.stringify(k))\r\n      // 注意：这里更新旧值采用的是深层复制而非简单的引用\r\n      this.itemOld = _.cloneDeep(val)\r\n      this.lastUpdateTime = new Date().toISOString()\r\n    },\r\n    // 这里是关键，代表递归监听 items 的变化\r\n    deep: true\r\n  },\r\n```\r\n\r\n## 总结\r\n\r\nvuejs 的坑是真的不少呢，不过踩过去就好啦\r\n","createdTime":1580652937883,"updatedTime":1609330980293,"resources":[],"tags":[{"id":"d86454b85c8f4c38aef6fa1575487e7f","title":"vue","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"fd87dcc05def45e381ff6005e6921f0e","title":"Vue 自定义标签的 src 属性不能使用相对路径","body":"## 场景\r\n\r\n吾辈在使用 Vuetify 时突然遇到的，明明 `img` 标签就可以使用相对路径获取到图片，而 Veutify 的组件 `v-img` 却不能使用。\r\n\r\n如下面 3 种加载图片的方式\r\n\r\n```html\r\n<!-- 正常加载 -->\r\n<v-img :src=\"require('../../assets/logo.png')\" />\r\n<!-- 无法加载 -->\r\n<v-img src=\"../../assets/logo.png\" />\r\n<!-- 正常加载 -->\r\n<img src=\"../../assets/logo.png\" />\r\n```\r\n\r\n> 吾辈在 [segmentfault](https://segmentfault.com/q/1010000016871400) 上的提问\r\n\r\n## 原因\r\n\r\n是的，居然必须用 `require()` 引入图片才能生效，那为什么 `img` 标签可以直接使用相对路径呢？这和 [vue-loader 资源路径处理](https://vue-loader-v14.vuejs.org/zh-cn/configurations/asset-url.html) 有关系。\r\n\r\n![官方资源路径处理](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181101130706.png)\r\n\r\n官方明确指出会将所有资源路径作为模块依赖，也就是后台 `vue-loader` 帮我们转换成 `require()` 的形式了。\r\n\r\n## 解决方案\r\n\r\n### vue cli 3\r\n\r\nvue cli 3 的配置项 API 发生了改变，由 `transformToRequire` 改为 `transformAssetUrls`，而且配置方式也不再是直接修改 webpack 配置文件，而是修改 `vue.config.js` 这个经过包装后的文件。现在，最新的配置方式如下\r\n\r\n```js\r\nmodule.exports = {\r\n  chainWebpack: (config) => {\r\n    config.module\r\n      .rule(\"vue\")\r\n      .use(\"vue-loader\")\r\n      .loader(\"vue-loader\")\r\n      .tap((options) => {\r\n        return {\r\n          ...options,\r\n          //修复静态资源引用的问题 vue cli 2 => vue cli 3 升级之后配置项由 transformToRequire 改为 transformAssetUrls\r\n          transformAssetUrls: {\r\n            video: [\"src\", \"poster\"],\r\n            source: \"src\",\r\n            img: \"src\",\r\n            image: \"xlink:href\",\r\n            // 在这里添加需要使用静态资源的自定义元素\r\n            \"a-avatar\": \"src\",\r\n          },\r\n        }\r\n      })\r\n  },\r\n}\r\n```\r\n\r\n> 具体参考\r\n> [Vue Loader => 从 v14 迁移 => 废弃的选项](https://vue-loader.vuejs.org/zh/migrating.html#%E5%BA%9F%E5%BC%83%E7%9A%84%E9%80%89%E9%A1%B9)  \r\n> [Vue Cli 3 => webpack 相关 => 链式操作 (高级) => 修改 Loader 选项](https://cli.vuejs.org/zh/guide/webpack.html#%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F)\r\n\r\n### vue cli 2\r\n\r\n那么，Veutify 组件中的 `src` 不能使用相对路径的原因就很明确了。因为 `vue-loader` 并不知道我们要把 `v-img` 的 `src` 属性转换成 `require()` 依赖。我们找到 `vue-loader` 配置处，在 `options.transformToRequire` 中加上 `v-img` 即可\r\n\r\n```js\r\n// vuetify 框架的 src 标签也需要自动转换为 require\r\n'v-img': 'src'\r\n```\r\n\r\n吾辈的配置文件在 _build > vue-loader.conf.js_\r\n\r\n```js\r\n\"use strict\"\r\nconst utils = require(\"./utils\")\r\nconst config = require(\"../config\")\r\nconst isProduction = process.env.NODE_ENV === \"production\"\r\nconst sourceMapEnabled = isProduction\r\n  ? config.build.productionSourceMap\r\n  : config.dev.cssSourceMap\r\n\r\nmodule.exports = {\r\n  loaders: utils.cssLoaders({\r\n    sourceMap: sourceMapEnabled,\r\n    extract: isProduction,\r\n  }),\r\n  cssSourceMap: sourceMapEnabled,\r\n  cacheBusting: config.dev.cacheBusting,\r\n  transformToRequire: {\r\n    video: [\"src\", \"poster\"],\r\n    source: \"src\",\r\n    img: \"src\",\r\n    image: \"xlink:href\",\r\n    \"v-img\": \"src\",\r\n  },\r\n}\r\n```\r\n\r\n> [vue-loader 官方文档参考](https://vue-loader-v14.vuejs.org/zh-cn/options.html#transformtorequire)\r\n\r\n然后重启 `npm run dev` 刷新一下就行啦\r\n","createdTime":1580652937884,"updatedTime":1609330966491,"resources":[],"tags":[{"id":"d86454b85c8f4c38aef6fa1575487e7f","title":"vue","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"8fe300cfeedb4f40a5059c458c95e972","title":"Vue 实现一个简单的瀑布流组件","body":"## 场景\r\n\r\n在用 Vue 写前端的时候，需要实现无限滚动翻页的功能。因为用到的地方很多，于是便想着抽出一个通用组件。\r\n\r\n## 实现\r\n\r\n> 实现源码放到了 [GitHub](https://github.com/rxliuli/vue-waterfalls-flow)，[Demo 演示](https://vue-waterfalls-flow.rxliuli.com/) 想直接看源码/效果的人可以直接去看\r\n\r\n### 思路\r\n\r\n1. 定义一个 vuejs 容器组件\r\n2. 抽离出公共的属性（加载一页数据的函数/每个元素的模板）\r\n3. 在父容器中遍历每个元素并绑定到传入的模板上\r\n4. 监听滚动事件，如果不是最后一页就加载下一页\r\n5. 重新渲染集合元素\r\n\r\n### 代码\r\n\r\n定义模板\r\n\r\n```vuejs\r\n/**\r\n自定义瀑布流组件\r\n使用方法如下：\r\n<rx-waterfalls-flow :load=\"load\">\r\n    <!-- 这里 slotProps 绑定的便是子组件的数据，通过 slotProps 可以访问到子组件绑定到模板上的数据，当然，更简单的方法是使用 ES6 的解构 -->\r\n    <template slot-scope=\"{item}\">\r\n  <!-- 在模板里面便可以使用集合中的元素 item 了 -->\r\n  <li :key=\"item.id\">\r\n    {{item.text}}\r\n  </li>\r\n</template>\r\n  </rx-waterfalls-flow>\r\n */\r\n<template>\r\n  <div id=\"rx-waterfalls-flow-container\">\r\n    <slot\r\n      v-for=\"item in items\"\r\n      :item=\"item\"\r\n    />\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  props: {\r\n    load: {\r\n      type: Function,\r\n      default: function () {\r\n        throw new Error('你需要为 RxWaterfallsFlow 组件定义分页加载的参数')\r\n      }\r\n    }\r\n  },\r\n  data: () => ({\r\n    items: [],\r\n    page: {\r\n      total: 0,\r\n      size: 10,\r\n      pages: 10,\r\n      current: 1,\r\n      records: []\r\n    }\r\n  }),\r\n  methods: {\r\n    async loadPage (current, size) {\r\n      this.page = await this.load(current, size)\r\n      this.items.push(...this.page.records)\r\n      this.page.records = []\r\n    },\r\n    /**\r\n     * 初始化方法，加载第一页的数据，加载监听器\r\n     */\r\n    async init () {\r\n      this.loadPage()\r\n      // 绑定窗口滚动事件\r\n      // 获得文档高度和滚动高度\r\n      // 计算是否已经到底了\r\n      // 到底的话就加载下一页的数据，否则忽略\r\n      const otherOnscrollFn = document.onscroll ? document.onscroll : function () { }\r\n      document.onscroll = () => {\r\n        otherOnscrollFn()\r\n        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop\r\n        const clientHeight = document.documentElement.clientHeight\r\n        const scrollHeight = document.documentElement.scrollHeight\r\n        // console.log(`已滚动的高度：${scrollTop}, 滚动条高度：${scrollHeight}, ${clientHeight}`)\r\n        // 向下滚动时判断判断是否正在向上滚动，是的话就清除定时器，停在当前位置\r\n        if (scrollHeight - scrollTop - clientHeight <= 0 && this.page.current < this.page.pages) {\r\n          this.loadPage(this.page.current + 1, this.page.size)\r\n        }\r\n      }\r\n    }\r\n  },\r\n  mounted () {\r\n    this.init()\r\n  }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n/* 容器宽度要占 100% */\r\n#rx-waterfalls-flow-container {\r\n  width: 100%;\r\n}\r\n</style>\r\n```\r\n\r\n### 使用\r\n\r\n使用起来就很简单了\r\n\r\n```vuejs\r\n<template>\r\n  <rx-waterfalls-flow :load=\"load\">\r\n    <!-- 这里 slotProps 绑定的便是子组件的数据，通过 slotProps 可以访问到子组件绑定到模板上的数据，当然，更简单的方法是使用 ES6 的解构 -->\r\n    <!-- 这里面的是你自定义每个元素显示的内容 -->\r\n    <template slot-scope=\"{item}\">\r\n      <!-- 在模板里面便可以使用集合中的元素 item 了 -->\r\n      <li\r\n        class=\"item-style\"\r\n        :key=\"item.id\"\r\n      >\r\n        {{item.text}}\r\n      </li>\r\n    </template>\r\n  </rx-waterfalls-flow>\r\n</template>\r\n\r\n<script>\r\n// 引入瀑布流组件\r\nimport RxWaterfallsFlow from '@/components/common/RxWaterfallsFlow'\r\nimport _ from 'lodash'\r\n\r\nexport default {\r\n  components: {\r\n    RxWaterfallsFlow\r\n  },\r\n  methods: {\r\n    // 使用 Promise 封装 setTimeout，模拟 ajax 的异步造成的延迟\r\n    await: ms => new Promise(resolve => setTimeout(resolve, ms)),\r\n    load: (page => {\r\n      // 该方法用于模拟 ajax 数据加载\r\n      return async function () {\r\n        await this.await(1000)\r\n        console.log(`加载了第 ${page.current} 页，共 ${page.pages} 页`)\r\n        // 使用 lodash 模拟数据\r\n        page.records = _.range(\r\n          (page.current - 1) * page.size + 1,\r\n          (++page.current - 1) * page.size + 1\r\n        )\r\n          .map(i => ({\r\n            id: i,\r\n            text: `第 ${i} 行内容`\r\n          }))\r\n        return page\r\n      }\r\n    })({\r\n      current: 1,\r\n      size: 10,\r\n      pages: 100,\r\n      total: this.current * this.pages,\r\n      records: []\r\n    })\r\n  }\r\n}\r\n</script>\r\n\r\n<style>\r\nli {\r\n  width: 500px;\r\n  height: 200px;\r\n  line-height: 200px;\r\n  background-color: aqua;\r\n  margin: 10px auto;\r\n}\r\n</style>\r\n```\r\n\r\n### 缺陷\r\n\r\n目前这个简单的瀑布流公用组件还有着相当多的缺陷，却是要等到后面再进行改进了呢\r\n\r\n- 没有 DOM 回收机制，会造成 DOM 树越来越大，网页就会变得越来越卡（Twitter 就是这样）\r\n- 没有一键回到顶部的功能，毕竟翻了太久的话回到顶部很麻烦呢\r\n- 自定义属性还是不够，例如一页的数据的条数，最大页数什么的\r\n","createdTime":1580652937881,"updatedTime":1609330919070,"resources":[],"tags":[{"id":"d86454b85c8f4c38aef6fa1575487e7f","title":"vue","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"c3a85bdc85f94927ab017df2c2f552b6","title":"点击按钮自动提交了 Form 表单","body":"## 场景\r\n\r\n在吾辈的写 HTML 时遇到了一个问题，一个普通的按钮，点击之后一旦在 `click` 事件中进行了 `return`，则立刻提交 `Form` 表单。\r\n\r\n像下面这段代码，不管是点击 _修改按钮_ 还是 _提交按钮_，`Form` 表单都会被提交（可以看到 `alert` 弹框）。\r\n\r\n```html\r\n<form action=\"\" id=\"form\" onsubmit=\"submitFn()\">\r\n  <input type=\"text\" name=\"username\" placeholder=\"文本输入框\" />\r\n  <button onclick=\"updateFn()\">修改</button> <button type=\"submit\">提交</button>\r\n</form>\r\n<script>\r\n  // 提交方法\r\n  function submitFn() {\r\n    alert('form 表单被提交了')\r\n  }\r\n\r\n  // 修改方法\r\n  function updateFn() {\r\n    const $username = document.querySelector('#form > input')\r\n    if (!$username.value) {\r\n      return false\r\n    }\r\n    $username.value = ''\r\n  }\r\n</script>\r\n```\r\n\r\n## 解决\r\n\r\n后来经过同事提醒，在 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button#%E5%B1%9E%E6%80%A7) 找到了关于 `button` 按钮的解释，在 _属性 => type_ 小结中，有下面这样一段内容\r\n\r\n> **type**\r\n> button 的类型。可选值：\r\n>\r\n> - `submit`: 此按钮将表单数据提交给服务器。如果未指定属性，或者属性动态更改为空值或无效值，则此值为默认值。\r\n> - `reset`: 此按钮重置所有组件为初始值。\r\n> - `button`: 此按钮没有默认行为。它可以有与元素事件相关的客户端脚本，当事件出现时可触发。\r\n> - `menu`: 此按钮打开一个由指定 `<menu>` 元素进行定义的弹出菜单。\r\n\r\n是的，当没有指定 `button` 元素的 `type` 属性时，浏览器将默认为 `submit` 而非 `button`，导致了在 `Form` 表单中容易出现奇怪的自动提交问题。\r\n\r\n修改后的代码\r\n\r\n```html\r\n<form action=\"\" id=\"form\" onsubmit=\"submitFn()\">\r\n  <input type=\"text\" name=\"username\" placeholder=\"文本输入框\" />\r\n  <!-- 实际上只是在这里加了一个 type=\"button\" 属性而已 -->\r\n  <button type=\"button\" onclick=\"updateFn()\">修改</button>\r\n  <button type=\"submit\">提交</button>\r\n</form>\r\n<script>\r\n  // 提交方法\r\n  function submitFn() {\r\n    alert('form 表单被提交了')\r\n  }\r\n\r\n  // 修改方法\r\n  function updateFn() {\r\n    const $username = document.querySelector('#form > input')\r\n    if (!$username.value) {\r\n      return false\r\n    }\r\n    $username.value = ''\r\n  }\r\n</script>\r\n```\r\n\r\n实际上吾辈也只添加了一个 `type` 属性，但却因为这个问题耗费许久，终归是基础知识的坑踩得不够多。不过幸好，吾辈可以记录下来，避免在同一个坑里跌倒两次！\r\n","createdTime":1580652937928,"updatedTime":1609305593609,"resources":[],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"bef08cec63cd48fca96fec5a049ab920","title":"Windows 下 MongoDB 便携版安装与初始化","body":"> [官网](https://www.mongodb.org/)\n\n## 下载\n\n> [下载位置](https://www.mongodb.org/dl/win32/x86_64-2008plus-ssl)\n\n选择一个便携版本下载（`.zip` 结尾），例如吾辈选择的就是 [win32/mongodb-win32-x86_64-2008plus-ssl-4.0.1.zip](http://downloads.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-4.0.1.zip)\n\n## 配置环境变量\n\n下载完成后解压到本地，将 `/bin/` 目录添加环境变量 `Path` 中以方便使用 `mongodb` 的命令。\n\n配置完成后验证一下\n\n```sh\nmongo -version\n```\n\n如果环境变量配置正确的话会有类似于下面的这种输出\n\n```sh\nMongoDB shell version v4.0.1\n```\n\n## 配置日志文件与数据目录\n\n吾辈的 `mongodb` 的安装目录是 `D:\\Program\\mongodb-win32-x86_64-2008plus-ssl-4.0.1`，所以就在安装目录下创建数据与日志目录了。\n\n目录列表如下：\n\n- mongodb_data\n  - log\n    - mongodb.log\n  - data\n\n指定日志文件的位置\n\n```sh\nmongod --logpath \"D:\\Program\\mongodb-win32-x86_64-2008plus-ssl-4.0.1\\mongodb_data\\log\\mongodb.log\"\n```\n\n指定数据存放的目录\n\n```sh\nmongod --dbpath \"D:\\Program\\mongodb-win32-x86_64-2008plus-ssl-4.0.1\\mongodb_data\\data\"\n```\n\n输出\n\n```sh\n2018-08-08T22:26:35.411+0800 I CONTROL  [main] Automatically disabling TLS 1.0, to force-enable TLS 1.0 specify --sslDisabledProtocols 'none'\n```\n\n然后，就停住了，其实这里并未发生错误，仔细看最后一行 `NETWORK [listener] connection accepted from 127.0.0.1:12598`，指的是正在监听连接 `127.0.0.1:12598`。所以这个时候在开一个新的 `cmd` 标签输入 `mongo` 命令就进入到 `mongo shell` 里面玩耍啦\n\n## 安装服务\n\n每次打开都要手动输入命令指定数据目录并启动 `mongod` 未免麻烦，我们可以将之添加到系统服务中，以后需要的时候只要启动服务就好了，也能设置自动启动什么的了呢\n\n```sh\nmongod --dbpath \"D:\\Program\\mongodb-win32-x86_64-2008plus-ssl-4.0.1\\mongodb_data\\data\" --logpath \"D:\\Program\\mongodb-win32-x86_64-2008plus-ssl-4.0.1\\mongodb_data\\log\\mongodb.log\" --auth --install --serviceName \"MongoDB\"\n```\n\n检查一下系统服务里面是否有 `MongoDB`，如果没有的话使用管理员权限打开 `cmd` 再执行一次上面的命令就好了，如果服务没有启动的话就启动它。\n\n这样便安装完成了，在命令行输入 `mongo` 就可以啦\n","createdTime":1587219249414,"updatedTime":1609305544293,"resources":[],"tags":[{"id":"1656d5691cc143f8a555566791858bac","title":"sql","parent_id":""},{"id":"4e00e5550c864473a3f16e4b0698f1c3","title":"windows","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"13df762003114c38a6fe53f03f8fa1ec","title":"MySQL 创建用户及授权","body":"## 用户\n\n### 创建用户\n\n使用 `root` 用户登录到 MySQL\n\n```sql\nCREATE USER rxliuli\n  IDENTIFIED BY '123456';\n```\n\n### 删除用户\n\n```sql\nDROP USER rxliuli;\n```\n\n## 授权\n\n### 添加授权\n\n命令格式：\n\n```sql\nGRANT privilegesCode ON dbName.tableName TO username@host IDENTIFIED BY \"password\";\n```\n\n例如下面就是为 rxliuli 用户赋予了 mytimelinedb 数据库所有表的所有操作权限\n\n```sql\nGRANT ALL PRIVILEGES ON mytimelinedb.* TO rxliuli\nIDENTIFIED BY '123456';\n```\n\n`privilegesCode` 代表权限，常用选项如下：\n\n- ALL PRIVILEGES ：所有权限\n- SELECT：读取权限\n- DELETE ：删除权限\n- UPDATE ：更新权限\n- CREATE ：创建权限\n- DROP ：删除数据库、数据表权限\n\n`dbName.tableName` 代表数据库.数据表，常用选项如下：\n\n- .：所有数据库的所有表的权限\n- dbName.\\*：指定数据库的所有表的权限\n- dbName.tableName：指定数据库下指定数据表的权限\n\n`username@host` 表示授予的用户及允许该用户登录的 IP 地址。host 常用选项是：\n\n- 不填：允许任意 IP 地址登录\n- localhost：只允许本地登录\n- %：只允许远程登录\n- 192.168.2.100：只允许指定 IP 地址登录\n\n`password` 代表该用户的登录密码  \n`FLUSH PRIVILEGES` 代表刷新权限\n\n### 查看授权\n\n```sql\nSHOW GRANTS FOR rxliuli;\n```\n\n### 删除授权\n\n```sql\nrevoke select on *.* from rxliuli;\n```\n\n### 刷新权限\n\n```sql\nflush privileges;\n```\n","createdTime":1587219249412,"updatedTime":1609305540539,"resources":[],"tags":[{"id":"1656d5691cc143f8a555566791858bac","title":"sql","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"84c23dd0034c4dfaa803e2845852ab09","title":"MySQL 使用 IF 判断是否执行 SQL","body":"语法  \n`if(condition, value_if_true, value_if_false)`\n\n上面的三个参数的意思是，如果 `condition`（表达式）为 `true`，则执行表达式 `value_if_true`，否则执行表达式 `value_if_false`。\n\n例如有下面这个 `User` 用户表：\n\n```sql\nCREATE TABLE User (\n  name VARCHAR(10) NOT NULL\n  COMMENT '姓名',\n  age  INT         NOT NULL\n  COMMENT '年龄',\n  sex  BOOLEAN     NOT NULL\n  COMMENT '性别'\n)\n  COMMENT '用户表'\n```\n\n一个简单的根据属性查询列表的 SQL 语句大致如下：\n\n```sql\nSELECT *\nFROM User\nWHERE\n  name = ?\n  AND age = ?\n  AND sex = ?;\n```\n\n那么，现在问题来了。我们有一个需求就是如果性别为空，就查询全部的性别，否则就根据性别进行查询。这时就可以使用 if 来进行判断了（吾辈的某位同事就是碰到了这个坑。。。），如果 `condition`(`sex = null`) 为 `true`，就直接执行表达式 `value_if_true`(`true`)，否则执行 `value_if_false`(`sex = ?`)。\n\n```sql\nSELECT *\nFROM User\nWHERE\n  name = ?\n  AND age = ?\n  AND if(sex = NULL, TRUE, sex = ?);\n```\n\n> 注：这里不要使用 `1 = 1` 而直接使用 `true` 就好了。  \n> PS：这难道就是所谓的习惯成自然么。。。  \n> 附：诚然，在使用了 ORM 框架(例如 Mybatis 后)，基本上都可以对传入的参数进行判空处理，然而有时候会出现一种情况：  \n> 某个属性经由其他属性统合计算而得到，并非是实体（或是其他的什么）传入进来的参数，那便是只能使用 SQL 的原生语法了呢\n","createdTime":1587219249412,"updatedTime":1609305537896,"resources":[],"tags":[{"id":"1656d5691cc143f8a555566791858bac","title":"sql","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"a24c7e06b014490b9f8c813cfabf0e20","title":"MySQL 字符串数字比较大小的问题以及解决方案","body":"为什么要写这篇文章呢？因为吾辈碰到了 MySQL 中字符串数字比较起来的坑。\n\n> 字符串数字：明明是数字却在数据库中使用 varchar 等类型进行存储的数字。\n\n例如以下的表结构：\n\n```sql\nCREATE TABLE test_table (\n  id      BIGINT       NOT NULL\n  COMMENT 'id',\n  int_str VARCHAR(200) NOT NULL\n  COMMENT '使用 varchar 保存数字的列'\n)\n  COMMENT '测试用的数据表';\n```\n\n当吾辈想要查询 `big_int_column` 大于某个值的数据时，最初是这样写的：\n\n```sql\nSELECT *\nFROM test_table\nWHERE int_str > ?;\n```\n\n但后来发现一个问题。。。\n\n其实很简单，因为字符串的比较规则和数字并不一样，虽然很多时候看起来好像没什么不同。\n\n例如下面的 SQL 语句：\n\n```sql\nSELECT 2 > 12; #结果为 0(false)\nSELECT '2' > '12'; #结果为 1(true)\n```\n\n只是类型变化了，但结果却截然相反，因为字符串是按照字符依次进行对比，而数字则是按照大小直接比较。\n\n> 按照字母依次进行对比的意思是：  \n> 例如上面的 '2' 和 '12'，首先会比较字符 '2' 和 '1' 的大小，如果不是相等，就立刻得出结果，否则继续比较下一位，直到得到结果或没有可以继续比较的情况为止，所以就会得到看似荒谬的 1(true)。\n\n所以后来去稍微查询了一下，发现了 MySQL 中的两个函数：\n\n- cast()\n  标准语法：\n\n  ```sql\n  cast(value as type)\n  ```\n\n  或者（不是重点）\n\n  ```sql\n  cast(value AS CHAR CHARACTER SET encoding)\n  ```\n\n  使用示例：\n\n  ```sql\n  # 转换为整数(值区间 [-9223372036854775808 ~ 9223372036854775807])\n  cast('12' AS SIGNED)\n  # 或者转换为无符号整数(值区间 [0 ~ 18446744073709551615])\n  cast('12' AS UNSIGNED)\n  ```\n\n- convert()\n\n  标准语法：\n\n  ```sql\n  convert(value, type)\n  ```\n\n  或者（不是重点）\n\n  ```sql\n  convert(value using charset)\n  ```\n\n  使用示例：\n\n  ```sql\n  # 转换为整数\n  convert('12', SIGNED)\n  # 或者转换为无符号整数\n  convert('12', UNSIGNED)\n  ```\n\n所以吾辈将查询的 SQL 语句修改成如下样子：\n\n```sql\nSELECT *\nFROM test_table\nWHERE int_str > cast(? AS UNSIGNED);\n```\n\n算是解决了一些问题，然而如果 `int_str` 的值大于 `UNSIGNED` 类型的最大值又会发生问题。。。\n\n然后从网络上看到了一种推荐的 SQL 的写法：\n\n```sql\nSELECT '12' + 0;\n```\n\n但经过了测试，甚至比上面的 `cast()` 和 `convert()` 表现更糟。\n\n例如下面的 SQL：\n\n```sql\nSELECT '9223372036854775807' + 0; #结果是：9223372036854776000\n```\n\n所以说，还是直接直接用数字存储数字最好啦！（＿´ω ｀）\n","createdTime":1587219249412,"updatedTime":1609305535220,"resources":[],"tags":[{"id":"1656d5691cc143f8a555566791858bac","title":"sql","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"b0c1f108a8bf450e8fd05615a2e8b8e2","title":"MySQL 无法插入中文数据","body":"刚刚在 Linux Centos 装完 MySQL 后，想试一下是否能正常使用，但在插入中文数据时发生了下面的这个错误。\n\n```sql\n[HY000][1366] Incorrect string value: '\\xE7\\x90\\x89\\xE7\\x92\\x83' for column 'name' at row 1\n```\n\n感觉是 MySQL 编码问题，查看一下编码格式\n\n```sql\nshow variables like '%char%';\n```\n\n结果\n\n| Variable_name                        | Value                      |\n| ------------------------------------ | -------------------------- |\n| character_set_client                 | utf8                       |\n| character_set_connection             | utf8                       |\n| character_set_database               | latin1                     |\n| character_set_filesystem             | latin1                     |\n| character_set_results                | utf8                       |\n| character_set_server                 | latin1                     |\n| character_set_system                 | utf8                       |\n| character_sets_dir                   | /usr/share/mysql/charsets/ |\n| validate_password_special_char_count | 1                          |\n\n果然有几个编码是不支持中文的，所以将 `latin1` 编码修改为 `utf8mb4`/`utf8` 就好啦\n\n> 有关编码格式请参考：[latin1](https://zh.wikipedia.org/wiki/ISO/IEC_8859-1), [utf8](https://zh.wikipedia.org/wiki/UTF-8), `utf8mb4` 与 `utf8` 区别可以参考 <https://my.oschina.net/xsh1208/blog/1052781>\n\n修改它们\n\n```sql\nset character_set_client = utf8mb4;\nset character_set_connection = utf8mb4;\nset character_set_database = utf8mb4;\nset character_set_filesystem = utf8mb4;\nset character_set_results = utf8mb4;\nset character_set_server = utf8mb4;\n```\n\n然后再次尝试插入中文数据，好像还是不行呀，怎么办呢？实际上上面修改的是数据库默认的编码格式，对于已经存在的表和列并未生效\n\n查看一下数据表编码\n\n```sql\nshow create table user;\n```\n\n| Table | Crate Table                                                                                                                                                                                                                                    |\n| ----- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| user  | `CREATE TABLE user ( id bigint(20) NOT NULL COMMENT '编号', name varchar(20) NOT NULL COMMENT '名字', sex tinyint(1) DEFAULT NULL COMMENT '性别', age int(11) DEFAULT NULL COMMENT '年龄' ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户'` |\n\n查看全部列编码\n\n```sql\nshow full columns from user;\n```\n\n| Field | Type        | Collation       | Null | Key | Default | Extra Privileges                | Comment |\n| ----- | ----------- | --------------- | ---- | --- | ------- | ------------------------------- | ------- |\n| id    | bigint(20)  | null            | NO   | \"\"  | \"\"      | select,insert,update,references | 编号    |\n| name  | varchar(20) | utf8_general_ci | NO   | \"\"  | \"\"      | select,insert,update,references | 名字    |\n| sex   | tinyint(1)  | null            | YES  | \"\"  | \"\"      | select,insert,update,references | 性别    |\n| age   | int(11)     | null            | YES  | \"\"  | \"\"      | select,insert,update,references | 年龄    |\n\n现在有两个选择\n\n- 删除数据库重新建一个，数据库的编码格式就默认是 utf8mb4 了\n- 手动修改数据库，数据表，字段的编码方式\n\n1. 删除重建数据库的话只需要将数据库导出 sql 脚本，然后重新执行即可（如果存在很多数据/数据库正在使用则此方法不适用）\n2. 手动修改编码\n   1. 修改数据库编码\n      ```sql\n      alter database <db_name> character set utf8mb4;\n      ```\n   2. 修改数据表编码\n      ```sql\n      alter table <table_name> character set utf8mb4;\n      ```\n   3. 修改字段编码\n      ```sql\n      ALTER TABLE <table_name> MODIFY COLUMN <field_name> <field_type> CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;\n      ```\n\n那么，关于 MySQL 不能插入中文数据的问题就到这里啦\n","createdTime":1587219249412,"updatedTime":1609305532461,"resources":[],"tags":[{"id":"1656d5691cc143f8a555566791858bac","title":"sql","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"1e9c346748e14f35a390b49c5d520754","title":"MySQL 获取随机条数据","body":"## 场景\n\n有一个需要从数据库随机获取指定数量的数据的需求，然而这个问题却是意外的挺麻烦。\n\n假设有一个数据表\n\n```sql\ncreate table topic (\n  id      int primary key not null\n  comment '编号',\n  content varchar(20)     not null\n  comment '内容'\n)\n  comment '主题表';\n```\n\n> 这里的 `topic` 表有两个关键性的特点\n>\n> - 主键可以进行比较（`int`）\n> - 主键整体存在趋势（自增/自减）\n\n## 解决方案 1：直接使用 `order by rand()`\n\n直接使用 `order by rand()` 就可以获取到随机的数据了，而且能够获取到全部的数据（顺序仍然是随机的）。\n\n1. 按照 `rand()` 产生的结果\n   > 这一步相当于为每条数据加上一列由 `rand()` 函数产生的数据，然后对这一列进行排序\n2. 限制查询条数\n\n```sql\nselect *\nfrom topic\norder by rand()\nlimit 50000;\n```\n\n但缺点很明显，速度是个问题，因为 rand() 的数据没有索引，所以会造成排序速度极慢。\n\n在 10w 条数据中随机获取 5w 条数据，花费时常 **6 s 378 ms**，这个时间真的太长了点。\n\n其实 `order by rand()` 看起来很奇怪，实际上等效于：\n\n```sql\nselect *\nfrom (\n       select\n         topic.*,\n         rand() as order_column\n       from topic\n     ) as temp\norder by order_column\nlimit 50000;\n```\n\n## 解决方案 2：使用 `where subquery` 取中间的随机值\n\n因为 `order by rand()` 没有索引导致的排序太耗时，我们可以尝试绕过这个问题。\n\n下面的这种解决方案便是如此\n\n1. 取最小值和最大值之间的随机值\n2. 判断 id 是否大于（或者小于）这个随机值\n3. 限制查询条数\n\n```sql\nselect *\nfrom topic\nwhere id >= ((select max(id)\n              from topic)\n             - (select min(id)\n                from topic))\n            * rand()\n            + (select min(id)\n               from topic)\nlimit 50000;\n```\n\n这种方法查询速度虽然极快（150 ms），但却会受到数据分布密度的影响。如果数据不是平均的，那么查询到的总数据条数就会受限。\n\n那么，下面来说该方法的缺陷\n\n- 获取到的数据受分布密度影响\n\n  例如数据分布呈以下情况\n\n  `1,100002,100003,100004...199999,200000`\n\n  那么使用上述代码就只能获取到很少一部分数据（大约在 2.5w 条左右）。然而如果将符号稍微下改一下，将 `>=` 修改为 `<=`，那么能够获取到的平均数量将大大增加（7.5w 条左右）。\n\n  ```sql\n  select *\n  from topic\n  # 注意：这里的符号修改了\n  where id >= ((select max(id)\n                from topic)\n              - (select min(id)\n                  from topic))\n              * rand()\n              + (select min(id)\n                from topic)\n  limit 50000;\n  ```\n\n- 每一条数据获取到的概率不是完全相同的\n  虽然获取到的全部数据是随机的，但每一个的概率却并不相同。例如在 `<=` 时会出现永远都为第一条的现象，究其原因就是因为 **第一条** 的概率实在是太大了，因为查询数据表时数据的检索规则是从第一条开始的呢！即便修改成 `>=`，所得到的第一条数据也普遍偏小。\n  使用 `>=` 的结果\n  - 数据越是在前面，那么获取到的概率就越低\n  - 但即便是很低概率，在最前面总有机会，所以第一条一般偏小\n  - 数据密度前面偏大时，获取到的数量会非常小\n\n密度越是趋于平均，获取到的最大随机数据条数的平均值愈接近 `1/2`，否则则会愈加偏离（不一定偏大还是偏小）。\n\n## 解决方案 3：使用临时表 `temporary table`\n\n解决方案 2 着眼于避免使用没有索引的 `rand()` 进行排序，但这里思考另一个解决方案，使用加了索引之后的 `rand()` 进行排序。创建临时表，仅包含主键 `id` 和需要进行排序的索引列 `randomId`，然后排序完成过后获取到乱序数据。\n\n```sql\ndrop temporary table if exists temp_topic;\ncreate temporary table temp_topic (\n  id       bigint primary key not null,\n  randomId double             not null,\n  index (randomId)\n)\n  as\n    select\n      id,\n      rand() as randomId\n    from topic;\nselect t.*\nfrom topic t\n  join (\n         select id\n         from (\n                select id\n                from temp_topic\n                order by randomId\n              ) as temp\n         limit 50000\n       ) as temp\n    on t.id = temp.id;\n```\n\n这种方法的查询速度不算很快（878 ms，相比于第二种），而且仍然是与数据量呈正相关的（因为要复制数据）。但和第一种，也是真正的随机获取。\n\n## 解决方案 4：使用 `join order by rand()`\n\n吾辈在 [StackOverflow](https://stackoverflow.com) 上面看到了一个 [最优解 by 2016](https://stackoverflow.com/a/36013954/8409380)，一切表现的都很好，速度不算慢（261 ms），也可以获取到全部数据，也是真正的随机获取。\n\n```sql\nselect g.*\nfrom\n  topic g\n  join\n  (select id\n   from\n     topic\n   where\n     rand() < (select ((50000 / count(0)) * 10)\n               from\n                 topic)\n   order by rand()\n   limit 50000) as z on z.id = g.id;\n```\n\n这里的 `where rand()` 是想要在获取的数据与总数据量差距过大（10 倍以上）时过滤数据，提高排序效率。\n\n吾辈这里不清楚上面发生了什么，感觉 `rand()` 只要在 `join` 里面之后的排序就会变得很快！  \n事实上，只要使用 `join` 内连接之后，就算是 `order by rand()` 的效率也很高，甚至在获取少量数据时比上面使用 `where rand` 过滤数据后再排序的的速度还要快\n\n```sql\nSELECT t.*\nFROM topic t\n  JOIN\n  (SELECT id\n   FROM `topic`\n   ORDER BY RAND()\n   LIMIT 50000) AS z ON z.id = t.id;\n```\n\n> 注：在获取的数据量很大时，使用上面那种 `where` 过滤一次的效率上会更有优势一点！\n\n## 总结\n\n> 这里有一篇不错的英文文章对随机获取数据进行了分析：<http://jan.kneschke.de/projects/mysql/order-by-rand/>，也有人在 StackOverflow 上进行了讨论 <https://stackoverflow.com/questions/1823306/>\n\n| 不同点                 | `order by rand()` | `where subquery` | `temporary table` | `join order by rand()` |\n| ---------------------- | ----------------- | ---------------- | ----------------- | ---------------------- |\n| 可以随机获取全部       | 可以              | 几乎不可能       | 可以              | 可以                   |\n| 速度                   | 慢                | 极快             | 较快              | 极快                   |\n| 需要可比较的主键类型   | 否                | 是               | 否                | 否                     |\n| 受数据分布密度影响     | 否                | 是               | 否                | 否                     |\n| 速度受表数据复杂度影响 | 很大              | 极小             | 较小              | 极小                   |\n\n那么，看完上面的不同点对比，我们也可以得出它们的使用场景了\n\n- 强烈推荐首选 `join order by rand()` 作为随机获取数据的解决方案\n- 唯一不推荐的就是 `order by rand()`，这是新手才会写出来 sql。当然，如果你的数据量很小（1000 条以下）时，直接使用 `order by rand()` 以现代机器的性能 sql 也不会很慢呢\n\n> 注：如果仅仅只是需要打乱数据顺序的话还是更推荐将数据读取到内存中在进行操作更好！\n","createdTime":1587219249412,"updatedTime":1609305529641,"resources":[],"tags":[{"id":"1656d5691cc143f8a555566791858bac","title":"sql","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"5c0cf314a3974a9996241b9cc5296c17","title":"MySQL 行列转换","body":"## 场景\n\n面试的时候遇到的一个问题，之前没有碰到过这种场景，所以却是无论如何都回答不了呢！然而本着遇到的坑跌倒过一次就够了的理念，回来时吾辈稍微 Google 了一下这个问题，结果便在此记录一下好啦\n\n## 行转列\n\n指的是将数据行根据状态区分为不同的列，主要应用场景应该是统计报表吧\n\n例如下面这个 `exam` 表\n\n```sql\ndrop table if exists exam;\ncreate table exam (\n  name    varchar(20) not null\n  comment '姓名',\n  subject varchar(20) not null\n  comment '考试科目',\n  score   int         null\n  comment '考试成绩'\n)\n  comment '考试记录';\n\ninsert into exam values ('琉璃', '语文', 90);\ninsert into exam values ('琉璃', '英语', 85);\ninsert into exam values ('楚轩', '数学', 100);\ninsert into exam values ('楚轩', '物理', 100);\ninsert into exam values ('张三', '化学', 40);\ninsert into exam values ('李四', '生物', 100);\n```\n\n直接查询会是下面这个样子\n\n| 姓名 | 科目 | 分数 |\n| ---- | ---- | ---- |\n| 琉璃 | 语文 | 90   |\n| 琉璃 | 英语 | 85   |\n| 楚轩 | 数学 | 100  |\n| 楚轩 | 物理 | 100  |\n| 张三 | 化学 | 40   |\n| 李四 | 生物 | 100  |\n\n然而需要的结果却是\n\n| 姓名 | 语文 | 数学 | 英语 | 物理 | 化学 | 生物 |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 张三 | 0    | 0    | 0    | 0    | 40   | 0    |\n| 李四 | 0    | 0    | 0    | 100  | 0    | 0    |\n| 楚轩 | 0    | 100  | 0    | 100  | 0    | 0    |\n| 琉璃 | 90   | 0    | 85   | 0    | 0    | 0    |\n\n大致的实现思路是判断 `subject` 的值，如果等于 `转换列` 的值，就将之设置为该 `转换列` 的值。（此处的 `转换列` 指的是根据 `subject` 的值查询的新列）\n\n目前网络上能找到的方法有下面两种\n\n### 使用 if 实现行转列\n\n```sql\nselect\n  name                              as '姓名',\n  max(if(subject = '语文', score, 0)) as '语文',\n  max(if(subject = '数学', score, 0)) as '数学',\n  max(if(subject = '英语', score, 0)) as '英语',\n  max(if(subject = '物理', score, 0)) as '物理',\n  max(if(subject = '化学', score, 0)) as '化学',\n  max(if(subject = '生物', score, 0)) as '生物'\nfrom exam\ngroup by name;\n```\n\n优点：简单方便，即便是将几列合并也可以简单做到。例如我们想要统计主科/副科的总分\n\n```sql\nselect\n  name                                                                  as '姓名',\n  sum(if(subject = '语文' or subject = '数学' or subject = '英语', score, 0)) as '主科',\n  sum(if(subject = '物理' or subject = '化学' or subject = '生物', score, 0)) as '副科'\nfrom exam\ngroup by name;\n```\n\n查询结果\n\n| 姓名 | 主科 | 副科 |\n| ---- | ---- | ---- |\n| 张三 | 0    | 40   |\n| 李四 | 0    | 100  |\n| 楚轩 | 100  | 100  |\n| 琉璃 | 250  | 0    |\n\n或者简单的实现小计\n\n```sql\nselect\n  -- 这里的 ifnull 其实是为了让最后一行的统计不为 null\n  ifnull(name, 'total')             as '姓名',\n  max(if(subject = '语文', score, 0)) as '语文',\n  max(if(subject = '数学', score, 0)) as '数学',\n  max(if(subject = '英语', score, 0)) as '英语',\n  max(if(subject = '物理', score, 0)) as '物理',\n  max(if(subject = '化学', score, 0)) as '化学',\n  max(if(subject = '生物', score, 0)) as '生物',\n  -- 统计每一行数据\n  sum(score)                        as total\nfrom exam\n-- 按照 name 进行分组并进行小计\ngroup by name with rollup;\n```\n\n查询结果\n\n| 姓名  | 语文 | 数学 | 英语 | 物理 | 化学 | 生物 | total |\n| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ----- |\n| 张三  | 0    | 0    | 0    | 0    | 40   | 0    | 40    |\n| 李四  | 0    | 0    | 0    | 0    | 0    | 100  | 100   |\n| 楚轩  | 0    | 100  | 0    | 100  | 0    | 0    | 200   |\n| 琉璃  | 90   | 0    | 85   | 0    | 0    | 0    | 250   |\n| total | 90   | 100  | 85   | 100  | 40   | 100  | 590   |\n\n### 使用 case when 实现行转列\n\n```sql\nselect\n  name as '姓名',\n  max(case subject when '语文' then score else 0 end) as '语文',\n  max(case subject when '数学' then score else 0 end) as '数学',\n  max(case subject when '英语' then score else 0 end) as '英语',\n  max(case subject when '物理' then score else 0 end) as '物理',\n  max(case subject when '化学' then score else 0 end) as '化学',\n  max(case subject when '生物' then score else 0 end) as '生物'\nfrom exam\ngroup by name;\n```\n\n优点：相比于 `if` 更加灵活，可以对每个 `转换列` 的值进行单独的处理。例如我们想要统计主科/副科的总分，并设置计算语文/数学时增加一半，而英语的分数则忽略不计\n\n> 感觉这个优势相当的小，当然如果用到的话却是无需多言的\n\n```sql\nselect\n  name     as '姓名',\n  sum(case subject\n      when '语文'\n        then score * 1.5\n      when '数学'\n        then score * 1.5\n      when '英语'\n        then 0\n      else 0\n      end) as '主科',\n  sum(case subject\n      when '物理'\n        then score\n      when '化学'\n        then score\n      when '生物'\n        then score\n      else 0\n      end) as '副科'\nfrom exam\ngroup by name;\n```\n\n查询结果\n\n| 姓名 | 主科  | 副科 |\n| ---- | ----- | ---- |\n| 张三 | 0.0   | 40   |\n| 李四 | 0.0   | 100  |\n| 楚轩 | 150.0 | 100  |\n| 琉璃 | 247.5 | 0    |\n\n### 使用子查询实现行转列\n\n```sql\nselect\n  name,\n  if(language != 'null', language, 0)       as '语文',\n  if(mathematics != 'null', mathematics, 0) as '数学',\n  if(english != 'null', english, 0)         as '英语',\n  if(physical != 'null', physical, 0)       as '物理',\n  if(chemistry != 'null', chemistry, 0)     as '化学',\n  if(biological != 'null', biological, 0)   as '生物'\nfrom (\n       select\n         e.name,\n         (select e1.score from exam e1 where subject = '语文' and e1.name = e.name limit 1) as language,\n         (select e1.score from exam e1 where subject = '数学' and e1.name = e.name limit 1) as mathematics,\n         (select e1.score from exam e1 where subject = '英语' and e1.name = e.name limit 1) as english,\n         (select e1.score from exam e1 where subject = '物理' and e1.name = e.name limit 1) as physical,\n         (select e1.score from exam e1 where subject = '化学' and e1.name = e.name limit 1) as chemistry,\n         (select e1.score from exam e1 where subject = '生物' and e1.name = e.name limit 1) as biological\n       from exam e\n       group by name\n     ) temp;\n```\n\n优点：使用起来最灵活，但代码量也是最大的。可以对每一个列的多条/单条数据进行单独的处理，不需要必须使用统计函数（`sum/avg/max/min/count`）。例如上面就是如果查到了多条数据就直接取第一条，当然也可以对第一条数据做后续处理。\n\n### 使用 group_concat 简单的行连接\n\n并非是真正的行转列，实际上只是把不同字段的数据 _连接_ 了起来\n\n```sql\nselect\n  name                              as '姓名',\n  group_concat(subject, ' ', score) as '成绩单'\nfrom exam\ngroup by name;\n```\n\n查询结果\n\n| 姓名 | 成绩单                  |\n| ---- | ----------------------- |\n| 张三 | 化学 40                 |\n| 李四 | 生物 100                |\n| 楚轩 | 数学 100,物理 100       |\n| 琉璃 | 语文 75,语文 90,英语 85 |\n\n## 列转行\n\n将类似的列按照某种规则变成一列，并生成等同倍数的行。\n\n我们需要将上面行转列得到的表转换回来，例如下面的 `exam_score` 表\n\n```sql\ncreate table exam_score (\n  name        varchar(20) not null\n  comment '姓名',\n  language    int         not null\n  comment '语文',\n  mathematics int         not null\n  comment '数学',\n  english     int         not null\n  comment '英语',\n  physical    int         not null\n  comment '物理',\n  chemistry   int         not null\n  comment '化学',\n  biological  int         not null\n  comment '生物'\n)\n  comment '考试成绩';\ninsert into exam_score (name, language, mathematics, english, physical, chemistry, biological)\nvalues ('张三', 0, 0, 0, 0, 40, 0);\ninsert into exam_score (name, language, mathematics, english, physical, chemistry, biological)\nvalues ('李四', 0, 0, 0, 0, 0, 100);\ninsert into exam_score (name, language, mathematics, english, physical, chemistry, biological)\nvalues ('楚轩', 0, 100, 0, 100, 0, 0);\ninsert into exam_score (name, language, mathematics, english, physical, chemistry, biological)\nvalues ('琉璃', 90, 0, 85, 0, 0, 0);\n```\n\n直接查询结果是\n\n| name | language | mathematics | english | physical | chemistry | biological |\n| ---- | -------- | ----------- | ------- | -------- | --------- | ---------- |\n| 张三 | 0        | 0           | 0       | 0        | 40        | 0          |\n| 李四 | 0        | 0           | 0       | 0        | 0         | 100        |\n| 楚轩 | 0        | 100         | 0       | 100      | 0         | 0          |\n| 琉璃 | 90       | 0           | 85      | 0        | 0         | 0          |\n\n然而我们需要得到\n\n| 姓名 | 科目 | 分数 |\n| ---- | ---- | ---- |\n| 琉璃 | 语文 | 90   |\n| 琉璃 | 英语 | 85   |\n| 楚轩 | 数学 | 100  |\n| 楚轩 | 物理 | 100  |\n| 张三 | 化学 | 40   |\n| 李四 | 生物 | 100  |\n\n### 使用 union all 联合查询\n\n```sql\nselect\n  name,\n  '语文'     as 'subject',\n  language as score\nfrom exam_score\nwhere language != 0\nunion all\nselect\n  name,\n  '数学'        as 'subject',\n  mathematics as score\nfrom exam_score\nwhere mathematics != 0\nunion all\nselect\n  name,\n  '英语'    as 'subject',\n  english as score\nfrom exam_score\nwhere english != 0\nunion all\nselect\n  name,\n  '物理'     as 'subject',\n  physical as score\nfrom exam_score\nwhere physical != 0\nunion all\nselect\n  name,\n  '化学'      as 'subject',\n  chemistry as score\nfrom exam_score\nwhere chemistry != 0\nunion all\nselect\n  name,\n  '生物'       as 'subject',\n  biological as score\nfrom exam_score\nwhere biological != 0;\n```\n\n唔，好长的 sql 语句，这还只是 6 个 `转换列`，如果有更多的话恐怕。。。\n\n## 总结\n\n### sql 行转列的问题\n\nsql 的技巧确实很多，然而相比之下 sql 只是一门 [结构化查询语言](https://zh.wikipedia.org/wiki/SQL)，并不算是真正的编程语言呢！行转列/列转行这些需求放到真正的编程语言中是很容易处理的，下面演示使用 js 的实现\n\n### 使用 JavaScript 实现行转列\n\n假设有下面这样一个 json 数据\n\n```json\n[\n  {\n    \"name\": \"琉璃\",\n    \"subject\": \"语文\",\n    \"score\": 75\n  },\n  {\n    \"name\": \"琉璃\",\n    \"subject\": \"语文\",\n    \"score\": 90\n  },\n  {\n    \"name\": \"琉璃\",\n    \"subject\": \"英语\",\n    \"score\": 85\n  },\n  {\n    \"name\": \"楚轩\",\n    \"subject\": \"数学\",\n    \"score\": 100\n  },\n  {\n    \"name\": \"楚轩\",\n    \"subject\": \"物理\",\n    \"score\": 100\n  },\n  {\n    \"name\": \"张三\",\n    \"subject\": \"化学\",\n    \"score\": 40\n  },\n  {\n    \"name\": \"李四\",\n    \"subject\": \"生物\",\n    \"score\": 100\n  }\n]\n```\n\n转换方法\n\n```js\n/**\n * 行转列\n * @param {Array} arr 需要进行行转列的数组\n * @returns {Array} 行转列得到的数组\n */\nfunction rowToCol(arr) {\n  /**\n   * js 数组按照某个条件进行分组\n   * 注：分组完成后会得到一个二维数组，并且顺序会被打乱\n   * 时间复杂度为 2On\n   * @param {Function} {fn} 元素分组的方法，默认使用 {@link JSON.stringify()}\n   * @returns {Array} 新的数组\n   */\n  Array.prototype.groupBy = function (fn = (item) => JSON.stringify(item)) {\n    // 将元素按照分组条件进行分组得到一个 条件 -> 数组 的对象\n    const obj = {}\n    this.forEach((item) => {\n      const name = fn(item)\n      // 如果已经有这个键了就直接追加, 否则先将之赋值为 [] 再追加元素\n      ;(obj[name] || (obj[name] = [])).push(item)\n    })\n    // 将对象转换为数组\n    return Object.keys(obj).map((key) => obj[key])\n  }\n\n  /**\n   * js 的数组去重方法\n   * @param {Function} {fn} 唯一标识元素的方法，默认使用 {@link JSON.stringify()}\n   * @returns {Array} 进行去重操作之后得到的新的数组 (原数组并未改变)\n   */\n  Array.prototype.uniqueBy = function (fn = (item) => JSON.stringify(item)) {\n    const obj = {}\n    return this.filter(function (item) {\n      return obj.hasOwnProperty(fn(item)) ? false : (obj[fn(item)] = true)\n    })\n  }\n\n  /**\n   * 获取所有的科目 -> 分数映射表\n   * 看起来函数有点奇怪，但实际上只是一个闭包函数而已\n   * @returns {Object} 所有的科目 -> 分数映射表的拷贝\n   */\n  const subjectMap = ((obj) => () => Object.assign({}, obj))(\n    arr\n      .map((row) => row.subject)\n      .uniqueBy()\n      .reduce((res, subject) => {\n        res[subject] = 0\n        return res\n      }, {}),\n  )\n  return arr\n    .groupBy((row) => row.name)\n    .map((arr) =>\n      arr\n        .uniqueBy((row) => row.subject)\n        .reduce((res, temp) => {\n          res = Object.assign(subjectMap(), res)\n          res.name = temp.name\n          res[temp.subject] = temp.score\n          return res\n        }, {}),\n    )\n}\n```\n\n看起来好像更长了？但实际上 `groupBy()/uniqueBy()` 都是通用的函数，所以实际代码应该不超过 20 行。转换后的数据如下\n\n```json\n[\n  {\n    \"语文\": 75,\n    \"英语\": 85,\n    \"数学\": 0,\n    \"物理\": 0,\n    \"化学\": 0,\n    \"生物\": 0,\n    \"name\": \"琉璃\"\n  },\n  {\n    \"语文\": 0,\n    \"英语\": 0,\n    \"数学\": 100,\n    \"物理\": 100,\n    \"化学\": 0,\n    \"生物\": 0,\n    \"name\": \"楚轩\"\n  },\n  {\n    \"语文\": 0,\n    \"英语\": 0,\n    \"数学\": 0,\n    \"物理\": 0,\n    \"化学\": 40,\n    \"生物\": 0,\n    \"name\": \"张三\"\n  },\n  {\n    \"语文\": 0,\n    \"英语\": 0,\n    \"数学\": 0,\n    \"物理\": 0,\n    \"化学\": 0,\n    \"生物\": 100,\n    \"name\": \"李四\"\n  }\n]\n```\n\n### 使用 JavaScript 实现列转行\n\n那么，如何转换回来呢？转换回来的话却是简单许多了呢\n\n```js\n/**\n * 列转行\n * @param {Array} arr 需要进行列转行的数组\n * @returns {Array} 列转行得到的数组\n */\nfunction colToRow(arr) {\n  // 定义好需要进行合并列的数组\n  var cols = ['语文', '英语', '数学', '物理', '化学', '生物']\n  return arr.flatMap((row) =>\n    cols\n      .map((subject) => ({\n        name: row.name,\n        subject: subject,\n        score: row[subject],\n      }))\n      .filter((newRow) => newRow.score != 0),\n  )\n}\n```\n\n---\n\n那么，关于 MySQL 行列转换的问题就到这里啦\n","createdTime":1587219249413,"updatedTime":1609305526671,"resources":[],"tags":[{"id":"1656d5691cc143f8a555566791858bac","title":"sql","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"040c6e4f06dc481f9ea294bbc6f6c53a","title":"MySQL 递归查询","body":"## 场景\n\n最近需要将根据父级分类查询出所有的自己分类，所以却是需要使用 MySQL 实现递归查询的功能。\n\n对于以下数据表（此处简化了）\n\n| id  | parentId | name       |\n| --- | -------- | ---------- |\n| 1   | 0        | 数学       |\n| 2   | 1        | 高等数学   |\n| 3   | 1        | 线性代数   |\n| 4   | 0        | 英语       |\n| 5   | 4        | 即时翻译   |\n| 6   | 4        | 口语阅读   |\n| 7   | 0        | 物理       |\n| 8   | 7        | 高能物理   |\n| 9   | 8        | 无限能量   |\n| 10  | 9        | 迪克拉之海 |\n\nSQL 结构/数据\n\n```sql\ncreate table question_type (\n  id       bigint primary key  not null\n  comment '问题编号',\n  parentId bigint              not null\n  comment '问题父分类编号，根节点为 0',\n  name     varchar(20)         not null\n  comment '编号名称'\n)\n  comment '问题编号';\ninsert into question_type values (1, 0, '数学');\ninsert into question_type values (2, 1, '高等数学');\ninsert into question_type values (3, 1, '线性代数');\ninsert into question_type values (4, 0, '英语');\ninsert into question_type values (5, 4, '即时翻译');\ninsert into question_type values (6, 4, '口语阅读');\ninsert into question_type values (7, 0, '物理');\ninsert into question_type values (8, 7, '高能物理');\ninsert into question_type values (9, 8, '无限能量');\ninsert into question_type values (10, 9, '迪克拉之海');\n```\n\n吾辈只有一个 id，想要查询出所有的子级\n\n## 解决\n\n这个问题在网络上流传着各种各样的解决方案\n\n- 使用额外的字段存储节点全路径\n- 在应用层递归查询完成\n- 使用 Mybatis collection 标签\n- 使用存储过程\n- 使用 SQL 视图\n- 使用单条 SQL 实现\n\n吾辈目前只尝试了其中三种\n\n## 使用额外的字段存储节点全路径\n\n有人提出使用一个额外的字段记录当前节点的全路径，每一级使用 `,` 进行分割，所以吾辈的数据表变成了下面这样\n\n| id  | parentId | name       | path       |\n| --- | -------- | ---------- | ---------- |\n| 1   | 0        | 数学       | 0,1        |\n| 2   | 1        | 高等数学   | 0,1,2      |\n| 3   | 1        | 线性代数   | 0,1,3      |\n| 4   | 0        | 英语       | 0,4        |\n| 5   | 4        | 即时翻译   | 0,4,5      |\n| 6   | 4        | 口语阅读   | 0,4,6      |\n| 7   | 0        | 物理       | 0,7        |\n| 8   | 7        | 高能物理   | 0,7,8      |\n| 9   | 8        | 无限能量   | 0,7,8,9    |\n| 10  | 9        | 迪克拉之海 | 0,7,8,9,10 |\n\nSQL 结构/数据\n\n```sql\ncreate table question_type (\n  id       bigint primary key  not null\n  comment '问题编号',\n  parentId bigint              not null\n  comment '问题父分类编号，根节点为 0',\n  name     varchar(20)         not null\n  comment '编号名称',\n  path     varchar(100)        not null\n  comment '全路径，每级使用 , 分割'\n)\n  comment '问题编号';\ninsert into question_type values (1, 0, '数学', '0,1');\ninsert into question_type values (2, 1, '高等数学', '0,1,2');\ninsert into question_type values (3, 1, '线性代数', '0,1,3');\ninsert into question_type values (4, 0, '英语', '0,4');\ninsert into question_type values (5, 4, '即时翻译', '0,4,5');\ninsert into question_type values (6, 4, '口语阅读', '0,4,6');\ninsert into question_type values (7, 0, '物理', '0,7');\ninsert into question_type values (8, 7, '高能物理', '0,7,8');\ninsert into question_type values (9, 8, '无限能量', '0,7,8,9');\ninsert into question_type values (10, 9, '迪克拉之海', '0,7,8,9,10');\n```\n\n现在，我们可以很简单的查询了子级信息了\n\n```sql\n# 查询物理分类及其子级\nselect *\nfrom question_type\nwhere path regexp concat(\n    ',', 7,\n    ',|^', 7,\n    ',|,', 7,\n    '$|^', 7,\n    '$');\n```\n\n> 这里使用正则是为了避免出现部分重复的情况，例如 `1` 和 `10`，直接使用 `like` 的话可能会出现错误查询额外的数据。\n\n## 在应用层递归查询完成\n\n在不修改数据表结构的情况下有什么方法能递归查询么？答案是可以的！我们可以在程序中递归查询数据库，虽然效率上会低点，但对于不能修改的数据库而言还是相当有用的。\n\nDomain 实体\n\n```java\n@TableName(\"question_type\")\npublic class QuestionType implements Serializable {\n    /**\n     * 问题编号\n     */\n    private Long id;\n    /**\n     * 问题父分类编号，根节点为 0\n     */\n    private Long parentId;\n    /**\n     * 编号名称\n     */\n    private String name;\n    /**\n     * 全路径，每级使用 , 分割\n     */\n    private String path;\n    // getter / setter\n}\n```\n\nService 及其实现\n\n```java\npublic interface QuestionTypeService {\n    /**\n     * 递归查询节点及其子节点\n     *\n     * @param rootId 查询的根节点 id\n     * @return 子节点列表\n     */\n    List<QuestionType> selectRecursiveById(Long rootId);\n}\n\n@Service\npublic class QuestionTypeServiceImpl implements QuestionTypeService {\n    @Autowired\n    private QuestionTypeDao baseMapper;\n\n    @Override\n    public List<QuestionType> selectRecursiveById(Long rootId) {\n        final List<QuestionType> list = baseMapper.selectListByParentId(rootId).stream()\n                .flatMap(qt -> selectRecursiveById(qt.getId()).stream())\n                .collect(Collectors.toList());\n        Optional.ofNullable(baseMapper.selectById(rootId)).ifPresent(list::add);\n        return list;\n    }\n}\n\n```\n\nDao/Mapper.xml\n\n```java\n@Repository\npublic interface QuestionTypeDao {\n    /**\n     * 根据 id 查询分类\n     *\n     * @param id 分类 id\n     * @return 查询到的分类数据\n     */\n    QuestionType selectById(@Param(\"id\") Long id);\n\n    /**\n     * 根据父节点 id 查询一级子节点\n     *\n     * @param parentId 父节点 id\n     * @return 一级子节点列表\n     */\n    List<QuestionType> selectListByParentId(@Param(\"parentId\") Long parentId);\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.rxliuli.example.mybatisplussqlinjector.dao.QuestionTypeDao\">\n    <select id=\"selectListByParentId\"\n            resultType=\"com.rxliuli.example.mybatisplussqlinjector.entity.QuestionType\">\n        select *\n        from question_type\n        where parentId = #{parentId};\n    </select>\n    <select id=\"selectById\" resultType=\"com.rxliuli.example.mybatisplussqlinjector.entity.QuestionType\">\n        select *\n        from question_type\n        where id = #{id};\n    </select>\n</mapper>\n```\n\n调用的时候只要传入一个根节点 id 就可以查找到所有节点及其所有子节点了\n\n## 使用 Mybatis collection 标签\n\n如果你使用的 ORM 是 Mybatis，那么也可以使用 Mybatis collection 标签实现递归查询的功能。\n\n1. Mybatis `collection` 标签可以查询一个集合为字段赋值\n2. 那么我们可以使用 `select` 指向查询子分类本身\n3. 查询的参数 `cloumn` 设置为查询出来每一个对象的 `id` 字段\n4. 更改查询子分类的返回值为 `resultMap=\"RecursiveMap\"`\n\n```java\n@Repository\npublic interface QuestionTypeDao {\n    /**\n     * 根据父分类 id 递归查询子分类（不包含父分类本身）\n     *\n     * @param parentId 分类 id\n     * @return 查询到的分类树\n     */\n    List<QuestionType> selectRecursiveByParentId(@Param(\"parentId\") Long parentId);\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.rxliuli.example.mybatisplussqlinjector.dao.QuestionTypeDao\">\n    <!-- 定义一个结果映射 -->\n    <resultMap id=\"RecursiveMap\" type=\"com.rxliuli.example.mybatisplussqlinjector.entity.QuestionType\">\n        <result property=\"id\" column=\"id\"/>\n        <result property=\"parentId\" column=\"parentId\"/>\n        <result property=\"name\" column=\"name\"/>\n        <result property=\"path\" column=\"path\"/>\n        <!-- 这里是关键，定义集合字段，元素类型，查询函数以及对应的列 -->\n        <collection property=\"childrenList\" ofType=\"com.rxliuli.example.mybatisplussqlinjector.entity.QuestionType\"\n                    select=\"com.rxliuli.example.mybatisplussqlinjector.dao.QuestionTypeDao.selectRecursiveByParentId\"\n                    column=\"id\"/>\n    </resultMap>\n\n    <!-- 正常查询子分类，唯一修改之处就是 resultMap -->\n    <select id=\"selectRecursiveByParentId\" resultMap=\"RecursiveMap\">\n        select *\n        from question_type\n        where parentId = #{parentId}\n    </select>\n</mapper>\n```\n\n---\n\n那么，关于 MySQL 递归查询暂且到此为止了。如果吾辈找到了更好的方法，也会继续更新这篇文章的！\n","createdTime":1587219249413,"updatedTime":1609305523169,"resources":[],"tags":[{"id":"1656d5691cc143f8a555566791858bac","title":"sql","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"37bd6ad2404241058cd01cb971d3e18e","title":"在 Windows 上使用 FTP/SFTP 服务端","body":"## 场景\r\n\r\n最近在做 `WebService` 项目时遇到了定时上传统计报表的需求。协议是 `FTP/SFTP`，然而第三方服务暂时无法集成，所以只能在本地使用软件模拟出 `FTP/SFTP` 服务端，然后在代码中进行测试。\r\n\r\n## 前言\r\n\r\n吾辈并未使用 Windows 上大名鼎鼎的 [FileZilla](https://filezilla-project.org/)。  \r\n谜之音：**FileZilla 开源免费，而且 `FTP/SFTP/FTPS` 都能支持岂不美滋滋？**  \r\n吾辈：然而安装完成直接启动就报错了  \r\n谜之音：**报错就去查一下，这都觉得麻烦却是没办法了呢！**\r\n\r\n事实上这是很多开发者，尤其是 Linux 下的开发者，习惯了使用软件可能报错、可能有问题，对使用体验毫不在意。  \r\n所以吾辈滚了，滚去使用其他的软件了。\r\n\r\n## 使用 freeFTPd\r\n\r\n> [freeFTPd 官网](http://www.freesshd.com/)\r\n\r\n点击 [下载链接](http://www.freesshd.com/freeFTPd.exe) 下载 freeFTPd，然后点击安装。第一次运行时会询问你 **是否创建/使用私钥** 和 **是否运行系统服务**，全部选择 **是** 即可。\r\n\r\n1. 打开程序  \r\n   可以看到默认在 `Status` 标签，显示者 FTP 和 SFTP 服务都是关闭状态。\r\n   ![首页](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217213152.png)\r\n2. 添加用户  \r\n   首先，我们需要添加一个用户，可以连接 FTP/SFTP 服务端的用户。\r\n   1. 点击 Users 标签，然后点击 Add 添加用户  \r\n      ![Users 标签](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217213700.png)\r\n   2. 设置用户信息  \r\n      ![添加用户信息](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217214421.png)  \r\n      依次\r\n      1. 输入用户名\r\n      2. 选择使用密码认证\r\n      3. 输入密码\r\n      4. 选择用户的服务端根目录\r\n      5. 同时选择允许 FTP/SFTP 连接（默认选中）\r\n      6. 点击 Apply 完成添加\r\n3. 启动 FTP 服务端  \r\n   ![启动 FTP](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217214719.png)\r\n4. 启动 SFTP 服务端  \r\n   ![启动 SFTP](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217214843.png)\r\n5. 查看 Status 状态页  \r\n   ![Status 选项页](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217214951.png)\r\n\r\n## 测试 FTP/SFTP\r\n\r\n如果仅仅是连接 FTP/SFTP 的话，我们确实可以使用 [WinSCP](https://winscp.net/) 作为 FTP/SFTP 客户端。然而，作为开发者，连接 Linux 服务器也是家常便饭，所以我们选择 [MobaXterm](https://mobaxterm.mobatek.net/)。\r\n\r\n在 [下载页面](https://mobaxterm.mobatek.net/download-home-edition.html) 选择 **MobaXterm Home Edition v11.1 (Portable edition)** 下载免费便携版。下载完成得到一个压缩包，解压之，点击 **MobaXterm_Personal_11.1.exe** 运行程序。\r\n\r\nMobaXterm 首页  \r\n![MobaXterm 首页](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217220138.png)\r\n\r\n1. 点击 **Session** 添加会话  \r\n   ![连接 FTP](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217220648.png)\r\n2. 设置用户认证信息  \r\n   ![设置用户认证信息](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217220940.png)\r\n3. 选择用户认证信息  \r\n   ![选择用户认证信息](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217221138.png)\r\n4. 连接 FTP 成功  \r\n   ![连接 FTP 成功](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217221321.png)\r\n5. 同理添加 SFTP 连接  \r\n   ![同理添加 SFTP 连接](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217221633.png)\r\n6. 连接 SFTP 成功  \r\n   ![连接 SFTP 成功](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190217221801.png)\r\n\r\n---\r\n\r\n最后，虽然概率很低，但如果在你的 PC 上按照该教程搭建失败，可以在文章底部进行评论告诉吾辈哦 （ｖ＾＿＾）ｖ\r\n","createdTime":1580652938043,"updatedTime":1609305178402,"resources":[],"tags":[{"id":"4e00e5550c864473a3f16e4b0698f1c3","title":"windows","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"a2bdf59b8059475793df3dfb99d67b3d","title":"Java 跨域问题处理","body":"## 问题\n\n在页面上要使用 `Ajax` 请求去获取另外一个服务的数据，由于浏览器的 [同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)，所以直接请求会得到一个 `Error`。\n\n```text\nFailed to load https://www.baidu.com/: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost:3000' is therefore not allowed access. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.\n```\n\n大概就是这样的一个错误，关键词是 **Access-Control-Allow-Origin**，一般出现这个都是跨域问题。\n\n## 解决方案\n\n解决跨域问题的方式有很多，但这里之说 [Cors](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS) 的方案。\n\n在后台添加一个 `Filter` 过滤器\n\n```java\n/**\n * 使用自定义的 Filter 拦截器实现跨域请求、\n * 适用于所有的 Java Web 项目并且不局限于某个框架\n * 注：此处的 @Component 仅为让 Spring 知道这个 Bean, 不然拦截器不会加载\n *\n * @author rxliuli\n */\npublic class CustomCorsFilterConfig implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) {\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        //允许所有来源\n        String allowOrigin = \"*\";\n        //允许以下请求方法\n        String allowMethods = \"GET,POST,PUT,DELETE,OPTIONS\";\n        //允许以下请求头\n        String allowHeaders = \"Content-Type,X-Token,Authorization\";\n        //允许有认证信息（cookie）\n        String allowCredentials = \"true\";\n\n        String origin = request.getHeader(\"Origin\");\n        //此处是为了兼容需要认证信息(cookie)的时候不能设置为 * 的问题\n        response.setHeader(\"Access-Control-Allow-Origin\", origin == null ? allowOrigin : origin);\n        response.setHeader(\"Access-Control-Allow-Methods\", allowMethods);\n        response.setHeader(\"Access-Control-Allow-Credentials\", allowCredentials);\n        response.setHeader(\"Access-Control-Allow-Headers\", allowHeaders);\n\n        //处理 OPTIONS 的请求\n        if (\"OPTIONS\".equals(request.getMethod())) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            return;\n        }\n        filterChain.doFilter(request, response);\n    }\n\n    @Override\n    public void destroy() {\n    }\n}\n```\n\n在 `web.xml` 文件中添加拦截器配置（注：如果可能就配置成第一个 `Filter`）\n\n```xml\n<!--cors 跨域访问-->\n<filter>\n  <filter-name>customCorsFilterConfig</filter-name>\n  <filter-class>CustomCorsFilterConfig</filter-class>\n</filter>\n<filter-mapping>\n  <filter-name>customCorsFilterConfig</filter-name>\n  <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n## Spring Web 的解决方案\n\n配置一个每次请求都过滤一次的 `Filter` 就好了\n\n```java\n@Configuration\npublic class CorsConfig {\n    @Bean\n    public OncePerRequestFilter corsFilter() {\n        return new OncePerRequestFilter() {\n            @Override\n            protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n                //允许所有来源\n                String allowOrigin = \"*\";\n                //允许以下请求方法\n                String allowMethods = \"GET,POST,PUT,DELETE,OPTIONS\";\n                //允许以下请求头\n                String allowHeaders = \"Content-Type,X-Token,Authorization\";\n                //允许有认证信息（cookie）\n                String allowCredentials = \"true\";\n\n                String origin = request.getHeader(\"Origin\");\n                //此处是为了兼容需要认证信息(cookie)的时候不能设置为 * 的问题\n                response.setHeader(\"Access-Control-Allow-Origin\", origin == null ? allowOrigin : origin);\n                response.setHeader(\"Access-Control-Allow-Methods\", allowMethods);\n                response.setHeader(\"Access-Control-Allow-Credentials\", allowCredentials);\n                response.setHeader(\"Access-Control-Allow-Headers\", allowHeaders);\n\n                //处理 OPTIONS 的请求\n                if (\"OPTIONS\".equals(request.getMethod())) {\n                    response.setStatus(HttpServletResponse.SC_OK);\n                    return;\n                }\n                filterChain.doFilter(request, response);\n            }\n        };\n    }\n}\n```\n\n## 使用示例\n\n下面是一些简单的使用 `fetch` 进行跨域请求的示例：\n\n- 简单 fetch 请求，和正常使用 fetch 并无区别\n\n  ```js\n  fetch(url)\n    .then((res) => res.json())\n    .then((json) => console.log(json))\n  ```\n\n- 表单请求\n\n  ```js\n  var fd = new FormData()\n  fd.append('username', 'rx')\n  fd.append('password', 'rx')\n\n  fetch(url, {\n    method: 'POST',\n    body: fd,\n  })\n    .then((res) => res.json())\n    .then((json) => console.log(json))\n  ```\n\n- 需要认证的请求\n\n  ```js\n  fetch(url, {\n    /**\n     * 关键就在这里，代表用户是否应该在跨域的情况下发送 cookies 和 HTTP Basic authentication 等验信息以及服务端能否返回 Set-Cookie（服务端 Session 需要使用这个向 cookie 中设置 sessionId）。\n     * 包含三个可选值：omit(从不发送), same-origin(同源才发送), include(总会发送)\n     * 参考链接：<https://developer.mozilla.org/zh-CN/docs/Web/API/Request/credentials>\n     */\n    credentials: 'include',\n  })\n    .then((res) => res.json())\n    .then((json) => console.log(json))\n  ```\n\n  > 注：如果想要服务端返回 `Set-Cookie`（`SessionId` 也需要通过这个响应属性去设置） 就必须设置这个请求参数！\n\n那么，之后在前端跨域请求的时候就可以愉快地玩耍啦（ｖ＾＿＾）ｖ\n","createdTime":1587219249393,"updatedTime":1609305059978,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"5ac18d41f1ef478288f456ba1a96f9e5","title":"Java 中 String 转 LocalDateTime 出现错误","body":"## 场景\n\n在 Java 中使用 `LocalDateTime` 解析 `String` 失败\n\n代码如下\n\n```java\nfinal LocalDateTime result = LocalDateTime.parse(\"2000-01-01\", DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"));\nlog.info(\"result: {}\", result);\n```\n\n抛出异常\n\n```sh\njava.time.format.DateTimeParseException: Text '2000-01-01' could not be parsed: Unable to obtain LocalDateTime from TemporalAccessor: {},ISO resolved to 2000-01-01 of type java.time.format.Parsed\n```\n\n吾辈也在 [SegmentFault](https://segmentfault.com/q/1010000018526018) 上提出了这个问题，然而直到写出这篇记录时然而没有人告诉吾辈答案。。。\n\n## 解决\n\n### 先转换为 LocalDate 再二次转换\n\n吾辈首先找到了一种笨方法\n\n1. 先解析为 `LocalDate`\n2. 将 `LocalDate` 转换为 `LocalDateTime`。\n\n```java\nfinal LocalDateTime localDateTime = LocalDate.parse(\"2018-12-11\", DateTimeFormatter.ISO_DATE).atStartOfDay();\nassertThat(localDateTime)\n    .isNotNull();\n```\n\n### 使用 DateTimeFormatter 先解析，然后转换为 LocalDateTime\n\n1. 使用 `DateTimeFormatter.ISO_DATE` 解析文本并得到 `TemporalAccessor` 对象\n2. 使用 `temporalAccessor.get` 方法获取指定属性\n3. 使用 `LocalDateTime.of` 构造一个 `LocalDateTime` 对象\n\n```java\nfinal TemporalAccessor temporalAccessor = DateTimeFormatter.ISO_DATE.parse(\"2018-12-11\");\nfinal LocalDateTime localDateTime = LocalDateTime.of(\n    secureGet(temporalAccessor, ChronoField.YEAR),\n    secureGet(temporalAccessor, ChronoField.MONTH_OF_YEAR),\n    secureGet(temporalAccessor, ChronoField.DAY_OF_MONTH),\n    secureGet(temporalAccessor, ChronoField.HOUR_OF_DAY),\n    secureGet(temporalAccessor, ChronoField.MINUTE_OF_HOUR),\n    secureGet(temporalAccessor, ChronoField.SECOND_OF_MINUTE),\n    secureGet(temporalAccessor, ChronoField.NANO_OF_SECOND)\n);\nlog.info(\"localDateTime: {}\", localDateTime);\n```\n\n`secureGet` 是吾辈自定义的一个工具方法，具体看下面的代码\n\n```java\n/**\n  * 安全获取时间的某个属性\n  *\n  * @param temporalAccessor 需要获取的时间对象\n  * @param chronoField      需要获取的属性\n  * @return 时间的值，如果无法获取则默认为 0\n  */\nprivate static int secureGet(TemporalAccessor temporalAccessor, ChronoField chronoField) {\n    if (temporalAccessor.isSupported(chronoField)) {\n        return temporalAccessor.get(chronoField);\n    }\n    return 0;\n}\n```\n\n### 使用 DateTimeFormatterBuilder 构建器\n\n吾辈在 [StackOverflow](https://stackoverflow.com/questions/27454025) 找到了一个好的方法\n\n1. 使用 `DateTimeFormatterBuilder` 构建 `DateTimeFormatter` 对象\n2. 赋予可选匹配项默认值（**非常重要**）\n3. 使用 `LocalDateTime.parse` 进行解析\n\n```java\nfinal DateTimeFormatter formatter = new DateTimeFormatterBuilder()\n    .appendPattern(\"yyyy-MM-dd[['T'hh][:mm][:ss]]\")\n    .parseDefaulting(ChronoField.HOUR_OF_DAY, 0)\n    .parseDefaulting(ChronoField.MINUTE_OF_HOUR, 0)\n    .parseDefaulting(ChronoField.SECOND_OF_MINUTE, 0)\n    .parseDefaulting(ChronoField.MILLI_OF_SECOND, 0)\n    .toFormatter();\nfinal LocalDateTime localDateTime = LocalDateTime.parse(\"2018-12-11\", formatter);\nassertThat(localDateTime)\n    .isNotNull();\n```\n\n---\n\n最后一种方法满足了吾辈的需求，所以，也便是在这里记录一下啦\n","createdTime":1587219249393,"updatedTime":1609305056203,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"f5aa5f95061f4befa8406520b7f1c04b","title":"Java 优雅的拷贝对象属性","body":"## 场景\n\n在 Java 项目中，经常遇到需要在对象之间拷贝属性的问题。然而，除了直接使用 `Getter/Stter` 方法，我们还有其他的方法么？  \n当然有，例如 `Apache Common Lang3` 的 `BeanUtils`，然而 `BeanUtils` 却无法完全满足吾辈的需求，所以吾辈便自己封装了一个，这里分享出来以供参考。\n\n- 需要大量复制对象的属性\n- 对象之间的属性名可能是不同的\n- 对象之间的属性类型可能是不同的\n\n## 目标\n\n简单易用的 API\n\n- `copy`: 指定需要拷贝的源对象和目标对象\n- `prop`: 拷贝指定对象的字段\n- `props`: 拷贝指定对象的多个字段\n- `exec`: 执行真正的拷贝操作\n- `from`: 重新开始添加其他对象的属性\n- `get`: 返回当前的目标对象\n- `config`: 配置拷贝的一些策略\n\n## 思路\n\n1. 定义门面类 `BeanCopyUtil` 用以暴露出一些 API\n2. 定义每个字段的操作类 `BeanCopyField`，保存对每个字段的操作\n3. 定义 `BeanCopyConfig`，用于配置拷贝属性的策略\n4. 定义 `BeanCopyOperator` 作为拷贝的真正实现\n\n图解\n\n![图解](https://img.rxliuli.com/20190227215703.png)\n\n## 实现\n\n> 注：反射部分依赖于 [joor](https://github.com/jOOQ/jOOR), JDK1.8 请使用 [joor-java-8](https://mvnrepository.com/artifact/org.jooq/joor-java-8/0.9.7)\n\n### 定义门面类 `BeanCopyUtil` 用以暴露出一些 API\n\n```java\n/**\n * java bean 复制操作的工具类\n *\n * @author rxliuli\n */\npublic class BeanCopyUtil<F, T> {\n    /**\n     * 源对象\n     */\n    private final F from;\n    /**\n     * 目标对象\n     */\n    private final T to;\n    /**\n     * 拷贝的字段信息列表\n     */\n    private final List<BeanCopyField> copyFieldList = new LinkedList<>();\n    /**\n     * 配置信息\n     */\n    private BeanCopyConfig config = new BeanCopyConfig();\n\n    private BeanCopyUtil(F from, T to) {\n        this.from = from;\n        this.to = to;\n    }\n\n    /**\n     * 指定需要拷贝的源对象和目标对象\n     *\n     * @param from 源对象\n     * @param to   目标对象\n     * @param <F>  源对象类型\n     * @param <T>  目标对象类型\n     * @return 一个 {@link BeanCopyUtil} 对象\n     */\n    public static <F, T> BeanCopyUtil<F, T> copy(F from, T to) {\n        return new BeanCopyUtil<>(from, to);\n    }\n\n    /**\n     * 拷贝指定对象的字段\n     *\n     * @param fromField 源对象中的字段名\n     * @param toField   目标对象中的字段名\n     * @param converter 将源对象中字段转换为目标对象字段类型的转换器\n     * @return 返回 {@code this}\n     */\n    public BeanCopyUtil<F, T> prop(String fromField, String toField, Function<? super Object, ? super Object> converter) {\n        copyFieldList.add(new BeanCopyField(fromField, toField, converter));\n        return this;\n    }\n\n    /**\n     * 拷贝指定对象的字段\n     *\n     * @param fromField 源对象中的字段名\n     * @param toField   目标对象中的字段名\n     * @return 返回 {@code this}\n     */\n    public BeanCopyUtil<F, T> prop(String fromField, String toField) {\n        return prop(fromField, toField, null);\n    }\n\n    /**\n     * 拷贝指定对象的字段\n     *\n     * @param field     源对象中与目标对象中的字段名\n     * @param converter 将源对象中字段转换为目标对象字段类型的转换器\n     * @return 返回 {@code this}\n     */\n    public BeanCopyUtil<F, T> prop(String field, Function<? super Object, ? super Object> converter) {\n        return prop(field, field, converter);\n    }\n\n    /**\n     * 拷贝指定对象的字段\n     *\n     * @param field 源对象中与目标对象中的字段名\n     * @return 返回 {@code this}\n     */\n    public BeanCopyUtil<F, T> prop(String field) {\n        return prop(field, field, null);\n    }\n\n    /**\n     * 拷贝指定对象的多个字段\n     *\n     * @param fields 源对象中与目标对象中的多个字段名\n     * @return 返回 {@code this}\n     */\n    public BeanCopyUtil<F, T> props(String... fields) {\n        for (String field : fields) {\n            prop(field);\n        }\n        return this;\n    }\n\n    /**\n     * 执行真正的拷贝操作\n     *\n     * @return 返回 {@code this}\n     */\n    public BeanCopyUtil<F, T> exec() {\n        new BeanCopyOperator<>(from, to, copyFieldList, config).copy();\n        return this;\n    }\n\n    /**\n     * 重新开始添加其他对象的属性\n     * 用于在执行完 {@link #exec()} 之后还想复制其它对象的属性\n     *\n     * @param from 源对象\n     * @param <R>  源对象类型\n     * @return 一个新的 {@link BeanCopyUtil} 对象\n     */\n    public <R> BeanCopyUtil<R, T> from(R from) {\n        return new BeanCopyUtil<>(from, to);\n    }\n\n    /**\n     * 返回当前的目标对象\n     *\n     * @return 当前的目标对象\n     */\n    public T get() {\n        return to;\n    }\n\n    /**\n     * 配置拷贝的一些策略\n     *\n     * @param config 拷贝配置对象\n     * @return 返回 {@code this}\n     */\n    public BeanCopyUtil<F, T> config(BeanCopyConfig config) {\n        this.config = config;\n        return this;\n    }\n}\n```\n\n### 定义每个字段的操作类 `BeanCopyField`，保存对每个字段的操作\n\n```java\n/**\n * 拷贝属性的每一个字段的选项\n *\n * @author rxliuli\n */\npublic class BeanCopyField {\n    private String from;\n    private String to;\n    private Function<? super Object, ? super Object> converter;\n\n    public BeanCopyField() {\n    }\n\n    public BeanCopyField(String from, String to, Function<? super Object, ? super Object> converter) {\n        this.from = from;\n        this.to = to;\n        this.converter = converter;\n    }\n\n    public String getFrom() {\n        return from;\n    }\n\n    public BeanCopyField setFrom(String from) {\n        this.from = from;\n        return this;\n    }\n\n    public String getTo() {\n        return to;\n    }\n\n    public BeanCopyField setTo(String to) {\n        this.to = to;\n        return this;\n    }\n\n    public Function<? super Object, ? super Object> getConverter() {\n        return converter;\n    }\n\n    public BeanCopyField setConverter(Function<? super Object, ? super Object> converter) {\n        this.converter = converter;\n        return this;\n    }\n}\n```\n\n### 定义 `BeanCopyConfig`，用于配置拷贝属性的策略\n\n```java\n/**\n * 拷贝属性的配置\n *\n * @author rxliuli\n */\npublic class BeanCopyConfig {\n    /**\n     * 同名的字段自动复制\n     */\n    private boolean same = true;\n    /**\n     * 覆盖同名的字段\n     */\n    private boolean override = true;\n    /**\n     * 忽略 {@code null} 的源对象属性\n     */\n    private boolean ignoreNull = true;\n    /**\n     * 尝试进行自动转换\n     */\n    private boolean converter = true;\n\n    public BeanCopyConfig() {\n    }\n\n    public BeanCopyConfig(boolean same, boolean override, boolean ignoreNull, boolean converter) {\n        this.same = same;\n        this.override = override;\n        this.ignoreNull = ignoreNull;\n        this.converter = converter;\n    }\n\n    public boolean isSame() {\n        return same;\n    }\n\n    public BeanCopyConfig setSame(boolean same) {\n        this.same = same;\n        return this;\n    }\n\n    public boolean isOverride() {\n        return override;\n    }\n\n    public BeanCopyConfig setOverride(boolean override) {\n        this.override = override;\n        return this;\n    }\n\n    public boolean isIgnoreNull() {\n        return ignoreNull;\n    }\n\n    public BeanCopyConfig setIgnoreNull(boolean ignoreNull) {\n        this.ignoreNull = ignoreNull;\n        return this;\n    }\n\n    public boolean isConverter() {\n        return converter;\n    }\n\n    public BeanCopyConfig setConverter(boolean converter) {\n        this.converter = converter;\n        return this;\n    }\n}\n```\n\n### 定义 `BeanCopyOperator` 作为拷贝的真正实现\n\n```java\n/**\n * 真正执行 copy 属性的类\n *\n * @author rxliuli\n */\npublic class BeanCopyOperator<F, T> {\n    private static final Logger log = LoggerFactory.getLogger(BeanCopyUtil.class);\n    private final F from;\n    private final T to;\n    private final BeanCopyConfig config;\n    private List<BeanCopyField> copyFieldList;\n\n    public BeanCopyOperator(F from, T to, List<BeanCopyField> copyFieldList, BeanCopyConfig config) {\n        this.from = from;\n        this.to = to;\n        this.copyFieldList = copyFieldList;\n        this.config = config;\n    }\n\n    public void copy() {\n        //获取到两个对象所有的属性\n        final Map<String, Reflect> fromFields = Reflect.on(from).fields();\n        final Reflect to = Reflect.on(this.to);\n        final Map<String, Reflect> toFields = to.fields();\n        //过滤出所有相同字段名的字段并进行拷贝\n        if (config.isSame()) {\n            final Map<ListUtil.ListDiffState, List<String>> different = ListUtil.different(new ArrayList<>(fromFields.keySet()), new ArrayList<>(toFields.keySet()));\n            copyFieldList = Stream.concat(different.get(ListUtil.ListDiffState.common).stream()\n                    .map(s -> new BeanCopyField(s, s, null)), copyFieldList.stream())\n                    .collect(Collectors.toList());\n        }\n        //根据拷贝字段列表进行拷贝\n        copyFieldList.stream()\n                //忽略空值\n                .filter(beanCopyField -> !config.isIgnoreNull() || fromFields.get(beanCopyField.getFrom()).get() != null)\n                //覆盖属性\n                .filter(beanCopyField -> config.isOverride() || toFields.get(beanCopyField.getTo()).get() == null)\n                //如果没有转换器，则使用默认的转换器\n                .peek(beanCopyField -> {\n                    if (beanCopyField.getConverter() == null) {\n                        beanCopyField.setConverter(Function.identity());\n                    }\n                })\n                .forEach(beanCopyField -> {\n                    final String fromField = beanCopyField.getFrom();\n                    final F from = fromFields.get(fromField).get();\n                    final String toField = beanCopyField.getTo();\n                    try {\n                        to.set(toField, beanCopyField.getConverter().apply(from));\n                    } catch (ReflectException e) {\n                        log.warn(\"Copy field failed, from {} to {}, exception is {}\", fromField, toField, e.getMessage());\n                    }\n                });\n    }\n}\n```\n\n## 使用\n\n### 使用流程图\n\n![使用流程图](https://img.rxliuli.com/20190228000845.png)\n\n### 测试\n\n代码写完了，让我们测试一下！\n\n```java\npublic class BeanCopyUtilTest {\n    private final Logger log = LoggerFactory.getLogger(getClass());\n    private Student student;\n    private Teacher teacher;\n\n    @Before\n    public void before() {\n        student = new Student(\"琉璃\", 10, \"女\", 4);\n        teacher = new Teacher();\n    }\n\n    @Test\n    public void copy() {\n        //简单的复制（类似于 BeanUtils.copyProperties）\n        BeanCopyUtil.copy(student, teacher).exec();\n        log.info(\"teacher: {}\", teacher);\n        assertThat(teacher)\n                .extracting(\"age\")\n                .containsOnlyOnce(student.getAge());\n    }\n\n    @Test\n    public void prop() {\n        //不同名字的属性\n        BeanCopyUtil.copy(student, teacher)\n                .prop(\"sex\", \"sex\", sex -> Objects.equals(sex, \"男\"))\n                .prop(\"realname\", \"name\")\n                .exec();\n        assertThat(teacher)\n                .extracting(\"name\", \"age\", \"sex\")\n                .containsOnlyOnce(student.getRealname(), student.getAge(), false);\n    }\n\n    @Test\n    public void prop1() {\n        //不存的属性\n        assertThat(BeanCopyUtil.copy(student, teacher)\n                .prop(\"sex\", \"sex\", sex -> Objects.equals(sex, \"男\"))\n                .prop(\"realname\", \"name2\")\n                .exec()\n                .get())\n                .extracting(\"age\", \"sex\")\n                .containsOnlyOnce(student.getAge(), false);\n    }\n\n    @Test\n    public void from() {\n        final Teacher lingMeng = new Teacher()\n                .setName(\"灵梦\")\n                .setAge(17);\n        //测试 from 是否覆盖\n        assertThat(BeanCopyUtil.copy(student, teacher)\n                .prop(\"sex\", \"sex\", sex -> Objects.equals(sex, \"男\"))\n                .prop(\"realname\", \"name\")\n                .exec()\n                .from(lingMeng)\n                .exec()\n                .get())\n                .extracting(\"name\", \"age\", \"sex\")\n                .containsOnlyOnce(lingMeng.getName(), lingMeng.getAge(), false);\n    }\n\n    @Test\n    public void get() {\n        //测试 get 是否有效\n        assertThat(BeanCopyUtil.copy(student, teacher)\n                .prop(\"sex\", \"sex\", sex -> Objects.equals(sex, \"男\"))\n                .prop(\"realname\", \"name\")\n                .exec()\n                .get())\n                .extracting(\"name\", \"age\", \"sex\")\n                .containsOnlyOnce(student.getRealname(), student.getAge(), false);\n    }\n\n    @Test\n    public void config() {\n        //不自动复制同名属性\n        assertThat(BeanCopyUtil.copy(new Student().setAge(15), new Teacher())\n                .config(new BeanCopyConfig().setSame(false))\n                .exec()\n                .get())\n                .extracting(\"age\")\n                .containsOnlyNulls();\n        //不覆盖不为空的属性\n        assertThat(BeanCopyUtil.copy(new Student().setAge(15), new Teacher().setAge(10))\n                .config(new BeanCopyConfig().setOverride(false))\n                .exec()\n                .get())\n                .extracting(\"age\")\n                .containsOnlyOnce(10);\n        //不忽略源对象不为空的属性\n        assertThat(BeanCopyUtil.copy(new Student(), student)\n                .config(new BeanCopyConfig().setIgnoreNull(false))\n                .exec()\n                .get())\n                .extracting(\"realname\", \"age\", \"sex\", \"grade\")\n                .containsOnlyNulls();\n    }\n\n    /**\n     * 测试学生类\n     */\n    private static class Student {\n        /**\n         * 姓名\n         */\n        private String realname;\n        /**\n         * 年龄\n         */\n        private Integer age;\n        /**\n         * 性别，男/女\n         */\n        private String sex;\n        /**\n         * 年级，1 - 6\n         */\n        private Integer grade;\n\n        public Student() {\n        }\n\n        public Student(String realname, Integer age, String sex, Integer grade) {\n            this.realname = realname;\n            this.age = age;\n            this.sex = sex;\n            this.grade = grade;\n        }\n\n        public String getRealname() {\n\n            return realname;\n        }\n\n        public Student setRealname(String realname) {\n            this.realname = realname;\n            return this;\n        }\n\n        public Integer getAge() {\n            return age;\n        }\n\n        public Student setAge(Integer age) {\n            this.age = age;\n            return this;\n        }\n\n        public String getSex() {\n            return sex;\n        }\n\n        public Student setSex(String sex) {\n            this.sex = sex;\n            return this;\n        }\n\n        public Integer getGrade() {\n            return grade;\n        }\n\n        public Student setGrade(Integer grade) {\n            this.grade = grade;\n            return this;\n        }\n\n        @Override\n        public String toString() {\n            return ToStringBuilder.reflectionToString(this);\n        }\n    }\n\n    /**\n     * 测试教师类\n     */\n    private static class Teacher {\n        /**\n         * 姓名\n         */\n        private String name;\n        /**\n         * 年龄\n         */\n        private Integer age;\n        /**\n         * 性别，true 男，false 女\n         */\n        private Boolean sex;\n        /**\n         * 职位\n         */\n        private String post;\n\n        public Teacher() {\n        }\n\n        public Teacher(String name, Integer age, Boolean sex, String post) {\n            this.name = name;\n            this.age = age;\n            this.sex = sex;\n            this.post = post;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public Teacher setName(String name) {\n            this.name = name;\n            return this;\n        }\n\n        public Integer getAge() {\n            return age;\n        }\n\n        public Teacher setAge(Integer age) {\n            this.age = age;\n            return this;\n        }\n\n        public Boolean getSex() {\n            return sex;\n        }\n\n        public Teacher setSex(Boolean sex) {\n            this.sex = sex;\n            return this;\n        }\n\n        public String getPost() {\n            return post;\n        }\n\n        public Teacher setPost(String post) {\n            this.post = post;\n            return this;\n        }\n\n        @Override\n        public String toString() {\n            return ToStringBuilder.reflectionToString(this);\n        }\n    }\n}\n```\n\n如果没有发生什么意外，那么一切将能够正常运行！\n\n---\n\n好了，那么关于在 Java 中优雅的拷贝对象属性就到这里啦\n","createdTime":1587219249393,"updatedTime":1609305052519,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"33de2f98ebaf4f23af2942274589a800","title":"Java 使用 FTP/SFTP","body":"## 场景\n\n项目中需要使用 FTP，所以做了简单的 `FTP/SFTP` 封装，此处仅做一下记录。\n\n> 注：这里并未实现连接池管理，生产环境强烈建议手动实现连接池以提高性能！\n\n## UML 图像说明\n\n### 形状\n\n> 注：此处参考自 IDEA UML 图中的颜色\n\n- 蓝色：类/步骤\n- 黄色：字段\n- 红色：函数\n- 紫色：配置\n\n### 图形\n\n- 长方形：类/配置文件/依赖项\n- 圆角长方形：字段/函数/对象/变量\n- 箭头：拥有/向下依赖的意思\n\n## 目标\n\n封装简单的通用操作\n\n- 上传单个文件\n- 上传使用 `InputStream`(内存操作)\n- 下载单个文件\n- 下载得到 `InputStream`(内存操作)\n- 创建目录\n- 递归创建目录\n- 删除单个文件/空目录\n- 获取指定目录下的文件信息列表\n- 获取文件/目录信息\n- 递归获取文件/目录信息\n- 递归删除目录\n- 监听目录变化（内部使用）\n- 异步上传后等待结果\n\n## 思路\n\n1. 定义顶层接口 `FtpOperator`，具体实现由子类（`BasicFtpOperatorImpl`, `SftpOperatorImpl`）完成\n2. 定义顶层配置文件基类 `FtpClientConfig`，包含着 ftp 连接必须的一些东西，具体细节在子类配置中 `BasicFtpClientConfig`, `SftpClientConfig`\n3. 添加工厂类 `FtpOperatorFactory`，根据不同子类的配置对象创建不同的 ftp 操作对象，并且一经创建就可以永久性使用\n4. 添加 `FtpWatchConfig`, `FtpWatch`, `FtpWatchFactory` FTP 监听器\n5. 添加集成 SpringBoot 中，读取 `application.yml` 中的配置，并创建不同的 `FtpOperator` 暴露给外部使用，动态初始化 FTP 监视器\n\n> 注：这里使用 FTP 监视器的原因是为了避免每次上传数据后都要单独监听 FTP 目录的变化，造成 FTP 多线程连接数量过多\n> 注：这里的并未实现 FTPClient 及 Jsch 的对象池管理，所以仅可参考实现，生产环境中仍需进行修改！\n\n图解如下\n\n![图解](https://img.rxliuli.com/20190226221826.png)\n\n## 实现\n\n具体的代码吾辈就不贴到这里了，全部的代码已经放到 [GitHub 的公共仓库](https://github.com/rxliuli/java-ftp-example) 上了。\n\n## FTP 使用\n\nFtpOperator API 图解  \n![FtpOperator API 图解](https://img.rxliuli.com/20190302115433.png)\n\n上传部分流程图解  \n![上传部分流程图解](https://img.rxliuli.com/20190302120512.png)\n\n### 使用 FtpOperator 进行基本操作\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class FtpSpringConfigTest {\n    private final Logger log = LoggerFactory.getLogger(getClass());\n    @Autowired\n    private FtpOperator ftp;\n\n    @Test\n    public void put() throws UnsupportedEncodingException {\n        // 上传数据\n        final ByteArrayInputStream is = new ByteArrayInputStream(\"测试数据\".getBytes(\"UTF-8\"));\n        final boolean result = ftp.put(is, \"/test.txt\");\n        assertThat(result)\n                .isTrue();\n    }\n\n    @Test\n    public void exist() {\n        // 判断数据是否存在于 ftp 服务器\n        final boolean exist = ftp.exist(\"/test.txt\");\n        assertThat(exist)\n                .isTrue();\n    }\n\n    @Test\n    public void get() {\n        // 从 ftp 服务器上下载数据\n        ftp.get(\"/test.txt\", is -> {\n            try {\n                final List<String> list = IOUtils.readLines(is);\n                log.info(\"list: {}\", list);\n                assertThat(list)\n                        .isNotEmpty();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n\n        });\n    }\n\n    @Test\n    public void mkdir() {\n        // 创建文件夹\n        assertThat(ftp.mkdir(\"/test\"))\n                .isTrue();\n    }\n\n    @Test\n    public void mkdirR() {\n        // 递归创建文件夹\n        assertThat(ftp.mkdirR(\"/test/test2/test3\"))\n                .isTrue();\n    }\n\n    @Test\n    public void ls() {\n        // 获取目录下的文件信息列表\n        final List<Stat> list = ftp.ls(\"/\");\n        log.info(\"list: {}\", list.stream()\n                .map(Stat::getPath)\n                .collect(Collectors.joining(\"\\n\")));\n        assertThat(list)\n                .isNotEmpty();\n    }\n\n    @Test\n    public void lsr() {\n        // 获取目录下的文件信息列表\n        final List<Stat> list = ftp.lsR(\"/\");\n        log.info(\"list: {}\", list.stream()\n                .map(Stat::getPath)\n                .collect(Collectors.joining(\"\\n\")));\n        assertThat(list)\n                .isNotEmpty();\n    }\n\n    @Test\n    public void rm() {\n        // 删除单个文件\n        assertThat(ftp.rm(\"/test.txt\"))\n                .isTrue();\n    }\n\n    @Test\n    public void rmdir() {\n        // 删除指定空目录\n        assertThat(ftp.rmdir(\"/test/test2/test3\"))\n                .isTrue();\n    }\n\n    @Test\n    public void rmdirR() {\n        // 递归删除指定目录\n        assertThat(ftp.rmdirR(\"/test\"))\n                .isTrue();\n    }\n}\n```\n\n### 使用 FtpOperator 上传文件并监听结果\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class FtpSpringConfigTest extends BaseTest {\n    private final Logger log = LoggerFactory.getLogger(getClass());\n    @Autowired\n    private FtpOperator ftp;\n    @Test\n    public void watch() throws InterruptedException, UnsupportedEncodingException {\n        // 监听新文件 /test.md 的出现\n        final String path = \"/test.md\";\n        ftp.watch((Predicate<String>) str -> str.equals(path))\n                .thenAcceptAsync(stat -> {\n                    log.warn(\"stat: {}\", stat);\n                    assertThat(ftp.exist(stat.getPath()))\n                            .isNotNull();\n                });\n        // 创建测试文件\n        final ByteArrayInputStream is = new ByteArrayInputStream(\"测试数据\".getBytes(\"UTF-8\"));\n        log.warn(\"test file upload completed!\");\n        assertThat(ftp.put(is, path))\n                .isTrue();\n        // 注意，这里有一个问题就是如果程序结束的太快，那么更新将变得不可能的！\n        Thread.sleep(2000);\n        // 删除测试文件\n        ftp.rm(path);\n    }\n}\n```\n\n---\n\n那么，关于 Java 中使用 `FTP/SFTP` 便到此为止啦\n","createdTime":1587219249393,"updatedTime":1609305048233,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"a15c161497d14819971f4854862475f0","title":"Java8 函数式功能速查","body":"## 场景\n\n有时候使用 `lambda` 参数的时候忘记应该接口的名字，所以便在此写一下 Java8\n`function` 包下原生的相关接口，方便快速查找。\n\n## lambda 接口\n\n| class            | 参数    | 返回值    | `Stream` 示例     | 应用场景     |\n| ---------------- | ------- | --------- | ----------------- | ------------ |\n| `Function`       | `<T>`   | `<R>`     | `map/flatMap`     | 映射         |\n| `Consumer`       | `<T>`   | `void`    | `forEach/peek`    | 迭代         |\n| `Predicate`      | `<T>`   | `boolean` | `filter/anyMatch` | 过滤         |\n| `Supplier`       |         | `<R>`     | `generate`        | 生成         |\n| `BiFunction`     | `<U,T>` | `<T>`     | `reduce`          | 归纳         |\n| `UnaryOperator`  | `<T>`   | `<T>`     | `iterate`         | 映射相同类型 |\n| `BinaryOperator` | `<T,T>` | `<T>`     | `reduce`          | 归纳相同类型 |\n| `Comparator`     | `<T,T>` | `<U>`     | `sort`            | 比较         |\n\n## Stream 流\n\nStream 流为我们提供了一种简单的操作集合的方式，每个操作都具有原子性。\n\n| function         | 参数                    | 返回值        | 功能                            |\n| ---------------- | ----------------------- | ------------- | ------------------------------- |\n| `filter`         | `Predicate<T>`          | `Stream<T>`   | 过滤                            |\n| `map`            | `Function<T,T>`         | `Stream<T>`   | 映射                            |\n| `flatMap`        | `Function<T,Stream<T>>` | `Stream<T>`   | 压平映射                        |\n| `distinct`       |                         | `Stream<T>`   | 去重                            |\n| `sorted`         |                         | `Stream<T>`   | 排序, 要求 `T` 实现 `Closeable` |\n| `sorted`         | `Comparator<T>`         | `Stream<T>`   | 排序                            |\n| `peek`           | `Consumer<T>`           | `Stream<T>`   | 迭代，但有返回值                |\n| `limit`          | `long`                  | `Stream<T>`   | 限制数量                        |\n| `skip`           | `long`                  | `Stream<T>`   | 从开头丢弃指定数量的元素        |\n| `forEach`        | `Consumer<T>`           | `void`        | 迭代                            |\n| `forEachOrdered` | `Consumer<T>`           | `void`        | 保证顺序的迭代                  |\n| `toArray`        |                         | `Object[]`    | 转换为数组                      |\n| `toArray`        | `IntFunction<T[]>`      | `T[]`         | 转换为指定类型的数组            |\n| `reduce`         | `BinaryOperator<T>`     | `Optional<T>` | 归纳为一个元素                  |\n| `collect`        | `Collector<T,A,R>`      | `R`           | 将结果归集                      |\n| `min`            | `Comparator<T>`         | `Optional<T>` | 最小值                          |\n| `max`            | `Comparator<T>`         | `Optional<T>` | 最大值                          |\n| `count`          |                         | `long`        | 长度                            |\n| `anyMatch`       | `Predicate<T>`          | `boolean`     | 是否存在匹配的元素              |\n| `allMatch`       | `Predicate<T>`          | `boolean`     | 是否所有元素都匹配              |\n| `noneMatch`      | `Predicate<T>`          | `boolean`     | 是否所有元素都不匹配            |\n| `findFirst`      |                         | `Optional<T>` | 查找第一个元素                  |\n| `findAny`        |                         | `Optional<T>` | 查找任意一个元素                |\n| `empty`          |                         | `Stream<T>`   | 获取一个空的流                  |\n| `of`             | `T...`                  | `Stream<T>`   | 将多个元素构造为流              |\n| `iterate`        | `T,UnaryOperator<T>`    | `Stream<T>`   | 构造无限有序流                  |\n| `generate`       | `Supplier`              | `Stream<T>`   | 构造无限无序流                  |\n| `concat`         | `Stream<T>,Stream<T>`   | `Stream<T>`   | 连接两个流                      |\n| `parallel`       |                         | `Stream<T>`   | 将流转换为并行模式（多线程）    |\n\n## Collectors\n\nCollectors 是一个 Java8 增加的一个工具类，用于简单的构造 `Collector` 接口的实现，主要用于 `Stream.collect()` 中的参数。`Stream.collect()` 用于将流转换为其他的数据结构，包括但不限于 `Collection`, `Map`, `String`, `Long` 等等，并以此衍生出了许多有用的操作：分组，转换为 `Map`，归约（`reduce` 的另一种使用方式），连接（归约的特化形式）\n\n| function               | 功能                                                                                                       | 示例 |\n| ---------------------- | ---------------------------------------------------------------------------------------------------------- | ---- |\n| `toList`               | 转换为 `List`                                                                                              |\n| `toSet`                | 转换为 `Set`                                                                                               |\n| `toMap`                | 转换为 `Map`                                                                                               |\n| `toCollection`         | 转换为 `Collection` 的子类                                                                                 |\n| `joining`              | 所有元素连接为 `String`, 可以指定**分隔符/开头/结尾**                                                      |\n| `mapping`              | 在转换之前对每个元素进行映射，常用于分组                                                                   |\n| `collectingAndThen`    | 在转为之前对结果进行一些操作，例如构造不可变集合                                                           |\n| `counting`             | 计算元素总数                                                                                               |\n| `minBy`                | 最小值                                                                                                     |\n| `maxBy`                | 最大值                                                                                                     |\n| `summingInt`           | 计算总和（结果为 `Integer`）                                                                               |\n| `summingLong`          | 计算总和（结果为 `Long`）                                                                                  |\n| `summingDouble`        | 计算总和（结果为 `Double`）                                                                                |\n| `averagingInt`         | 计算平均值（结果为 `Integer`）                                                                             |\n| `averagingLong`        | 计算平均值（结果为 `Long`）                                                                                |\n| `averagingDouble`      | 计算平均值（结果为 `Double`）                                                                              |\n| `reducing`             | 归纳, 与 `Stream.reduce()` 功能相同                                                                        |\n| `groupingBy`           | 分组, `Collectors` 独有                                                                                    |\n| `groupingByConcurrent` | 并发分组                                                                                                   |\n| `partitioningBy`       | 特化分组, 分成 `true` 和 `false`                                                                           |\n| `toMap`                | 转换为 `Map`                                                                                               |\n| `toConcurrentMap`      | 转换为并发 `Map`                                                                                           |\n| `summarizingInt`       | 汇总信息并尽可能返回 `Integer`。注: `summarizing*` 的方法汇总的信息都是 **数量/求和/平均值/最小值/最大值** |\n| `summarizingLong`      | 汇总信息并尽可能返回 `Long`                                                                                |\n| `summarizingDouble`    | 汇总信息并尽可能返回 `Double`                                                                              |\n\n## 一些示例\n\n### 常见 Stream 操作\n\n```java\nfinal List<String> collect = Stream.of(\"1\", \"12\", \"\", \"123\", \"2\", \"12\", \"321\", \"\")\n                //过滤\n                .filter(s -> !s.isEmpty())\n                //提取出组成字符串的字符\n                .flatMap(s -> Arrays.stream(s.split(\"\")))\n                //去重\n                .distinct()\n                //转换为集合\n                .collect(Collectors.toList());\nSystem.out.println(collect); //结果是 [1, 2, 3]\n```\n\n### 常见 Collectors 操作\n\n```java\nfinal Map<Integer, List<List<String>>> collect = Stream.of(\"1\", \"12\", \"\", \"123\", \"2\", \"13\", \"321\", \"\")\n        .collect(\n                //分组\n                Collectors.groupingBy(\n                        //分组条件\n                        String::length,\n                        //分组之前对每个元素进行映射\n                        Collectors.mapping(\n                                //映射函数\n                                s -> Arrays.asList(s.split(\"\")),\n                                //最后将 Stream 转换为 List\n                                Collectors.toList()\n                        )\n                )\n        );\nSystem.out.println(collect); //结果是 {0=[[], []], 1=[[1], [2]], 2=[[1, 2], [1, 3]], 3=[[1, 2, 3], [3, 2, 1]]}\n```\n\n---\n\n最后，Java8 有很多有趣的功能，或许我们所使用的不过是其中一个很小的子集，然而了解的越多越是觉得 Java8 的改进很多呢\n\n> 注：本文并非 `API` 列表，并未包含**全部**的功能，所以如果找不到所需要的函数可以查看 [JDK8 Oracle Documentation](https://docs.oracle.com/javase/8/)\n","createdTime":1587219249394,"updatedTime":1609305044868,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"4550b527cf7347e4b63ec081299ec120","title":"Java8 时间格式化 DateTimeFormatter","body":"## 场景\n\n吾辈在使用 Java8 的 `LocalDateTime` 想要根据某种格式格式化字符串为日期时间，本以来会简单的事情，事实上却出乎预料！\n\n## 问题\n\n想要格式化一个字符串为日期时间。例如常见的 `yyyy-MM-dd hh:mm:ss` 格式的 `2017-12-11 10:11:05`，吾辈习惯性的写出以下代码\n\n```java\nfinal String text = \"2017-12-11 10:11:05\";\nfinal String pattern = \"yyyy-MM-dd hh:mm:ss\";\nfinal LocalDateTime dateTime = LocalDateTime.parse(text, DateTimeFormatter.ofPattern(pattern));\nSystem.out.println(dateTime);\n```\n\n谜之音：**JVM** 不想理你，并抛给了你一个 **Error**\n\n```sh\njava.time.format.DateTimeParseException: Text '2017-12-11 10:11:05' could not be parsed: Unable to obtain LocalDateTime from TemporalAccessor: {MinuteOfHour=11, MilliOfSecond=0, MicroOfSecond=0, SecondOfMinute=5, HourOfAmPm=10, NanoOfSecond=0},ISO resolved to 2017-12-11 of type java.time.format.Parsed\n```\n\n大意便是无法解析，去 Google 了一下，在 StackOverflow 上发现了这个问题：[DateTimeParseException: Text could not be parsed: Unable to obtain LocalDateTime from TemporalAccessor\n](https://stackoverflow.com/questions/43732751/)\n\n里面的答案说是使用 `HH`（每小时）而非 `hh`（每小时上午时钟），所以吾辈修改了代码，变成了下面这样\n\n```java\nfinal String text = \"2017-12-11 10:11:05\";\n// 只改了这里的格式\nfinal String pattern = \"yyyy-MM-dd HH:mm:ss\";\nfinal LocalDateTime dateTime = LocalDateTime.parse(text, DateTimeFormatter.ofPattern(pattern));\nSystem.out.println(dateTime);\n```\n\n然而确实能正常解析了！？？**#黑人问号**\n\n## 根源\n\n去看了一下 Java8 的 `DateTimeFormatter` 日期时间格式化类，发现了 class 上一段有趣的注释\n\nAll letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters. The\nfollowing pattern letters are defined:\n\n| Symbol | Meaning                    | Presentation | Examples                                       |\n| ------ | -------------------------- | ------------ | ---------------------------------------------- |\n| `G`    | era                        | text         | AD; Anno Domini; A                             |\n| `u`    | year                       | year         | 2004; 04                                       |\n| `y`    | year-of-era                | year         | 2004; 04                                       |\n| `D`    | day-of-year                | number       | 189                                            |\n| `M/L`  | month-of-year              | number/text  | 7; 07; Jul; July; J                            |\n| `d`    | day-of-month               | number       | 10                                             |\n| `Q/q`  | quarter-of-year            | number/text  | 3; 03; Q3; 3rd quarter                         |\n| `Y`    | week-based-year            | year         | 1996; 96                                       |\n| `w`    | week-of-week-based-year    | number       | 27                                             |\n| `W`    | week-of-month              | number       | 4                                              |\n| `E`    | day-of-week                | text         | Tue; Tuesday; T                                |\n| `e/c`  | localized day-of-week      | number/text  | 2; 02; Tue; Tuesday; T                         |\n| `F`    | week-of-month              | number       | 3                                              |\n| `a`    | am-pm-of-day               | text         | PM                                             |\n| `h`    | clock-hour-of-am-pm (1-12) | number       | 12                                             |\n| `K`    | hour-of-am-pm (0-11)       | number       | 0                                              |\n| `k`    | clock-hour-of-am-pm (1-24) | number       | 0                                              |\n| `H`    | hour-of-day (0-23)         | number       | 0                                              |\n| `m`    | minute-of-hour             | number       | 30                                             |\n| `s`    | second-of-minute           | number       | 55                                             |\n| `S`    | fraction-of-second         | fraction     | 978                                            |\n| `A`    | milli-of-day               | number       | 1234                                           |\n| `n`    | nano-of-second             | number       | 987654321                                      |\n| `N`    | nano-of-day                | number       | 1234000000                                     |\n| `V`    | time-zone ID               | zone-id      | America/Los_Angeles; Z; -08:30                 |\n| `z`    | time-zone name             | zone-name    | Pacific Standard Time; PST                     |\n| `O`    | localized zone-offset      | offset-O     | GMT+8; GMT+08:00; UTC-08:00;                   |\n| `X`    | zone-offset 'Z' for zero   | offset-X     | Z; -08; -0830; -08:30; -083015; -08:30:15;     |\n| `x`    | zone-offset                | offset-x     | +0000; -08; -0830; -08:30; -083015; -08:30:15; |\n| `Z`    | zone-offset                | offset-Z     | +0000; -0800; -08:00;                          |\n| `p`    | pad next                   | pad modifier | 1                                              |\n| `'`    | escape for text            | delimiter    |                                                |\n| `''`   | single quote               | literal '    |                                                |\n| `[`    | optional section start     |              |                                                |\n| `]`    | optional section end       |              |                                                |\n| `#`    | reserved for future use    |              |                                                |\n| `{`    | reserved for future use    |              |                                                |\n| `}`    | reserved for future use    |              |                                                |\n\n是的，这是一个日期格式的说明，在这里确实可以看到 `HH` 才代表的是 24 小时，而 `hh` 则是将小时分为 `am/pm`（上午/下午）。\n\n> 附：这里吐槽一下，Java 的格式化规则居然和标准的有偏差，`uuuu` 也能当作更好的 `yyyy` 使用（主要针对负的年份）\n\n所以现在也只能将格式化时间的 pattern 修改为 `uuuu-MM-dd HH:mm:ss` 便能正常匹配了！\n\n## 解决\n\n那么，既然知道日期时间格式化模式的规则，那么接下来就可以直接写模式字符串了\n\n- 日期：`uuuu-MM-dd`\n- 时间：`HH:mm:ss`\n- 常见的日期时间：`uuuu-MM-dd HH:mm:ss`\n- 标准的日期时间：`DateTimeFormatter.ISO_DATE_TIME`（Java8 time 库中已存在）\n\n将字符串转换为日期时间大致有两种方式\n\n```java\nfinal String text = \"2019-02-12T01:24:07.425Z\";\n// 先解析为时间在转换为具体的日期时间类\nfinal LocalDateTime from = LocalDateTime.from(DateTimeFormatter.ISO_DATE_TIME.parse(text));\n// 直接根据指定的格式解析字符串为具体的日期时间类\nfinal LocalDateTime parse = LocalDateTime.parse(text, DateTimeFormatter.ISO_DATE_TIME);\n```\n\n---\n\n那么，`Java8` 的踩坑之路还在继续，不知还有多少人在用 `Java7-` 呢？＼（＠￣ ∇ ￣＠）／\n","createdTime":1587219249394,"updatedTime":1609305041247,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"0e503f26d34f4187a9710f24e937d7f6","title":"Spring 配置静态资源访问后结果发生 404 了？","body":"## 场景\n\n这两天使用 SpringMVC 时突然发现了一个问题，在 `spring-mvc.xml` 中配置静态资源访问以后，突然发现访问什么 `Controller` 控制的页面都 404 了。  \n如果把这个配置删除后，就能正常访问了，后来在与曾经的项目配置文件对比时发现是缺少了配置 `<mvc:annotation-driven/>`。  \n然而，在没有添加静态资源访问时，没有这个配置也能够使用 `Controller` 控制器。吾辈好奇的去网络上查询了一下 `<mvc:annotation-driven/>` 相关的信息，在此记录到 blogger 中，以供日后查阅。\n\n吾辈的 `spring-mvc.xml` 中的静态资源访问配置：\n\n```xml\n<!--扫描静态资源文件-->\n<mvc:default-servlet-handler/>\n<mvc:resources mapping=\"/statics/**\" location=\"/statics/\"/>\n```\n\n那么，下面就说一下 `<mvc:annotation-driven/>` 具体有什么作用好啦！\n`<mvc:annotation-driven>` 相当于注册了 `Spring MVC` 分发请求到控制器所必须 `DefaultAnnotationHandlerMapping` 和 `AnnotationMethodHandlerAdapter` 两个 Bean，配置一些 messageconvert。即解决了 `@Controller` 注解的使用前提配置。\n\n配置中如果没有 `<mvc:annotation-driven/>`，那么所有的 `Controller` 可能就没有解析，所有当有请求时候都没有匹配的处理请求类，就都去 `<mvc:default-servlet-handler/>` 即 `default servlet` 处理了。添加上 `<mvc:annotation-driven/>` 后，相应的请求被 `Controller` 处理，而静态资源因为没有相应的 `Controller` 就会被 `default servlet` 处理。总之没有相应的 `Controller` 就会被 `default servlet` 处理就 ok 了。\n\n然后，`<mvc:annotation-driven/>` 标签配置的这 2 个 Bean 可以根据 classpath 中的内容默认提供以下功能：\n\n1. Support for Spring 3's Type ConversionService in addition to JavaBeans PropertyEditors during Data Binding.A ConversionService instance produced by the org.springframework.format.support.FormattingConversionServiceFactoryBean is used by default.This can be overriden by setting the conversion-service attribute.  \n   支持 spring3 的 javaBeans 属性编辑器数据绑定时的类型转换服务。\n   类型转换服务实例默认为 org.springframework.format.support.FormattingConversionServiceFactoryBean。\n   可以覆盖 conversion-service 属性来指定类型转换服务实例类。\n2. Support for formatting Number fields using the @NumberFormat annotation.  \n   支持 @NumberFormat 注解格式化数字类型字段。\n3. Support for formatting Date, Calendar, Long, and Joda Time fields using the @DateTimeFormat annotation, if Joda Time 1.3 or higher is present on the classpath.  \n   @DateTimeFormat 注解格式化 Date, Calendar, Long 和 Joda Time（如 classpath 下存在 Joda Time 1.3 或更高版本）字段\n4. Support for validating @Controller inputs with @Valid, if a JSR-303 Provider is present on the classpath.The validation system can be explicitly configured by setting the validator attribute.  \n   支持 @Valid 注解验证控制器数据，classpath 中需 JSR-303 的 \\*\\*。可以使用 setting 明确的配置\n5. Support for reading and writing XML, if JAXB is present on the classpath.  \n   支持读写 xml，classpath 中需 JAXB 。\n6. Support for reading and writing JSON, if Jackson is present on the classpath.  \n   支持读写 json，classpath 中需 Jackson 。\n\n嗯，这篇 blogger 就这么多啦(其实大部分都是借鉴网络上诸位大佬的啦)\n","createdTime":1587219249394,"updatedTime":1609305037497,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"c3b0f31116a54d93ad13f48dd4bdd9b2","title":"MybatisPlus 自定义全局操作 exists 一直返回 null","body":"## 场景\n\n为 `mybatis-plus` 自定义了一个全局操作，然后就一直返回 `null`。。。\n\n在自定义 sql 注入器类的时候，突然发现 `existsById()` 一直都在抛空指针异常，就去看了一下结果发现一直返回 `null`。\n\n```java\npackage com.rxliuli.example.mybatisplussqlinjector.config;\n\nimport com.baomidou.mybatisplus.entity.TableInfo;\nimport com.baomidou.mybatisplus.mapper.AutoSqlInjector;\nimport org.apache.ibatis.builder.MapperBuilderAssistant;\nimport org.apache.ibatis.mapping.SqlSource;\nimport org.apache.ibatis.session.Configuration;\n\n/**\n * 自定义 sql 注入器\n * 注: 此处不能声明为 Bean, 因为回和 MybatisPlus 自己的 SqlInjector 冲突\n */\npublic class CustomSqlInjector extends AutoSqlInjector {\n    /**\n     * 根据 id 确定数据是否存在\n     */\n    private static final String SQL_EXISTS_BY_ID = \"select exists(select 0 from %s where id = #{id});\";\n\n    @Override\n    public void inject(Configuration configuration, MapperBuilderAssistant builderAssistant, Class<?> mapperClass, Class<?> modelClass, TableInfo table) {\n        existsById(mapperClass, modelClass, table);\n    }\n\n    public void existsById(Class<?> mapperClass, Class<?> modelClass, TableInfo table) {\n        final String sql = String.format(SQL_EXISTS_BY_ID, table.getTableName());\n        final SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);\n        this.addSelectMappedStatement(mapperClass, \"existsById\", sqlSource, modelClass, table);\n    }\n}\n```\n\n自定义的 `BaseDao` 基类\n\n```java\npackage com.rxliuli.example.mybatisplussqlinjector.common.dao;\n\nimport com.baomidou.mybatisplus.mapper.BaseMapper;\nimport org.apache.ibatis.annotations.Param;\n\nimport java.io.Serializable;\n\n/**\n * @author rxliuli\n */\npublic interface BaseDao<T extends Serializable> extends BaseMapper<T> {\n    /**\n     * 根据 id 查询数据是否存在\n     *\n     * @param id 数据 id\n     * @return 数据是否存在\n     */\n    Boolean existsById(@Param(\"id\") Long id);\n}\n```\n\n测试代码\n\n```java\npackage com.rxliuli.example.mybatisplussqlinjector.dao;\n\nimport com.rxliuli.example.mybatisplussqlinjector.entity.User;\nimport common.test.BaseDaoAndServiceTest;\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class UserDaoTest extends BaseDaoAndServiceTest<UserDao> {\n    @Test\n    public void existsById() {\n        final Boolean res = base.existsById(1L);\n        log.debug(\"res: {}\", res);\n        assertThat(res)\n                .isTrue();\n    }\n\n    @Test\n    public void selectById() {\n        final User user = base.selectById(1L);\n        log.debug(\"user: {}\", user);\n        assertThat(user)\n                .isNotNull();\n    }\n}\n```\n\n结果\n\n![测试结果](https://img.rxliuli.com/20181211202332.png)\n\n然而，当我把全局注入的 sql 操作放到 xml 文件时\n\nDao 和对应的 xml 文件\n\n```java\npackage com.rxliuli.example.mybatisplussqlinjector.dao;\n\nimport com.rxliuli.example.mybatisplussqlinjector.common.dao.BaseDao;\nimport com.rxliuli.example.mybatisplussqlinjector.entity.User;\nimport org.apache.ibatis.annotations.Param;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface UserDao extends BaseDao<User> {\n    @Override\n    Boolean existsById(@Param(\"id\") Long id);\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.rxliuli.example.mybatisplussqlinjector.dao.UserDao\">\n    <select id=\"existsById\" resultType=\"java.lang.Boolean\">\n        select exists(select 0\n                      from user\n                      where id = #{id});\n    </select>\n</mapper>\n```\n\n现在，一切又能正常运行了，这其中到底发生了什么呢？\n\n![测试正常运行](https://img.rxliuli.com/20181211202834.png)\n\n> 目前该问题已经在 [官方 GitHub](https://github.com/baomidou/mybatis-plus) 上提出了一个 [issue](https://github.com/baomidou/mybatis-plus/issues/694)\n\n## 解决\n\n好吧，开发人员说是要在使用 `addSelectMappedStatement()` 时对返回值进行界定，之前一直查的都是表数据确实没注意到还需要对返回值类型进行界定呢\n\n修改的地方其实只有一处\n\n```java\npackage com.rxliuli.example.mybatisplussqlinjector.config;\n\nimport com.baomidou.mybatisplus.entity.TableInfo;\nimport com.baomidou.mybatisplus.mapper.AutoSqlInjector;\nimport org.apache.ibatis.builder.MapperBuilderAssistant;\nimport org.apache.ibatis.mapping.SqlSource;\nimport org.apache.ibatis.session.Configuration;\n\n/**\n * 自定义 sql 注入器\n * 注: 此处不能声明为 Bean, 因为回和 MybatisPlus 自己的 SqlInjector 冲突\n */\npublic class CustomSqlInjector extends AutoSqlInjector {\n    /**\n     * 根据 id 确定数据是否存在\n     */\n    private static final String SQL_EXISTS_BY_ID = \"select exists(select 0 from %s where id = #{id});\";\n\n    @Override\n    public void inject(Configuration configuration, MapperBuilderAssistant builderAssistant, Class<?> mapperClass, Class<?> modelClass, TableInfo table) {\n        existsById(mapperClass, modelClass, table);\n    }\n\n    public void existsById(Class<?> mapperClass, Class<?> modelClass, TableInfo table) {\n        final String sql = String.format(SQL_EXISTS_BY_ID, table.getTableName());\n        final SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);\n        // 注：在此处界定返回值类型\n        this.addSelectMappedStatement(mapperClass, \"existsById\", sqlSource, Boolean.class, table);\n    }\n}\n```\n\n> 代码已经上传到 [GitHub](https://github.com/rxliuli/mybatis-plus-sql-injector-example)\n\n虽然只是个不起眼的小错误，不过这里还是记录一下吧，毕竟坑只要踩过一次就够了 ┐(￣ヮ￣)┌\n","createdTime":1587219249394,"updatedTime":1609305029930,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"8f7de362e0024b428f5393c21a71dfdc","title":"SpringBoot 使用 Jackson 处理 Java8 时间 API","body":"## 场景\n\n在项目中的实体类里面使用了 `Java8` 新的时间 API，例如 `LocalDate`, `LocalTime`, `LocalDateTime` 等。然而在将这些时间类型的字段序列化返回到前端时，但格式却感觉有些异常。\n\n嗯，大概就是下面这种样子的\n\n```json\n{\n  \"dayOfMonth\": 27,\n  \"dayOfWeek\": \"MONDAY\",\n  \"dayOfYear\": 239,\n  \"month\": \"AUGUST\",\n  \"monthValue\": 8,\n  \"year\": 2018,\n  \"hour\": 10,\n  \"minute\": 0,\n  \"nano\": 370000000,\n  \"second\": 52,\n  \"chronology\": {\n    \"id\": \"ISO\",\n    \"calendarType\": \"iso8601\"\n  }\n}\n```\n\n这是什么鬼的格式。。。\n\n## 解决方案\n\n添加依赖\n\n```xml\n<dependency>\n    <groupId>com.fasterxml.jackson.datatype</groupId>\n    <artifactId>jackson-datatype-jsr310</artifactId>\n</dependency>\n```\n\n修改 `application.yml`，配置 `spring.jackson.serialization.write_dates_as_timestamps` 禁用 _打印日期为时间戳的功能_。\n\n```yaml\nspring:\n  jackson:\n    serialization:\n      write_dates_as_timestamps: false\n```\n\n如此，在返回数据到前端的时候 SpringBoot 就会自动将日期格式化为 `yyyy-MM-ddThh:mm:ss`\n\n然而，如果我们想要在程序中手动的序列化日期怎么办呢？实际上也很简单，使用代码 `.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)` 来禁止序列化时间为时间戳并注册 `jackson-datatype-jsr310` 中的 `JavaTimeModule` 模块。\n\n下面是吾辈在项目里使用的一个全局 `ObjectMapper` 对象\n\n```java\n/**\n  * 提供一个全局可用的序列化 Bean\n  */\npublic static final ObjectMapper OM = new ObjectMapper()\n        //Date 对象的格式\n        .setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"))\n        //禁止序列化值为 null 的属性\n        .setSerializationInclusion(JsonInclude.Include.NON_NULL)\n        //禁止序列化时间为时间戳\n        .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n        .registerModules(\n                //注册 Jsr310（Java8 的时间兼容模块）\n                new JavaTimeModule(),\n                //序列化 Long 为 String\n                new SimpleModule()\n                        //大数字直接序列化为 String\n                        .addSerializer(Long.class, ToStringSerializer.instance)\n                        .addSerializer(Long.TYPE, ToStringSerializer.instance)\n                        .addSerializer(long.class, ToStringSerializer.instance)\n                        .addSerializer(BigInteger.class, ToStringSerializer.instance)\n                        //大浮点数直接序列化为 String\n                        .addSerializer(BigDecimal.class, new JsonSerializer<BigDecimal>() {\n                            @Override\n                            public void serialize(BigDecimal value, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n                                gen.writeString(value.setScale(10, BigDecimal.ROUND_HALF_UP).toPlainString());\n                            }\n                        })\n        )\n        //JSON 序列化移除 transient 修饰的 Page 无关紧要的返回属性(Mybatis Plus)\n        .configure(MapperFeature.PROPAGATE_TRANSIENT_MARKER, true);\n```\n\n那么，以上就是 SpringBoot 序列化 Java8 时间 API 的问题和解决方案啦 ヾ(@^▽^@)ノ\n","createdTime":1587219249395,"updatedTime":1609305012897,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"e0271cf3c06f49d7b3c51372e1893e10","title":"SpringBoot 使用阿里云的短信服务出现问题","body":"## 异常\n\n```java\nException in thread \"main\" java.lang.NoSuchMethodError: org.json.JSONArray.iterator()Ljava/util/Iterator;\n\tat com.aliyuncs.regions.LocalEndpointResolver.<init>(LocalEndpointResolver.java:39)\n\tat com.aliyuncs.profile.DefaultProfile.<init>(DefaultProfile.java:72)\n\tat com.aliyuncs.profile.DefaultProfile.getProfile(DefaultProfile.java:209)\n\tat com.rx.f3d.common.util.SmsSendUtil.main(SmsSendUtil.java:28)\n```\n\n## 解决方案\n\n`NoSuchMethodError` 不能找到方法，吾辈第一感觉就是包冲突了。去网络找了一圈，大概有下面这几种说法\n\n- 从 `spring-boot-*-starter` 中排除掉 `andriod-json` 包，避免与 `aliyun-java-sdk-core` 依赖的 `json` 包冲突  \n  链接：<https://github.com/qcloudsms/qcloudsms_java/wiki/maven%E8%A7%A3%E5%86%B3org.json%E5%86%B2%E7%AA%81%E7%A4%BA%E4%BE%8B>\n- 不使用 `Maven`，手动引入 `Jar` 到项目中  \n  链接：<https://blog.csdn.net/liuxiaochang_2011/article/details/80468746>\n- 修改 `aliyun-java-sdk-core` 的版本  \n  链接：<http://www.mamicode.com/info-detail-2396491.html>\n\n对于吾辈而言，只有最后一种方法是有效的。当然，吾辈修改的版本是 `3.3.1` 才行的呢\n\n```xml\n<dependency>\n    <groupId>com.aliyun</groupId>\n    <artifactId>aliyun-java-sdk-core</artifactId>\n    <version>3.3.1</version>\n</dependency>\n<dependency>\n    <groupId>com.aliyun</groupId>\n    <artifactId>aliyun-java-sdk-dysmsapi</artifactId>\n    <version>1.1.0</version>\n</dependency>\n```\n\n修改完后记得清空缓存并重启 `IDE` ，然后删除 `maven` 本地仓库下的 `aliyun-java-sdk-core` 包以避免缓存问题。\n\n> 注：吾辈使用的 `SpringBoot` 版本是 `1.5.12.RELEASE`，可能和这个也有关系呢\n","createdTime":1587219249395,"updatedTime":1609304998002,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"2edc3c5f92714553a1ccb1adb0758aa6","title":"SpringBoot 集成 WebSocket","body":"- [SpringBoot 集成 WebSocket](#springboot-集成-websocket)\n  - [场景 & 需求](#场景--需求)\n  - [前置知识](#前置知识)\n  - [引入依赖](#引入依赖)\n  - [配置 `SpringBoot WebSocket` 支持](#配置-springboot-websocket-支持)\n  - [双向广播服务端](#双向广播服务端)\n  - [双向广播客户端](#双向广播客户端)\n  - [单向广播服务端](#单向广播服务端)\n  - [单向广播客户端](#单向广播客户端)\n  - [点对点推送服务端](#点对点推送服务端)\n  - [点对点推送客户端](#点对点推送客户端)\n  - [单向点对点推送服务端](#单向点对点推送服务端)\n  - [单向点对点推送客户端](#单向点对点推送客户端)\n  - [记录 user -> Socket 会话对应的映射表](#记录-user---socket-会话对应的映射表)\n  - [接受/返回复杂类型的消息（服务端）](#接受返回复杂类型的消息服务端)\n  - [发送/订阅复杂类型的消息（客户端）](#发送订阅复杂类型的消息客户端)\n  - [WebSocket 客户端封装](#websocket-客户端封装)\n\n## 场景 & 需求\n\n1. 客户端发送请求后，服务端进行处理后可以对所有的客户端进行 **广播**\n2. 服务端可以在任何时候主动对所有客户端进行 **广播**\n3. 客户端发送请求后，服务端进行处理后可以对指定客户端进行 **点对点推送**\n4. 服务端可以在任何时候主动对指定客户端进行 **点对点推送**\n5. 服务端可以在任何时候主动对指定某些客户端进行 **广播**\n6. 服务端可以识别客户端（状态），并以此进行 **点对点推送**\n\n## 前置要求\n\n本文假设你已经了解或知道以下技能，尤其而且是勾选的内容。\n\n- [x] Java\n- [x] Maven\n- [x] SpringBoot\n\n## 引入依赖\n\n创建一个 `SpringBoot` 项目，并添加 `spring-boot-starter-websocket` 依赖\n\n```xml\n<!--spring boot web socket-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-websocket</artifactId>\n</dependency>\n```\n\n## 配置 `SpringBoot WebSocket` 支持\n\n```java\n/**\n * 配置 SpringBoot WebSocket 支持\n *\n * @author rxliuli\n */\n@Configuration\n@EnableWebSocketMessageBroker\npublic class SpringWebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {\n    /**\n     * 注册一个 Socket 端点\n     *\n     * @param stompEndpointRegistry stomp 端点注册表\n     */\n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry stompEndpointRegistry) {\n        stompEndpointRegistry.addEndpoint(\"/endpoint\")\n                //设置允许所有源请求（跨域）\n                .setAllowedOrigins(\"*\")\n                .withSockJS();\n    }\n\n    /**\n     * 注册一些广播消息代理\n     *\n     * @param registry 消息代理注册对象\n     */\n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry registry) {\n        //注册简单代理（里面是前缀）\n        //注：默认 topic 是主题（广播），user 则是用户（点对点）\n        registry.enableSimpleBroker(\"/topic\", \"/user\");\n    }\n}\n```\n\n## 双向广播服务端\n\n客户端发送请求后，服务端进行处理后可以对所有的客户端进行 **广播**\n\n```java\n/**\n * 双向广播控制器\n *\n * @author rxliuli\n */\n@Controller\npublic class BilateralBroadcastingSocket {\n    /**\n     * 广播推送\n     * 注解 @Payload 是为了绑定消息到参数 text 上\n     *\n     * @param text      简单的文本信息\n     * @param sessionId 当前请求 socket 会话 id\n     * @return 会话 id 和消息内容\n     */\n    @MessageMapping(value = \"/talk\")\n    @SendTo(\"/topic/broadcasting/bilateral/allClient\")\n    public String talk(@Payload String text, @Header(\"simpSessionId\") String sessionId) throws InterruptedException {\n        //模拟处理其他事情\n        Thread.sleep(1000L);\n        return \"[ \" + sessionId + \"] 说: [\" + text + \"]\";\n    }\n}\n```\n\n## 双向广播客户端\n\n向服务端发送消息，并监听服务端的广播。客户端发送消息与监听是分离的，也可以只向服务端发送消息而不监听广播，或者只接收广播不发送消息。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n    <title>Document</title>\n  </head>\n\n  <body>\n    <script\n      type=\"application/javascript\"\n      src=\"https://cdn.bootcss.com/sockjs-client/1.1.4/sockjs.min.js\"\n    ></script>\n    <script\n      type=\"application/javascript\"\n      src=\"https://cdn.bootcss.com/stomp.js/2.3.3/stomp.min.js\"\n    ></script>\n    <script>\n      let socket = new SockJS('http://127.0.0.1:8080/endpoint')\n      stompClient = Stomp.over(socket)\n      stompClient.connect(\n        {},\n        // 连接成功回调函数\n        (frame) => {\n          console.log('服务端 Socket 连接建立')\n\n          // 获取 websocket 连接的 sessionId\n          const sessionId = /\\/([^\\/]+)\\/websocket/.exec(\n            socket._transport.url,\n          )[1]\n          console.log('connected, session id: ' + sessionId)\n\n          // 订阅广播消息（双向通信）\n          // 这里是关键（订阅了服务端的 topic）\n          stompClient.subscribe(\n            '/topic/broadcasting/bilateral/allClient',\n            (res) => {\n              console.log(`[广播（双向通信）]: ${res.body}`)\n            },\n          )\n\n          // 发送请求\n          send()\n        },\n        (error) => {\n          console.log('Socket 连接失败')\n        },\n      )\n\n      function send() {\n        // 发送一个消息到服务端\n        // 发送消息到服务端\n        var headers = {}\n        var body = {\n          message: '消息内容',\n        }\n        stompClient.send('/talk', headers, JSON.stringify(body))\n      }\n\n      /**\n       * 监听窗口关闭事件，窗口关闭前，主动关闭连接，防止连接还没断开就关闭窗口，server 端会抛异常\n       */\n      window.onbeforeunload = function () {\n        if (stompClient !== null) {\n          stompClient.disconnect()\n          socket.close()\n        }\n        console.log('断开连接')\n      }\n    </script>\n  </body>\n</html>\n```\n\n## 单向广播服务端\n\n从服务端推送消息到所有客户端，是单向推送到客户端的，不接受从客户端的输入。\n\n```java\n/**\n * 单向广播控制器\n *\n * @author rxliuli\n */\n@Controller\npublic class UnidirectionalBroadcastingSocket {\n    /**\n     * 从服务端推送消息到所有客户端\n     * 这是单向推送到客户端的，不接受从客户端的输入\n     */\n    @SendTo(\"/topic/broadcasting/unidirectional/allClient\")\n    public Object broadcasting() {\n        return null;\n    }\n}\n\n/**\n * 使用 Scheduled 不停的推送信息\n *\n * @author rxliuli\n */\n@Component\npublic class ScheduledRefreshJob {\n    @Autowired\n    private SimpMessagingTemplate simpMessagingTemplate;\n\n    /**\n     * 不停地推送消息到客户端\n     */\n    @Scheduled(fixedDelay = 10 * 1000)\n    public void scheduledBroadcasting() {\n        simpMessagingTemplate.convertAndSend(\"/topic/broadcasting/unidirectional/allClient\", new Person(1L, \"rx\", false));\n    }\n}\n```\n\n## 单向广播客户端\n\n客户端只需要添加一个监听器就好了，不需要也不能向服务端发送消息。\n\n```js\n// 订阅广播消息（服务端单向推送）\nconst subscription_broadcast = stompClient.subscribe(\n  '/topic/broadcasting/unidirectional/allClient',\n  (response) => {\n    console.log(`[广播（服务端单向推送）]: ${response.body}`)\n  },\n)\n```\n\n## 点对点推送服务端\n\n服务端使用 `@SendToUser(path)` 向单个客户端推送消息，这里的 `@Header(\"simpSessionId\")` 指的是从客户端的请求头中的 `simpSessionId` 参数赋值给 `sessionId`（`WebSocket` 会话 `ID`，和用户 `Session` 不同，是每一个 `WebSocket` 唯一的 #即和用户不是一一对应）\n\n```java\n/**\n * 双向点对点推送控制器\n *\n * @author rxliuli\n */\n@Controller\npublic class BilateralPushSocket {\n    /**\n     * 点对点推送（双向通信）\n     *\n     * @param text      消息\n     * @param sessionId 会话 id\n     * @return 推送到当前会话的消息\n     */\n    @MessageMapping(\"/speak\")\n    @SendToUser(\"/push/bilateral/thisClient\")\n    public String speak(@Payload String text, @Header(\"simpSessionId\") String sessionId) throws InterruptedException {\n        //模拟处理其他事情\n        Thread.sleep(1000L);\n        return \"[ \" + sessionId + \"] send: [\" + text + \"]\";\n    }\n}\n```\n\n## 点对点推送客户端\n\n客户端请求的路径需要注意一下，是以 `/user/${sessionId}` 开头，后面才是 `@SendToUser(path)` 中设置的 `path`。\n\n```js\n// 订阅私人消息（双向通信）\nstompClient.subscribe(`/user/${sessionId}/push/bilateral/thisClient`, (res) => {\n  console.log(`[点对点推送（双向通信）]: ${res.body}`)\n})\n```\n\n## 单向点对点推送服务端\n\n其实和上面双向的点对点推送没什么太大的差别，就是只用 `@SendToUser(path)` 而不用 `@MessageMapping(path)` 了而已\n\n```java\n/**\n * 单向点对点推送服务端\n *\n * @author rxliuli\n */\n@Controller\npublic class UnidirectionalPushSocket {\n    /**\n     * 从服务端推送消息到所有客户端\n     * 这是单向推送到客户端的，不接受从客户端的输入\n     */\n    @SendToUser(\"/push/unidirectional/thisClient\")\n    public Object push() {\n        return null;\n    }\n}\n\n/**\n * 使用 Scheduled 不停的推送信息\n *\n * @author rxliuli\n */\n@Component\npublic class ScheduledRefreshJob {\n    @Autowired\n    private SimpMessagingTemplate simpMessagingTemplate;\n\n    /**\n     * 不停推送消息到某个指定的客户端\n     */\n    @Scheduled(fixedDelay = 10 * 1000)\n    public void scheduledPush() {\n        simpMessagingTemplate.convertAndSendToUser(\"r2qspi4s\", \"/push/unidirectional/thisClient\", new Person(2L, \"琉璃\", false));\n    }\n}\n```\n\n## 单向点对点推送客户端\n\n客户端和上面的双向点对点推送基本一致（完全一样好么？！）\n\n```js\n// 订阅私人消息（单向通信）\nstompClient.subscribe(\n  `/user/${sessionId}/push/unidirectional/thisClient`,\n  (res) => {\n    console.log(`[点对点推送（单向通信）]：${res.body}`)\n  },\n)\n```\n\n## 记录 user -> Socket 会话对应的映射表\n\n上面的点对点推送客户端几乎是没什么用处的（尤其而且是 [单向点对点推送](#单向点对点推送服务端)），因为每次创建的 `Socket` 连接都会变化，而没有与用户建立对应关系的话怎无法知道哪个用户对应的哪个人，也就不能发送消息给指定的用户（非 `Socket Session Id`）了\n。\n\n1. 首先需要一个记录用户 `Socket Session Id` 的类，并注册为 SpringBoot 的组件。\n\n```java\n/**\n* 用户 session 记录类\n*\n* @author rxliuli\n*/\n@Component\npublic class SocketSessionRegistry {\n    /**\n    * 未登录的用户默认存储的 user id\n    */\n    public static final String DIRECT_TOURIST = \"DIRECT_TOURIST\";\n    /**\n    * 这个集合存储 用户 id -> session 列表\n    * 单个用户可能打开多个页面，就会出现多个 Socket 会话\n    */\n    private final ConcurrentMap<String, Set<String>> userSessionIds = new ConcurrentHashMap<>();\n    private final Object lock = new Object();\n\n    /**\n    * 根据 user id 获取 sessionId\n    *\n    * @param user 用户 id\n    * @return 用户关联的 sessionId\n    */\n    public Set<String> getSessionIds(String user) {\n        Set<String> set = this.userSessionIds.get(user);\n        return set != null ? set : Collections.emptySet();\n    }\n\n    /**\n    * 获取所有 session\n    *\n    * @return 所有的 用户 id -> session 列表\n    */\n    public ConcurrentMap<String, Set<String>> getAllSessionIds() {\n        return this.userSessionIds;\n    }\n\n    /**\n    * 根据用户 id 注册一个 session\n    *\n    * @param user      用户 id\n    * @param sessionId Socket 会话 id\n    */\n    public void registerSessionId(String user, String sessionId) {\n        Assert.notNull(user, \"User must not be null\");\n        Assert.notNull(sessionId, \"Session ID must not be null\");\n        synchronized (this.lock) {\n            Set<String> set = this.userSessionIds.get(user);\n            if (set == null) {\n                this.userSessionIds.put(user, new CopyOnWriteArraySet<>());\n            }\n            set.add(sessionId);\n        }\n    }\n\n    /**\n    * 根据用户 id 删除一个 session\n    *\n    * @param user      用户 id\n    * @param sessionId Socket 会话 id\n    */\n    public void unregisterSessionId(String user, String sessionId) {\n        Assert.notNull(user, \"User Name must not be null\");\n        Assert.notNull(sessionId, \"Session ID must not be null\");\n        synchronized (this.lock) {\n            Set set = this.userSessionIds.get(user);\n            if (set != null && set.remove(sessionId) && set.isEmpty()) {\n                this.userSessionIds.remove(user);\n            }\n        }\n    }\n}\n```\n\n2. 监听 `WebSocket` 连接建立和关闭事件\n\n```java\n/**\n* 会话事件监听基类\n*\n* @author rxliuli\n*/\npublic abstract class BaseSessionEventListener<Event extends AbstractSubProtocolEvent> implements ApplicationListener<Event> {\n    protected final Logger log = LoggerFactory.getLogger(getClass());\n    @Autowired\n    protected SocketSessionRegistry webAgentSessionRegistry;\n\n    /**\n    * 计算出 user id 和 session id 并传入到自定义的函数中\n    *\n    * @param event      事件\n    * @param biConsumer 自定义的操作\n    */\n    protected void using(Event event, BiConsumer<String, String> biConsumer) {\n        StompHeaderAccessor sha = StompHeaderAccessor.wrap(event.getMessage());\n        //login get from browser\n        List<String> shaNativeHeader = sha.getNativeHeader(\"Authorization\");\n        String user;\n        if (shaNativeHeader == null || shaNativeHeader.isEmpty()) {\n            user = null;\n        } else {\n            user = shaNativeHeader.get(0);\n        }\n        //如果当前用户没有登录（没有认证信息），就添加到游客里面\n        if (user == null || \"\".equals(user) || \"undefined\".equals(user) || \"null\".equals(user)) {\n            user = SocketSessionRegistry.DIRECT_TOURIST;\n        }\n        String sessionId = sha.getSessionId();\n        biConsumer.accept(user, sessionId);\n    }\n}\n\n/**\n* Socket 连接建立监听\n* 用于 session 注册 以及 key 值获取\n*\n* @author rxliuli\n*/\n@Component\npublic class SessionConnectEventListener extends BaseSessionEventListener<SessionConnectEvent> {\n    @Override\n    public void onApplicationEvent(SessionConnectEvent event) {\n        using(event, (user, sessionId) -> webAgentSessionRegistry.registerSessionId(user, sessionId));\n    }\n}\n\n/**\n* Socket 会话断开监听\n*\n* @author rxliuli\n*/\n@Component\npublic class SessionDisconnectEventListener extends BaseSessionEventListener<SessionDisconnectEvent> {\n    @Override\n    public void onApplicationEvent(SessionDisconnectEvent event) {\n        //这里先根据 session id 查询出 user，然后删除对应的会话 id\n        //前端无法传递 token 到这里却是只能出此下策了\n        using(event, (user, sessionId) -> webAgentSessionRegistry.getAllSessionIds().entrySet().stream()\n                .filter(sse -> sse.getValue().contains(sessionId))\n                .findFirst()\n                .ifPresent(sse -> {\n                    webAgentSessionRegistry.unregisterSessionId(sse.getKey(), sessionId);\n                    log.info(\"Socket 连接断开，用户：{}，会话：{}\", sse.getKey(), sessionId);\n                }));\n    }\n}\n```\n\n3. 客户端在打开和关闭连接的时候需要发送 user 给服务端\n\n这里使用 `headers` 存放用户认证信息（唯一标识），所以在连接和关闭时要带上请求头\n\n```java\nstompClient.connect(getHeaders(), function(){\n    console.log('打开 Socket 连接')\n})\n// TODO 这里还有一些问题，无法带上 headers 到后端\nstompClient.disconnect(function () {\n    console.log('断开连接');\n}, getHeaders());\n\n/**\n   * 获取一个认证的 headers 信息\n   * @return {{\"X-Requested-With\": string, Authorization: any}} 含有认证信息的 headers 对象\n   */\n  function getHeaders() {\n      return {\n          'X-Requested-With': 'X-Requested-With',\n          'Authorization': localStorage.token\n      }\n  }\n```\n\n4. 使用记录的 `user -> session id` 发送消息给指定的用户\n\n下面是获取到所有已经登录的用户的 `WebSocket` 连接并发送一条消息\n\n```java\nsocketSessionRegistry.getAllSessionIds().entrySet().stream()\n        .filter(kv -> !SocketSessionRegistry.DIRECT_TOURIST.equals(kv.getKey()))\n        .forEach(kv -> kv.getValue().forEach(sessionId -> simpMessagingTemplate.convertAndSendToUser(sessionId, \"/push/unidirectional/thisClient\", new Person(2L, \"琉璃\", false))));\n```\n\n## 接受/返回复杂类型的消息（服务端）\n\n其实看起来和刚才是没什么区别的，但 `SpringBoot WebSocket` 原本就对消息进行了解析/封装，所以我们不需要再去手动转换了\n\n```java\n/**\n * 接受和发送复杂类型的消息\n *\n * @author rxliuli\n */\n@Controller\npublic class ComplexMessageSocket {\n    /**\n     * 接收/返回复杂类型 Person 的对象\n     *\n     * @param person Person 类对象\n     * @return Person 类对象\n     */\n    @MessageMapping(\"/complexMessage\")\n    @SendTo(\"/topic/complexMessage/allClient\")\n    public Person complexMessage(Person person) {\n        return new Person().setName(\"Mr. \" + person.getName());\n    }\n}\n```\n\n## 发送/订阅复杂类型的消息（客户端）\n\n客户端和之前的也差不多，需要注意的就是无论是发送/接受都需要将复杂类型的对象序列化为字符串（`JavaScript` 原生支持）\n\n```js\n// 订阅返回复杂类型的消息\nstompClient.subscribe('/topic/complexMessage/allClient', (res) => {\n  console.log('订阅复杂类型类型的返回消息：{}', JSON.parse(res.body))\n})\n\n// 发送一个复杂类型的消息\nstompClient.send(\n  '/complexMessage',\n  headers,\n  JSON.stringify({\n    id: 17,\n    name: 'rxliuli',\n    sex: false,\n  }),\n)\n```\n\n## WebSocket 客户端封装\n\n每次这么一大堆的代码可以封装一下，吾辈也封装了一个 `StopmClient` 的客户端工具类，如果有什么不好的地方欢迎提出！\n\n```js\n/**\n * websocket 连接的工具类\n * 该工具类依赖于 sockjs-client 与 webstomp-client 两个类库\n * 使用方法：\n * 1. 设定 endpoint 属性\n * 2. 添加连接成功 / 失败的回调函数进行连接\n * 3. 订阅 / 发送消息\n * 4. 断开连接\n */\nconst socketUtil = {\n  //最大重连次数\n  maxLen: 10,\n  //当前重连次数\n  currentLen: 0,\n  // 每次连接的时间间隔\n  timeInterval: 3000,\n  // 连接的 Socket 节点\n  endpoint: undefined,\n  // Socket 连接信息\n  stompClient: undefined,\n  socket: undefined,\n  /**\n   * Socket 连接的方法\n   */\n  connectWebSocket(successFn, errorFn) {\n    this.socket = new SockJS(this.endpoint)\n    this.stompClient = Stomp.over(this.socket)\n    this.stompClient.connect(this.getHeaders(), successFn, (error) => {\n      if (this.currentLen++ < this.maxLen) {\n        console.log(`Socket 连接失败，将在 ${this.timeInterval / 1000}s 后重试`)\n        setTimeout(() => this.connectWebSocket(), 3000)\n      } else {\n        console.log('Socket 连接失败次数过多，将不再重试')\n      }\n      errorFn(error)\n    })\n  },\n  /**\n   * 断开连接的方法\n   */\n  disconnectWebSocket() {\n    if (this.stompClient) {\n      this.stompClient.disconnect(function () {\n        console.log('断开连接')\n      }, this.getHeaders())\n      this.socket.close()\n    }\n  },\n  /**\n   * 获取当前 Socket 连接的 session id\n   */\n  getSessionId() {\n    return /\\/([^\\/]+)\\/websocket/.exec(this.socket._transport.url)[1]\n  },\n  /**\n   * 获取一个认证的 headers 信息\n   * 该方法可以被覆盖\n   * @return {{\"X-Requested-With\": string, Authorization: any}} 含有认证信息的 headers 对象\n   */\n  getHeaders() {\n    return {\n      'X-Requested-With': 'X-Requested-With',\n      Authorization: localStorage.token,\n    }\n  },\n  /**\n   * 发送简单文本类型的消息\n   */\n  sendText(url, body, headers = {}) {\n    return this.stompClient.send(url, headers, body)\n  },\n  /**\n   * 发送 json 类型的消息\n   */\n  sendJSON(url, body, headers = {}) {\n    return this.stompClient.send(url, headers, JSON.stringify(body))\n  },\n  /**\n   * 订阅简单文本类型的消息\n   */\n  subscribeText(url, successFn) {\n    return this.stompClient.subscribe(url, (res) => successFn(res))\n  },\n  /**\n   * 订阅 json 类型的消息\n   */\n  subscribeJSON(url, successFn) {\n    return this.stompClient.subscribe(url, (res) =>\n      successFn(JSON.parse(res.body)),\n    )\n  },\n  /**\n   * 取消订阅\n   * @param obj 订阅对象\n   */\n  unsubscribe(obj) {\n    if (obj && obj.unsubscribe) {\n      obj.unsubscribe()\n    }\n  },\n}\n```\n","createdTime":1587219249395,"updatedTime":1609304981605,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"d0d1bfcdc10e48aebdda7f1eea2c8df9","title":"配置文件 yml","body":"> 本文主要引用自：[Spring Boot 配置文件详解](https://www.cnblogs.com/itdragon/p/8686554.html)，这里主要是为了进行记录以便吾辈进行查找。\n\nyml 是 YAML（YAML Ain't Markup Language）语言的文件，以数据为中心，比 json、xml 等更适合做配置文件。\n\n> 对比：\n> yml 和 xml 相比，少了一些结构化的代码，使数据更直接，一目了然。  \n> yml 和 json 呢？没有谁好谁坏，合适才是最好的。yml 的语法比 json 优雅，注释更标准，适合做配置文件。json 作为一种机器交换格式比 yml 强，更适合做 api 调用的数据交换。\n\n## 语法\n\n- 以空格的缩进程度来控制层级关系。空格的个数并不重要，只要左边空格对齐则视为同一个层级。注意不能用 `tab` 代替 `空格`。且大小写敏感。支持字面值，对象，数组三种数据结构，也支持复合结构。\n- 字面值：字符串，布尔类型，数值，日期。字符串默认不加引号，单引号会转义特殊字符。日期格式支持 `yyyy/MM/dd HH:mm:ss`\n- 对象：由键值对组成，形如 key:(空格)value 的数据组成。冒号后面的空格是必须要有的，每组键值对占用一行，且缩进的程度要一致，也可以使用行内写法：{k1: v1, ....kn: vn}\n- 数组：由形如 -(空格)value 的数据组成。短横线后面的空格是必须要有的，每组数据占用一行，且缩进的程度要一致，也可以使用行内写法： [1,2,...n]\n- 复合结构：上面三种数据结构任意组合\n\n## 使用\n\n创建一个 Spring Boot 的全局配置文件 application.yml，配置属性参数。主要有字符串，带特殊字符的字符串，布尔类型，数值，集合，行内集合，行内对象，集合对象这几种常用的数据格式。\n\n```yaml\nyaml:\n  str: 字符串可以不加引号\n  specialStr: \"双引号直接输出\\n特殊字符\"\n  specialStr2: '单引号可以转义\\n特殊字符'\n  flag: false\n  num: 666\n  Dnum: 88.88\n  list:\n    - one\n    - two\n    - two\n  set: [1, 2, 2, 3]\n  map: { k1: v1, k2: v2 }\n  positions:\n    - name: ITDragon\n      salary: 15000.00\n    - name: ITDragonBlog\n      salary: 18888.88\n```\n\n## 注意\n\n- 字符串可以不加引号，若加双引号则输出特殊字符，若不加或加单引号则转义特殊字\n- 数组类型，短横线后面要有空格；对象类型，冒号后面要有空格。\n- YAML 是以空格缩进的程度来控制层级关系，但不能用 tab 键代替空格，大小写敏\n- 如何让一个程序员崩溃？在 yml 文件中加几个空格！(〃＞皿＜)\n","createdTime":1587219249398,"updatedTime":1609304980935,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"50931c01eb444f7abe80042ca54721f7","title":"使用 Java 实现 setTimeout/setInterval","body":"## 场景\n\n之前想把 Java 代码中使用回调函数的方法改成 `Promise` 风格，苦思冥想而不得其解。然而突发奇想之下，吾辈尝试在 Java 中实现 JavaScript 的 `setTimeout/setInterval`，并在之后想到了如何封装回调为 `Promise`，所以便先在此将这个想法的写出来以供参考。\n\n> `Promise` 是 ES6 添加的一个重要的元素，它将回调函数压平为了一级调用，并在 ES7 的 `async/await` 中彻底改变了异步的使用方式！\n\n## 实现\n\n```java\npublic class AsyncUtil {\n    private static final Logger log = LoggerFactory.getLogger(AsyncUtil.class);\n\n    /**\n     * 将当前线程休眠指定的时间\n     *\n     * @param millis 毫秒\n     */\n    public static void sleep(long millis) {\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * 实现 JavaScript 中的 setTimeout\n     * 注：由于 {@link CompletableFuture#cancel(boolean)} 方法的限制，该定时器无法强制取消\n     *\n     * @param ms 等待时间\n     * @return 异步对象\n     */\n\n    public static CompletableFuture<Void> setTimeout(long ms) {\n        return CompletableFuture.runAsync(() -> sleep(ms));\n    }\n\n    /**\n     * 实现等待指定资源加载完成\n     * 注：由于 {@link CompletableFuture#cancel(boolean)} 方法的限制，该定时器无法强制取消\n     *\n     * @param condition 临界条件\n     * @return 异步对象\n     */\n    public static CompletableFuture<Void> waitResource(Supplier<Boolean> condition) {\n        return CompletableFuture.runAsync(() -> {\n            while (!condition.get()) {\n                sleep(100);\n            }\n        });\n    }\n\n    /**\n     * 实现 JavaScript 中的 setInterval 周期函数\n     * 该方法并不是非常精确的定时器，仅适用于一般场景，如有需要请使用 {@link ScheduledExecutorService} 类\n     * 注：由于 {@link CompletableFuture#cancel(boolean)} 方法的限制，该定时器无法强制取消\n     *\n     * @param ms       间隔毫秒数\n     * @param runnable 回调函数\n     * @return 永远不会完成的异步对象\n     */\n    public static CompletableFuture<Void> setInterval(long ms, Runnable runnable) {\n        return CompletableFuture.runAsync(() -> {\n            //noinspection InfiniteLoopStatement\n            while (true) {\n                try {\n                    runnable.run();\n                    sleep(ms);\n                } catch (Exception e) {\n                    log.error(\"使用 setInterval 发生异常: \", e);\n                }\n            }\n        });\n    }\n}\n```\n\n使用\n\n```java\npublic class AsyncUtilTest {\n    private final Logger log = LoggerFactory.getLogger(getClass());\n\n    public static void main(String[] args) {\n        final AsyncUtilTest asyncUtilTest = new AsyncUtilTest();\n        asyncUtilTest.setTimeout();\n        asyncUtilTest.waitResource();\n        asyncUtilTest.setInterval();\n        AsyncUtil.sleep(4000);\n    }\n\n    @Test\n    public void setTimeout() {\n        log.info(\"setTimeout completed before time: {}\", LocalDateTime.now());\n        AsyncUtil.setTimeout(1000)\n                .thenRunAsync(() -> log.info(\"setTimeout completed after time: {}\", LocalDateTime.now()));\n    }\n\n    @Test\n    public void waitResource() {\n        log.info(\"waitResource completed before time: {}\", LocalDateTime.now());\n        final AtomicInteger i = new AtomicInteger(1);\n        AsyncUtil.waitResource(() -> i.get() == 3)\n                .thenRunAsync(() -> log.info(\"waitResource completed after time: {}\", LocalDateTime.now()));\n        AsyncUtil.sleep(2);\n        i.set(3);\n    }\n\n    @Test\n    public void setInterval() {\n        log.info(\"setInterval completed before time: {}\", LocalDateTime.now());\n        final CompletableFuture<Void> future = AsyncUtil.setInterval(100, () -> log.info(\"setInterval in the loop, current time: {}\", LocalDateTime.now()));\n        AsyncUtil.sleep(500);\n        future.complete(null);\n        AsyncUtil.sleep(1000);\n    }\n}\n```\n","createdTime":1587219249397,"updatedTime":1609304978827,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"d33aa9f1e3044a789afa3497ca60607e","title":"SpringMVC @RequestParam 参数不能自动转换泛型集合","body":"> [GitHub example](https://github.com/rxliuli/springmvc-not-generic-param-example)\n\n## 场景\n\n在使用 SpringMVC 传参的时候遇到的一个问题，本来需要的参数类型是 `Map<Integer, Integer>l`。然而浏览器传递过来的是 `Map<String, String>`。然而，此时 SpringMVC 并没有直接说参数类型错误。\n\nController 大概是下面这样\n\n```java\n@RestController\n@RequestMapping(\"/\")\npublic class HomeApi {\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @PostMapping(\"testMap\")\n    public Map<Integer, Integer> testMap(@RequestParam Map<Integer, Integer> map) {\n        // 简单的打印 map\n        log.info(\"map: {}\", map);\n        return map;\n    }\n}\n```\n\n然而，当吾辈调用这个接口时，却出现了错误\n\n```js\nconst fd = new FormData()\nfd.append(1, 1)\nfd.append(2, 2)\nfd.append(3, 3)\nfetch('/testMap', {\n  method: 'post',\n  body: fd,\n})\n  .then((res) => res.json())\n  .then((json) => console.log(json))\n```\n\n报错信息\n\n```json\n{\n  \"timestamp\": \"2019-01-17T09:59:16.809+0000\",\n  \"status\": 500,\n  \"error\": \"Internal Server Error\",\n  \"message\": \"Could not write JSON: java.lang.String cannot be cast to java.lang.Number; nested exception is com.fasterxml.jackson.databind.JsonMappingException: java.lang.String cannot be cast to java.lang.Number\",\n  \"path\": \"/testMap\"\n}\n```\n\n可以看到，Spring 告诉我们，不能转换 `String` 为 `Integer`。这是为什么呢？让我们来调试一下！\n\n可以看到，确实进入了方法，然而最后一步却报错了  \n![进入了方法](https://img.rxliuli.com/20190117180704.png)\n\n报错原因\n\n- 泛型只在编译期有约束，运行时泛型实际并不存在，所以可以进入方法而非出现参数错误\n- 最终转换类型为 `Map<Integer, Integer>` 的时候发现类型错误\n\n那么，我们是否可以手动将之转换为 `Map<Integer, Integer>` 呢？修改代码如下\n\n```java\n@RestController\n@RequestMapping(\"/\")\npublic class HomeApi {\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @PostMapping(\"testMap\")\n    public Map<Integer, Integer> testMap(@RequestParam Map<Integer, Integer> map) {\n        log.info(\"map: {}\", map);\n        return map.entrySet().stream().collect(Collectors.toMap(kv -> Integer.parseInt(kv.getKey()), kv -> Integer.parseInt(kv.getValue())));\n    }\n}\n```\n\n再次调用，发现在 `kv.getKey()` 这里就已经发生了异常。那么，我们应该如何解决呢？\n\n## 解决\n\n### 使用 `Map<String, String>`\n\n其实，我们只要将参数类型声明为 `Map<String, String>`，然后再手动转换即可\n\n```java\n@RestController\n@RequestMapping(\"/\")\npublic class HomeApi {\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @PostMapping(\"testMap\")\n    public Map<Integer, Integer> testMap(@RequestParam Map<String, String> map) {\n        log.info(\"map: {}\", map);\n        return map.entrySet().stream().collect(Collectors.toMap(kv -> Integer.parseInt(kv.getKey()), kv -> Integer.parseInt(kv.getValue())));\n    }\n}\n```\n\n再次调用，一切恢复了正常！\n\n### 使用 `@RequestBody`\n\n除此之外，我们或许还有另外一种方法，使用支持泛型的参数的 `@RequestBody` 标识为 `json` 参数。修改代码如下\n\n```java\n@RestController\n@RequestMapping(\"/\")\npublic class HomeApi {\n    private final Logger log = LoggerFactory.getLogger(this.getClass());\n\n    @PostMapping(\"testMap\")\n    public Map<Integer, Integer> testMap(@RequestBody Map<Integer, Integer> map) {\n        log.info(\"map: {}\", map);\n        return map;\n    }\n}\n```\n\n同时，客户端也要修改为以 `json` 的形式，将参数传递给服务端\n\n```js\nfetch('/testMap', {\n  method: 'post',\n  body: JSON.stringify({\n    1: 1,\n    2: 2,\n    3: 3,\n  }),\n  headers: {\n    'content-type': 'application/json',\n  },\n})\n  .then((res) => res.json())\n  .then((json) => console.log(json))\n```\n\n---\n\n那么，关于 SpringMVC 不能自动转换泛型集合便到这里就结束啦\n","createdTime":1587219249396,"updatedTime":1609304974484,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"c7b9b6e1ec444eeaa63a09dacedfe9dc","title":"SpringBoot 集成 Thymeleaf 模板引擎","body":"## 场景\n\n最近开始了一个新的项目，后端使用了 SpringBoot。因为没有进行前后端分离，所以还需要模板引擎。经过调查，我们放弃 `JSP/JSTL` 而选择了 SpringBoot 默认推荐的 `Thymeleaf`。\n\n> 附：不要吐槽 `JSP/JSTL` 很老，吾辈自己都觉得很老，然而公司不允许前后端分离，无解。。。（或许有？）\n\n## 实现\n\n### 创建项目\n\n使用 [springboot.io](https://start.spring.io/) 创建项目，选择 `Web` 和 `Thymeleaf` 依赖，生成的 `build.gradle` 配置如下\n\n```groovy\nplugins {\n    id 'org.springframework.boot' version '2.1.3.RELEASE'\n    id 'java'\n}\n\napply plugin: 'io.spring.dependency-management'\n\ngroup = 'com.rxliuli.example'\nversion = '0.0.1-SNAPSHOT'\nsourceCompatibility = '1.8'\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n```\n\n### 添加公共 js 依赖管理\n\n公共 `JavaScript` 依赖: _templates/common/common-lib-js.html_\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-CN\" xmlns:th=\"http://www.thymeleaf.org\">\n  <body>\n    <div th:fragment=\"common-lib-js\">\n      <script src=\"https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js\"></script>\n    </div>\n  </body>\n</html>\n```\n\n### 添加公共顶部\n\n公共的顶部: _templates/common/common-header.html_\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-CN\" xmlns:th=\"http://www.thymeleaf.org\">\n  <body>\n    <header th:fragment=\"common-header\" id=\"common-header\">\n      <style>\n        #common-header {\n          height: 100px;\n          width: 100%;\n        }\n\n        #common-header .text-center {\n          text-align: center;\n        }\n      </style>\n      <h1 class=\"text-center\">这里是公共顶部</h1>\n    </header>\n  </body>\n</html>\n```\n\n### 添加公共底部\n\n公共的底部: _templates/common/common-footer.html_\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-CN\" xmlns:th=\"http://www.thymeleaf.org\">\n  <body>\n    <header th:fragment=\"common-footer\" id=\"common-footer\">\n      <style>\n        #common-footer {\n          height: 100px;\n          width: 100%;\n        }\n\n        #common-footer .text-center {\n          text-align: center;\n        }\n      </style>\n      <h1 class=\"text-center\">这里是公共底部</h1>\n    </header>\n  </body>\n</html>\n```\n\n### 在页面中引入\n\n下面在页面中引入看看效果\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-CN\" xmlns:th=\"http://www.thymeleaf.org\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\n    />\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n    <style>\n      .text-center {\n        text-align: center;\n      }\n    </style>\n    <title>首页</title>\n  </head>\n  <body>\n    <div th:replace=\"common/common-header::common-header\"></div>\n    <main>\n      <p class=\"text-center\">这里是页面单独的内容部分</p>\n    </main>\n    <div th:replace=\"common/common-footer::common-footer\"></div>\n    <div th:replace=\"common/common-lib-js::common-lib-js\"></div>\n    <script>\n      console.log($)\n    </script>\n  </body>\n</html>\n```\n\n效果图\n\n![效果图](https://img.rxliuli.com/20190309095422.png)\n\n可以看到 `common-lib-js`, `common-header`, `common-footer` 都已经引入成功\n\n注意，我们在页面中引入的顺序是\n\n1. `common-header`: 公共头部\n2. 页面自定义 HTML 内容\n3. `common-footer`: 公共底部\n4. `common-lib-js`: 公共 JavaScript 依赖\n5. 页面自定义 JavaScript 脚本\n\n主要遵循下面几个原则\n\n- JavaScript 必须在 HTML body 结尾处引入，避免加载的速度问题\n- 自定义的 JavaScript 必须在公共的 JavaScript 之后引入，避免依赖找不到\n\n## 更进一步\n\n难道每个页面我们都需要引入这些公共的文件么？有什么更好的方法么？例如每个页面只要写单独的部分，在渲染的时候 **自动** 将页面中的单独部分渲染到某个布局页面中。  \n很遗憾的是，`Thymeleaf` 本身并未提供这个功能。然而，`Thymeleaf` 已经有人做出了第三方的库以提供此功能。\n\n1.添加依赖项\n\n```groovy\nimplementation 'nz.net.ultraq.thymeleaf:thymeleaf-layout-dialect:2.3.0'\n```\n\n2.添加布局文件\n\n```html\n<!DOCTYPE html>\n<html\n  lang=\"zh-CN\"\n  xmlns:th=\"http://www.thymeleaf.org\"\n  xmlns:layout=\"http://www.ultraq.net.nz/thymeleaf/layout\"\n>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\n    />\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n    <title>layout</title>\n  </head>\n  <body>\n    <!--公共的头部-->\n    <div th:replace=\"common/common-header::common-header\"></div>\n    <!--页面自定义的 HTML-->\n    <div layout:fragment=\"html\"></div>\n    <!--公共的尾部-->\n    <div th:replace=\"common/common-footer::common-footer\"></div>\n    <!--公共的 js 依赖-->\n    <div th:replace=\"common/common-lib-js::common-lib-js\"></div>\n    <!--页面的 js 依赖-->\n    <div layout:fragment=\"js\"></div>\n  </body>\n</html>\n```\n\n3.使用布局文件\n\n```html\n<!DOCTYPE html>\n<html\n  lang=\"zh-CN\"\n  xmlns:layout=\"http://www.ultraq.net.nz/thymeleaf/layout\"\n  layout:decorator=\"common/layout\"\n>\n  <head>\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"\n    />\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n    <style>\n      .text-center {\n        text-align: center;\n      }\n    </style>\n    <title>首页</title>\n  </head>\n  <body>\n    <main layout:fragment=\"html\">\n      <p class=\"text-center\">这里是页面单独的内容部分</p>\n    </main>\n    <script layout:fragment=\"js\">\n      console.log($)\n    </script>\n  </body>\n</html>\n```\n\n再次刷新，将看到与直接引入有着相同的效果！\n","createdTime":1587219249396,"updatedTime":1609304971065,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"7fefb689b04840dc92ff85a703128115","title":"Windows 上安装 JDK 并设置环境变量","body":"## 从 Oracle 官网下载 JDK\n\n首先在浏览器打开 [JDK8 下载页面](https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)\n\n找到 **Java SE Development Kit 8uXXX** 勾选 **Accept License Agreement**，点击下载平台对应的二进制文件，这里以 Windows 平台为例，选择 **jdk-8u191-windows-x64.exe** 下载就好了\n\n![JDK8 下载](https://img.rxliuli.com/20181017141137.png)\n\n## 运行安装程序\n\n双击打开 JDK 安装，其实基本上就是一路 Next 下去就好啦\n\n![JDK 安装 01](https://img.rxliuli.com/20181017145812.png)\n\n![JDK 安装 02](https://img.rxliuli.com/20181017145854.png)\n\n![JDK 安装 02](https://img.rxliuli.com/20181017145932.png)\n\n![JDK 安装 03](https://img.rxliuli.com/20181017150018.png)\n\n这里需要注意一下，对于安装 JDK 的人来说，Java 安装是可有可无的，所以我们这里直接点 X 就好再确定就好。\n\n![不安装 Java](https://img.rxliuli.com/20181017150310.png)\n\n![安装完成](https://img.rxliuli.com/20181017150357.png)\n\n安装完成，关闭安装窗口即可，然而我们并不能立刻开始使用 JDK，因为我们还需要设置 JDK 的环境变量\n\n## 设置 JDK 的环境变量\n\n1. 在 **此电脑** 上右键选择 **属性**\n\n![此电脑右键属性](https://img.rxliuli.com/20181017142509.png)\n\n2. 在 **控制面板\\系统和安全\\系统** 选择 **高级系统设置**\n\n![高级系统设置](https://img.rxliuli.com/20181017142726.png)\n\n3. 在 **系统属性 > 高级** 选项卡选择 **环境变量**\n\n![环境变量](https://img.rxliuli.com/20181017142652.png)\n\nJDK：需要设置 3 个环境变量（如果找不到就添加）\n\n> 附：这里一般设置到 **系统变量** 里面\n\n![环境变量设置](https://img.rxliuli.com/20181017143203.png)\n\n- JAVA_HOME：浏览文件夹选择 JDK 安装路径就行了\n\n  ![JAVA_HOME 环境变量](https://img.rxliuli.com/20181017143629.png)\n\n- CLASSPATH：`.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;`\n\n  ![CLASSPATH 环境变量](https://img.rxliuli.com/20181017144048.png)\n\n- Path：添加 `%JAVA_HOME%\\bin` 和 `%JAVA_HOME%\\jre\\bin`\n\n  ![Path 环境变量](https://img.rxliuli.com/20181017143940.png)\n\n设置完环境变量之后一定要按确定依次关闭 **环境变量**，**系统属性** 窗口\n\nJDK 安装完成了，现在测试一下能否正常使用，使用 `Win + R` 输入 `cmd` 打开 CMD 命令行窗口，或者在菜单中找到 _Windows 系统 > 命令提示符_ 点击也同样能打开 CMD。\n\n## 测试 JDK 是否安装成功\n\n![在菜单中打开 CMD](https://img.rxliuli.com/20181017145201.png)\n\n在命令行输入 `javac`，你应该得到类似于下面的这些输出\n\n```bash\n用法: javac <options> <source files>\n其中, 可能的选项包括:\n  -g                         生成所有调试信息\n  -g:none                    不生成任何调试信息\n  -g:{lines,vars,source}     只生成某些调试信息\n  -nowarn                    不生成任何警告\n  -verbose                   输出有关编译器正在执行的操作的消息\n  -deprecation               输出使用已过时的 API 的源位置\n  -classpath <路径>            指定查找用户类文件和注释处理程序的位置\n  -cp <路径>                   指定查找用户类文件和注释处理程序的位置\n  -sourcepath <路径>           指定查找输入源文件的位置\n  -bootclasspath <路径>        覆盖引导类文件的位置\n  -extdirs <目录>              覆盖所安装扩展的位置\n  -endorseddirs <目录>         覆盖签名的标准路径的位置\n  -proc:{none,only}          控制是否执行注释处理和/或编译。\n  -processor <class1>[,<class2>,<class3>...] 要运行的注释处理程序的名称; 绕过默认的搜索进程\n  -processorpath <路径>        指定查找注释处理程序的位置\n  -parameters                生成元数据以用于方法参数的反射\n  -d <目录>                    指定放置生成的类文件的位置\n  -s <目录>                    指定放置生成的源文件的位置\n  -h <目录>                    指定放置生成的本机标头文件的位置\n  -implicit:{none,class}     指定是否为隐式引用文件生成类文件\n  -encoding <编码>             指定源文件使用的字符编码\n  -source <发行版>              提供与指定发行版的源兼容性\n  -target <发行版>              生成特定 VM 版本的类文件\n  -profile <配置文件>            请确保使用的 API 在指定的配置文件中可用\n  -version                   版本信息\n  -help                      输出标准选项的提要\n  -A关键字[=值]                  传递给注释处理程序的选项\n  -X                         输出非标准选项的提要\n  -J<标记>                     直接将 <标记> 传递给运行时系统\n  -Werror                    出现警告时终止编译\n  @<文件名>                     从文件读取选项和文件名\n```\n\n如果你得到了类似下面错误的输出，请务必重新检查上面的安装步骤\n\n```bash\n'javac' 不是内部或外部命令，也不是可运行的程序\n或批处理文件。\n```\n\n到此 JDK 的安装就算完成了\n","createdTime":1587219249396,"updatedTime":1609304961370,"resources":[],"tags":[{"id":"4e00e5550c864473a3f16e4b0698f1c3","title":"windows","parent_id":""},{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"000f77381ffc4421af246bc07bd90c70","title":"Windows 下安装 Gradle","body":"> [官网](https://gradle.org), [GitHub](https://github.com/gradle/gradle)\n\n## 场景\n\n吾辈需要在 Windows 下 build Android 的项目，作为 Android 官方推荐的构建工具，Gradle 也却是不得不用呀\n\n## 安装\n\n在官网的版本 [发布页面](https://gradle.org/releases/) 找到 Download 的 **binary-only** 链接，点击即可下载了（后面的 **complete** 指的是完整版，我们只是使用的话并不需要下载那个）。  \n![版本发布](https://img.rxliuli.com/20181116203320.png)  \n![下载详情](https://img.rxliuli.com/20181116203612.png)\n\n## 设置环境变量\n\n下载完成后，将文件解压出来，解压出来的文件夹内大概是这个样子\n\n![Gradle 解压目录](https://img.rxliuli.com/20181116203858.png)\n\n现在，我们需要设置环境变量了\n\n在 _控制面板 > 系统和安全 > 系统_ 中找到 _高级系统设置_ 项  \n![系统](https://img.rxliuli.com/20181116204013.png)\n\n点击 _环境变量_  \n![系统属性](https://img.rxliuli.com/20181116204130.png)\n\n双击 _系统变量 > Path_  \n![Path](https://img.rxliuli.com/20181116204344.png)\n\n点击 **新建** 创建一个环境变量，随便输入点什么，然后点击 **浏览**  \n![新建环境变量](https://img.rxliuli.com/20181116204638.png)\n\n选择 gradle 解压后的文件夹位置，之后点击确定  \n![选择解压后的文件夹位置](https://img.rxliuli.com/20181116205022.png)\n\n然后一路点击确认关闭这 3 个窗口  \n![关闭窗口](https://img.rxliuli.com/20181116205528.png)\n\n## 测试\n\n打开 Cmd，下面是从菜单中找到 _Windows 系统 > 命令提示符_  \n![打开 Cmd](https://img.rxliuli.com/20181116205716.png)\n\n在 Cmd 中输入 `gradle -v` 验证一下，如果得到的是类似于下面的输出，那么 gradle 便是安装成功了  \n![在 Cmd 下验证 Gradle](https://img.rxliuli.com/20181116210006.png)\n\n那么，Gradle 的安装到这里便是基本结束了呢 (★^O^★)\n","createdTime":1587219249397,"updatedTime":1609304946533,"resources":[],"tags":[{"id":"4e00e5550c864473a3f16e4b0698f1c3","title":"windows","parent_id":""},{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"3e615fbd1550496eb30c0910a1b5e4c5","title":"使用 GitHub 作为 Maven 仓库","body":"> [GitHub 示例](https://github.com/rxliuli/maven-repository-example)\n\n## 场景\n\n吾辈在日常工具中也有一些公共的代码库，一直想分离成单独的类库却没有机会，看到使用 github 就能部署 maven 仓库就尝试了一下。\n\n> 这里吐槽一下 maven 中央仓库的发布流程，不知道为什么不能像 npm 一样一个简单的命令就能发布多好！\n\n## 创建一个 maven 项目上传到 github\n\n这是初始的 `pom.xml`\n\n```xml\n<!-- pom.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n<!-- 项目的组织名，如果没有域名或组织的话就是用 com.github.[你的用户名] -->\n  <groupId>com.rxliuli</groupId>\n  <!-- 项目的名字 -->\n  <artifactId>maven-repository-example</artifactId>\n  <!-- 版本号，默认是 1.0-SNAPSHOT -->\n  <version>1.0-SNAPSHOT</version>\n</project>\n```\n\n添加一个忽略配置 _.gitignore_ 就可以上传到 GitHub 了\n\n```ignore\ntarget/\npom.xml.tag\npom.xml.releaseBackup\npom.xml.versionsBackup\npom.xml.next\nrelease.properties\ndependency-reduced-pom.xml\nbuildNumber.properties\n.mvn/timing.properties\n.mvn/wrapper/maven-wrapper.jar\n\n# 忽略 IDEA 配置文件\n*.iml\n.idea/\nrebel.xml\n```\n\n## 修改 `maven-deploy-plugin` 插件\n\n主要是设置部署目录\n\n```xml\n<!-- 其他内容。。。 -->\n<build>\n  <plugins>\n    <plugin>\n      <artifactId>maven-deploy-plugin</artifactId>\n      <version>2.8.1</version>\n      <configuration>\n        <!--设置部署目录-->\n        <altDeploymentRepository>\n          internal.repo::default::file://${project.build.directory}/mvn-repo\n        </altDeploymentRepository>\n      </configuration>\n    </plugin>\n  </plugins>\n</build>\n<!-- 其他内容。。。 -->\n```\n\n## 在 settings.xml 中添加 github 用户信息\n\n找到 maven 用户配置文件，默认位置在 _~/.m2/settings.xml_。如果不存在，则从 maven 安装目录复制一份过来，具体位置在 _MAVEN_HOME/conf/settings.xml_。\n\n```xml\n<!-- 其他内容。。。 -->\n<servers>\n  <server>\n    <!-- id，这只是一个标识名，根据它找到用户名和密码 -->\n    <id>github</id>\n    <!-- github 用户名 -->\n    <username>rxliuli</username>\n    <!-- github 密码 -->\n    <password>123456</password>\n  </server>\n</servers>\n<!-- 其他内容。。。 -->\n```\n\n## 添加插件 com.github.github\n\n```xml\n<!-- 其他内容。。。 -->\n<properties>\n  <!-- 设置 github 服务器使用的配置，在 ~/.m2/settings.xml 中定义 -->\n  <github.global.server>github</github.global.server>\n</properties>\n\n<build>\n  <plugins>\n    <plugin>\n      <groupId>com.github.github</groupId>\n      <artifactId>site-maven-plugin</artifactId>\n      <!--\n        这里需要使用 0.12, 0.9 部署时会出错，具体查看\n        https://github.com/github/maven-plugins/issues/105\n      -->\n      <version>0.12</version>\n      <configuration>\n        <!--git 提交的消息-->\n        <message>Maven artifacts for ${project.version}</message>\n        <!--禁用网页处理-->\n        <noJekyll>true</noJekyll>\n        <!--部署的目录，这里是和上面的 maven-deploy-plugin 的 configuration.altDeploymentRepository 对应-->\n        <outputDirectory>${project.build.directory}/mvn-repo\n        </outputDirectory> <!-- matches distribution management repository url above -->\n        <!--远程分支名-->\n        <branch>refs/heads/mvn-repo</branch>\n        <includes>\n          <include>**/*</include>\n        </includes>\n        <!--github 仓库的名字-->\n        <repositoryName>maven-repository-example</repositoryName>\n        <!--github 用户名-->\n        <repositoryOwner>rxliuli</repositoryOwner>\n      </configuration>\n      <executions>\n        <execution>\n          <goals>\n            <!--suppress MybatisMapperXmlInspection -->\n            <goal>site</goal>\n          </goals>\n          <phase>deploy</phase>\n        </execution>\n      </executions>\n    </plugin>\n  </plugins>\n</build>\n<!-- 其他内容。。。 -->\n```\n\n## 进行部署\n\n使用命令进行部署\n\n```sh\nmvn clean deploy\n```\n\n查看 github 项目库，可以看到已经自动创建了一个分支 `mvn-repo` 并存放了部署后的文件。\n\n## 使用\n\n添加仓库地址\n\n```xml\n<repositories>\n  <repository>\n    <id>maven-repository-example</id>\n    <!-- 格式是 https://raw.githubusercontent.com/[github 用户名]/[github 仓库名]/[分支名]/repository -->\n    <url>\n      https://raw.githubusercontent.com/rxliuli/maven-repository-example/mvn-repo/repository\n    </url>\n  </repository>\n</repositories>\n```\n\n就像其他 maven 仓库一样，我们知道 `groupId`, `artifactId` 与 `version`，自然可以直接使用啦\n\n```xml\n <dependency>\n   <groupId>com.rxliuli</groupId>\n   <artifactId>maven-repository-example</artifactId>\n   <version>1.0-SNAPSHOT</version>\n </dependency>\n```\n\n> 注: 这种使用 github 部署的 maven 仓库，在 [maven 中央仓库](https://mvnrepository.com) 中并不能搜索到的哦\n","createdTime":1587219249397,"updatedTime":1609304937137,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"1be5a81d31cd4c0b9b1f198f556eec81","title":"使用 Java8 新的时间 API","body":"## 简介\n\nJava8 面世以来已经 6 年了，许多人也开始使用起了 `lambda`,`Stream<T>`,`Optional<T>` 之类的新的语言特性，然而对于 Java8 提供的新的时间 `API` 虽然据说比旧版本的 `Date` 好很多，但并没有得到完全的使用。一方面是为了兼容旧的系统，另一方面 Java8 的时间 API 似乎太过于强大了，让人有些不知所措，不知道应该从何下手。再加上因为对 `Date`,`Calendar` 的熟悉，此消彼长之下自然是懒得去修改了。\n\n其实对于时间 API，大致的需求是一样的\n\n- 创建/修改/比较/转换简单\n- 对遗留系统的时间可以集成/转换\n- 主流框架对其要有支持\n\n## API\n\n### 常用的类\n\n- [LocalDate](#LocalDate): 日期的不可变类\n- [LocalTime](#LocalTime): 时间的不可变类\n- [LocalDateTime](#LocalDateTime): 日期时间的不可变类\n- [OffsetDateTime](#OffsetDateTime): 偏移标准 UTC 时间的日期时间不可变类\n- [Temporal/TemporalAccessor](#Temporal/TemporalAccessor): 上面几个时间类的基类\n- [Period](#Period): 计算日期差值\n- [Duration](#Duration): 计算日期时间差值\n- [ChronoField/TemporalField](#TemporalField/ChronoField): 时间的单位\n- [ChronoUnit/TemporalUnit](#TemporalUnit/ChronoUnit): 根据指定的单位计算时间\n- [DateTimeFormatter](#DateTimeFormatter): 时间格式化\n- [兼容 Date](#兼容-Date): 兼容旧的 Date 类\n\n### LocalDate\n\n一个不可变（线程安全）的日期对象，用且表示 _年-月-日_ 的时间，默认 `toString()` 格式是 `yyyy-MM-dd`。\n\n基本操作\n\n```java\n//获取当前的日期\nfinal LocalDate now = LocalDate.now();\n//toString 一下日期\n//会得到 yyyy-MM-dd 格式\nSystem.out.println(\"现在：\" + now);\n//1 天后的日期\nfinal LocalDate localDatePlusDayOne = now.plusDays(1);\nSystem.out.println(\"一天后：\" + localDatePlusDayOne);\n//一天前的日期\nfinal LocalDate localDateMinusDayOne = now.minusDays(1);\nSystem.out.println(\"一天前：\" + localDateMinusDayOne);\n//比较两个日期/时间的大小\nfinal int nowEvenBigger = now.compareTo(localDatePlusDayOne);\nSystem.out.println(\"当前时间更大么？\" + nowEvenBigger);\n//获取指定单位的日期（年/月/日/星期）\n//获取当前月的时间\nfinal int dayOfMonth = now.getDayOfMonth();\nSystem.out.println(\"当前月的天数：\" + dayOfMonth);\n//更加通用获取方式\n//使用枚举类 ChronoField\nfinal int dayOfMonthForChronoField = now.get(ChronoField.DAY_OF_MONTH);\nSystem.out.println(\"当前月的天数（通过 get() 获取）：\" + dayOfMonthForChronoField);\n//比较两个日期的差值\nfinal long between = ChronoUnit.DAYS.between(now, localDatePlusDayOne);\nSystem.out.println(between);\n```\n\n上面有些地方看不太懂不碍事，先过一遍，下面对其中的部分代码会有解释\n\n### LocalTime\n\n一个不可变的（线程安全）的时间对象，用于表示 _时：分：秒：毫秒_ 的时间，默认 `toString()` 格式是 `hh:mm:ss.SSS`。\n\n基本操作\n\n```java\n//获得当前时间\nfinal LocalTime now = LocalTime.now();\n//默认格式 hh:mm:ss.SSS\nSystem.out.println(\"现在：\" + now);\n//一个小时后的时间\nfinal LocalTime localTimePlusHourOne = now.plusHours(1);\nSystem.out.println(\"一小时后：\" + localTimePlusHourOne);\n//一分钟前的时间\nfinal LocalTime localTimeMinusMinuteOne = now.minusMinutes(1);\nSystem.out.println(localTimeMinusMinuteOne);\n//比较时间大小（实现了 Comparable 接口）\nfinal int nowEvenBigger = now.compareTo(localTimeMinusMinuteOne);\nSystem.out.println(\"当前时间更大么？\" + nowEvenBigger);\n//获取指定单位的时间\n//当前小时数\nfinal int hour = now.getHour();\nSystem.out.println(\"当前时间的小时数：\" + hour);\n//使用枚举类 ChronoField 获取\nfinal int hourOfDay = now.get(ChronoField.HOUR_OF_DAY);\nSystem.out.println(\"当前时间的小时数（通过 get() 获取）：\" + hourOfDay);\n//比较两个日期的差值\nfinal long between = ChronoUnit.HOURS.between(now, localTimePlusHourOne);\nSystem.out.println(between);\n```\n\n### LocalDateTime\n\n不可变的日期时间对象，用于表示 _日-月-年 时：分：秒：毫秒_ 的日期时间，默认格式化格式是 `yyyy-MM-ddThh:mm:ss.SSS`。\n\n基本操作\n\n```java\n//当前日期时间\nfinal LocalDateTime now = LocalDateTime.now();\n//默认格式 yyyy-MM-ddThh:mm:ss.SSS\nSystem.out.println(\"现在：\" + now);\n//一个小时后的时间\nfinal LocalDateTime localTimePlusHourOne = now.plusHours(1);\nSystem.out.println(\"一小时后：\" + localTimePlusHourOne);\n//一分钟前的时间\nfinal LocalDateTime localTimeMinusMinuteOne = now.minusMinutes(1);\nSystem.out.println(localTimeMinusMinuteOne);\n//比较时间大小（实现了 Comparable 接口）\nfinal int nowEvenBigger = now.compareTo(localTimeMinusMinuteOne);\nSystem.out.println(\"当前时间更大么？\" + nowEvenBigger);\n//获取指定单位的时间\n//当前小时数\nfinal int hour = now.getHour();\nSystem.out.println(\"当前时间的小时数：\" + hour);\n//使用枚举类 ChronoField 获取\nfinal int hourOfDay = now.get(ChronoField.HOUR_OF_DAY);\nSystem.out.println(\"当前时间的小时数（通过 get() 获取）：\" + hourOfDay);\n//比较两个日期的差值\nfinal long between = ChronoUnit.HOURS.between(now, localTimePlusHourOne);\nSystem.out.println(between);\n//获取一天的开始和结束\nfinal LocalDateTime start = LocalDateTime.of(yesterday, LocalTime.MIN);\nfinal LocalDateTime end = LocalDateTime.of(yesterday, LocalTime.MAX);\nSystem.out.println(start);\nSystem.out.println(end);\n```\n\n可以看到，和上面的 [LocalTime](#LocalTime) 除了类型不同外，代码是完全相同的，因为 [LocalDateTime](#LocalDateTime) 是包含 [LocalDate](#LocalDate) 与 [LocalTime](#LocalTime) 的。在源码中也可以看到其包含了两个属性。\n\n```java\n//获取日期/时间对象\nfinal LocalDate localDate = now.toLocalDate();\nfinal LocalTime localTime = now.toLocalTime();\nSystem.out.println(\"当前日期：\" + localDate);\nSystem.out.println(\"当前时间：\" + localTime);\n```\n\n### OffsetDateTime\n\n代表偏移标准 UTC 时间的日期时间不可变对象，用于表示 _日-月-年 时：分：秒：毫秒时区_，默认格式是 `yyyy-MM-ddThh:mm:ss.SSSZoneId`\n\n基本操作\n\n```java\n//当前偏移的日期时间\nfinal OffsetDateTime now = OffsetDateTime.now();\nSystem.out.println(now);\n//其实个人感觉就是多了一个时区\n//获取到时区\nZoneId zone = now.toZonedDateTime().getZone();\nSystem.out.println(zone);\n//转换时区\nZonedDateTime zonedDateTime = now.atZoneSameInstant(ZoneId.of(\"+00:00\"));\nSystem.out.println(zonedDateTime);\n//其他基本操作和上面的差不多，就不啰嗦啦\n```\n\n### Temporal/TemporalAccessor\n\n上面的 [LocalDate](#LocalDate), [LocalTime](#LocalTime), [LocalDateTime](#LocalDateTime), [OffsetDateTime](#OffsetDateTime) 的基类，并定义了一系列非常通用的方法\n\n- minus: 减少时间\n- plus: 增加时间\n- with: 获取时间指定单位的值\n\n```java\nfinal LocalDateTime now = LocalDateTime.now();\n//获取上个星期\nfinal LocalDateTime lastWeek = now.minus(1, ChronoUnit.WEEKS);\n//获取下个月\nfinal LocalDateTime nextMonth = now.plus(1, ChronoUnit.MONTHS);\n//获取当前是今年的第几个星期\nfinal int weekValue = now.get(ChronoField.ALIGNED_WEEK_OF_YEAR);\n//获取这周星期一的时间\nfinal LocalDateTime nowOfMonday = now.with(DayOfWeek.MONDAY);\nfinal LocalDateTime nowOfMonday2 = now.with(ChronoField.DAY_OF_WEEK, 1);\nSystem.out.println(\n    \"lastWeek: \" + lastWeek\n        + \"\\nnextMonth: \" + nextMonth\n        + \"\\nweekValue: \" + weekValue\n        + \"\\nnowOfMonday: \" + nowOfMonday\n        + \"\\nnowOfMonday2: \" + nowOfMonday2\n);\n```\n\n### Period\n\n代表两个日期的差值，默认 `toString()` 格式是 `P([时间][单位])*`\n\n基本操作\n\n```java\nfinal LocalDate now = LocalDate.now();\nfinal LocalDate localTimePlusMonthOne = now.plusDays(1);\n//计算相差的时间\nfinal Period betweenForDay = Period.between(now, localTimePlusMonthOne);\n//获取相差的天数\nSystem.out.println(\"相差的天数：\" + betweenForDay.getDays());\n//使用 get() 方法获取通用的相差的天数\nSystem.out.println(\"相差的天数(使用 get() 获取)：\" + betweenForDay.get(ChronoUnit.DAYS));\n//对相差的日期减去一天并判断是否为 0\nSystem.out.println(\"相差的日期减去 1 天是不是就相同了呢？\" + betweenForDay.minusDays(1).isZero());\n```\n\n### Duration\n\n代表两个日期时间的差值，默认 `toString()` 格式是 `PT([时间][单位])*`\n\n基本操作\n\n```java\nfinal LocalDateTime now = LocalDateTime.now();\nfinal LocalDateTime localDateTimeForPlusHourOne = now.plusHours(1);\n//计算两个时间的差值\nfinal Duration between = Duration.between(now, localDateTimeForPlusHourOne);\n//默认格式是 PT 时间 单位\nSystem.out.println(\"相差的时间：\" + between);\n//获取日期\nfinal long betweenSeconds = between.getSeconds();\nSystem.out.println(\"相差的时间（/秒）：\" + betweenSeconds);\n//根据指定单位获取相差时间的大小\nfinal long betweenSecondsForGet = between.get(ChronoUnit.SECONDS);\nSystem.out.println(\"相差的时间（/秒）：\" + betweenSecondsForGet);\n//转换成毫秒\nSystem.out.println(\"相差的时间（/毫秒）：\" + between.toMillis());\n//获取相差时间支持的单位列表（其实感觉上没太大意义）\nfinal List<TemporalUnit> temporalUnitList = between.getUnits();\nSystem.out.println(\"相差的时间列表：\" + temporalUnitList);\n//在创建一个时间差\nfinal Duration betweenForMinutes = Duration.between(now, now.minusMinutes(100));\n//判断两个时间差哪个更大\nSystem.out.println(\"between 的时间差更大么？\" + between.compareTo(betweenForMinutes));\n//获取绝对值\nSystem.out.println(\"相差的绝对时间：\" + betweenForMinutes.abs());\n```\n\n### TemporalField/ChronoField\n\n日期/时间单位字段，TemporalField 是接口，ChronoField 则是实现类。\n\n基本操作\n\n```java\nfinal LocalDateTime now = LocalDateTime.now();\nfinal ChronoField hourOfDay = ChronoField.HOUR_OF_DAY;\nSystem.out.println(hourOfDay);\n//获取当前小时数\nfinal long nowForHours = hourOfDay.getFrom(now);\nSystem.out.println(\"当前时间的小时数：\" + nowForHours);\n//获取到指定单位的时间大小\nfinal int hoursForGet = now.get(ChronoField.HOUR_OF_DAY);\nSystem.out.println(\"当前时间的小时数（get()）：\" + hoursForGet);\n//获取到特定单位的时间对比对象 Duration\nfinal TemporalUnit baseUnit = hourOfDay.getBaseUnit();\nSystem.out.println(baseUnit);\n```\n\n### TemporalUnit/ChronoUnit\n\n也是时间单位，TemporalUnit 是接口，ChronoUnit 则是实现类。和上面的不同的地方在于上面的不能 ChronoField 不能对时间进行对比差值，只能根据指定单位获取时间的大小。\n\n基本操作\n\n```java\n//获取一个小时数\nfinal ChronoUnit chronoUnit = ChronoUnit.MILLIS;\nSystem.out.println(chronoUnit);\n//获取两个时间的差值毫秒数\nfinal LocalDateTime now = LocalDateTime.now();\nfinal LocalDateTime localDateTimePlusHourOne = now.plusHours(1);\nfinal long betweenForMillis = chronoUnit.between(now, localDateTimePlusHourOne);\nSystem.out.println(\"相差的毫秒数：\" + betweenForMillis);\n//根据指定的单位修改时间也需要使用这个\nfinal LocalDateTime localDateTimePlusMinuteOne = now.plus(1, ChronoUnit.MINUTES);\nSystem.out.println(\"一分钟后的时间：\" + localDateTimePlusMinuteOne);\n```\n\n### DateTimeFormatter\n\n日期时间格式化类，基本上没什么好说的（标准的格式化一般就足够了，毕竟显示是前端的事情，而标准的格式化确实是国际标准呢）\n\n基本使用\n\n```java\n//获取一个标准 iso 日期时间格式化对象\nfinal DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ISO_DATE_TIME;\nSystem.out.println(dateTimeFormatter);\n//格式化日期时间\nfinal LocalDateTime now = LocalDateTime.now();\nSystem.out.println(\"当前日期时间：\" + dateTimeFormatter.format(now));\n//根据自定义的格式格式化时间\nfinal DateTimeFormatter customDateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 hh时mm分ss秒\");\nSystem.out.println(customDateTimeFormatter.format(now));\n```\n\n### 兼容 Date\n\n使用新的时间 API 固然很令人舒服，但有时候不得不兼容旧的 Date 类型，这时候如何转换就很重要了呢\n\n```java\nfinal LocalDateTime now = LocalDateTime.now();\n//转换为 Instant（包括时区）\nfinal Instant instant = now.toInstant(ZoneOffset.UTC);\nSystem.out.println(instant);\n//转换为 Date\nfinal Date date = Date.from(instant);\nSystem.out.println(\"当前时间：\" + date);\n//转换为 Instant\nfinal Instant dateToInstant = date.toInstant();\nSystem.out.println(\"两次转换后的时间还是相同的吧？\" + dateToInstant.equals(instant));\n//转换为 LocalDateTime\nfinal ZoneId zoneId = ZoneId.systemDefault();\nfinal LocalDateTime toLocalDateTime = LocalDateTime.ofInstant(dateToInstant, zoneId);\nSystem.out.println(\"转换后的日期时间：\" + toLocalDateTime);\n```\n\n## 主流框架支持\n\n现如今大部分的包应该都支持 Java8 时间 API 了吧\n\n例如：\n\n- Jackson：jackson-datatype-jsr310\n- Mybatis：mybatis-typehandlers-jsr310\n\n那么，关于 Java8 新的时间 API 的使用暂且到这里了，想到什么吾辈再补充啦（=´∇ ｀=）\n","createdTime":1587219249397,"updatedTime":1609304933083,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"9413f341bc2e46ca844d6914b99349d4","title":"使用 Spring 时进行测试","body":"- [使用 Spring 时进行测试](#使用-spring-时进行测试)\n  - [前置要求](#前置要求)\n  - [概略](#概略)\n  - [普通测试](#普通测试)\n  - [Dao/Service 层测试](#daoservice-层测试)\n    - [手动使用 `ApplicationContext` 去获取 Bean 然后进行测试](#手动使用-applicationcontext-去获取-bean-然后进行测试)\n    - [使用注解自动加载 Spring 测试环境](#使用注解自动加载-spring-测试环境)\n  - [Web 层测试](#web-层测试)\n    - [独立安装测试](#独立安装测试)\n    - [集成 Web 环境测试](#集成-web-环境测试)\n\n## 前置要求\n\n- Java\n- Spring/SpringMVC\n- Maven\n\n## 概略\n\n单元测试/集成测试是软件开发时重要的一项流程，而 Spring 对于测试提供了非常强大的支持。\n\n- 支持主流测试框架 `Junit`/`TestNG`\n- 支持在测试中使用依赖注入\n- 支持在测试中事物自动回滚\n- 支持使用各种注解增强功能\n\n那么，测试基本上按照场景分为三种情况：\n\n- 普通测试：不需要使用 Spring 容器的测试（工具类）\n- Dao/Service 层测试：需要使用 Spring 容器的依赖注入\n- Web 层测试：测试对外部提供的接口\n\n这里新建一个用来测试的项目，吾辈将之丢到了 GitHub 上面\n\n> [项目链接](https://github.com/rxliuli/springtest)\n\n你也可以自己创建一个基础的 Maven 项目，项目结构应当如下：\n\n- /\n  - src/\n    - main/\n      - java/\n      - resources/\n    - test/\n      - java/\n  - pom.xml\n\n## 普通测试\n\n假设吾辈有一个 `SpringUtil`（路径是 `/src/main/java/com/rxliuli/study/springtest/util/SpringUtil.java`） 工具类，想要测试怎么办呢？\n\n```java\n/**\n * 用于测试的字符串工具类\n *\n * @author rxliuli\n */\npublic class StringUtil {\n    /**\n     * 判断是否为空\n     *\n     * @param string 要进行判断的字符串\n     * @return 是否为 null 或者空字符串\n     */\n    public static boolean isEmpty(String string) {\n        return string == null || string.isEmpty();\n\n    }\n\n    /**\n     * 判断是否为空\n     *\n     * @param string 要进行判断的字符串\n     * @return 是否为 null 或者空字符串\n     */\n    public static boolean isNotEmpty(String string) {\n        return !isEmpty(string);\n    }\n\n    /**\n     * 判断是否有字符串为空\n     *\n     * @param strings 要进行判断的一个或多个字符串\n     * @return 是否有 null 或者空字符串\n     */\n    public static boolean isAnyEmpty(String... strings) {\n        return Arrays.stream(strings)\n                .anyMatch(StringUtil::isEmpty);\n    }\n\n    /**\n     * 判断字符串是否全部为空\n     *\n     * @param strings 要进行判断的一个或多个字符串\n     * @return 是否全部为 null 或者空字符串\n     */\n    public static boolean isAllEmpty(String... strings) {\n        return Arrays.stream(strings)\n                .allMatch(StringUtil::isEmpty);\n    }\n}\n```\n\n首先需要引入以下依赖\n\n- `Junit4`：流行的 Java 测试框架。虽然吾辈个人更喜欢 `TestNG`，但 `Junit` 的流行度要更高一点，`SpringBoot` 甚至将之默认引入了，所以这里使用 `Junit` 框架。\n- `AssertJ`：流行的 Java 流畅式断言框架。`Junit` 也有自己的断言方法，但和 `AssertJ` 相比就是小巫见大巫了。\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.12</version>\n    <scope>test</scope>\n</dependency>\n<dependency>\n    <groupId>org.assertj</groupId>\n    <artifactId>assertj-core</artifactId>\n    <version>3.9.1</version>\n    <scope>test</scope>\n</dependency>\n```\n\n> 注：生产环境中 **version** 应该放到 **properties** 节点下，这里只做演示。  \n> 此篇不对 `Junit` 和 `AssertJ` 进行详细的讲解，如果想要入门了解参考 [Junit](http://wiki.jikexueyuan.com/project/junit/), [AssertJ](http://hao.jobbole.com/assertj/)\n\n然后创建一个对应的测试类 `StringUtilTest`（`/src/test/java/com/rxliuli/study/springtest/util/SpringUtilTest.java`）直接进行测试即可。\n\n```java\n/**\n * @author rxliuli\n */\npublic class StringUtilTest {\n    private String strNull = null;\n    private String strEmpty = \"\";\n    private String strSome = \"str\";\n\n    @Test\n    public void isEmpty() {\n        //测试 null\n        assertThat(StringUtil.isEmpty(strNull))\n                .isTrue();\n        //测试 empty\n        assertThat(StringUtil.isEmpty(strEmpty))\n                .isTrue();\n        //测试 some\n        assertThat(StringUtil.isEmpty(strSome))\n                .isFalse();\n    }\n\n    @Test\n    public void isNotEmpty() {\n        //测试 null\n        assertThat(StringUtil.isNotEmpty(strNull))\n                .isFalse();\n        //测试 empty\n        assertThat(StringUtil.isNotEmpty(strEmpty))\n                .isFalse();\n        //测试 some\n        assertThat(StringUtil.isNotEmpty(strSome))\n                .isTrue();\n    }\n\n    @Test\n    public void isAnyEmpty() {\n        assertThat(StringUtil.isAnyEmpty(strNull, strEmpty, strSome))\n                .isTrue();\n        assertThat(StringUtil.isAnyEmpty())\n                .isFalse();\n    }\n\n    @Test\n    public void isAllEmpty() {\n        assertThat(StringUtil.isAllEmpty(strNull, strEmpty, strSome))\n                .isFalse();\n        assertThat(StringUtil.isAnyEmpty(strNull, strEmpty))\n                .isTrue();\n    }\n}\n```\n\n上面测试流程基本如下：\n\n- 构建出测试需要的参数（非必需）\n- 调用需要测试的方法\n- 使用 AssertJ 对得到的结果进行断言\n\n## Dao/Service 层测试\n\n准确的说是需要使用 Spring 容器的测试，测试方法有 2 种。\n\n1. 手动使用 `ApplicationContext` 去获取 Bean 然后进行测试\n2. 使用注解自动加载 Spring 测试环境\n\n### 手动使用 `ApplicationContext` 去获取 Bean 然后进行测试\n\n这里先演示手动使用 `ApplicationContext` 的做法进行测试，为了简化测试，这里直接使用 `H2DB` 和 `SpringJdbcTemplate`。\n\n```xml\n<!--spring-->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>4.3.14.RELEASE</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-jdbc</artifactId>\n    <version>4.3.14.RELEASE</version>\n</dependency>\n<!--h2 db-->\n<dependency>\n    <groupId>com.h2database</groupId>\n    <artifactId>h2</artifactId>\n    <version>1.4.196</version>\n    <scope>test</scope>\n</dependency>\n```\n\n创建初始化 sql 文件 `hsqldb/initDatabase.sql`\n\n```sql\ndrop table if exists user;\ncreate table user (\n  id   int auto_increment not null\n  comment '编号',\n  name varchar(20)        not null\n  comment '名字',\n  sex  boolean            null\n  comment '性别',\n  age  int                null\n  comment '年龄'\n);\n\ninsert into user (id, name, sex, age)\nvalues\n  (1, '琉璃', false, 17),\n  (2, '月姬', false, 1000);\n```\n\nSpring 配置文件 `spring/spring-context.xml`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n    <!--自动扫描-->\n    <context:component-scan base-package=\"com.rxliuli.study.springtest\"/>\n\n    <jdbc:embedded-database id=\"dataSource\" type=\"H2\">\n        <!--初始化 db-->\n        <jdbc:script location=\"classpath:hsqldb/initDatabase.sql\" encoding=\"UTF-8\"/>\n    </jdbc:embedded-database>\n\n    <!--配置 Spring JdbcTemplate-->\n    <bean class=\"org.springframework.jdbc.core.JdbcTemplate\" id=\"jdbcTemplate\"\n          p:dataSource-ref=\"dataSource\"/>\n</beans>\n```\n\n接下来我们可以编写实体类 `com.rxliuli.study.springtest.entity.User`，dao 层 `com.rxliuli.study.springtest.dao.UserDao` 和 dao 对应的测试类 `com.rxliuli.study.springtest.dao.UserDaoTest`。\n\n- User\n\n```java\n/**\n * @author rxliuli\n * @date 2018/7/31\n */\npublic class User {\n    private Integer id;\n    private String name;\n    private Boolean sex;\n    private Integer age;\n\n    public User() {\n    }\n\n    public User(String name, Boolean sex, Integer age) {\n        this.name = name;\n        this.sex = sex;\n        this.age = age;\n    }\n\n    public User(Integer id, String name, Boolean sex, Integer age) {\n        this.id = id;\n        this.name = name;\n        this.sex = sex;\n        this.age = age;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n\n    public User setId(Integer id) {\n        this.id = id;\n        return this;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public User setName(String name) {\n        this.name = name;\n        return this;\n    }\n\n    public Boolean getSex() {\n        return sex;\n    }\n\n    public User setSex(Boolean sex) {\n        this.sex = sex;\n        return this;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public User setAge(Integer age) {\n        this.age = age;\n        return this;\n    }\n}\n```\n\n- UserDao\n\n```java\n/**\n * @author rxliuli\n * @date 2018/7/31\n */\n@Repository\npublic class UserDao {\n    private final RowMapper<User> userRowMapper = (rs, rowNum) -> new User(\n            rs.getInt(\"id\"),\n            rs.getString(\"name\"),\n            rs.getBoolean(\"sex\"),\n            rs.getInt(\"age\")\n    );\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    /**\n     * 根据 id 获取一个对象\n     *\n     * @param id id\n     * @return 根据 id 查询到的对象，如果没有查到则为 null\n     */\n    public User get(Integer id) {\n        return jdbcTemplate.queryForObject(\"select * from user where id = ?\", userRowMapper, id);\n    }\n\n    /**\n     * 查询全部用户\n     *\n     * @return 全部用户列表\n     */\n    public List<User> listForAll() {\n        return jdbcTemplate.query(\"select * from user\", userRowMapper);\n    }\n}\n```\n\n> 注：这里直接使用了 Dao 类，生产过程中最好使用接口。\n\n- UserDaoTest\n\n```java\n/**\n * @author rxliuli\n * @date 2018/7/31\n */\npublic class UserDaoTest {\n    private UserDao userDao;\n\n    @Before\n    public void before() {\n        //使用 spring xml 配置文件初始化 ApplicationContext\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:/spring/spring-context.xml\");\n        //然后使用 ApplicationContext 获取 UserDao 的对象\n        userDao = context.getBean(UserDao.class);\n    }\n\n    @Test\n    public void get() {\n        int id = 1;\n        User result = userDao.get(id);\n        //断言 id 和 get id 相同\n        assertThat(result)\n                .extracting(User::getId)\n                .contains(id);\n    }\n\n    @Test\n    public void listForAll() {\n        List<User> userList = userDao.listForAll();\n        //断言不为空\n        assertThat(userList)\n                .isNotEmpty();\n    }\n}\n```\n\n手动加载的基本思路就是：\n\n- 先加载 ApplicationContext 初始化 Spring 环境\n  注：这一步实际上就已经加载了 Spring 容器，并且使用 `initDatabase.sql` 初始化 h2 DB 了\n- 使用 ApplicationContext 对象获得 UserDao 实例\n- 调用被测试的方法\n- 对结果进行断言\n\n但这里实际上，ApplicationContext 是会被初始化两次的，所以会造成浪费和麻烦（例如初始化 sql 脚本也会被执行两次，当然这里吾辈先把 user 表删除后再创建的所以没事）。其实 Spring 早已想到了这一切，并为我们准备了解决方案。\n\n使用 `SpringTest` 整合测试！\n\n### 使用注解自动加载 Spring 测试环境\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-test</artifactId>\n    <version>4.3.14.RELEASE</version>\n    <scope>test</scope>\n</dependency>\n```\n\n使用 SpringTest 进行测试\n\n```java\n/**\n * @author rxliuli\n * @date 2018/7/31\n */\n//加载 Spring 配置文件\n@ContextConfiguration(locations = \"classpath:/spring/spring-context.xml\")\n//使用 SpringJUnit4ClassRunner 来运行 test\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class UserDaoSpringTest {\n    /**\n     * 直接注入 UserDao 就好了\n     */\n    @Autowired\n    private UserDao userDao;\n\n    @Test\n    public void get() {\n        int id = 1;\n        User result = userDao.get(id);\n        //断言 id 和 get id 相同\n        assertThat(result)\n                .extracting(User::getId)\n                .contains(id);\n    }\n\n    @Test\n    public void listForAll() {\n        List<User> userList = userDao.listForAll();\n        //断言不为空\n        assertThat(userList)\n                .isNotEmpty();\n    }\n}\n```\n\n可以看到，这里我们甚至可以使用 Spring 的自动注入注解 `@Autowired` 了\n\n当然，现在还有一个问题就是现在测试对数据库的影响是持久的，也就是说不能重复的测试。\n例如删除了一个为 id 为 1 的用户，返回值应当是 1，但第二次删除时，因为 id 为 1 的用户已经不存在了，所以返回值是 0，然后就报错了 23333\n\n我们可以测试一下\n\n1. 在 UserDao 中新增方法 `deleteById`\n\n```java\n/**\n * 根据 id 删除用户\n *\n * @param id 用户 id\n * @return 受影响行数\n */\npublic int deleteById(Integer id) {\n    return jdbcTemplate.update(\"delete from user where id = ?\", id);\n}\n```\n\n然后在测试类 `UserDaoSpringTest` 中添加两个删除测试方法\n\n```java\n@Test\npublic void deleteById() {\n    int result = userDao.deleteById(1);\n    assertThat(result)\n            .isGreaterThan(0);\n}\n\n@Test\npublic void deleteByIdForTransaction() {\n    //这个仅仅是为了测试事物与自动回滚是否生效\n    int result = userDao.deleteById(1);\n    assertThat(result)\n            .isGreaterThan(0);\n}\n```\n\n然后运行测试类，你会得到一个错误\n\n```java\njava.lang.AssertionError:\nExpecting:\n <0>\nto be greater than:\n <0>\n```\n\n所以我们需要让所有测试的操作都不影响到数据库，即 **全局事物** + **默认回滚**。\n\n首先需要在 `spring-context.xml` 中添加数据库事务管理的配置\n\n```xml\n<!--配置数据库事务并开启注解支持-->\n<bean class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\" id=\"dataSourceTransactionManager\"\n        p:dataSource-ref=\"dataSource\"/>\n<tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\"/>\n```\n\n在 `UserDaoSpringTest` 测试类上添加两个注解\n\n```java\n//为这个测试类开启事物\n@Transactional\n//默认回滚所有数据库操作\n@Rollback\n```\n\n再次运行，一切便都正常了，是不是感觉很棒！但每个测试类头上都加那么一大堆注解也很麻烦，所以我们需要将之抽出一个父类直接继承就好了\n\n以下是一个最简单的测试基类 `BaseTest`(common.test.BaseTest)\n\n```java\n/**\n * 简单的测试基类\n * <BaseBean> 需要自动注入的 Bean 类型\n *\n * @author rxliuli\n * @date 2018/7/31\n */\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:/spring/spring-context*.xml\")\n@Transactional\n@Rollback\npublic abstract class BaseTest<BaseBean> {\n    /**\n     * 自动注入的 Bean\n     */\n    @SuppressWarnings(\"SpringJavaInjectionPointsAutowiringInspection\")\n    @Autowired\n    private BaseBean base;\n}\n```\n\n然后创建测试类 `UserDaoBaseTest`(com.rxliuli.study.springtest.dao.UserDaoBaseTest) 继承 `BaseTest` 进行测试\n\n```java\n/**\n * @author rxliuli\n * @date 2018/7/31\n */\npublic class UserDaoBaseTest extends BaseTest<UserDao> {\n    @Test\n    public void get() {\n        int id = 1;\n        User result = base.get(id);\n        //断言 id 和 get id 相同\n        assertThat(result)\n                .extracting(User::getId)\n                .contains(id);\n    }\n\n    @Test\n    public void listForAll() {\n        List<User> userList = base.listForAll();\n        //断言不为空\n        assertThat(userList)\n                .isNotEmpty();\n    }\n\n    @Test\n    public void deleteById() {\n        int result = base.deleteById(1);\n        assertThat(result)\n                .isGreaterThan(0);\n    }\n\n    @Test\n    public void deleteByIdForTransaction() {\n        //这个仅仅是为了测试事物与自动回滚是否生效\n        int result = base.deleteById(1);\n        assertThat(result)\n                .isGreaterThan(0);\n    }\n}\n```\n\n运行结果也是一切正常呢，对 Dao/Service 需要加载 Spring 容器的测试暂且到这里便结束了。。。\n\n## Web 层测试\n\n绝大部分时候，很多人喜欢写完代码就到前台页面直接看效果。但人眼是不一定准确的，而且可重复性/可靠性不足。如果是 API，大部分人或许会选择诸如 **Postman**, **IDEA HttpClient** 这一类的工具吧，但实际上，SpringTest 已经考虑到了对 Web 层的测试并集成了这些。\n\n首先还是需要添加依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>4.3.14.RELEASE</version>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-core</artifactId>\n    <version>2.9.5</version>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.9.5</version>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-annotations</artifactId>\n    <version>2.9.5</version>\n</dependency>\n<dependency>\n    <groupId>com.fasterxml.jackson.module</groupId>\n    <artifactId>jackson-module-jaxb-annotations</artifactId>\n    <version>2.9.5</version>\n</dependency>\n<!--json-path-assert 对 MockMvc response 中返回的 json 数据进行断言-->\n<dependency>\n    <groupId>com.jayway.jsonpath</groupId>\n    <artifactId>json-path-assert</artifactId>\n    <version>2.4.0</version>\n    <scope>test</scope>\n</dependency>\n```\n\n设置 maven 打包时为 `war`\n\n```xml\n<packaging>war</packaging>\n```\n\n添加配置文件 `spring/spring-mvc.xml`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n    <!--配置支持注解并自动扫描-->\n    <mvc:annotation-driven/>\n    <context:component-scan base-package=\"com.rxliuli.study.springtest\">\n        <context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n        <context:include-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.RestController\"/>\n    </context:component-scan>\n</beans>\n```\n\n添加 web 的根目录 `/src/main/webapp` 并在 webapp 目录下创建 `web.xml`(WEB-INF/web.xml)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"\n         version=\"3.1\">\n    <!--context configLocation -->\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath*:/spring/spring-context*.xml</param-value>\n    </context-param>\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n    <listener>\n        <listener-class>org.springframework.web.context.request.RequestContextListener</listener-class>\n    </listener>\n\n    <!--encoding filter-->\n    <filter>\n        <filter-name>encodingFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>UTF-8</param-value>\n        </init-param>\n        <init-param>\n            <param-name>forceEncoding</param-name>\n            <param-value>true</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>encodingFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n\n    <!--MVC Servlet-->\n    <servlet>\n        <servlet-name>springServlet</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath*:/spring/spring-mvc*.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>springServlet</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n</web-app>\n```\n\n至此，项目中便添加了 web 环境支持。\n\n下面开始编写要测试的接口 `UserController`(com.rxliuli.study.springtest.web.UserController)\n\n```java\n/**\n * @author rxliuli\n * @date 2018/7/31\n */\n@RestController\npublic class UserController {\n    @Autowired\n    private UserDao userDao;\n\n    /**\n     * 获取用户信息\n     *\n     * @param id 用户 id\n     * @return 用户对象信息\n     */\n    @GetMapping(\"/user/{id}\")\n    public User get(@PathVariable(\"id\") Integer id) {\n        return userDao.get(id);\n    }\n\n    /**\n     * 获取全部的用户列表\n     *\n     * @return 全部的用户列表\n     */\n    @PostMapping(\"/user/listForAll\")\n    public List<User> listForAll() {\n        return userDao.listForAll();\n    }\n}\n```\n\n这时候启动 web 项目在浏览器中访问 `localhost:8080/{上下文}/user/1` 应当会得到一个 User 对象。\n\n> 注：上下文 IDEA 默认为空，Eclipse 默认为项目名\n\n然而测试却是有两种方法：\n\n1. 独立安装测试  \n   手动加载单个 Controller，所以测试其他 Controller 中的接口会发生异常。但测试速度上较快，所以应当优先选择。\n2. 集成 Web 环境测试  \n   将启动并且加载所有的 Controller, 所以效率上之于 BaseWebUnitTest 来说非常低下, 仅适用于集成测试多个 Controller 时使用。\n\n### 独立安装测试\n\n简单的独立安装测试类 `UserControllerUnitTest`(com.rxliuli.study.springtest.web.UserControllerUnitTest)\n\n```java\n/**\n * @author rxliuli\n * @date 2018/7/31\n */\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:/spring/spring-*.xml\")\n@Transactional\n@Rollback\n@WebAppConfiguration\npublic class UserControllerUnitTest {\n    @Autowired\n    private UserController userController;\n    /**\n     * 用于测试 API 的模拟请求对象\n     */\n    private MockMvc mockMvc;\n\n    @Before\n    public void before() {\n        //模拟一个 Mvc 测试环境，获取一个 MockMvc 实例\n        mockMvc = MockMvcBuilders.standaloneSetup(userController)\n                .build();\n    }\n\n    @Test\n    public void testGet() throws Exception {\n        //测试能够正常获取\n        Integer id = 1;\n        mockMvc.perform(\n                //发起 get 请求\n                get(\"/user/\" + id)\n        )\n                //断言请求的状态是成功的(200)\n                .andExpect(status().isOk())\n                //断言返回对象的 id 和请求的 id 相同\n                .andExpect(jsonPath(\"$.id\").value(id));\n    }\n\n    @Test\n    public void listForAll() throws Exception {\n        //测试正常获取\n        mockMvc.perform(\n                //发起 post 请求\n                post(\"/user/listForAll\")\n        )\n                //断言请求状态\n                .andExpect(status().isOk())\n                //断言返回结果是数组\n                .andExpect(jsonPath(\"$\").isArray())\n                //断言返回数组不是空的\n                .andExpect(jsonPath(\"$\").isNotEmpty());\n    }\n}\n```\n\n### 集成 Web 环境测试\n\n简单的独立安装测试类 `UserControllerIntegratedTest`(com.rxliuli.study.springtest.web.UserControllerIntegratedTest)\n\n```java\n/**\n * @author rxliuli\n * @date 2018/7/31\n */\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = \"classpath:/spring/spring-*.xml\")\n@Transactional\n@Rollback\n@WebAppConfiguration\npublic class UserControllerIntegratedTest {\n    @Autowired\n    private WebApplicationContext context;\n    /**\n     * 用于测试 API 的模拟请求对象\n     */\n    private MockMvc mockMvc;\n\n    @Before\n    public void before() {\n        //这里把整个 WebApplicationContext 上下文都丢进去了，所以可以测试所有的 Controller\n        mockMvc = MockMvcBuilders.webAppContextSetup(context)\n                .build();\n    }\n\n    @Test\n    public void testGet() throws Exception {\n        //测试能够正常获取\n        Integer id = 1;\n        mockMvc.perform(\n                //发起 get 请求\n                get(\"/user/\" + id)\n        )\n                //断言请求的状态是成功的(200)\n                .andExpect(status().isOk())\n                //断言返回对象的 id 和请求的 id 相同\n                .andExpect(jsonPath(\"$.id\").value(id));\n    }\n\n    @Test\n    public void listForAll() throws Exception {\n        //测试正常获取\n        mockMvc.perform(\n                //发起 post 请求\n                post(\"/user/listForAll\")\n        )\n                //断言请求状态\n                .andExpect(status().isOk())\n                //断言返回结果是数组\n                .andExpect(jsonPath(\"$\").isArray())\n                //断言返回数组不是空的\n                .andExpect(jsonPath(\"$\").isNotEmpty());\n    }\n}\n```\n\n---\n\n其实从上面可以看出来主要就是获得 MockMvc 的方式不同，所以其实也可以抽出来公共的测试父类。这里就不再赘述，具体的做法可以参考 [测试基类](https://github.com/rxliuli/springtest/tree/master/src/test/java/common)\n\n那么，有关使用 Spring 进行测试的问题就像说到这里啦\n\n> 附：用了 SpringBoot 之后才觉得 Spring 的各种配置好麻烦。。。\n","createdTime":1587219249397,"updatedTime":1609304929445,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"eb0e9882c19546bfa4b90e8190e25fa3","title":"成为 Java 高级程序员需要掌握哪些？","body":"> 转自 <https://blog.csdn.net/zhibuguonicuo/article/details/60345715>，吾辈只修改了部分排版/错字以更好的阅读。\n\n## Section 1\n\n1. Core Java，就是 Java 基础、JDK 的类库，很多童鞋都会说，JDK 我懂，但是懂还不足够，知其然还要知其所以然，JDK 的源代码写的非常好，要经常查看，对使用频繁的类，比如 String，集合类（List，Map，Set）等数据结构要知道它们的实现，不同的集合类有什么区别，然后才能知道在一个具体的场合下使用哪个集合类更适合、更高效，这些内容直接看源代码就 OK 了\n\n2. 多线程并发编程，现在并发几乎是写服务端程序必须的技术，那对 Java 中的多线程就要有足够的熟悉，包括对象锁机制、synchronized 关键字，concurrent 包都要非常熟悉，这部分推荐你看看《Java 并发编程实践》这本书，讲解的很详细\n\n3. I/O，Socket 编程，首先要熟悉 Java 中 Socket 编程，以及 I/O 包，再深入下去就是 Java NIO, 再深入下去是操作系统底层的 Socket 实现, 了解 Windows 和 Linux 中是怎么实现 socket 的\n\n4. JVM 的一些知识，不需要熟悉，但是需要了解，这是 Java 的本质，可以说是 Java 的母体, 了解之后眼界会更宽阔，比如 Java 内存模型（会对理解 Java 锁、多线程有帮助）、字节码、JVM 的模型、各种垃圾收集器以及选择、JVM 的执行参数（优化 JVM）等等, 这些知识在《深入 Java 虚拟机》这本书中都有详尽的解释, 或者去 oracle 网站上查看具体版本的 JVM 规范.\n\n5. 一些常用的设计模式，比如单例、模板方法、代理、适配器等等，以及在 Core Java 和一些 Java 框架里的具体场景的实现，这个可能需要慢慢积累，先了解有哪些使用场景，见得多了，自己就自然而然会去用。\n\n6. 常用数据库（Oracle、MySQL 等）、SQL 语句以及一般的优化\n\n7. JavaWeb 开发的框架，比如 Spring、iBatis 等框架，同样他们的原理才是最重要的，至少要知道他们的大致原理。\n\n8. 其他一些有名的用的比较多的开源框架和包，Netty 网络框架，Apache common 的 N 多包，Google 的 Guava 等等，也可以经常去 Github 上找一些代码看看。\n\n## section 2\n\n每逢长假都会有很多程序员跳槽，十一、过年是跳槽黄金时刻，尤其是过年。过年的时候年终奖到手，没有了多少牵挂，年终同学同事聚会比较多，沟通的就多，各种工作机会的消息也相应会多，所以跳槽的机会也就会多。跳槽就必不可少的要经过面试，那么作为一个 Java 程序员需要准备哪些面试知识呢？下面就给大家说说。\n\n1. 集合框架  \n    ![集合框架](https://img.rxliuli.com/20181126223446.png)  \n   从上图可以看到主要是 Collection 和 Map 的继承类和 Iterator 的实现类，重点掌握 ArrayList、LinkedList、Vector、Stack、PriorityQueue、HashSet、LinkedHashSet、TreeSet、HashMap、LinkedHashMap、TreeMap、WeakHashMap、EnumMap、TreeMap、HashTable 的特点和实现原理，还有多线程使用场景和插入多还是删除多的时候使用什么样的集合类效率会更高。\n\n2. IO 框架  \n   ![IO 框架](https://img.rxliuli.com/20181126223616.png)  \n   主要掌握 Reader、Writer、InputStream、OutputStream 的继承类，重点掌握字节流 (FileInputStream、FileOutputSteam、BufferedInputStream、BufferedOutputStream、DataInputStream、DataOutputStream) 和字符流(FileReader、FileWriter、BufferedReader、BufferedWriter、InputStreamReader、OutputStreamWriter)，并熟练运用。还有就是 NIO 的工作原理要知道。\n\n3. String 相关  \n   主要考察对 String 的处理，顺带考察多线程和算法，大公司就是喜欢考察字符串的算法，主要是字符串查找或者剔除，多线程打印字符串，超大字符串处理。\n\n4. 异常处理  \n   ![异常处理](https://img.rxliuli.com/20181126223820.png)  \n   掌握 Throwable 继承类，理解 Error 和 Exception 的区别，理解运行时异常和编译异常的区别，掌握异常的处理方法，掌握 try、catch、finally、throw、throws 关键字的意义，掌握 try-catch-finally 语句的执行顺序，掌握异常的工作原理，知道常见的异常有哪些。\n\n5. 多线程  \n   如何创建和启动一个线程，有哪些方法？多线程如何交互，线程之间的调度、让步、合并，如何同步？生产和消费者模型。还有就是掌握线程安全、线程池，死锁。\n\n6. JVM 知识  \n   掌握常见的垃圾回收机制，掌握程序计数器、堆、栈、方法区的作用，掌握类的加载机制。掌握内存分代模型和工作原理。掌握 JVM 启动参数常见配置，了解 JVM 调优。\n\n7. 数据结构与算法：  \n   掌握常见查找和排序算法实现及其时间、空间复杂度。掌握常见数据结构如链表、队列、栈的基本原理和实现。\n\n## section 3\n\n经常主持对高级工程师和中基层 Tech Leader 的面试，一年下来总有百八十场，我给大家分享一下我对于高级工程师的定位吧，虽然我主要负责. Net 团队，但是对于其他语言应该也是适用的。\n\n**一、理论基础：** 高级工程师必须有较好的理论基础，既包含一些基础的学科知识，也要包含个人专攻方向的前沿理论。我遇到过形形色色的求职者，有人自称精通领域模式，却不明白什么是聚合根（领域根）。甚至有人无法列举常用的非线性结构，更别提伪码实现和应用场景分析了。这些人普遍振振有词地说， 我有丰富的开发经验，项目需要实现的功能我都能做出来，我只是没有去记那些术语名词。抱歉，你不是没有记术语名词，你是根本没有潜心看技术文章的心态，你所谓的学习就是看一些诸如《21 天精通 Java》，《7 天，从菜鸟到专家》之类的垃圾书，或者看点视频。那么你这个高工，比别人高在哪里呢？当单位需要你代表团队和合作机构沟通，甚至发表专栏的时候，你是不是也准备跟大家讲” 这个东西我不知道该怎么讲，大家可以看一下我的代码 “。只有代码可秀的人是码农，不是高工，所以我给这类求职者的综评是中 + 封顶。\n\n**二、工作经验：** 高级工程师必须有过在项目中担心核心模块开发或者整体架构设计的经验，并且项目越高大上越好，比如你在互联网企业搞过读写分离的实现，你在电商搞过秒杀算法，你在电信行业做过网络层，我必定会高看一眼。如果你就仅仅只是一个人全栈搞过几个小网站，啪啪啪一大堆成熟框架用得倍溜，那么你只是一个装配工。我给这类求职者的综评是中 + 封顶。\n\n**三、培养潜力：** 高级工程师必须有全局思维，如果在你过往的工作历程中，你对你兄弟团队或者部门的工作情形一问三不知，甚至于一个项目中，你只懂自己的模块，其他同事负责的模块你就只会 call 个 API，那么你就是一个很难再进一步的人。对于企业来说，有你不多，无你不少，所以我给这类求职者的综评是中 + 封顶。\n\n**四、沟通能力：** 高级工程师在技术团队中是绝对的核心人中，小项目中你就是负责人，大项目中你也要负责带新人，那么良好的沟通能力必不可少，如果你仅仅是自己一个人心里亮堂，你对企业的价值就要大打折扣。这类求职者，我也有录用过不少，因为程序员木讷可以说是一种共性，在这方面没法太挑剔，但是我给他们的综评是高 - 封顶。\n\n## section 4\n\n如果要应聘高级开发工程师职务，仅仅懂得 Java 的基础知识是远远不够的，还必须懂得常用数据结构、算法、网 络、操作系统等知识。因此本文不会讲解具体的技术，笔者综合自己应聘各大公司的经历，整理了一份大公司对 Java 高级开发工程师职位的考核纲要，希望可以帮助到需要的人。\n\n### 1、Java 基础\n\n#### 1.1 Collection 和 Map\n\n1. 掌握 Collection 和 Map 的继承体系。\n2. 掌握 ArrayList、LinkedList、Vector、Stack、PriorityQueue、HashSet、 LinkedHashSet、TreeSet、HashMap、LinkedHashMap、TreeMap、WeakHashMap、EnumMap、 TreeMap、HashTable 的特点和实现原理。\n3. 掌握 CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap 的实现原理和适用场景。\n\n#### 1.2 IO\n\n1. 掌握 InputStream、OutputStream、Reader、Writer 的继承体系。\n2. 掌握字节流 (FileInputStream、DataInputStream、BufferedInputStream、 FileOutputSteam、DataOutputStream、BufferedOutputStream) 和字符流 (BufferedReader、InputStreamReader、FileReader、BufferedWriter、 OutputStreamWriter、PrintWriter、FileWriter)，并熟练运用。\n3. 掌握 NIO 实现原理及使用方法。\n\n#### 1.3 异常\n\n1. 掌握 Throwable 继承体系。\n2. 掌握异常工作原理。\n3. 了解常见受检异常 (比如 FileNotFoundException)、非受检异常(比如 NullPointerException) 和错误(比如 IOError)。\n\n#### 1.4 多线程\n\n1. 掌握 Executors 可以创建的三种 (JAVA8 增加了一种，共四种) 线程池的特点及适用范围。\n2. 掌握多线程同步机制，并熟练运用。\n\n#### 1.5 Socket\n\n1. 掌握 Socket 通信原理。\n2. 熟练使用多线程结合 Socket 进行编程。\n\n### 2、Java 虚拟机\n\n#### 2.1 JVM 内存区域划分\n\n1. 掌握程序计数器、堆、虚拟机栈、本地方法栈、方法区（JAVA8 已移除）、元空间（JAVA8 新增）的作用及基本原理。\n2. 掌握堆的划分：新生代（Eden、Survivor1、Survivor2）和老年代的作用及工作原理。\n3. 掌握 JVM 内存参数设置及调优。\n\n#### 2.2 类加载\n\n1. 掌握类的加载阶段：加载、链接（验证、准备、解析）、初始化、使用、卸载。\n2. 掌握类加载器分类及其应用：启动类加载器、扩展类加载器、应用程序类加载器、自定义加载器。\n\n#### 3、J2EE\n\n1. 掌握 JSP 内置对象、动作及相关特点和工作原理。\n2. 掌握 Servlet 的特点和工作原理。\n3. 掌握 Spring 框架的 IOC 和 AOP 实现原理（反射和动态代理）。\n4. 至少掌握一个 MVC 框架（Spring MVC，Struts 等）的工作原理，并熟练运用。\n5. 至少掌握一个 ORM 框架 (Hibernate，MyBatis 等) 的工作原理，并熟练运用。\n\n#### 4、数据结构与算法\n\n1. 掌握线性表和树的特点并熟练运用。\n2. 掌握常用排序和查找算法：插入排序 (直接插入排序、希尔排序)、选择排序 (直接选择排序、堆排序)、交换排序 (冒泡排序、快速排序)、归并排序，顺序查找、二分查找、哈希查找。\n3. 熟练运用常见排序和查找算法思想解决编程问题。\n4. 了解几大基本算法：贪心算法、分治策略、动态规划。\n\n#### 5、计算机网络\n\n1. 掌握网络的分层结构，及每层的功能特点。\n2. 掌握 TCP/IP 的通信原理 (三次握手、四次挥手)\n\n#### 6、数据库\n\n1. 掌握复杂的 SQL 语句编写。\n2. 掌握数据库的优化（SQL 层面和表设计层面）。\n3. 至少掌握一款数据库产品。\n4. 熟悉高并发、大数据情况下的数据库开发。\n\n#### 7、Web 技术\n\n1. 掌握 AJAX 的工作原理。\n2. 至少熟悉一款 JS 框架 (比如 JQuery)。\n\n#### 8、设计模式\n\n1. 熟悉常见的设计模式。\n2. 会将设计模式理论应用到实际开发中。\n\n#### 9、Linux\n\n1. 熟练运用 Linux 常见命令。\n2. 熟悉 Linux 操作系统基本概念及特点。\n3. 熟悉 Shell 脚本。\n\n#### 10、操作系统\n\n1. 掌握操作系统的进程管理。\n2. 了解操作系统的 I/O。\n\n#### 11、正则表达式\n\n1. 掌握常见正则表达式符号。\n2. 熟练运用正则表达式解决实际问题 (比如匹配电话号码、邮箱、域名等)。\n\n## Section 5\n\n- h5edu 的源码\n- pure-- 响应式 css 框架\n- Hadoop 大数据\n- ERP 系统开发\n- linux\n- freemarker\n- weblogic/jobss\n- webwhpere\n- webservice http://www.iteye.com/topic/1135747\n- bootstrap\n- HTML5\n- android\n- css/jslever\n- spring aop ssh ssm 徒手搭建\n- jquery 源码分析融汇\n- 缓存 echacge\n- 并发\n- 页面静态化\n- UML\n- shell\n- pathy\n- github\n- 网络编程\n- ExtJS\n- 网络爬虫\n- 设计模式\n- 多线程与并发\n- 第三方支付 / 登录\n\n## ============= 高级工程 =============\n\n### 1、Core Java 部分\n\n这是最基础的, 对于一个 java 高级开发 / 设计人员, 你需要对这一部分达到精通的水平, 重点内容如下:\n\n1. 面向对象编程思想 (封装继承多态接口)\n2. 字符串处理\n3. java.lang 包, java.util 包等常用包\n4. java 异常处理\n\n### 2、Java 高级部分\n\n1. Java I/O 流\n2. Java 多线程技术\n3. Java 网络编程\n4. Java Swing\n\n> 后两项可以了解即可, 如果项目需要可以深入研究\n\n### 3、前端基本技能\n\n- HTML + CSS 网页开发\n- JavaScript\n- Jquery\n- 浏览器兼容性 CSS hack(了解)\n\n### 4、熟练使用 JSP + Servlet 进行开发\n\n### 5、MVC 设计模式, 原理, 以及相关框架, 如 Struts\n\n### 6、SSH 框架\n\n### 7、缓存技术 session & cookie\n\n### 8、熟练使用一种以上 Java 开发工具\n\nEclipse/MyEclipse/Jbuilder/Jcreator\n\n### 9、熟练使用 XML\n\nJDOM w3c.dom SAX\n\n### 10、Java 设计模式\n\n工厂模式, 单例模式 ==\n\n### 11、Java 反射机制\n\n反射的各种用法\n\n### 12、了解或熟悉 C, C++, .NET\n\n### 13、熟悉 JDK 的配置, 环境变量\n\n### 14、数据库 oracle 必学, 其他最好了解一种以上 (mysql,sql server,access==)\n\noracle: 视图, 索引, 存储过程, 触发器, 游标, 包, 常用函数 ==\n\n### 15、数据库原理\n\n事务的原理, 锁机制, 表连接, 复杂查询语句 (工作经验), 性能调优, 锁表以及解决方案 ==\n\n### 16、JDBC, 连接池\n\n### 17、Ajax, 反向 Ajax\n\n### 18、HTTP 协议, request 和 response 的原理, HTTP status(了解常用的),Https 原理\n\n### 19、熟悉 Linux 基本命令, 使用过 Linux/Unix 系统, 可以编写 shell 脚本, 可以在 Linux 上部署项目\n\n### 20、了解 windows 系统批处理脚本 bat\n\n### 21、了解 HTML5, 最好学习过\n\n### 22、熟悉一种 JS 框架, 如 Prototype\n\n### 23、J2EE 原理 熟悉一种以上 web 容器如 Tomcat,JBoss,websphere,weblogic==\n\n### 24、熟悉 ant 或 maven\n\n### 25、熟悉一门脚本语言, 如 python ,ruby\n\n26. 了解 php/ asp\n\n### 27、了解 ftp 协议及原理\n\n### 28、熟练使用 Junit 测试, 熟悉 Mockito 等测试工具\n\n### 29、熟悉 javac,javadoc,native,native2ascii 等常用命令\n\n### 30、熟悉常用的排序算法, 如冒泡排序, 快速排序等, 最好自己研究过一些的算法, 下面的这个就是我曾经研究过的一个:\n\nhttp wenku baidu com /view/391db3f0941ea76e58fa04e9 点 html\nhttp://wenku.baidu.com/view.391db3f0941ea76e58fa04e9.html\n\n### 31、了解 Flex(不学也没关系)\n\n### 32、了解敏捷开发模式\n\n### 33、工作流 workflow 至少用过一种, 如 OSworkflow, 了解原理\n\n### 34、使用过 VPN 了解其原理\n\n### 35、熟悉 jstl 表达式和 el 表达式\n\n### 36、熟悉 webservice,WSDL,SOAP\n\n### 37、图片处理, 如图片上传, 预览, 限制大小等, 下面共享一 (垃圾勿喷):\n\nhttp wenku baidu com/view/05337bfc770bf78a6529541b 点 html\n\n### 38、版本控制工具, CVS VSS SVN\n\n### 39、JSON 技术, JSON+AJAX\n\n### 40、分页技术, 最好自己实现过不仅仅是用过要知道原理\n\n### 41、Java Mail\n\n### 42、Java 读写 txt,excel\n\nJXL 技术\n\n### 43、JVM 原理, JVM 内存管理, GC,Java 堆栈池\n\n### 44、熟练使用下面的工具:\n\n- office 办公软件, word,excel,ppt 等\n- plsql,sqldevelop 数据库开发工具\n- outlook 大公司都用\n- ue 编辑器\n- 浏览器控制台, 调试\n- SHH/PUTTY 远程\n\n### 45、UML 建模工具 Rational Rose 等\n\n### 46、使用 log4j\n\n### 47、使用过开放 API 如百度地图, 腾讯街景, 新浪微博等\n\n### 48、页面静态化技术 (伪静态页面)UrlRwriter\n\n### 49、报表技术, 使用过报表制作工具, 如水晶易表\n\n### 50、定时任务, 如 Spring batch, 学会自定义 batch 任务 (不适用第三方工具)\n\n### 51、了解 uuid\n\n### 52、B/s 和 C/s 架构\n\n### 53、正则表达式\n\n### 54、了解 JNDI JMS\n\n### 55、ERP\n\n### 56、unicode 编码, 乱码的解决\n\n### 57、开源网络编辑器, 如 ckEditor\n\n### 58、二进制原理\n\n### 59、使用过, 了解开源论坛框架, 如 discuzz\n\n### 60、GWT ,Closure 框架\n\n### 61、了解 大数据, 云计算\n\n### 62、搜索引擎搜索技术\n\n### 63、软件工程, 项目管理\n\n![软件工程, 项目管理](https://img.rxliuli.com/20181126225820.png)\n\n1. 你需要精通面向对象分析与设计 (OOA/OOD)、涉及模式(GOF，J2EEDP) 以及综合模式。你应该十分了解 UML，尤其是 class，object，interaction 以及 statediagrams。\n2. 你需要学习 JAVA 语言的基础知识以及它的核心类库 (collections，serialization，streams，networking， multithreading，reflection，event，handling，NIO，localization，以及其他)。\n3. 你应该了解 JVM，classloaders，classreflect，以及垃圾回收的基本工作机制等。你应该有能力反编译一个类文件并且明白一些基本的汇编指令。\n4. 如果你将要写客户端程序，你需要学习 WEB 的小应用程序 (applet)，必需掌握 GUI 设计的思想和方法，以及桌面程序的 SWING，AWT， SWT。你还应该对 UI 部件的 JAVABEAN 组件模式有所了解。\n   JAVABEANS 也被应用在 JSP 中以把业务逻辑从表现层中分离出来。\n5. 你需要学习 java 数据库技术，如 JDBCAPI 并且会使用至少一种 persistence/ORM 构架，例如 Hibernate，JDO， CocoBase，TopLink，InsideLiberator(国产 JDO 红工厂软件) 或者 iBatis。\n6. 你还应该了解对象关系的阻抗失配的含义，以及它是如何影响业务对象的与关系型数据库的交互，和它的运行结果，还需要掌握不同的数据库产品运用，比如: oracle，mysql，mssqlserver。\n7. 你需要学习 JAVA 的沙盒安全模式 (classloaders，bytecodeverification，managers，policyandpermissions，\n   codesigning， digitalsignatures，cryptography，certification，Kerberos，以及其他) 还有不同的安全 / 认证 API，例如 JAAS(JavaAuthenticationandAuthorizationService)，\n   JCE (JavaCryptographyExtension)，JSSE(JavaSecureSocketExtension)，以及 JGSS (JavaGeneralSecurityService)。\n8. 你需要学习 Servlets，JSP，以及 JSTL(StandardTagLibraries) 和可以选择的第三方 TagLibraries。\n9. 你需要熟悉主流的网页框架，例如 JSF，Struts，Tapestry，Cocoon，WebWork，以及他们下面的涉及模式，如 MVC/MODEL2。\n10. 你需要学习如何使用及管理 WEB 服务器，例如 tomcat，resin，Jrun，并且知道如何在其基础上扩展和维护 WEB 程序。\n11. 你需要学习分布式对象以及远程 API，例如 RMI 和 RMI/IIOP。\n12. 你需要掌握各种流行中间件技术标准和与 java 结合实现，比如 Tuxedo、CROBA，当然也包括 javaEE 本身。\n13. 你需要学习最少一种的 XMLAPI，例如 JAXP(JavaAPIforXMLProcessing)，JDOM(JavaforXMLDocumentObjectModel)，DOM4J，或 JAXR(JavaAPIforXMLRegistries)。\n14. 你应该学习如何利用 JAVAAPI 和工具来构建 WebService。例如 JAX-RPC(JavaAPIforXML/RPC)，SAAJ (SOAPwithAttachmentsAPIforJava)，JAXB(JavaArchitectureforXMLBinding)，\n    JAXM(JavaAPIforXMLMessaging)， JAXR(JavaAPIforXMLRegistries)，或者 JWSDP(JavaWebServicesDeveloperPack)。\n15. 你需要学习一门轻量级应用程序框架，例如 Spring，PicoContainer，Avalon，以及它们的 IoC/DI 风格 (setter，constructor，interfaceinjection)。\n16. 你需要熟悉不同的 J2EE 技术，例如 JNDI(JavaNamingandDirectoryInterface)，JMS (JavaMessageService)，JTA/JTS(JavaTransactionAPI/JavaTransactionService)\n","createdTime":1587219249398,"updatedTime":1609304917784,"resources":[],"tags":[{"id":"d574d7de00434d869972201a262124c8","title":"转载","parent_id":""},{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"2d25acf8a5c5447aae3f4a1522dc5651","title":"在 VSCode 中使用路径别名也有提示","body":"## 场景\r\n\r\n最近在学 ReactJS，遇到了一个很奇怪的问题。当吾辈在 webpack 配置中配置了路径别名之后，VSCode 再输入路径便没有了提示。\r\n\r\n路径别名配置\r\n\r\n```js\r\nalias: {\r\n  // Support React Native Web\r\n  // https://www.smashingmagazine.com/2016/08/a-glimpse-into-the-future-with-react-native-for-web/\r\n  'react-native': 'react-native-web',\r\n  '@': path.resolve(__dirname, '../src'),\r\n},\r\n```\r\n\r\n吾辈也安装了 [Path Intellisense](https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense) 插件，然而这毫无意义，仍然是只有在相对路径的情况下才会提示。\r\n\r\n## 解决\r\n\r\n抱着这个疑问，吾辈稍微去搜索了一下。然后，找到了 [webpack 自定义别名后，VScode 路径提示问题](https://segmentfault.com/q/1010000014941483) 这个问题。在下面的回答中，吾辈找到了答案。\r\n\r\n> 注：这里已采纳的答案实际上应该是复制少了一个括号导致实际使用会出错，不过确实是正确答案。\r\n\r\n在项目根目录下添加 `jsconfig.json` 并添加以下配置\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"baseUrl\": \"./\",\r\n    \"paths\": {\r\n      \"@/*\": [\"src/*\"]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n然后重启 VSCode，之后，一切便恢复了理想状态！\r\n\r\n## 原因\r\n\r\n那么，`jsconfig.json` 到底是什么神奇的东西，为什么能影响到 VSCode 的提示呢？吾辈找到了 VSCode 官网上的文档，文档上对此的说明是：**VSCode 大部分功能都是开箱即用，然而有些却需要进行一些基本的配置才能获得最佳体验，jsconfig 就是用来配置 JavaScript 语言的相关功能。**\r\n\r\n所以，原因明了了，这是 VSCode 内置的功能，就是为了便于开发的。而我们仅仅需要做一些简单的配置，即可使用这些功能。  \r\n吾辈也使用 `tsc` 命令生成了一份 `jsconfig.json`（由 `tsconfig.json` 改名），泥萌可以复制并按照自己的需求修改其中的配置。\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    /* Basic Options */\r\n    \"target\": \"ES2018\" /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017','ES2018' or 'ESNEXT'. */,\r\n    \"module\": \"es2015\" /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */,\r\n    // \"lib\": [],                             /* Specify library files to be included in the compilation. */\r\n    // \"allowJs\": true,                       /* Allow javascript files to be compiled. */\r\n    // \"checkJs\": true,                       /* Report errors in .js files. */\r\n    // \"jsx\": \"preserve\",                     /* Specify JSX code generation: 'preserve', 'react-native', or 'react'. */\r\n    // \"declaration\": true,                   /* Generates corresponding '.d.ts' file. */\r\n    // \"declarationMap\": true,                /* Generates a sourcemap for each corresponding '.d.ts' file. */\r\n    // \"sourceMap\": true,                     /* Generates corresponding '.map' file. */\r\n    // \"outFile\": \"./\",                       /* Concatenate and emit output to single file. */\r\n    // \"outDir\": \"./\",                        /* Redirect output structure to the directory. */\r\n    // \"rootDir\": \"./\",                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */\r\n    // \"composite\": true,                     /* Enable project compilation */\r\n    // \"removeComments\": true,                /* Do not emit comments to output. */\r\n    // \"noEmit\": true,                        /* Do not emit outputs. */\r\n    // \"importHelpers\": true,                 /* Import emit helpers from 'tslib'. */\r\n    // \"downlevelIteration\": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */\r\n    // \"isolatedModules\": true,               /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */\r\n\r\n    /* Strict Type-Checking Options */\r\n    \"strict\": true /* Enable all strict type-checking options. */,\r\n    // \"noImplicitAny\": true,                 /* Raise error on expressions and declarations with an implied 'any' type. */\r\n    // \"strictNullChecks\": true,              /* Enable strict null checks. */\r\n    // \"strictFunctionTypes\": true,           /* Enable strict checking of function types. */\r\n    // \"strictBindCallApply\": true,           /* Enable strict 'bind', 'call', and 'apply' methods on functions. */\r\n    // \"strictPropertyInitialization\": true,  /* Enable strict checking of property initialization in classes. */\r\n    // \"noImplicitThis\": true,                /* Raise error on 'this' expressions with an implied 'any' type. */\r\n    // \"alwaysStrict\": true,                  /* Parse in strict mode and emit \"use strict\" for each source file. */\r\n\r\n    /* Additional Checks */\r\n    // \"noUnusedLocals\": true,                /* Report errors on unused locals. */\r\n    // \"noUnusedParameters\": true,            /* Report errors on unused parameters. */\r\n    // \"noImplicitReturns\": true,             /* Report error when not all code paths in function return a value. */\r\n    // \"noFallthroughCasesInSwitch\": true,    /* Report errors for fallthrough cases in switch statement. */\r\n\r\n    /* Module Resolution Options */\r\n    // \"moduleResolution\": \"node\",            /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */\r\n    \"baseUrl\": \"./\" /* Base directory to resolve non-absolute module names. */,\r\n    \"paths\": {\r\n      \"@/*\": [\"src/*\"]\r\n    } /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */,\r\n    // \"rootDirs\": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */\r\n    // \"typeRoots\": [],                       /* List of folders to include type definitions from. */\r\n    // \"types\": [],                           /* Type declaration files to be included in compilation. */\r\n    // \"allowSyntheticDefaultImports\": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */\r\n    \"esModuleInterop\": true /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */\r\n    // \"preserveSymlinks\": true,              /* Do not resolve the real path of symlinks. */\r\n\r\n    /* Source Map Options */\r\n    // \"sourceRoot\": \"\",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */\r\n    // \"mapRoot\": \"\",                         /* Specify the location where debugger should locate map files instead of generated locations. */\r\n    // \"inlineSourceMap\": true,               /* Emit a single file with source maps instead of having a separate file. */\r\n    // \"inlineSources\": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */\r\n\r\n    /* Experimental Options */\r\n    // \"experimentalDecorators\": true,        /* Enables experimental support for ES7 decorators. */\r\n    // \"emitDecoratorMetadata\": true,         /* Enables experimental support for emitting type metadata for decorators. */\r\n  }\r\n}\r\n```\r\n","createdTime":1580652937920,"updatedTime":1609304827440,"resources":[],"tags":[{"id":"2dc486a3eb624e698c76e4512f46af5e","title":"vscode","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"acf9dce315ae4520987a9159dfda0db0","title":"2018 React Redux 入门教程","body":"> 吾辈已转 mobx，放弃使用 redux 了。\r\n> [译文链接](http://www.superbug.me/2018/02/06/react-redux-tutorial-for-beginners-learning-redux-in-2018/), [原文链接](https://www.codementor.io/valentino/react-redux-tutorial-for-beginners-learning-redux-in-2018-fek71ojgh)  \r\n> 老实说学习 Redux 真的很有挫败感，虽然 Redux 的源码很小（< 2kb），然而其文档却庞大无比，老实说让人害怕！即便吾辈看了阮一峰写的 [Redux 入门教程](http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html)，然而还是在第二篇就 GG 了。纵然了解了概念，然而却不知如何使用，便是如此了。。。这篇翻译过来的教程吾辈感觉还不错，所以也便是转发一下好啦  \r\n> 吾辈也跟着教程写了一个 [Redux Demo](https://github.com/rxliuli/react-start/tree/dev/src/components/redux)，仅供参考。\r\n\r\n我希望这是学习 React Redux 最简单的入门教程。\r\n\r\n我一开始学习 Redux 的时候我想找到最浅显易懂的入门教程。\r\n\r\n尽管有大量的资源，但是我对于 Redux 的一些概念依旧搞不清楚。\r\n\r\n我知道什么是 state ，但是 actions， action creators 和 reducers 又是什么鬼？我被搞晕掉了。\r\n\r\n然后我也搞不明白 React 和 Redux 是怎样结合起来的。\r\n\r\n前端时间开始着手写 React Redux 教程的过程中我理解了许多。\r\n\r\n我通过写这篇教程自学 Redux 的基本概念。我也希望这可以帮助所有正在学习 React 和 Redux 的人。\r\n\r\n## 适用人群\r\n\r\n如果满足下列条件，那么本教程正是你要找的：\r\n\r\n- 良好的 Javascript, ES6, React 基础\r\n- 你希望以最简单的方式学习 Redux\r\n\r\n## 你可以学到什么\r\n\r\n通过这篇教程你可以学到：\r\n\r\n- Redux 是什么\r\n- 怎样结合 React 使用 Redux\r\n\r\n## 搭建 React 开发环境\r\n\r\n看这篇教程你需要有扎实的 Javascript, ES6, React 基础。\r\n\r\n开始之前，让我们来简单搭建一个 React 开发环境。\r\n\r\n你可以选择 webpack 3 或者 Parcel。\r\n\r\n如果选用 Parcel 你可以参考这个链接 Setting up React with Parcel ，或者从我的 Github 上克隆仓库：\r\n\r\ngit clone git@github.com:valentinogagliardi/minimal-react-parcel.git\r\n\r\n如果你想用 webpack 3 可以参考这个教程 How to set up React, Webpack 3, and Babel ，或者从我的 Github 上克隆仓库：\r\n\r\n`git clone git@github.com:valentinogagliardi/minimal-react-webpack.git`\r\n\r\n## 什么是 state ？\r\n\r\n理解 Redux 之前你首先需要理解什么是 state 。\r\n\r\n如果你曾经写过 React 的 state , 应该不足为奇。\r\n\r\n我猜你应该写过如下的 React 状态组件：\r\n\r\n```js\r\nimport React, { Component } from 'react'\r\nclass ExampleComponent extends Component {\r\n  constructor() {\r\n    super()\r\n    this.state = {\r\n      articles: [\r\n        { title: 'React Redux Tutorial for Beginners', id: 1 },\r\n        { title: \"Redux e React: cos'è Redux e come usarlo con React\", id: 2 },\r\n      ],\r\n    }\r\n  }\r\n  render() {\r\n    const { articles } = this.state\r\n    return (\r\n      <ul>\r\n        {articles.map((el) => (\r\n          <li key={el.id}>{el.title}</li>\r\n        ))}\r\n      </ul>\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n上述组件是基于 Javascript ES6 class 的。\r\n\r\n每个 React 状态组件持有自己的 state 。在 React 中 state 持有数据。组件渲染这组数据展示给用户。\r\n\r\nReact 提供了一个 setState 方法来更新组件内部的 state 。\r\n\r\n我们通常这么用：\r\n\r\n1. 从组件内部持有的 state 中获取数据渲染\r\n2. 通过 React 的 setState 方法更新 state\r\n\r\n## Redux 解决了什么问题 ？\r\n\r\n应用规模比较小的时候，在 React 组件内部维护 state 很方便。\r\n\r\n但在复杂一点的业务场景下这么做就不太合适了。组件中会填满各种管理更新 state 的方法，臃肿不堪。前端不应该知道业务逻辑。\r\n\r\n那么，有没有其它管理 state 的方式呢？Redux 就是其中的一个解决方案。\r\n\r\nRedux 解决了一开始我们可能还不太清楚的问题：它为每一个 React 组件明确提供它所需要的 state 。\r\n\r\nRedux 统一在一个地方维护 state 。\r\n\r\n通过 Redux ，获取和管理 state 的逻辑也和 React 隔离开来。\r\n\r\n这中方式的好处可能还不太明显。当你用上它后就会发现它的威力。\r\n\r\n下一节内容我们聊一下为什么以及什么时候我们需要用 Redux。\r\n\r\n## 我要学 Redux 么 ？\r\n\r\n想学习 Redux 但是没搞定？\r\n\r\nRedux 的确吓坏了许多初学者。但是不必因此而感到担心。\r\n\r\nRedux 没有那么难。关键是：不要随波逐流地去使用它。\r\n\r\n你开始学习 Redux 应该是出于自发的动机和热情。\r\n\r\n我学习 Redux 是因为：\r\n\r\n我 100% 地渴望知道 Redux 是怎么工作的\r\n我想要提升我的 React 技能\r\n我想成为更牛 X 的 React 开发者\r\nReact/Redux 当下是黄金组合\r\nRedux 是一种思想，它和框架无关。学习了它可以在任何地方（比如 Vue JS，Angular 中）使用。\r\n\r\n## 我要用 Redux 么 ？\r\n\r\n没有 Redux 构建复杂的 React 应用也是可行的。只是有一些成本。\r\n\r\n用 Redux 也是有一定成本的：它加入了另外一个抽象层。但是我我认为是利大于弊的。\r\n\r\n另一个困惑初学者的问题是：我怎么判断什么时候我需要使用 Redux 呢？\r\n\r\n如果你没有经验判定是否需要用 Redux 来管理 state ，我有如下建议使用的场景：\r\n\r\n多个 React 组件需要访问同一个 state 但是又没有父子关系\r\n需要通过 props 向下向多个组件传递 state\r\n\r\n如果还是找不到感觉，别怕，我也一样。\r\n\r\nDan Abramov 说过『 Flux 就像眼镜：你需要的时候你自然会知道 』。\r\n\r\n事实上对于我而言也正是如此。\r\n\r\nDan Abramov 写了篇很棒的文章来帮助我们理解： Redux 的使用场景\r\n\r\ndev.to 上也有一篇 Dan 关于这一问题的 讨论\r\n\r\n看一下 Mark Erikson 整理的 Redux 学习资源\r\n\r\n顺便说下，Mark 的博客被视为 Redux 的最佳实践\r\n\r\nDave Ceddia 也分享过关于 Redux 干了什么？以及它的使用场景 的话题。\r\n\r\n在深入学习之前，花些时间去搞明白 Redux 解决了什么问题。然后再决定要不要学。\r\n\r\n要清楚在小型的应用中使用 Redux 没什么好处。只有在大型应用下才能发挥它的威力。但不管如此，学习 Redux 解决问题的思路总不是什么坏事。\r\n\r\n下一节，我们介绍一下内容：\r\n\r\nRedux 的基本原则\r\nRedux 和 React 怎么结合\r\n\r\n## 了解 Redux store\r\n\r\nActions， Reducers 我都知道。但有件事我搞不明白：这些动态的片段是怎么结合到一起的？\r\n\r\n有小黄人相助不成？\r\n\r\n是 store 把所有流动的片段协调地结合到 Redux 中。在 Redux 中 store 就像人类的大脑：这是种魔法。\r\n\r\nRedux store 是一切的基础：整个应用的 state 都在 store 中维护。\r\n\r\n如果我们把 Redux 的工作模式想象成人类的大脑。 state 就相当于存在于大脑（store）中的一段回忆。\r\n\r\n所以开始使用 Redux 的时候我们需要创建一个 store 来存放 state。\r\n\r\n切换到你的开发目录，安装 Redux：\r\n\r\n```sh\r\ncd minimal-react-webpack/\r\n\r\nnpm i redux --save-dev\r\n```\r\n\r\n创建一个目录来存放 store 相关逻辑：\r\n\r\n```sh\r\nmkdir -p src/js/store\r\n```\r\n\r\n在 src/js/store 中创建 index.js 并初始化：\r\n\r\n```js\r\n// src/js/store/index.js\r\n\r\nimport { createStore } from 'redux'\r\nimport rootReducer from '../reducers/index'\r\n\r\nconst store = createStore(rootReducer)\r\n\r\nexport default store\r\n```\r\n\r\ncreateStore 就是创建 Redux store 的方法。\r\n\r\ncreateStore 接收一个 reducer 作为第一个参数，就是代码中的 rootReducer。\r\n\r\n你也可以传递一个初始 state 进 createStore。 但是大多数时候你不必这么做。传递初始 state 在服务端渲染时比较有用。当然，state 来自 reducers。\r\n\r\n现在我们知道 reducer 做了啥了。reducer 生成了 state 。 state 并不是手动创建的。\r\n\r\n带着这些概念我们继续我们第一个 Redux reducer。\r\n\r\n## 了解 Redux reducers\r\n\r\n初始 state 在 服务端渲染 中很有用，它必须完全从 reducers 中产生。\r\n\r\nreducer 是个什么鬼？\r\n\r\nreducer 就是个 javascript 函数。它接收两个参数：当前的 state 和 action 。\r\n\r\nRedux 的第三条原则中强调：state 必须是不可变的。这也是为什么 reducer 必须是一个纯函数。纯函数就是指给有明确的输入输出的函数。\r\n\r\n在传统的 React 应用中我们通过 setState 方法来改变 state 。 在 Redux 中不可以这么做。\r\n\r\n创建一个 reducer 不难，就是个包含两个参数的 javascript 普通函数。\r\n\r\n在我们的例子中，我们将创建一个简单的 reducer， 并向他传递初始 state 作为第一个参数。第二个参数我们将提供一个 action 。到目前为止 reducer 除了返回初始状态什么都不会做。\r\n\r\n创建 reducer 根目录\r\n\r\n```sh\r\nmkdir -p src/js/reducers\r\n```\r\n\r\n然后在 src/js/reducers 创建一个名为 index.js 的新文件：\r\n\r\n```js\r\n// src/js/reducers/index.js\r\n\r\nconst initialState = {\r\n  articles: [],\r\n}\r\n\r\nconst rootReducer = (state = initialState, action) => state\r\n\r\nexport default rootReducer\r\n```\r\n\r\n我承诺这是篇尽可能简明的教程。所以我们仅有一个 reducer ：它除了返回初始 state 什么都不处理。\r\n\r\n注意下初始 state 是怎样作为 默认参数 传递的。\r\n\r\n下一节我们将结合一个 action 来让这个应用更加有趣。\r\n\r\n## 了解 Redux actions\r\n\r\nreducers 无疑是 Redux 中最重要的概念。reducers 用来生产应用的 state 。\r\n\r\n但是 reducers 怎么知道什么时候去生产下一个 state 呢？\r\n\r\nRedux 的第二条原则中说：改变 state 的唯一方式就是向 store 发送一个信号 。 这个 信号 指的就是 action 。\r\n\r\n怎么改变这个不可更改的状态呢？你不能。返回的 state 是当前 state 的副本结合新数据后的一个全新的 state 。这点必须要明确。\r\n\r\n比较欣慰的是 actions 就是简单的 javascript 对象。它长这样：\r\n\r\n```js\r\ntype: ‘ADD_ARTICLE’,\r\n\r\npayload: { name: ‘React Redux Tutorial for Beginners’, id: 1 }\r\n```\r\n\r\n每一个 action 都要有一个 type 属性来描述要对 state 做怎样的改变。\r\n\r\n你也可以指定一个叫 payload 的属性。在上面的例子中， payload 指代一篇新的文章。reducer 接下来将把这篇新文章加到 state 中去。\r\n\r\n最佳实践是将每一个 action 都通过函数包裹起来。这个函数就是 action creator。\r\n\r\n让我们来把这些都串起来创建一个简单的 action 。\r\n\r\n创建 actions 目录：\r\n\r\n```sh\r\nmkdir -p src/js/actions\r\n```\r\n\r\n在 src/js/actions 目录中创建名为 index.js 的文件：\r\n\r\n```js\r\n// src/js/actions/index.js\r\n\r\nexport const addArticle = (article) => ({\r\n  type: 'ADD_ARTICLE',\r\n  payload: article,\r\n})\r\n```\r\n\r\ntype 属性就是个简单的字符串。reducer 将根据这个字符串决定怎么处理生成下一个 state 。\r\n\r\n由于字符串很容易重复产生冲突，所以最好在常量中统一定义 action types 。\r\n\r\n这个方法可以避免一些很难排查的错误。\r\n\r\n创建一个新目录：\r\n\r\n```sh\r\nmkdir -p src/js/constants\r\n```\r\n\r\n然后在 src/js/constants 目录下创建名为 action-types.js 的文件：\r\n\r\n```js\r\n// src/js/constants/action-types.js\r\n\r\nexport const ADD_ARTICLE = 'ADD_ARTICLE'\r\n```\r\n\r\n然后打开 src/js/actions/index.js 用常量来替换字符串：\r\n\r\n```js\r\n// src/js/actions/index.js\r\n\r\nimport { ADD_ARTICLE } from '../constants/action-types'\r\n\r\nexport const addArticle = (article) => ({\r\n  type: ADD_ARTICLE,\r\n\r\n  payload: article,\r\n})\r\n```\r\n\r\n我们进一步完成了一个可运行的 Redux 应用。 接下来让我们重构下我们的 reducer 吧！\r\n\r\n## 重构 reducer\r\n\r\n进入下一步之前，让我们总结一下 Redux 的主要概念：\r\n\r\nRedux store 就像大脑：它负责将所有流动的片段有机地整合进 Redux 中\r\n应用中的 state 在 store 中以唯一且不可变对象的形式存在\r\n一旦 store 接收到一个 action 他就会触发一个 reducer\r\nreducer 返回下一个 state\r\n\r\nreducer 是怎样构成的？\r\n\r\nreducer 是一个 javascript 函数，它接收两个参数：state 和 action。\r\n\r\nreducer 一般会包含一个 switch 语句（傻一点的话也可以用：if /else）。\r\n\r\nreducer 根据 action type 产生下一个 state 。此外，当没有匹配到 action type 时它至少也要返回初始 state 。\r\n\r\n当 action type 匹配到一个 case 分支的时候， reducer 将计算下一个 state 并返回一个全新的对象。下面是个例子：\r\n\r\n```js\r\n// …\r\n\r\nswitch (action.type) {\r\n  case ADD_ARTICLE:\r\n    return { ...state, articles: [...state.articles, action.payload] }\r\n  default:\r\n    return state\r\n}\r\n\r\n// …\r\n```\r\n\r\n我们之前创建的 reducer 只返回了初始 state 什么都没做。让我们做点什么。\r\n\r\n打开 src/js/reducers/index.js 按如下例子更新 reducer:\r\n\r\n```js\r\nimport { ADD_ARTICLE } from '../constants/action-types'\r\n\r\nconst initialState = {\r\n  articles: [],\r\n}\r\n\r\nconst rootReducer = (state = initialState, action) => {\r\n  switch (action.type) {\r\n    case ADD_ARTICLE:\r\n      return { ...state, articles: state.articles.push(action.payload) }\r\n    default:\r\n      return state\r\n  }\r\n}\r\n\r\nexport default rootReducer\r\n```\r\n\r\n发现了什么？\r\n\r\n尽管代码逻辑没有错，但这违背了 Redux 的主要原则： 不可变 。\r\n\r\n`Array.prototype.push` 不是一个纯函数，它改变了原来的数组。\r\n\r\n解决的方式很简单。用 `Array.prototype.concat` 替换 `Array.prototype.push` 来保持原始数组是不可变的。\r\n\r\n```js\r\nimport { ADD_ARTICLE } from '../constants/action-types'\r\n\r\nconst initialState = {\r\n  articles: [],\r\n}\r\n\r\nconst rootReducer = (state = initialState, action) => {\r\n  switch (action.type) {\r\n    case ADD_ARTICLE:\r\n      return { ...state, articles: state.articles.concat(action.payload) }\r\n    default:\r\n      return state\r\n  }\r\n}\r\n\r\nexport default rootReducer\r\n```\r\n\r\n还不够！可以用 扩展运算符 优化一下：\r\n\r\n```js\r\nimport { ADD_ARTICLE } from '../constants/action-types'\r\n\r\nconst initialState = {\r\n  articles: [],\r\n}\r\n\r\nconst rootReducer = (state = initialState, action) => {\r\n  switch (action.type) {\r\n    case ADD_ARTICLE:\r\n      return { ...state, articles: [...state.articles, action.payload] }\r\n    default:\r\n      return state\r\n  }\r\n}\r\n\r\nexport default rootReducer\r\n```\r\n\r\n上述例子中初始 state 完全没受干扰。\r\n\r\n最初的文章数组并没有改变。\r\n\r\n初始 state 对象也没有改变。返回的 state 是初始 state 的一个副本。\r\n\r\n在 Redux 中有两个关键点来防止类似的改变。\r\n\r\n针对数组可以用 concat (), slice (), 和 … 操作符\r\n针对对象可以用 Object.assign () and … 操作符\r\n\r\n扩展运算符 在 webpack 3 中还是个实验性功能。需要安装一个 babel 插件来防止语法错误：\r\n\r\n```sh\r\nnpm i —save-dev babel-plugin-transform-object-rest-spread\r\n```\r\n\r\n打开 .babelrc 更改配置：\r\n\r\n```json\r\n{\r\n  \"presets\": [\"env\", \"react\"],\r\n  \"plugins\": [\"transform-object-rest-spread\"]\r\n}\r\n```\r\n\r\n小贴士： reducer 随着应用的增长会变得臃肿。你可以拆分 reducer 进不同的函数，然后通过 combineReducers 将他们结合起来。\r\n\r\n下一节我们将通过 console 控制台把玩一下 Redux 。搞起！\r\n\r\n## Redux store 中的方法\r\n\r\n这节内容将会很快过完，我保证。\r\n\r\n我想借助浏览器的控制台让你快速理解下 Redux 是怎样工作的。\r\n\r\nRedux 本身是一个很小的类库 （2KB）。它暴露了 一些简单的 API 让我们来管理 state 。其中最重要的方法就是：\r\n\r\n- getState 用于获取应用的 state\r\n- dispatch 用于触发一个 action\r\n- subscribe 用于监听 state 的变化\r\n\r\n我们将借助浏览器的管理控制台试验上述方法。\r\n\r\n我们需要创建全局变量将我们先前创建的 store 和 action 暴露出来。\r\n\r\n打开 src/js/index.js 按如下所示更新代码：\r\n\r\n```js\r\nimport store from '../js/store/index'\r\n\r\nimport { addArticle } from '../js/actions/index'\r\n\r\nwindow.store = store\r\n\r\nwindow.addArticle = addArticle\r\n```\r\n\r\n然后运行一下：\r\n\r\n```sh\r\nnpm start\r\n```\r\n\r\n在浏览器中打开 http://localhost:8080/ 并按 F12 打开管理控制台。\r\n\r\n由于我们全局暴露了 store ， 所以我们可以进入它的方法。试一下！\r\n\r\n首先访问当前 state:\r\n\r\n```js\r\nstore.getState()\r\n```\r\n\r\n输出：\r\n\r\n```sh\r\n{articles: Array(0)}\r\n```\r\n\r\n没有文章。事实上我们还没有更新初始 state 。\r\n\r\n让这变得更有趣些我们可以通过 subscribe 方法监听 state 的变化。\r\n\r\nsubscribe 方法接收一个回调函数，当 action 触发的时候该回调函数就会执行。触发 action 就意味着通知 store 我们想改变 state 。\r\n\r\n通过如下操作注册回调函数：\r\n\r\n```js\r\nstore.subscribe(() => console.log('Look ma, Redux!!'))\r\n```\r\n\r\n要想改变 state 我们需要触发一个 action 。要触发一个 action 我们就需要调用 dispatch 方法 。\r\n\r\n我们已经有了一个 action ：addArticle 用来向 state 中新增文章。\r\n\r\n让我们触发一下这个 action ：\r\n\r\n```js\r\nstore.dispatch( addArticle({ name: ‘React Redux Tutorial for Beginners’, id: 1 }))\r\n```\r\n\r\n执行上述代码后你将看到：\r\n\r\n```sh\r\nLook ma, Redux!!\r\n```\r\n\r\n验证一下 state 有没有变：\r\n\r\n```js\r\nstore.getState()\r\n```\r\n\r\n输出会是：\r\n\r\n```sh\r\n{articles: Array(1)}\r\n```\r\n\r\n这就是个最简单的 Redux 原型。\r\n\r\n难么？\r\n\r\n稍微花点时间练习一下 Redux 的三个方法。在控制台中玩一把：\r\n\r\n- getState 用于获取应用的 state\r\n- dispatch 用于触发一个 action\r\n- subscribe 用于监听 state 的变化\r\n\r\n这就是开始入坑所需要知道的全部内容。\r\n\r\n有信心进入下一步了么？让我们把 React 和 Redux 串起来吧。\r\n\r\n## 把 React 和 Redux 结合起来\r\n\r\n学习了 Redux 后我发现它并没有想象中那么复杂。\r\n\r\n我知道我可以通过 getState 方法获取当前 state ；通过 dispatch 触发一个 action ； 通过 subscribe 监听 state 的变化。\r\n\r\n目前我还不知道怎么将 React 和 Redux 组合起来使用。\r\n\r\n我问自己：我需要在 React component 中调用 getState 方法么？ 在 React component 我怎么去触发 action ？ 等等一些列问题。\r\n\r\nRedux 是框架无关的。你可以在纯 Javascript 中使用它。或者结合 Angular，Redux 一起使用。 有许多第三方库可以实现把 Redux 和任何你喜欢的框架结合起来使用。\r\n\r\n对于 React 而言， react-redux 就是这么一个第三方库。\r\n\r\n首先让我们通过下面的命令安装一下：\r\n\r\n```sh\r\nnpm i react-redux —save-dev\r\n```\r\n\r\n为了演示 React 和 Redux 是如何协同工作的，我们将构建一个超级简单的应用。这个应用由如下组件组成：\r\n\r\n- 一个 App 组件\r\n- 一个展示文章的 List 组件\r\n- 一个新增文章的 Form 组件\r\n\r\n（这是个玩具应用，仅仅用来展示文章列表，新增文章条目。但是可以算一个学习 Redux 不错的开端。）\r\n\r\n## react-redux\r\n\r\nreact-redux 是一个 React 和 Redux 绑定库。这个类库将 React 和 Redux 高效地连接起来。\r\n\r\nreact-redux 的 connect 方法做了什么呢？ 毫无疑问是将 React 的组件和 Redux 的 store 连接起来了。\r\n\r\n你可以根据需要向 connect 方法传递两个或者三个参数。需要知道的最基本的东西就是：\r\n\r\n- mapStateToProps 函数\r\n- mapDispatchToProps 函数\r\n\r\nreact-redux 中 mapStateToProps 做了什么呢？就像它的名字一样：它将部分 Redux state 和 React 组件中的 Props 连接了起来。通过这层连接，React 组件就可以从 store 中获取它所需要的 state 了。\r\n\r\nreact-redux 中 mapDispatchToProps 又做了什么呢？和 mapStateToProps 类似，只不过它是连接的 actions 。它将 部分 Redux action 和 React 组件中的 Props 连接了起来。通过这层连接，React 组件就可以从触发 actions 了。\r\n\r\n都清楚了么？如果没有，停下来重读一遍。我知道许多内容需要时间消化。我要着急，早晚会搞明白的。\r\n\r\n接下来的部分我们就要大显生手了！\r\n\r\n## App 组件 和 Redux store\r\n\r\n我们知道 mapStateToProps 将部分 Redux state 和 React 组件中的 Props 连接了起来。你可能想问：连接 React 和 Redux 这么做就够了吗？不，还不够。\r\n\r\n要连接 React 和 Redux 我们还要用到 Provider。\r\n\r\nProvider 是 react-redux 提供的一个高阶组件。\r\n\r\n直白地说，就是 Provider 将整个 React 应用封装起来，是它能够感知到整个 Redux store 的存在。\r\n\r\n为什么这么做？我们知道在 Redux 中 store 管理着一切。React 必须通过 store 来访问 state ， 触发 actions 。\r\n\r\n了解了以上这些，就打开 src/js/index.js ，修改如下：\r\n\r\n```js\r\nimport React from 'react'\r\nimport { render } from 'react-dom'\r\nimport { Provider } from 'react-redux'\r\nimport store from '../js/store/index'\r\nimport App from '../js/components/App'\r\nrender(\r\n  <Provider store={store}>\r\n    <App />\r\n  </Provider>,\r\n  document.getElementById('app'),\r\n)\r\n```\r\n\r\n看到没有？Provider 将整个应用包裹起来。并将 store 作为属性传入。\r\n\r\n现在让我们创建一个 App 组件。没什么特别的：App 组件导入一个 List 组件并渲染。\r\n\r\n创建一个目录来存放组件：\r\n\r\n```js\r\nmkdir -p src/js/components\r\n```\r\n\r\n在 src/js/components 目录下创建名为 App.js 的文件。\r\n\r\n```js\r\n// src/js/components/App.js\r\n\r\nimport React from 'react'\r\n\r\nimport List from './List'\r\n\r\nconst App = () => Articles\r\n\r\nexport default App\r\n```\r\n\r\n花时间看下组件的构成：\r\n\r\n```js\r\nimport React from 'react'\r\n\r\nimport List from './List'\r\n\r\nconst App = () => <List />\r\n\r\nexport default App\r\n```\r\n\r\n然后继续创建 List 组件。\r\n\r\nList 组件 和 Redux state\r\n\r\n目前为止我们没做特殊的操作。\r\n\r\n但是 List 组件需要和 Redux store 产生交互。\r\n\r\n简单总结一下：连接 React 组件 和 Redux 的关键就是 connect 方法。\r\n\r\nConnect 方法接收至少一个参数。\r\n\r\n由于我们想让 List 获取文章列表，因此我们需要让 state.articles 和组件连接起来。怎么做呢？用 mapStateToProps 参数来实现。\r\n\r\n在 src/js/components 目录下创建名为 List.js 的文件。写入如下内容：\r\n\r\n```js\r\n// src/js/components/List.js\r\n\r\nimport React from 'react'\r\nimport { connect } from 'react-redux'\r\n\r\nconst mapStateToProps = (state) => {\r\n  return { articles: state.articles }\r\n}\r\nconst ConnectedList = ({ articles }) => (\r\n  <ul className=\"list-group list-group-flush\">\r\n    {articles.map((el) => (\r\n      <li className=\"list-group-item\" key={el.id}>\r\n        {el.title}\r\n      </li>\r\n    ))}\r\n  </ul>\r\n)\r\nconst List = connect(mapStateToProps)(ConnectedList)\r\nexport default List\r\n```\r\n\r\nList 组件接收一个名为 articles 的属性， 它是一个 articles 数组的副本。这个数组寄生于我们之前创建的 Redux state 内。它来自 reducer :\r\n\r\n```js\r\nconst initialState = {\r\n  articles: [],\r\n}\r\n\r\nconst rootReducer = (state = initialState, action) => {\r\n  switch (action.type) {\r\n    case ADD_ARTICLE:\r\n      return { ...state, articles: [...state.articles, action.payload] }\r\n    default:\r\n      return state\r\n  }\r\n}\r\n```\r\n\r\n然后我们就可以用这个属性在 JSX 中生成一个文章列表了：\r\n\r\n```js\r\n{\r\n  articles.map((el) => (\r\n    <li className=\"list-group-item\" key={el.id}>\r\n      {el.title}\r\n    </li>\r\n  ))\r\n}\r\n```\r\n\r\n**小提示** 可以用 React PropTypes 对属性进行校验。\r\n\r\n最后组件被导出为 List。List 是无状态组件和 Redux store 连接之后的产物。\r\n\r\n无状态组件没有内部 state 。数据是通过属性传入的。\r\n\r\n依旧很困惑？我也是。理解 connect 的工作原理需要花点时间。别害怕，慢慢来。\r\n\r\n我建议你停下来花点时间看下 connect 和 mapStateToProps 。\r\n\r\n搞懂了我们就进入下一章的学习。\r\n\r\n## Form 组件 和 Redux actions\r\n\r\nForm 组件比 List 组件稍微复杂一点。它是用于创建文章的表单。\r\n\r\n另外它是一个状态组件。\r\n\r\n状态组件是指在组件内部维护自身 state 的组件 。\r\n\r\n状态组件？我们一直说要用 Redux 来管理 state 。 为什么现在又说要让 Form 自己去维护 state ?\r\n\r\n即使在使用 Redux 的时候，使用有状态的组件也是完全可以的，两者并不冲突。\r\n\r\n并不是所有的 state 都必须在 Redux 中管理。\r\n\r\n在这个例子中我不想其他任何组件知道 Form 组件内部的 state 。\r\n\r\n这么做很好。\r\n\r\n这个组件做什么事呢？\r\n\r\n该组件包含了一些在表单提交时更新本地 state 的逻辑。\r\n\r\n另外它接收一个 Redux action 作为属性传入其中。用这种方式它可以通过触发 addArticle action 来更新全局的 state。\r\n\r\n在 src/js/components 下建一个名为 Form.js 的文件。它看起来像下面这样：\r\n\r\n```js\r\n// src/js/components/Form.js\r\n\r\nimport React, { Component } from 'react'\r\nimport { connect } from 'react-redux'\r\nimport uuidv1 from 'uuid'\r\nimport { addArticle } from '../actions/index'\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n  return {\r\n    addArticle: (article) => dispatch(addArticle(article)),\r\n  }\r\n}\r\n\r\nclass ConnectedForm extends Component {\r\n  constructor() {\r\n    super()\r\n    this.state = {\r\n      title: '',\r\n    }\r\n    this.handleChange = this.handleChange.bind(this)\r\n    this.handleSubmit = this.handleSubmit.bind(this)\r\n  }\r\n\r\n  handleChange(event) {\r\n    this.setState({ [event.target.id]: event.target.value })\r\n  }\r\n\r\n  handleSubmit(event) {\r\n    event.preventDefault()\r\n    const { title } = this.state\r\n    const id = uuidv1()\r\n    this.props.addArticle({ title, id })\r\n    this.setState({ title: '' })\r\n  }\r\n\r\n  render() {\r\n    const { title } = this.state\r\n\r\n    return (\r\n      <form onSubmit={this.handleSubmit}>\r\n        <div className=\"form-group\">\r\n          <label htmlFor=\"title\">Title</label>\r\n\r\n          <input\r\n            type=\"text\"\r\n            className=\"form-control\"\r\n            id=\"title\"\r\n            value={title}\r\n            onChange={this.handleChange}\r\n          />\r\n        </div>\r\n\r\n        <button type=\"submit\" className=\"btn btn-success btn-lg\">\r\n          SAVE\r\n        </button>\r\n      </form>\r\n    )\r\n  }\r\n}\r\n\r\nconst Form = connect(null, mapDispatchToProps)(ConnectedForm)\r\n\r\nexport default Form\r\n```\r\n\r\n怎么描述这个组件呢？除了 mapDispatchToProps 和 connect 它就是标准的 React 的那套东西。\r\n\r\nmapDispatchToProps 将 Redux actions 和 React 属性 连接起来。这样组件就可以向外发送 action 了。\r\n\r\n你可以看下 action 是怎样在 handleSubmit 方法中被触发的：\r\n\r\n```js\r\n// ...\r\n  handleSubmit(event) {\r\n    event.preventDefault();\r\n    const { title } = this.state;\r\n    const id = uuidv1();\r\n    this.props.addArticle({ title, id }); // Relevant Redux part!!\r\n  // ...\r\n  }\r\n// ...\r\n```\r\n\r\n最后组件被导出为 Form 。 Form 就是组件和 Redux store 连接之后的产物。\r\n\r\n注意：当 mapStateToProps 不存在的时候，connect 的第一个参数必须为 null，就像例子中的 Form 一样。 否则，你会得到 TypeError: dispatch is not a function. 的警告。\r\n\r\n我们的组件部分就都结束了。\r\n\r\n更新下 App , 把 Form 组件加进来：\r\n\r\n```js\r\nimport React from 'react'\r\nimport List from './List'\r\nimport Form from './Form'\r\n\r\nconst App = () => (\r\n  <div className=\"row mt-5\">\r\n    <div className=\"col-md-4 offset-md-1\">\r\n      <h2>Articles</h2>\r\n      <List />\r\n    </div>\r\n    <div className=\"col-md-4 offset-md-1\">\r\n      <h2>Add a new article</h2>\r\n      <Form />\r\n    </div>\r\n  </div>\r\n)\r\n\r\nexport default App\r\n```\r\n\r\n运行一下：\r\n\r\n```sh\r\nnpm start\r\n```\r\n\r\n打开 <http://localhost:8080>\r\n\r\n你将看到如下界面：\r\n\r\n没什么特别的，但可以展示 React 和 Redux 是如何工作的。\r\n\r\n左边的 List 组件和 Redux store 相连。它将在你新建文章的时候刷新渲染。\r\n\r\n哈哈！\r\n\r\n你可以在 这里 查看源码。\r\n\r\n## 总结\r\n\r\n我希望你可以从这篇教程中学到一些东西。我尽力把例子写的足够简单。我希望可以在下面的评论中倾听你的反馈。\r\n\r\nRedux 有许多模板和移动部件。别灰心。拿起来把玩，花点时间去吸收它所有的概念。\r\n\r\n我逐步从零开始慢慢地理解了 Redux 。相信你也可以做到。\r\n\r\n当然，也请花点时间想清楚为什么需要在你的项目中引用 Redux。\r\n\r\n无论怎样：学习 Redux 都是 100% 值得的。\r\n\r\nRedux 并不是状态管理的唯一方式。[Mobx](Mobx) 是另一个有趣的可选方案。我也在关注 Apollo Client。谁将胜出？只有时间知道答案。\r\n\r\n## 函数式编程的一些资源\r\n\r\nRedux 使大多数初学者感到害怕，是因为它是围绕函数式编程和纯函数展开的。\r\n\r\n我只能是推荐一些资源给大家，因为函数式编程超出了本指南的范围。 下面是一些函数式编程和纯函数相关的资源：\r\n\r\n- [Professor Frisby’s Mostly Adequate Guide to Functional Programming](https://drboolean.gitbooks.io/mostly-adequate-guide-old/content/ch1.html)\r\n- [Functional-Light-JS](https://github.com/getify/Functional-Light-JS)\r\n\r\n## Redux 中的异步 actions\r\n\r\n我不确定谈论异步 actions 是否合适。\r\n\r\n大多数 Redux 初学者都很难仅学习纯粹的 Redux。 在 Redux 中处理复杂的异步 action 还是比较费劲的。\r\n\r\n当你了解了 Redux 的核心概念后可以去读一下 Matt Stow 写的 [A Dummy’s Guide to Redux and Thunk in React](https://medium.com/@stowball/a-dummys-guide-to-redux-and-thunk-in-react-d8904a7005d3)。这是篇关于 Redux 怎样用 redux-thunk 处理 API 请求的非常不错的介绍。\r\n\r\n谢谢阅读，码得愉快～\r\n","createdTime":1580652937855,"updatedTime":1609304627442,"resources":[],"tags":[{"id":"5a7776c036cf46738cb6a729934a1a7b","title":"react","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"90548a371a16435799bcbfae3e4dbfb6","title":"Vue 表格封装 BasicTableVue","body":"## 场景\r\n\r\n后台项目中大量使用表格，我们使用的 `element-ui` 中的表格并不足以满足吾辈的需求，而且使用起来重复的代码实在太多，所以吾辈便对数据表格进行了二次封装。\r\n\r\n## 实现\r\n\r\n### API 列表\r\n\r\n- `[el]`: 绑定的选择器。默认为 `'#app'`\r\n- `data`: 数据对象\r\n  - `form`: 搜索表单绑定对象\r\n  - `columns`: 表格的列数组。每个列定义参考 `TableColumn`\r\n  - `[formShow]`: 是否显示搜索表单\r\n  - `[page]`: 分页信息，包含分页的数据。具体参考 `Page`\r\n  - `[selectedIdList]`: 选中项的 `id` 列表\r\n  - `[fileSelectorShow]`: 是否显示导入 `Excel` 的文件选择器\r\n- `methods`: 绑定的函数\r\n  - `createForm`: 初始化 `form` 表单，主要是为了自定义初始化逻辑\r\n  - `getPage`: 获取分页信息\r\n  - `exportFile`: 导出文件\r\n  - `importFile`: 导入文件\r\n  - `deleteData`: 删除选择的数据\r\n  - `[init]`: 初始化函数，如果可能请使用该函数而非重写 `mounted` 生命周期函数，该函数会在 `mounted` 中调用\r\n  - `[resetFile]`: 重置导入选择的文件，必须为 `input:file` 绑定属性 `ref=\"fileInput\"`\r\n  - `[searchPage]`: 搜索分页信息\r\n  - `[resetPage]`: 重置分页信息\r\n  - `[toggle]`: 切换搜索表单显示\r\n  - `[selection]`: 选择的 `id`\r\n  - `[changeSize]`: 改变一页的大小\r\n  - `[goto]`: 跳转到指定页数\r\n  - `[deleteSelected]`: 删除选择的数据项\r\n  - `[showFileSelector]`: 是否显示导入文件选择器\r\n  - `[initCommon]`: 初始化功能，如果重写了 `mounted` 生命周期函数，请务必调用它！\r\n\r\n### 自定义表格组件\r\n\r\n```js\r\n/**\r\n * 自定义表格组件\r\n */\r\nVue.component('my-table', {\r\n  /**\r\n   * 列\r\n   */\r\n  props: {\r\n    columns: {\r\n      type: Array,\r\n      default: [],\r\n    },\r\n    data: {\r\n      type: Array,\r\n      default: [],\r\n    },\r\n  },\r\n  template: `<el-table\r\n  :data=\"data\"\r\n  tooltip-effect=\"dark\"\r\n  style=\"width: 100%\"\r\n  border\r\n  @selection-change=\"handleSelectionChange\"\r\n>\r\n  <template v-for=\"column in columns\">\r\n\r\n    <el-table-column\r\n      :type=\"column.type\"\r\n      :prop=\"column.prop\"\r\n      :label=\"column.title\"\r\n      :align=\"column.align\"\r\n      :sortable=\"column.sortable\"\r\n      :width=\"column.width\"\r\n      :formatter=\"column.formatter\"\r\n      v-if=\"column.customComponent\"\r\n    >\r\n      <!--suppress HtmlUnknownAttribute -->\r\n      <template #default=\"scope\">\r\n        <!--这里将传递给模板当前行的数据-->\r\n        <slot :name=\"humpToLine(column.prop)\" :row=\"scope.row\"></slot>\r\n      </template>\r\n    </el-table-column>\r\n    <el-table-column\r\n      :type=\"column.type\"\r\n      :prop=\"column.prop\"\r\n      :label=\"column.title\"\r\n      :align=\"column.align\"\r\n      :sortable=\"column.sortable\"\r\n      :width=\"column.width\"\r\n      :formatter=\"column.formatter\"\r\n      v-else\r\n    >\r\n    </el-table-column>\r\n  </template>\r\n\r\n</el-table>`,\r\n  methods: {\r\n    handleSelectionChange(val) {\r\n      this.$emit('handle-selection-change', val)\r\n    },\r\n    humpToLine(data) {\r\n      return toLine(data)\r\n    },\r\n  },\r\n})\r\n```\r\n\r\n### 定义一些公共的实体\r\n\r\n```js\r\n/**\r\n * 分页信息，多次使用到所以定义一个公共的\r\n */\r\nclass Page {\r\n  /**\r\n   * 构造函数\r\n   * @param {Number} current 当前页数，从 1 开始\r\n   * @param {Number} size 每页的数量\r\n   * @param {Number} total 数据总条数\r\n   * @param {Number} pages 数据总页数\r\n   * @param {Array} records 一页的数据记录\r\n   * @param {...Object} [args] 其他的参数项，这里只是为了避免遗漏\r\n   * @returns {Page} 分页对象\r\n   */\r\n  constructor({\r\n    current = 1,\r\n    size = 10,\r\n    total = 0,\r\n    pages = 0,\r\n    records = [],\r\n    ...args\r\n  } = {}) {\r\n    this.current = current\r\n    this.size = size\r\n    this.total = total\r\n    this.pages = pages\r\n    this.records = records\r\n    Object.assign(this, args)\r\n  }\r\n}\r\n\r\n/**\r\n * 表格的列\r\n */\r\nclass TableColumn {\r\n  /**\r\n   * 格式化日期事件\r\n   * @param value 字段的值\r\n   * @returns {String|*} 格式化得到的日期时间字符串 TableColumn.datetimeFormat()\r\n   */\r\n  static datetimeFormat(_row, _column, value, _index) {\r\n    return !value ? '' : rx.dateFormat(new Date(value), 'yyyy-MM-dd hh:mm:ss')\r\n  }\r\n\r\n  /**\r\n   * 构造函数\r\n   * @param {String} [prop] 字段名\r\n   * @param {String} [title] 标题\r\n   * @param {'selection'} [type] 列类型，可以设置为选择列\r\n   * @param {Boolean} [sortable=true] 排序方式\r\n   * @param {Number} [width] 宽度\r\n   * @param {'center'} [align='center'] 水平对齐方式\r\n   * @param {Function} [formatter] 格式化列\r\n   * @param {Boolean} [customComponent] 是否自定义组件\r\n   * @param {...Object} [args] 其他的参数项，这里只是为了避免遗漏\r\n   */\r\n  constructor({\r\n    prop,\r\n    type,\r\n    width,\r\n    title,\r\n    sortable = true,\r\n    align = 'center',\r\n    formatter,\r\n    customComponent,\r\n    ...args\r\n  } = {}) {\r\n    this.prop = prop\r\n    this.type = type\r\n    this.width = width\r\n    this.align = align\r\n    this.title = title\r\n    this.sortable = sortable\r\n    this.align = align\r\n    this.formatter = formatter\r\n    this.customComponent = customComponent\r\n    Object.assign(this, args)\r\n  }\r\n}\r\n```\r\n\r\n### 定义一个 BasicTableVue 继承 Vue\r\n\r\n```js\r\n/**\r\n * 基本的表格数据配置\r\n */\r\nclass BasicTableData {\r\n  /**\r\n   * 构造函数\r\n   * @param {Object} [form={}] 搜索表单，子类一般需要覆盖（不覆盖的话可能在 html 中没有提示）\r\n   * @param {Array<TableColumn>} [columns=[]] 列信息列表，子类必须覆盖\r\n   * @param {Boolean} [formShow=false] 是否显示搜索表单\r\n   * @param {Page} [page=new Page()] 分页信息，包含数据列表\r\n   * @param {Array} [selectedIdList=[]] 选择的列表 id\r\n   * @param {Boolean} [fileSelectorShow=false] 导入文件选择器是否需要\r\n   */\r\n  constructor({\r\n    form = {},\r\n    columns = [],\r\n    formShow = false,\r\n    page = new Page(),\r\n    selectedIdList = [],\r\n    fileSelectorShow = false,\r\n  } = {}) {\r\n    this.form = form\r\n    this.columns = columns\r\n    this.formShow = formShow\r\n    this.page = page\r\n    this.selectedIdList = selectedIdList\r\n    this.fileSelectorShow = fileSelectorShow\r\n  }\r\n}\r\n\r\n/**\r\n * 基本的表格方法\r\n */\r\nclass BasicTableMethods {\r\n  /**\r\n   * 构造函数\r\n   * @param {Function} createForm 初始化 form 表单，主要是为了自定义初始化逻辑\r\n   * @param {Function} getPage 获取分页信息，需要覆盖\r\n   * @param {Function} exportFile 导出文件，需要覆盖\r\n   * @param {Function} importFile 导入文件，需要覆盖\r\n   * @param {Function} deleteData 删除选择的数据，需要覆盖\r\n   * @param {Function} init 初始化函数，如果可能请使用该函数而非重写 mounted 生命周期函数，该函数会在 mounted 中调用\r\n   * @param {Function} [resetFile] 重置导入选择的文件，必须为 input:file 绑定属性 ref=\"fileInput\"\r\n   * @param {Function} [searchPage] 搜索分页信息\r\n   * @param {Function} [resetPage] 重置分页信息\r\n   * @param {Function} [toggle] 切换搜索表单显示\r\n   * @param {Function} [selection] 选择的 id\r\n   * @param {Function} [changeSize] 改变一页的大小\r\n   * @param {Function} [goto] 跳转到指定页数\r\n   * @param {Function} [deleteSelected] 删除选择的数据项\r\n   * @param {Function} [showFileSelector] 是否显示导入文件选择器\r\n   * @param {Function} [initCommon] 初始化功能，如果重写了 mounted 生命周期函数，请务必调用它！\r\n   */\r\n  constructor({\r\n    createForm = function () {\r\n      throw new Error('如果需要搜索条件，请重写 initForm() 方法')\r\n    },\r\n    getPage = async function (page, entity) {\r\n      throw new Error('如果需要自动分页，请重写 getPage() 方法')\r\n    },\r\n    exportFile = async function () {\r\n      throw new Error('如果需要导出数据，请重写 exportFile() 方法')\r\n    },\r\n    importFile = function () {\r\n      throw new Error('如果需要导入数据，请重写 importFile() 方法')\r\n    },\r\n    deleteData = async function (idList) {\r\n      throw new Error('如果需要删除数据，请重写 deleteData 方法')\r\n    },\r\n    init = async function () {},\r\n    resetFile = function () {\r\n      const $el = this.$refs['fileInput']\r\n      if (!$el) {\r\n        throw new Error(\r\n          '如果需要清空选择文件，请为 input:file 绑定属性 ref 的值为 fileInput',\r\n        )\r\n      }\r\n      $el.value = ''\r\n    },\r\n    searchPage = async function () {\r\n      try {\r\n        this.page = await this.getPage(this.page, this.form)\r\n      } catch (e) {\r\n        console.error(e)\r\n        await rxPrompt.dangerMsg('查询数据失败，请刷新页面')\r\n      }\r\n    },\r\n    resetPage = async function () {\r\n      this.form = this.createForm()\r\n      await this.searchPage()\r\n    },\r\n    toggle = function () {\r\n      this.formShow = !this.formShow\r\n    },\r\n    selection = function (data) {\r\n      this.selectedIdList = data.map(({ id }) => id)\r\n    },\r\n    changeSize = function (size) {\r\n      this.page.current = 1\r\n      this.page.size = size\r\n      this.searchPage()\r\n    },\r\n    goto = function (current) {\r\n      if (!current) {\r\n        current = this.page.current\r\n      }\r\n      if (current < 1) {\r\n        return\r\n      }\r\n      if (current > this.page.pages) {\r\n        return\r\n      }\r\n      this.page.current = current\r\n      this.searchPage()\r\n    },\r\n    deleteSelected = async function () {\r\n      const result = await this.deleteData(this.selectedIdList)\r\n      if (result.code !== 200 || !result.data) {\r\n        await rxPrompt.msg('')\r\n        return\r\n      }\r\n      // noinspection JSIgnoredPromiseFromCall\r\n      rxPrompt.msg('删除成功')\r\n      this.page.current = 1\r\n      await this.searchPage()\r\n    },\r\n    showFileSelector = function () {\r\n      this.fileSelectorShow = !this.fileSelectorShow\r\n    },\r\n    initCommon = async function () {\r\n      this.form = this.createForm()\r\n      this.searchPage()\r\n    },\r\n  } = {}) {\r\n    this.createForm = createForm\r\n    this.getPage = getPage\r\n    this.searchPage = searchPage\r\n    this.resetPage = resetPage\r\n    this.toggle = toggle\r\n    this.selection = selection\r\n    this.changeSize = changeSize\r\n    this.goto = goto\r\n    this.exportFile = exportFile\r\n    this.importFile = importFile\r\n    this.resetFile = resetFile\r\n    this.deleteData = deleteData\r\n    this.init = init\r\n    this.deleteSelected = deleteSelected\r\n    this.showFileSelector = showFileSelector\r\n    this.initCommon = initCommon\r\n  }\r\n}\r\n\r\n/**\r\n * 基本的 vue 表格配置信息\r\n */\r\nclass BasicTableOption {\r\n  /**\r\n   * 构造函数\r\n   * @param {String} [el='#app'] 标签选择器\r\n   * @param {BasicTableData} data 数据\r\n   * @param {BasicTableMethods} methods 方法\r\n   * @param {Function} mounted 初始化方法\r\n   */\r\n  constructor({\r\n    el = '#app',\r\n    data = new BasicTableData(),\r\n    methods = new BasicTableMethods(),\r\n    mounted = async function () {\r\n      await this.initCommon()\r\n      await this.init()\r\n    },\r\n  } = {}) {\r\n    this.el = el\r\n    this.data = data\r\n    this.methods = methods\r\n    this.mounted = mounted\r\n  }\r\n}\r\n\r\n/**\r\n * 基本的表格 vue 类\r\n */\r\nclass BasicTableVue extends Vue {\r\n  /**\r\n   * 构造函数\r\n   * @param {BasicTableOption} option 初始化选项\r\n   * @param {BasicTableData|Function} option.data vue 的 data 数据，如果是 {@link Function} 类型，则必须返回 {@link BasicTableData} 的结构\r\n   * @param {BasicTableMethods} option.methods vue 中的 methods 属性\r\n   * @param {Function} option.mounted 初始化方法，如果覆盖则必须手动初始化表格\r\n   */\r\n  constructor({ data, methods, mounted, ...args } = {}) {\r\n    //注：这里为了应对 data 既有可能是对象，又有可能是函数的情况\r\n    super(\r\n      _.merge(new BasicTableOption(), {\r\n        data: function () {\r\n          return _.merge(\r\n            new BasicTableData(),\r\n            typeof data === 'function' ? data.call(this) : data,\r\n          )\r\n        },\r\n        methods,\r\n        mounted,\r\n        ...args,\r\n      }),\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n> 注：这里分开这么多的类是因为便于 IDE 进行提示\r\n\r\n## 使用\r\n\r\n下面简单的使用一下 `BasicTableVue`\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\r\n    <title>Document</title>\r\n  </head>\r\n  <body>\r\n    <main>\r\n      <h1>用户列表</h1>\r\n      <!-- 使用内置函数 toggle 切换表单是否显示 -->\r\n      <button @click=\"toggle\">高级搜索</button>\r\n      <!-- 使用 formShow 属性控制表单是否显示 -->\r\n      <form v-show=\"formShow\">\r\n        <div>\r\n          <label for=\"name\">名字：</label>\r\n          <input v-model=\"form.name\" name=\"name\" type=\"text\" />\r\n        </div>\r\n        <div>\r\n          <label for=\"age\">年龄：</label>\r\n          <input v-model=\"form.age\" name=\"age\" type=\"number\" />\r\n        </div>\r\n        <div>\r\n          <!-- 使用 searchPage 查询 -->\r\n          <button @click=\"searchPage\">查询</button>\r\n          <!-- 使用 resetPage 重置条件并搜索 -->\r\n          <button @click=\"resetPage\">重置</button>\r\n        </div>\r\n      </form>\r\n      <div>\r\n        <!-- \r\n          分页数据绑定 page 对象的 records 属性\r\n          表格的列绑定 columns 属性（需要自定义覆盖）\r\n          选中的项需要将 selection 属性绑定到 @handle-selection-change 事件\r\n         -->\r\n        <my-table\r\n          :data=\"page.records\"\r\n          :columns=\"columns\"\r\n          @handle-selection-change=\"selection\"\r\n        >\r\n          <!-- \r\n            定义自定义操作列\r\n            scope 指代当前行的信息\r\n           -->\r\n          <template #operating=\"scope\">\r\n            <span>\r\n              <!-- 将自定义的函数绑定到 @click.stop.prevent 上 -->\r\n              <button @click.stop.prevent=\"() => viewInfo(scope.row)\">\r\n                查看信息\r\n              </button>\r\n            </span>\r\n          </template>\r\n        </my-table>\r\n        <!-- \r\n          分页组件\r\n          将内置的属性或函数绑定到 el-pagination 组件上\r\n          changeSize(): 改变一页数据大小的函数\r\n          goto(): 跳转指定页的函数\r\n          page: 具体参考 Page 对象\r\n         -->\r\n        <el-pagination\r\n          background\r\n          @size-change=\"changeSize\"\r\n          @current-change=\"goto\"\r\n          :current-page=\"page.current\"\r\n          :page-sizes=\"[10, 20, 30]\"\r\n          :page-size=\"page.size\"\r\n          layout=\"total, sizes, prev, pager, next, jumper\"\r\n          :total=\"page.total\"\r\n        >\r\n        </el-pagination>\r\n      </div>\r\n    </main>\r\n    <script src=\"/user-info.js\"></script>\r\n  </body>\r\n</html>\r\n```\r\n\r\nJavaScript 部分\r\n\r\n```js\r\nclass UserInfo {\r\n  constructor({ id, name, age, ...args }) {\r\n    this.id = id\r\n    this.name = name\r\n    this.age = age\r\n    Object.assign(this, args)\r\n  }\r\n}\r\n\r\nconst app = new BasicTableVue({\r\n  data: {\r\n    columns: [\r\n      new TableColumn({ width: 30, type: 'selection' }),\r\n      new TableColumn({ prop: 'name', title: '姓名' }),\r\n      new TableColumn({ prop: 'age', title: '年龄' }),\r\n      new TableColumn({\r\n        prop: 'operating',\r\n        title: '操作',\r\n        customComponent: true,\r\n      }),\r\n    ],\r\n  },\r\n  methods: {\r\n    createForm() {\r\n      return new UserInfo()\r\n    },\r\n    async getPage(page, entity) {\r\n      return await baseUserInfoApi.page(page, entity)\r\n    },\r\n    deleteData(idList) {\r\n      return baseCustomerApi.delete(idList)\r\n    },\r\n    viewInfo(row) {\r\n      forward('/user_info_detail', row)\r\n    },\r\n    async init() {\r\n      console.log('这里想做一些自定义的初始化操作')\r\n    },\r\n  },\r\n})\r\n```\r\n\r\n> 这里需要注意一些要点\r\n>\r\n> 1. 如果需要在 `data` 中调用 `methods` 中的函数，则 `data` 必须是一个函数并返回对象\r\n> 2. 不要直接重写 `mounted()` 生命周期函数，而是在重写的 `init()` 中进行自定义操作\r\n> 3. 任何实体都需要有 `...args` 属性以避免一些没有声明的属性找不到\r\n\r\n---\r\n\r\n那么，关于 `BasicTableVue` 的封装便到此结束了。这是一个相当简陋的封装，如果有什么更好的方式，后面也会更新。\r\n","createdTime":1580652937886,"updatedTime":1609304549683,"resources":[],"tags":[{"id":"d86454b85c8f4c38aef6fa1575487e7f","title":"vue","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"38cfb11098b64d66bf6e9e20098c8401","title":"react 受控表单必须初始化","body":"## 场景\r\n\r\n这些天在学习 `React` 的时候遇到了一个奇怪的问题，明明受控表单的双向绑定已经成功了，然而控制台还是会出现 react 的警告：\r\n\r\n```sh\r\nWarning: A component is changing an uncontrolled input of type undefined to be controlled. Input elements should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled input element for the lifetime of the component.\r\n```\r\n\r\n代码很简单，仅仅只是一个登录表单\r\n\r\n```js\r\n/**\r\n * 用户类\r\n */\r\nexport class User {\r\n  constructor({ username, password } = {}) {\r\n    this.username = username\r\n    this.password = password\r\n  }\r\n}\r\n```\r\n\r\n```js\r\nimport React, { Component } from 'react'\r\nimport { User } from './User'\r\n\r\nclass App extends Component {\r\n  constructor(props) {\r\n    super(props)\r\n    this.state = {\r\n      user: new User(),\r\n    }\r\n  }\r\n  change = (e) => {\r\n    const el = e.target\r\n    const k = el.name\r\n    const v = el.value\r\n    const user = { ...this.state.user }\r\n    user[k] = v\r\n    this.setState({\r\n      user,\r\n    })\r\n  }\r\n  submit = () => {}\r\n  reset = () => {\r\n    this.setState({\r\n      user: new User(),\r\n    })\r\n  }\r\n  render() {\r\n    const { username, password } = this.state.user\r\n    return (\r\n      <div>\r\n        <div>\r\n          <label htmlFor=\"username\">用户名: </label>\r\n          <input name=\"username\" value={username} onChange={this.change} />\r\n        </div>\r\n        <div>\r\n          <label htmlFor=\"password\">密码: </label>\r\n          <input name=\"password\" value={password} onChange={this.change} />\r\n        </div>\r\n        <div>\r\n          <button onClick={this.submit}>登录</button>\r\n          <button onClick={this.reset}>重置</button>\r\n        </div>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default App\r\n```\r\n\r\n在 App 组件的 `constructor` 中明明已经通过 `new User()` 初始化了 `user` 属性，然而在输入的时候，还是会出现警告。\r\n\r\n> 注：此时在输入框中输入值，确实会影响到 react state 中的 user 属性，反之亦然。只有一点，当重置表单，即使用 `this.setState({user: new User()})` 重置 user 对象无法影响到页面上输入框的值。\r\n\r\n此处出现了两个问题\r\n\r\n1. 为什么在输入的时候会出现警告\r\n2. 为什么重置之后输入框的值没有变化\r\n\r\n## 解决\r\n\r\n最终，吾辈在 [StackOverflow](https://stackoverflow.com/questions/37427508) 上找到了答案。\r\n很重要的一句话：**对于要控制的输入，其值必须与状态变量的值相对应。**\r\n最初并未满足这个条件，值为 `null` 的 `state` 属性会被 `react` 视为未定义，导致表单最初是不受控制的。但是，当 `onChange` 第一次被触发的时候，`this.state.user.username` 就被设置了。此时，满足了条件，从非受控表单转换为了受控表单并导致了控制台的警告。\r\n同理，当使用 `this.setState({user: new User()})` 重置的时候，又变成了非受控表单，所以这里的绑定再次失效了。\r\n\r\n> 注: react 使用 `==` 而非 `===` 比较是否为 `null`，而 `null == undefined` 的值为 `true`，所以。。。\r\n\r\n那么，知道问题了之后，我们只要保证初始值 `val != null` 即可。\r\n例如上面的代码可以修改 `User.js`：\r\n\r\n```js\r\n/**\r\n * 用户类\r\n */\r\nexport class User {\r\n  constructor({ username = '', password = '' } = {}) {\r\n    this.username = username\r\n    this.password = password\r\n  }\r\n}\r\n```\r\n\r\n那么，关于 react 中的受控表单初始化的问题便到此为止了。可想而知，react 的坑还有很多没有踩完呢\r\n","createdTime":1580652937906,"updatedTime":1609304518977,"resources":[],"tags":[{"id":"5a7776c036cf46738cb6a729934a1a7b","title":"react","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"f21600fda3914f5d8b5604534ca78138","title":"vue 使用 v-model 双向绑定父子组件的值","body":"## 场景\r\n\r\n今天在使用 `v-model` 进行组件双向数据绑定的时候遇到了一个奇怪的问题，网页本身运行正常，浏览器一直出现警告信息。\r\n\r\n```sh\r\n[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: \"value\"\r\n```\r\n\r\n引发这个警告的是一个自定义组件 `RxSelect`\r\n\r\n```js\r\nVue.component('RxSelect', {\r\n  model: {\r\n    prop: 'value',\r\n    event: 'change',\r\n  },\r\n  props: {\r\n    value: [Number, String],\r\n    map: Map,\r\n  },\r\n  template: `\r\n        <select\r\n          v-model=\"value\"\r\n          @change=\"$emit('change', value)\"\r\n        >\r\n          <option\r\n            v-for=\"[k,v] in map\"\r\n            :value=\"k\"\r\n            :key=\"k\"\r\n          >{{v}}</option>\r\n        </select>\r\n        `,\r\n})\r\n```\r\n\r\n吾辈使用的代码看起来代码貌似没什么问题？\r\n\r\n```html\r\n<main id=\"app\">\r\n  当前选择的性别是: {{map.get(sex)}}\r\n  <div>\r\n    <rx-select :map=\"map\" v-model=\"sex\" />\r\n  </div>\r\n</main>\r\n```\r\n\r\nJavaScript 代码\r\n\r\n```js\r\nnew Vue({\r\n  el: '#app',\r\n  data: {\r\n    map: new Map().set(1, '保密').set(2, '男').set(3, '女'),\r\n    sex: '',\r\n  },\r\n})\r\n```\r\n\r\n经测试，程序本身运行正常，父子组件的传值也没什么问题，双向数据绑定确实生效了，然而浏览器就是一直报错。\r\n\r\n## 尝试解决\r\n\r\n吾辈找到一种方式\r\n\r\n1. 为需要双向绑定的变量在组件内部 `data` 声明一个变量 `innerValue`，并初始化为 `value`\r\n2. 在 `select` 上使用 `v-model` 绑定这个变量 `innerValue`\r\n3. 监听 `value` 的变化，在父组件中 `value` 变化时修改 `innerValue` 的值\r\n4. 监听 `innerValue` 的变化，在变化时使用 `this.$emit('change', val)` 告诉父组件需要更新 `value` 的值\r\n\r\n```js\r\nVue.component('RxSelect', {\r\n  model: {\r\n    prop: 'value',\r\n    event: 'change',\r\n  },\r\n  props: {\r\n    value: [Number, String],\r\n    map: Map,\r\n  },\r\n  data() {\r\n    return {\r\n      innerValue: this.value,\r\n    }\r\n  },\r\n  watch: {\r\n    value(val) {\r\n      this.innerValue = val\r\n    },\r\n    innerValue(val) {\r\n      this.$emit('change', val)\r\n    },\r\n  },\r\n  template: `\r\n  <select v-model=\"innerValue\">\r\n    <option\r\n      v-for=\"[k,v] in map\"\r\n      :value=\"k\"\r\n      :key=\"k\"\r\n    >{{v}}</option>\r\n  </select>\r\n  `,\r\n})\r\n```\r\n\r\n使用代码完全一样，然而组件 `RxSelect` 的代码却多了许多。。。\r\n\r\n## 解决\r\n\r\n一种更优雅的方式是使用 `computed` 计算属性以及其的 `get/set`，代码增加的程度还是可以接受的\r\n\r\n```js\r\nVue.component('RxSelect', {\r\n  model: {\r\n    prop: 'value',\r\n    event: 'change',\r\n  },\r\n  props: {\r\n    value: [Number, String],\r\n    map: Map,\r\n  },\r\n  computed: {\r\n    innerValue: {\r\n      get() {\r\n        return this.value\r\n      },\r\n      set(val) {\r\n        this.$emit('change', val)\r\n      },\r\n    },\r\n  },\r\n  template: `\r\n  <select v-model=\"innerValue\">\r\n    <option\r\n      v-for=\"[k,v] in map\"\r\n      :value=\"k\"\r\n      :key=\"k\"\r\n    >{{v}}</option>\r\n  </select>\r\n  `,\r\n})\r\n```\r\n","createdTime":1580652937909,"updatedTime":1609304399911,"resources":[],"tags":[{"id":"d86454b85c8f4c38aef6fa1575487e7f","title":"vue","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"5850c154bdc84b889a3f333cda06a4eb","title":"layui-layer load 弹窗自动关闭的问题","body":"## 场景\r\n\r\n项目中的 Ajax 加载时的 loading 框有时候会关闭了弹窗之后很久页面上的数据才加载出来，而且这个问题是随机出现的，有些页面存在，有些页面则正常。\r\n\r\n最小复现代码\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\r\n    <title>Document</title>\r\n  </head>\r\n  <body>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/rx-util@1.6.3/dist/rx-util.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/jquery@3.4.0/dist/jquery.min.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/layui-layer@1.0.9/dist/layer.js\"></script>\r\n    <script>\r\n      /**\r\n       * 加载遮罩框\r\n       *\r\n       * @returns {Function} 一个关闭遮罩框的函数\r\n       */\r\n      function load() {\r\n        const id = layer.load(1)\r\n        return () => {\r\n          layer.close(id)\r\n        }\r\n      }\r\n      /**\r\n       * 模拟 ajax 异步请求\r\n       */\r\n      async function request(time) {\r\n        const close = load()\r\n        console.log('request start: ', time)\r\n        await rx.wait(time)\r\n        close()\r\n        console.log('request end: ', time)\r\n      }\r\n\r\n      ;(() => {\r\n        request(5000).then(() => console.log('第二个请求加载完成了'))\r\n        request(1000).then(() => console.log('第一个请求加载完成了'))\r\n      })()\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n控制台打印\r\n\r\n```sh\r\nrequest start:  5000\r\nrequest start:  1000\r\nrequest end:  1000\r\n第一个请求加载完成了\r\nrequest end:  5000\r\n第二个请求加载完成了\r\n```\r\n\r\n## 思考\r\n\r\n本来吾辈猜测是 vuejs 页面渲染的锅，认为 vuejs 的生命周期函数 `mouted` 执行时 DOM 还没加载完全的缘故。\r\n所以把 `load` 异步化，等待 document 加载完毕才会真正执行。\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\r\n    <title>Document</title>\r\n  </head>\r\n  <body>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/rx-util@1.6.3/dist/rx-util.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/jquery@3.4.0/dist/jquery.min.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/layui-layer@1.0.9/dist/layer.js\"></script>\r\n    <script>\r\n      /**\r\n       * 加载遮罩框\r\n       *\r\n       * @returns {Function} 一个关闭遮罩框的函数\r\n       */\r\n      async function load() {\r\n        await rx.wait(() => document.readyState === 'complete')\r\n        const id = layer.load(1)\r\n        return async () => {\r\n          await rx.wait(() => document.readyState === 'complete')\r\n          layer.close(id)\r\n        }\r\n      }\r\n      /**\r\n       * 模拟 ajax 异步请求\r\n       */\r\n      async function request(time) {\r\n        const close = await load()\r\n        console.log('request start: ', time)\r\n        await rx.wait(time)\r\n        await close()\r\n        console.log('request end: ', time)\r\n      }\r\n\r\n      ;(() => {\r\n        request(5000).then(() => console.log('第二个请求加载完成了'))\r\n        request(1000).then(() => console.log('第一个请求加载完成了'))\r\n      })()\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n控制台打印\r\n\r\n```sh\r\nrequest start:  5000\r\nrequest start:  1000\r\nrequest end:  1000\r\n第一个请求加载完成了\r\nrequest end:  5000\r\n第二个请求加载完成了\r\n```\r\n\r\n然而实际上却并不是这个问题。。。\r\n\r\n经过某位网友提醒，layer 源码中默认只允许一个活动的 `load` 弹窗。瞬间吾辈都不知道要怎么吐槽了，单例模式避免无谓的内存浪费是正常的，然而新的 `load` 函数却会关闭之前的 `load` 这种操作真的是很厉害了呢\r\n\r\n例如下面这段代码，无论调用多少次 `layer.close(id1)`，页面上的 `loading` 都不会关闭。。。\r\n\r\n```js\r\nconst id1 = layer.load()\r\nconst id2 = layer.load()\r\nlayer.close(id1)\r\nlayer.close(id1)\r\n// ...\r\nlayer.close(id1)\r\nlayer.close(id1)\r\n```\r\n\r\n> 这里吾辈可以想象到，layer 认为先加载的 `load()` 就应该先被 `close()`，而没有考虑到复杂异步的情况。\r\n\r\n## 解决\r\n\r\n既然 layer 的 `load` 本身存在缺陷，那么却是只能自己对 `load` 和 `close` 功能做控制了\r\n基本思路\r\n\r\n1. `layer.load` 每次都会关闭掉之前的弹窗，那么就记录最后一次的弹窗 id，在真正需要关闭的时候 close 掉就好了\r\n2. `layer.load` 关闭是直接关闭弹窗，如果是最后一个就会出现弹窗消失但数据没加载完全的问题，那么关闭这儿要判断当前是否还有活动的弹窗，只有在没有的情况下才真正关闭\r\n\r\n修改后的代码\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\r\n    <title>Document</title>\r\n  </head>\r\n  <body>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/rx-util@1.6.3/dist/rx-util.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/jquery@3.4.0/dist/jquery.min.js\"></script>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/layui-layer@1.0.9/dist/layer.js\"></script>\r\n    <script>\r\n      /**\r\n       * 加载遮罩框\r\n       *\r\n       * @returns {Function} 一个关闭遮罩框的函数\r\n       */\r\n      const load = ((num, lastId) => () => {\r\n        lastId = layer.load(1)\r\n        num++\r\n        return () => {\r\n          num--\r\n          if (num < 0) {\r\n            num = 0\r\n          }\r\n          if (num > 0) {\r\n            console.log('弹窗没有真正关闭哦')\r\n            return\r\n          }\r\n          layer.close(lastId)\r\n          console.log('弹窗真的关闭啦')\r\n        }\r\n      })(0)\r\n\r\n      /**\r\n       * 模拟 ajax 异步请求\r\n       */\r\n      async function request(time) {\r\n        const close = await load()\r\n        console.log('request start: ', time)\r\n        await rx.wait(time)\r\n        await close()\r\n        console.log('request end: ', time)\r\n      }\r\n\r\n      ;(() => {\r\n        request(5000).then(() => console.log('第二个请求加载完成了'))\r\n        request(1000).then(() => console.log('第一个请求加载完成了'))\r\n      })()\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n控制台打印\r\n\r\n```sh\r\nrequest start:  5000\r\nrequest start:  1000\r\n弹窗没有真正关闭哦\r\nrequest end:  1000\r\n第一个请求加载完成了\r\n弹窗真的关闭啦\r\nrequest end:  5000\r\n第二个请求加载完成了\r\n```\r\n","createdTime":1580652937893,"updatedTime":1609304256808,"resources":[],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"4842e93e045a4299a84d7d04b02038c4","title":"JavaScript 自定义限流队列 fetch","body":"## 为什么需要它\r\n\r\n有些时候不得不需要限制并发 fetch 的请求数量，避免请求过快导致 IP 封禁\r\n\r\n## 需要做到什么\r\n\r\n- 允许限制 fetch 请求同时存在的数量\r\n- 时间过久便认为是超时了\r\n\r\n## 如何实现\r\n\r\n### 暂停请求\r\n\r\n> 该方法的请求是无序的！\r\n\r\n1. 使用 class 定义默认超时设置和请求数量限制的构造函数\r\n2. 在请求前判断当前请求的数量，添加请求等待数量\r\n   1. 如果请求数量已满，则进行等待\r\n   2. 如果请求数量未满，则删除一个请求等待数量\r\n3. 请求完成，删除当前请求数量\r\n\r\n### 等待队列：循环监听\r\n\r\n> 该方法需要使用回调函数\r\n\r\n1. 使用 class 定义默认超时设置和请求数量限制的构造函数\r\n2. 在请求前将请求 argments 添加到等待队列中\r\n3. 使用 `setInterval` 函数持续监听队列和当前执行的请求数\r\n   - 发现请求数量没有到达最大值，且等待队列中还有值，那么就执行一次请求\r\n\r\n### 等待队列：触发钩子\r\n\r\n1. 使用 class 定义默认超时设置和请求数量限制的构造函数\r\n2. 在请求前将请求 argments 添加到等待队列中\r\n3. 添加完成，等待当前请求数量未满\r\n4. 尝试启动等待队列（钩子）\r\n\r\n## 实现代码\r\n\r\n### 暂停请求实现\r\n\r\n```js\r\n/**\r\n * 等待指定的时间/等待指定表达式成立\r\n * @param {Number|Function} param 等待时间/等待条件\r\n * @returns {Promise} Promise 对象\r\n */\r\nfunction wait(param) {\r\n  return new Promise(resolve => {\r\n    if (typeof param === \"number\") {\r\n      setTimeout(resolve, param);\r\n    } else if (typeof param === \"function\") {\r\n      var timer = setInterval(() => {\r\n        if (param()) {\r\n          clearInterval(timer);\r\n          resolve();\r\n        }\r\n      }, 100);\r\n    } else {\r\n      resolve();\r\n    }\r\n  });\r\n}\r\n/**\r\n * 为 fetch 请求添加超时选项\r\n * 注：超时选项并非真正意义上的超时即取消请求，请求依旧正常执行完成，但会提前返回 reject 结果\r\n * @param {Promise} fetchPromise fetch 请求的 Promise\r\n * @param {Number} timeout 超时时间\r\n * @returns {Promise} 如果超时就提前返回 reject, 否则正常返回 fetch 结果\r\n */\r\nfunction promiseTimeout(fetchPromise, timeout) {\r\n  var abortFn = null;\r\n  //这是一个可以被reject的promise\r\n  var abortPromise = new Promise(function(resolve, reject) {\r\n    abortFn = function() {\r\n      reject(\"abort promise\");\r\n    };\r\n  });\r\n  var abortablePromise = Promise.race([fetchPromise, abortPromise]);\r\n  setTimeout(function() {\r\n    abortFn();\r\n  }, timeout);\r\n\r\n  return abortablePromise;\r\n}\r\n/**\r\n * 限制并发请求数量的 fetch 封装\r\n */\r\nclass RequestLimiting {\r\n  constructor({ timeout = 10000, limit = 10 }) {\r\n    this.timeout = timeout;\r\n    this.limit = limit;\r\n    this.execCount = 0;\r\n    this.waitCount = 0;\r\n  }\r\n\r\n  /**\r\n   * 执行一个请求\r\n   * 如果到达最大并发限制时就进行等待\r\n   * 注：该方法的请求顺序是无序的，与代码里的顺序无关\r\n   * @param {RequestInfo} url 请求 url 信息\r\n   * @param {RequestInit} init 请求的其他可选项\r\n   * @returns {Promise} 如果超时就提前返回 reject, 否则正常返回 fetch 结果\r\n   */\r\n  async _fetch(url, init) {\r\n    this.waitCount++;\r\n    await wait(() => this.execCount < this.limit);\r\n    this.waitCount--;\r\n    this.execCount++;\r\n    try {\r\n      return await promiseTimeout(fetch(url, init), this.timeout);\r\n    } finally {\r\n      this.execCount--;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n使用示例\r\n\r\n```js\r\nconst requestLimiting = new RequestLimiting({ timeout: 500, limit: 1 });\r\nnew Array(100).fill(0).forEach(i =>\r\n  requestLimiting\r\n    ._fetch(\"/\")\r\n    .then(res => console.log(res))\r\n    .catch(err => console.log(err))\r\n);\r\n```\r\n\r\n## 等待队列：循环监听实现\r\n\r\n```js\r\n/**\r\n * 等待指定的时间/等待指定表达式成立\r\n * @param {Number|Function} param 等待时间/等待条件\r\n * @returns {Promise} Promise 对象\r\n */\r\nfunction wait(param) {\r\n  return new Promise(resolve => {\r\n    if (typeof param === \"number\") {\r\n      setTimeout(resolve, param);\r\n    } else if (typeof param === \"function\") {\r\n      var timer = setInterval(() => {\r\n        if (param()) {\r\n          clearInterval(timer);\r\n          resolve();\r\n        }\r\n      }, 100);\r\n    } else {\r\n      resolve();\r\n    }\r\n  });\r\n}\r\n/**\r\n * 为 fetch 请求添加超时选项\r\n * 注：超时选项并非真正意义上的超时即取消请求，请求依旧正常执行完成，但会提前返回 reject 结果\r\n * @param {Promise} fetchPromise fetch 请求的 Promise\r\n * @param {Number} timeout 超时时间\r\n * @returns {Promise} 如果超时就提前返回 reject, 否则正常返回 fetch 结果\r\n */\r\nfunction promiseTimeout(fetchPromise, timeout) {\r\n  var abortFn = null;\r\n\r\n  //这是一个可以被reject的promise\r\n  var abortPromise = new Promise(function(resolve, reject) {\r\n    abortFn = function() {\r\n      reject(\"abort promise\");\r\n    };\r\n  });\r\n\r\n  var abortablePromise = Promise.race([fetchPromise, abortPromise]);\r\n\r\n  setTimeout(function() {\r\n    abortFn();\r\n  }, timeout);\r\n\r\n  return abortablePromise;\r\n}\r\n/**\r\n * 限制并发请求数量的 fetch 封装\r\n */\r\nclass RequestLimiting {\r\n  constructor({ timeout = 10000, limit = 10 }) {\r\n    this.timeout = timeout;\r\n    this.limit = limit;\r\n    this.execCount = 0;\r\n    // 等待队列\r\n    this.waitArr = [];\r\n\r\n    // 监视 execCount 的值\r\n    setInterval(async () => {\r\n      if (this.execCount >= this.limit) {\r\n        return;\r\n      }\r\n      console.debug(\r\n        `执行 execCount: ${this.execCount}, waitArr length: ${\r\n          this.waitArr.length\r\n        }, index: ${JSON.stringify(this.waitArr[0])}`\r\n      );\r\n      const args = this.waitArr.shift(0);\r\n      if (!args) {\r\n        return;\r\n      }\r\n      this.execCount++;\r\n      const callback = args[2];\r\n      try {\r\n        // 如果没有错误就返回 res\r\n        callback({ res: await promiseTimeout(fetch(...args), this.timeout) });\r\n      } catch (err) {\r\n        // 否则返回 err\r\n        callback({\r\n          err: err\r\n        });\r\n      } finally {\r\n        this.execCount--;\r\n      }\r\n    }, 100);\r\n  }\r\n\r\n  /**\r\n   * 执行一个请求\r\n   * 如果到达最大并发限制时就进行等待\r\n   * 注：该方法的请求顺序是无序的，与代码里的顺序无关\r\n   * @param {RequestInfo} url 请求 url 信息\r\n   * @param {RequestInit} init 请求的其他可选项\r\n   * @param {Function} callback 回调函数\r\n   * @returns {Promise} 如果超时就提前返回 reject, 否则正常返回 fetch 结果\r\n   */\r\n  async _fetch(url, init, callback) {\r\n    this.waitArr.push(arguments);\r\n  }\r\n}\r\n```\r\n\r\n使用示例\r\n\r\n```js\r\nconst requestLimiting = new RequestLimiting({ timeout: 500, limit: 1 });\r\nnew Array(100).fill(0).forEach((item, i) =>\r\n  requestLimiting._fetch(\r\n    \"/\",\r\n    {\r\n      // 这里设置添加时的 index，用于验证是否真的顺序执行了\r\n      headers: {\r\n        index: i\r\n      }\r\n    },\r\n    // 这里使用了回调函数，参数使用解构得到\r\n    ({ res, err }) => {\r\n      console.log(`res: ${res}, err: ${err}`);\r\n    }\r\n  )\r\n);\r\n```\r\n\r\n## 等待队列：触发钩子实现\r\n\r\n```js\r\n/**\r\n * 等待指定的时间/等待指定表达式成立\r\n * @param {Number|Function} param 等待时间/等待条件\r\n * @returns {Promise} Promise 对象\r\n */\r\nfunction wait(param) {\r\n  return new Promise(resolve => {\r\n    if (typeof param === \"number\") {\r\n      setTimeout(resolve, param);\r\n    } else if (typeof param === \"function\") {\r\n      var timer = setInterval(() => {\r\n        if (param()) {\r\n          clearInterval(timer);\r\n          resolve();\r\n        }\r\n      }, 100);\r\n    } else {\r\n      resolve();\r\n    }\r\n  });\r\n}\r\n/**\r\n * 为 fetch 请求添加超时选项\r\n * 注：超时选项并非真正意义上的超时即取消请求，请求依旧正常执行完成，但会提前返回 reject 结果\r\n * @param {Promise} fetchPromise fetch 请求的 Promise\r\n * @param {Number} timeout 超时时间\r\n * @returns {Promise} 如果超时就提前返回 reject, 否则正常返回 fetch 结果\r\n */\r\nfunction promiseTimeout(fetchPromise, timeout) {\r\n  var abortFn = null;\r\n  //这是一个可以被 reject 的 Promise\r\n  var abortPromise = new Promise(function(resolve, reject) {\r\n    abortFn = function() {\r\n      reject(\"abort promise\");\r\n    };\r\n  });\r\n  // 有一个 Promise 完成就立刻结束\r\n  var abortablePromise = Promise.race([fetchPromise, abortPromise]);\r\n  setTimeout(function() {\r\n    abortFn();\r\n  }, timeout);\r\n  return abortablePromise;\r\n}\r\n/**\r\n * 限制并发请求数量的 fetch 封装\r\n */\r\nclass RequestLimiting {\r\n  constructor({ timeout = 10000, limit = 10 }) {\r\n    this.timeout = timeout;\r\n    this.limit = limit;\r\n    this.execCount = 0;\r\n    // 等待队列\r\n    this.waitArr = [];\r\n  }\r\n\r\n  /**\r\n   * 执行一个请求\r\n   * 如果到达最大并发限制时就进行等待\r\n   * 注：该方法的请求顺序是无序的，与代码里的顺序无关\r\n   * @param {RequestInfo} url 请求 url 信息\r\n   * @param {RequestInit} init 请求的其他可选项\r\n   * @returns {Promise} 如果超时就提前返回 reject, 否则正常返回 fetch 结果\r\n   */\r\n  async _fetch(url, init) {\r\n    const _innerFetch = async () => {\r\n      console.log(\r\n        `执行 execCount: ${this.execCount}, waitArr length: ${\r\n          this.waitArr.length\r\n        }, index: ${JSON.stringify(this.waitArr[0])}`\r\n      );\r\n      this.execCount++;\r\n      const args = this.waitArr.shift(0);\r\n      try {\r\n        return await promiseTimeout(fetch(...args), this.timeout);\r\n      } finally {\r\n        this.execCount--;\r\n      }\r\n    };\r\n    this.waitArr.push(arguments);\r\n    await wait(() => this.execCount < this.limit);\r\n    // 尝试启动等待队列\r\n    return _innerFetch();\r\n  }\r\n}\r\n```\r\n\r\n使用示例\r\n\r\n```js\r\nconst requestLimiting = new RequestLimiting({ timeout: 500, limit: 1 });\r\nnew Array(100).fill(0).forEach((item, i) =>\r\n  requestLimiting\r\n    ._fetch(\"/\", {\r\n      // 这里设置添加时的 index，用于验证是否真的顺序执行了\r\n      headers: {\r\n        index: i\r\n      }\r\n    })\r\n    .then(res => console.log(res))\r\n    .catch(err => console.log(err))\r\n);\r\n```\r\n\r\n## 总结\r\n\r\n目前而言，最后一种实现是最好的，同时实现了两种规范\r\n\r\n- 返回 `Promise`，避免使用回调函数\r\n- 请求执行与添加顺序相同\r\n","createdTime":1580652937874,"updatedTime":1609303937766,"resources":[],"tags":[{"id":"1de1ff51140a44d5a2c223459dabcc37","title":"异步","parent_id":""},{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"875aa4331b56435aac71d3b654c27950","title":"JavaScript 实现更多数组的高阶函数","body":"## 场景\r\n\r\n> 虽说人人平等，但有些人更加平等。\r\n\r\n为什么有了 Lodash 这种通用函数工具库，吾辈要写这篇文章呢？吾辈在 SegmentFault 上经常看到关于 JavaScript 数组的相关疑问，甚至于，相同类型的问题，只是数据变化了一些，就直接提出了一个新的问题（实际上，对自身并无帮助）。简单[搜索了一下 Array](https://segmentfault.com/search?q=Array&type=question)，居然有 2360+ 条的结果，足可见这类问题的频率之高。若是有一篇适合 JavaScript 萌新阅读的自己实现数组更多操作的文章，情况或许会发生一些变化。\r\n\r\n下面吾辈便来实现以下几种常见的操作\r\n\r\n- `uniqueBy`: 去重\r\n- `sortBy`: 排序\r\n- `filterItems`: 过滤掉一些元素\r\n- `diffBy`: 差异\r\n- `groupBy`: 分组\r\n- `arrayToMap`: Array 转换为 Map\r\n- 递归操作\r\n\r\n> 前言:\r\n> 你至少需要了解 ES6 的一些特性你才能愉快的阅读\r\n\r\n## `uniqueBy`: 去重\r\n\r\n相关问题\r\n\r\n- [javascript 怎么实现多种数据类型的数组去重？](https://segmentfault.com/q/1010000002674331)\r\n- [JS 有没有比较高效的数组去重的方法？](https://segmentfault.com/q/1010000010936175)\r\n\r\n```js\r\n/**\r\n * js 的数组去重方法\r\n * @param arr 要进行去重的数组\r\n * @param kFn 唯一标识元素的方法，默认使用 {@link returnItself}\r\n * @returns 进行去重操作之后得到的新的数组 (原数组并未改变)\r\n */\r\nfunction uniqueBy(arr, kFn = (val) => val) {\r\n  const set = new Set()\r\n  return arr.filter((v, ...args) => {\r\n    const k = kFn(v, ...args)\r\n    if (set.has(k)) {\r\n      return false\r\n    }\r\n    set.add(k)\r\n    return true\r\n  })\r\n}\r\n```\r\n\r\n使用\r\n\r\n```js\r\nconsole.log(uniqueBy([1, 2, 3, '1', '2'])) // [ 1, 2, 3, '1', '2' ]\r\nconsole.log(uniqueBy([1, 2, 3, '1', '2'], (i) => i + '')) // [ 1, 2, 3 ]\r\n```\r\n\r\n## `sortBy`: 排序\r\n\r\n相关问题\r\n\r\n- [js 中如何对含有特殊字符的数组进行排序？](https://segmentfault.com/q/1010000014304039)\r\n- [以下数组怎么按名称排序](https://segmentfault.com/q/1010000017141566)\r\n\r\n```js\r\n/**\r\n * 快速根据指定函数对数组进行排序\r\n * 注: 使用递归实现，对于超大数组（其实前端的数组不可能特别大吧？#笑）可能造成堆栈溢出\r\n * @param arr 需要排序的数组\r\n * @param kFn 对数组中每个元素都产生可比较的值的函数，默认返回自身进行比较\r\n * @returns 排序后的新数组\r\n */\r\nfunction sortBy(arr, kFn = (v) => v) {\r\n  // TODO 此处为了让 typedoc 能生成文档而不得不加上类型\r\n  const newArr = arr.map((v, i) => [v, i])\r\n  function _sort(arr, fn) {\r\n    // 边界条件，如果传入数组的值\r\n    if (arr.length <= 1) {\r\n      return arr\r\n    }\r\n    // 根据中间值对数组分治为两个数组\r\n    const medianIndex = Math.floor(arr.length / 2)\r\n    const medianValue = arr[medianIndex]\r\n    const left = []\r\n    const right = []\r\n    for (let i = 0, len = arr.length; i < len; i++) {\r\n      if (i === medianIndex) {\r\n        continue\r\n      }\r\n      const v = arr[i]\r\n      if (fn(v, medianValue) <= 0) {\r\n        left.push(v)\r\n      } else {\r\n        right.push(v)\r\n      }\r\n    }\r\n    return _sort(left, fn).concat([medianValue]).concat(_sort(right, fn))\r\n  }\r\n  return _sort(newArr, ([t1, i1], [t2, i2]) => {\r\n    const k1 = kFn(t1, i1, arr)\r\n    const k2 = kFn(t2, i2, arr)\r\n    if (k1 === k2) {\r\n      return 0\r\n    } else if (k1 < k2) {\r\n      return -1\r\n    } else {\r\n      return 1\r\n    }\r\n  }).map(([_v, i]) => arr[i])\r\n}\r\n```\r\n\r\n使用\r\n\r\n```js\r\nconsole.log(sortBy([1, 3, 5, 2, 4])) // [ 1, 2, 3, 4, 5 ]\r\nconsole.log(sortBy([1, 3, 5, '2', '4'])) // [ 1, '2', 3, '4', 5 ]\r\nconsole.log(sortBy([1, 3, 5, '2', '4'], (i) => -i)) // [ 5, '4', 3, '2', 1 ]\r\n```\r\n\r\n## `filterItems`: 过滤掉一些元素\r\n\r\n相关问题\r\n\r\n- [过滤数组子集](https://segmentfault.com/q/1010000009045163)\r\n- [对比两组对象数组 根据元素内某一属性是否相等过滤数组](https://segmentfault.com/q/1010000017464256)\r\n\r\n```js\r\n/**\r\n * 从数组中移除指定的元素\r\n * 注: 时间复杂度为 1~3On\r\n * @param arr 需要被过滤的数组\r\n * @param deleteItems 要过滤的元素数组\r\n * @param kFn 每个元素的唯一键函数\r\n */\r\nfunction filterItems(arr, deleteItems, kFn = (v) => v) {\r\n  const kSet = new Set(deleteItems.map(kFn))\r\n  return arr.filter((v, i, arr) => !kSet.has(kFn(v, i, arr)))\r\n}\r\n```\r\n\r\n使用\r\n\r\n```js\r\nconsole.log(filterItems([1, 2, 3, 4, 5], [1, 2, 0])) // [ 3, 4, 5 ]\r\nconsole.log(filterItems([1, 2, 3, 4, 5], ['1', '2'], (i) => i + '')) // [ 3, 4, 5 ]\r\n```\r\n\r\n## `diffBy`: 差异\r\n\r\n相关问题\r\n\r\n- [JS 求两个对象数组的差集](https://segmentfault.com/q/1010000019019878)\r\n- [JavaScript 数组系列问题：数组差集](https://segmentfault.com/q/1010000008825206)\r\n\r\n```js\r\n/**\r\n * 比较两个数组的差异\r\n * @param left 第一个数组\r\n * @param right 第二个数组\r\n * @param kFn 每个元素的唯一标识产生函数\r\n * @returns 比较的差异结果\r\n */\r\nfunction diffBy(left, right, kFn = (v) => v) {\r\n  // 首先得到两个 kSet 集合用于过滤\r\n  const kThanSet = new Set(left.map(kFn))\r\n  const kThatSet = new Set(right.map(kFn))\r\n  const leftUnique = left.filter((v, ...args) => !kThatSet.has(kFn(v, ...args)))\r\n  const rightUnique = right.filter(\r\n    (v, ...args) => !kThanSet.has(kFn(v, ...args)),\r\n  )\r\n  const kLeftSet = new Set(leftUnique.map(kFn))\r\n  const common = left.filter((v, ...args) => !kLeftSet.has(kFn(v, ...args)))\r\n  return { left: leftUnique, right: rightUnique, common }\r\n}\r\n```\r\n\r\n使用\r\n\r\n```js\r\nconsole.log(diffBy([1, 2, 3], [2, 3, 4])) // { left: [ 1 ], right: [ 4 ], common: [ 2, 3 ] }\r\nconsole.log(diffBy([1, 2, 3], ['2', 3, 4])) // { left: [ 1, 2 ], right: [ '2', 4 ], common: [ 3 ] }\r\nconsole.log(diffBy([1, 2, 3], ['2', 3, 4], (i) => i + '')) // { left: [ 1 ], right: [ 4 ], common: [ 2, 3 ] }\r\n```\r\n\r\n## `groupBy`: 分组\r\n\r\n相关问题\r\n\r\n- [求一个数组按属性分组的方法](https://segmentfault.com/q/1010000004944432)\r\n- [js 数组分组？](https://segmentfault.com/q/1010000008789413)\r\n\r\n```js\r\n/**\r\n * js 数组按照某个条件进行分组\r\n *\r\n * @param arr 要进行分组的数组\r\n * @param kFn 元素分组的唯一标识函数\r\n * @param vFn 元素分组的值处理的函数。第一个参数是累计值，第二个参数是当前正在迭代的元素，如果你使用过 {@link Array#reduce} 函数的话应该对此很熟悉\r\n * @param init 每个分组的产生初始值的函数。类似于 reduce 的初始值，但它是一个函数，避免初始值在所有分组中进行累加。\r\n * @returns 元素标识 => 数组映射 Map\r\n */\r\nfunction groupBy(\r\n  arr,\r\n  kFn = (v) => v,\r\n  /**\r\n   * 默认的值处理函数\r\n   * @param res 最终 V 集合\r\n   * @param item 当前迭代的元素\r\n   * @returns 将当前元素合并后的最终 V 集合\r\n   */\r\n  vFn = (res, item) => {\r\n    res.push(item)\r\n    return res\r\n  },\r\n  init = () => [],\r\n) {\r\n  // 将元素按照分组条件进行分组得到一个 条件 -> 数组 的对象\r\n  return arr.reduce((res, item, index, arr) => {\r\n    const k = kFn(item, index, arr)\r\n    // 如果已经有这个键了就直接追加, 否则先将之初始化再追加元素\r\n    if (!res.has(k)) {\r\n      res.set(k, init())\r\n    }\r\n    res.set(k, vFn(res.get(k), item, index, arr))\r\n    return res\r\n  }, new Map())\r\n}\r\n```\r\n\r\n使用\r\n\r\n```js\r\nconsole.log(groupBy([1, 2, 2, 2, 4, 4, 5, 5, 6], (i) => i)) // Map { 1 => [ 1 ],  2 => [ 2, 2, 2 ],  4 => [ 4, 4 ],  5 => [ 5, 5 ],  6 => [ 6 ] }\r\nconsole.log(groupBy([1, 2, 2, 2, 4, 4, 5, 5, 6], (i) => i % 2 === 0)) // Map { false => [ 1, 5, 5 ], true => [ 2, 2, 2, 4, 4, 6 ] }\r\nconsole.log(\r\n  groupBy(\r\n    [1, 2, 2, 2, 4, 4, 5, 5, 6],\r\n    (i) => i % 2 === 0,\r\n    (res, i) => res.add(i),\r\n    () => new Set(),\r\n  ),\r\n) // Map { false => Set { 1, 5 }, true => Set { 2, 4, 6 } }\r\n```\r\n\r\n## `arrayToMap`: 转换为 Map\r\n\r\n相关问题\r\n\r\n- [js 怎么把数组下面的对象里面的两个字段取出来组成一个新的对象，key:value 形式](https://segmentfault.com/q/1010000019537004)\r\n\r\n```js\r\n/**\r\n * 将数组映射为 Map\r\n * @param arr 数组\r\n * @param k 产生 Map 元素唯一标识的函数，或者对象元素中的一个属性名\r\n * @param v 产生 Map 值的函数，默认为返回数组的元素，或者对象元素中的一个属性名\r\n * @returns 映射产生的 map 集合\r\n */\r\nexport function arrayToMap(arr, k, v = (val) => val) {\r\n  const kFn = k instanceof Function ? k : (item) => Reflect.get(item, k)\r\n  const vFn = v instanceof Function ? v : (item) => Reflect.get(item, v)\r\n  return arr.reduce(\r\n    (res, item, index, arr) =>\r\n      res.set(kFn(item, index, arr), vFn(item, index, arr)),\r\n    new Map(),\r\n  )\r\n}\r\n```\r\n\r\n使用\r\n\r\n```js\r\nconst county_list = [\r\n  {\r\n    id: 1,\r\n    code: '110101',\r\n    name: '东城区',\r\n    citycode: '110100',\r\n  },\r\n  {\r\n    id: 2,\r\n    code: '110102',\r\n    name: '西城区',\r\n    citycode: '110100',\r\n  },\r\n  {\r\n    id: 3,\r\n    code: '110103',\r\n    name: '崇文区',\r\n    citycode: '110100',\r\n  },\r\n]\r\nconsole.log(arrayToMap(county_list, 'code', 'name')) // Map { '110101' => '东城区', '110102' => '西城区', '110103' => '崇文区' }\r\nconsole.log(\r\n  arrayToMap(\r\n    county_list,\r\n    ({ code }) => code,\r\n    ({ name }) => name,\r\n  ),\r\n) // Map { '110101' => '东城区', '110102' => '西城区', '110103' => '崇文区' }\r\n```\r\n\r\n## 递归\r\n\r\n相关问题\r\n\r\n- [复杂数组去重](https://segmentfault.com/q/1010000018502694)\r\n- [JavaScript 数组中包含数组如何去重？](https://segmentfault.com/q/1010000000444289)\r\n\r\n以上种种操作皆是对一层数组进行操作，如果我们想对嵌套数组进行操作呢？例如上面这两个问题？其实问题是类似的，只是递归遍历数组而已。\r\n\r\n```js\r\n/**\r\n * js 的数组递归去重方法\r\n * @param arr 要进行去重的数组\r\n * @param kFn 唯一标识元素的方法，默认使用 {@link returnItself}，只对非数组元素生效\r\n * @returns 进行去重操作之后得到的新的数组 (原数组并未改变)\r\n */\r\nfunction deepUniqueBy(arr, kFn = (val) => val) {\r\n  const set = new Set()\r\n  return arr.reduce((res, v, i, arr) => {\r\n    if (Array.isArray(v)) {\r\n      res.push(deepUniqueBy(v))\r\n      return res\r\n    }\r\n    const k = kFn(v, i, arr)\r\n    if (!set.has(k)) {\r\n      set.add(k)\r\n      res.push(v)\r\n    }\r\n    return res\r\n  }, [])\r\n}\r\n```\r\n\r\n使用\r\n\r\n```js\r\nconst testArr = [\r\n  1,\r\n  1,\r\n  3,\r\n  'hello',\r\n  [3, 4, 4, 'hello', '5', [5, 5, ['a', 'r']]],\r\n  {\r\n    key: 'test',\r\n  },\r\n  4,\r\n  [3, 0, 2, 3],\r\n]\r\nconsole.log(deepUniqueBy(testArr)) // [ 1,  3,  'hello',  [ 3, 4, 'hello', '5', [ 5, [Object] ] ],  { key: 'test' },  4,  [ 3, 0, 2 ] ]\r\n```\r\n\r\n## 反例\r\n\r\n事实上，目前 SegmentFault 上存在着大量低质量且重复的问题及回答，关于这点确实比不上 StackOverflow。下面是两个例子，可以看一下能否发现什么问题\r\n\r\n- [js 怎么把数组下面的对象里面的两个字段取出来组成一个新的对象，key:value 形式](https://segmentfault.com/q/1010000019537004)\r\n- [JS 中处理 JSON 数据重复问题，取出里面 name 字段数值相同的作为一个数组；不相同的作为一个数组？](https://segmentfault.com/q/1010000017490985)\r\n\r\n事实上，不管是问题还是答案，都没有突出核心 -- **Array 映射为 Map/Array 分组**，而且这种问题和答案还层出不穷。如果对 [Array 的 API](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array) 都没有看过一遍就来询问的话，对于帮助者来说却是太失礼了！\r\n\r\n## 总结\r\n\r\nJavaScript 对函数式编程支持很好，所以习惯高阶函数于我们而言是一件好事，将问题的本质抽离出来，而不是每次都局限于某个具体的问题上。\r\n","createdTime":1580652937869,"updatedTime":1609303920802,"resources":[],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"22c83c48320c4fca80798ec03c449c64","title":"读书-[人类简史]","body":"## 序\r\n\r\n断断续续，最近终于读完了[人类简史](https://zh.wikipedia.org/zh-hans/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2)。它是一个系列的书籍，一共三本「人类简史」，「未来简史」和「今日简史」，当然，系列的第一本「人类简史」是最出名的，吾辈也正是有所耳闻才去通读了该系列。\r\n\r\n![封面](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191201213231.png)\r\n\r\n## 言\r\n\r\n书里太多内容，读过之后却又没有记忆下来。然而，吾辈记忆深刻的有以下几点\r\n\r\n### 人类之所以成为「万物之灵」是因为想象力「虚构的故事」\r\n\r\n国家，政府，金钱，公司，资本主义，社会主义，不过都是虚构的概念，人类相信这些「故事」，所以能够形成大规模协作，而这是其他物种所不具备的。\r\n老实说这点确实有点违反吾辈一直以来的认知，甚至比曾经「官僚系统是人类史上最伟大的发明，能让无数互不相识的人互相协作」更有冲击性。\r\n附：之前吾辈的对官僚系统的认知基本上是腐败和权力，而且从小接受的教育告诉吾辈人类会使用工具才是人类成为万物之灵的关键（比如能够使用「火」）。\r\n\r\n### 人工智能会代替绝大多数人的工作，引起大规模失业\r\n\r\n这点和吾辈一直以来的想法不谋而合，重复的工作迟早被人工智能替代，但书中所言的现实更加绝望——连创造性的工作，文学和艺术都未能幸免于难。\r\n人工智能还有多久才能出现，这点谁也不好说，但能知道的是现今的 Google，MS 这些顶级的大公司都在研究人工智能，并已然初见成效（Google 搜索/翻译/微软小娜）。\r\n虽然现在人工智能看起来还很初级，只能在某个指定领域内击败人类，而且有些还很蠢（被称为人工智障），但不得不说人工智能的发展及其迅速，甚至自动驾驶汽车已经上路很多年了。\r\n\r\n### 一个人的职业会被迫需要改变\r\n\r\n曾经，一旦确定了职业，大多都是兢兢业业做一辈子。但现在，人类的寿命增加，社会变化又如此迅速，人类讲被迫适应一次次的职业改变。毕业即失业，学习到的东西到了社会上已然过时，这便是未来的真实写照了。\r\n老实说这点在吾辈父母身上已经初见端倪，父母四十几岁的人，却不得不改变了职业。当然，他们不喜欢这样，用他们的话说：你知道改变有多难么？出问题家里老小怎么办？\r\n现在，父母辈的人可能几十年换一次职业，但到了我们，却未必依然。或许，不久之后，十年换一次职业都是一件正常的事情了（#无奈）。\r\n\r\n### 法西斯在自身看来并不是邪恶的\r\n\r\n很多描述法西斯的书籍都把法西斯描述的无比邪恶，而身处其中的人却很难意识到（像是现如今的国内 #笑）。\r\n政府说什么是好的什么就是好的，权利比真相更重要，家长式的权威政府，前景难免不会变成 [1984](https://zh.wikipedia.org/zh/%E4%B8%80%E4%B9%9D%E5%85%AB%E5%9B%9B) 般的反乌托邦世界。每个人都被监听，家人之间互相举报，毫无信任感可言。\r\n现在，国内是世界上摄像头最多的地方，网络公司对隐私的侵犯也并不违反法律，这造成了国内公司的肆无忌惮，毫无底线的把数据收集用以收割韭菜，并且，报告给当局（参阅 `**IDC/ISP**` 数据上报规范）。\r\n\r\n## 思\r\n\r\n人的认知无法超越时代，即便如牛顿，爱因斯坦他们，亦然如此。这本书的所言所述，也并不代表真理，更不代表其中的一切都是对的，只是作者如此认为——**每个作者都有自己的偏见**。\r\n","createdTime":1580652938078,"updatedTime":1609303775135,"resources":[],"tags":[{"id":"cb9e3139d6c445159b47d8f26528445d","title":"读书","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"766122d4abda4119a4b10bfd62339f3e","title":"树莓派入坑体会","body":"## 前言\n\n最近想在家里搭个本地服务器玩，于是便买了个树莓派 4。现在，吾辈已经让它在纸盒里默默吃灰了。\n\n- 为什么吾辈搭建服务器？\n- 为什么吾辈要选择树莓派？\n- 以及为何最终它还是吃灰了？\n\n上面这些问题吾辈会在下面一一解答。\n\n## 为什么吾辈搭建服务器\n\n搭建本地服务器的原因当然是想让一些服务持续 24 小时运行了，而吾辈最初的需求便是 **PT/BT 做种**。BT 或许很多人听说过，PT 又是什么呢？\n\n![PT 下载](https://img.rxliuli.com/20190903081607.png)\n\nPT，全程 Private Tracker，是一种私有的 BT 服务。整个 BT 网络将不再是完全公开并且可供任何人下载的了，每个用户都会被计算上传量/下载量，如果这个比率过低就会被 ban。这种下载方式本意是为了解决 BT 中很多用户喜欢只下载而不进行上传的行为，强制所有人必须**殚精竭虑**地计算分享率，注意自己的下载量，考虑下载热门资源而赚取积分（事实证明这条路注定也不会走的太顺利，分享是一个长期收益的行为，最终下载的人短期内实际上并不多，而计算分享率却是实时的）。\n吾辈需要的便是 24h 不间断的挂着 PT/BT 服务，以在闲暇时刻消耗家里的网络带宽，顺便做一波公益行为。\n\n> [PT 下载 Wiki](https://zh.wikipedia.org/zh/PT下載)\n\n## 为什么吾辈要选择树莓派\n\n一言以蔽之：树莓派宣传的很厉害。\n\n![树莓派官方图](https://img.rxliuli.com/20190903143806.png)\n\n让我们看看网络上对树莓派的相关内容\n\n- [异次元软件: 树莓派 4 代 - 全球最流行的 Linux 小型迷你电脑，性能大幅飙升！(支持 4K / USB3.0)](https://www.iplaysoft.com/raspberrypi.html)\n- [知乎: 「树莓派」是什么以及普通人怎么玩？](https://www.zhihu.com/question/20859055)\n\n树莓派[官网](https://www.raspberrypi.org/)也自称是小型、双显示器的台式电脑，而且提供了一个树莓派专用的 Linux Debian 的定制发行版。\n\n下面放一张吾辈买的树莓派 4 的照片，体积之小可见一斑。\n![树莓派](https://img.rxliuli.com/20190903081924.png)\n\n讲真第一次看到这么小的时候吾辈真的被惊艳到了，从来没想过一个电脑能这么小，而且居然还能安装可视化的操作系统。\n\n## 以及为何最终它还是吃灰了\n\n之后吾辈便开始安装了官方的操作系统，首先，官方提供了两个选项\n\n- [NOOBS](https://www.raspberrypi.org/downloads/noobs/): 全新开箱即用的软件 - 适合初学者的操作系统安装引导程序。\n- [Raspbian](https://www.raspberrypi.org/downloads/raspbian/): 官方支持的树莓派操作系统 - 基于 Debian Buster。\n\n然而事实上，两者皆有不足之处。首先，前者需要屏幕、键盘和鼠标进行安装，对于吾辈这种只是想把它作为本地服务器的用户而言，这是不可接受的。而使用官方的烧录工具将 Raspbian 刻录到 SD 卡之后，启动命令行倒是没有什么问题，但在启动桌面时却遇到的 bug -- [树莓派 4 VNC 远程连接桌面错误](https://segmentfault.com/q/1010000020144913)。当时似乎互联网上并没有多少人遇到这个问题，而吾辈恰好遇到了，所以费了一番功夫之后才成功开启了桌面。\n进入桌面之后，又是换源又是更新，之后才在命令行安装了 qBittorrent（是的，即使已经有了桌面仍然需要从命令行安装程序）。嘛，不谈遇到了多少麻烦，qBittorrent 终于启动了 BT 服务，吾辈把 RSS 挂上了之后使其自动更新和下载最新种子，也便是大功告成了。\n\n![qBittorrent](https://img.rxliuli.com/20190903150304.png)\n\n然后发现种子的 RSS 服务器有时会更新失败，吾辈猜想是没有代理的问题，于是便去网络上找到了一个 Linux 下的 SSR 可视化客户端 -- [electron-ssr](https://github.com/shadowsocksrr/electron-ssr)，然而下载完之后安装直接提示安装错误。\n\n> 注: electron-ssr 项目作者已经被请喝茶了，真真是风声鹤唳。\n\n然后向他人询问的时候甚至说出了 **“咱也回答你了 ，需要找 arm 的 debian 包”**，我的天，难道 Linux 下安装程序这么麻烦的么？不仅发行版要区分，现在连 CPU 架构也要区分了？用户体验老实说糟糕透顶，吾辈最终直接使用了本地的 SSR 局域网代理，笔记本开着的时候有代理，关了就没了，也便只能是暂且用着。\n\n后来吾辈在几次偶尔使用 VNC 连接时发现 qBittorrent 关了，吾辈以为是 Linux 会默认杀掉不活跃的程序，没有在意，就手动重启了。直到昨天，吾辈在启动 qBittorrent 后直接闪退了。。。在观察了任务管理器之后，吾辈发现是启动时 CPU 的使用率暴增，然后就 GG 了。\n\n![GIF 动图](https://img.rxliuli.com/20190903150520.gif)\n\n好了，还是放它在角落里吃灰吧。既然吾辈这个唯一的需求都无法实现，那留它何用，拉出去斩了吧！这或许是 qBittorrent 的问题，或许是 Raspbian 的问题，但吾辈已然不想关心，深究之下终究就得不偿失。\n\n## 总结\n\n目前就吾辈使用的体验而言，树莓派不可能真正的普及开来，只能作为一个极客的玩具罢了 -- 没错，就是玩具，而非工具。\n这时候一定会有人反对吾辈说 **“永远不要（把自己遇到的问题）归因于（他人的）恶意，这恰恰说明了（你自己的）无能”**，这点 Linux 桌面的社区也有很多开发者喜欢这样说，然而现在的结果是 Linux 无法在桌面领域立足，究其原因还是对用户不友好，难道开发者就不算是用户了？记得有人说过 **“我是开发者，但同时也是用户。你的产品因为各种原因让我不爽，我就不会选你，我才不会管究竟是谁的锅”**，用户中心论在这里可以说是体现的淋漓尽致。\n","createdTime":1609303695361,"updatedTime":1609303725079,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"3505a9362de24569a777a762882b5f6d","title":"vue 使用 git-rev-sync 确定线上发布版本号","body":"## 场景\r\n\r\n目前公司仍然没有做 CI 持续集成，而是使用手动方式（脚本）部署项目。有时候，已经修改了代码，而线上（测试环境）却还没有部署，导致测试人员认为问题仍然没有修复。那么，怎么确定线上部署的代码版本呢？难道是打开线上网站查看某个功能是否完成了么？有没有更高效的方法呢？\r\n吾辈找到的解决方案便是 [git-rev-sync](https://www.npmjs.com/package/git-rev-sync)。\r\n\r\n## 简介\r\n\r\n官网描述只有一句话: 同步获取当前的 git commit 哈希，标签，计数，分支或提交消息。从 [git-rev](https://github.com/tblobaum/git-rev) 分叉。\r\n实际上就是一个同步获取当前 git commit 最新提交的一些信息，而我们可以将它挂载到 `window` 对象上，方便线上快速确定发布代码的版本。\r\n\r\n## 步骤\r\n\r\n### 安装\r\n\r\n```sh\r\nyarn add -D git-rev-sync\r\n```\r\n\r\n### 在 vue 打包文件中读取 git 信息\r\n\r\n只有在打包时我们才能读取到 git 信息（本地 nodejs 运行），而我们读取完之后不能直接挂载到 `window` 对象上，因为打包时处于 nodejs 环境，`window` 对象并不存在，这时候就需要用到 Vue 提供的环境变量功能了。\r\n\r\n> 引用\r\n> [Vue Cli 在客户端侧代码中使用环境变量](https://cli.vuejs.org/zh/guide/mode-and-env.html#%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BE%A7%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)\r\n\r\n```js\r\n// vue.config.js\r\nconst git = require('git-rev-sync')\r\n\r\n/**\r\n * 传递打包时的环境变量到前端必须是以 VUE_APP_ 开头且必须只能是字符串\r\n * @type {string}\r\n */\r\nprocess.env.VUE_APP_GIT = JSON.stringify({\r\n  short: git.short(),\r\n  long: git.long(),\r\n  branch: git.branch(),\r\n  count: git.count(),\r\n  date: git.date(),\r\n  isDirty: git.isDirty(),\r\n  isTagDirty: git.isTagDirty(),\r\n  message: git.message(),\r\n  remoteUrl: git.remoteUrl(),\r\n  tag: git.tag(),\r\n})\r\n```\r\n\r\n### 在 main.js 中读取环境变量并挂载到 window 对象上\r\n\r\n```js\r\n//在 window 对象上添加 git 属性便于查看指定版本\r\nwindow.git = JSON.parse(process.env.VUE_APP_GIT)\r\n```\r\n\r\n### 效果\r\n\r\n![效果图](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190927082613.png)\r\n\r\n## 总结\r\n\r\n说到底需要这个工具的原因是因为部署的代码与最新的代码不一致，如果有了持续集成工具自动部署的话便不会存在这个问题了呢（这或许就是为什么该项目 [star](https://github.com/kurttheviking/git-rev-sync-js/stargazers) 这么少的原因？）\r\n","createdTime":1580652937908,"updatedTime":1609303579815,"resources":[],"tags":[{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"d86454b85c8f4c38aef6fa1575487e7f","title":"vue","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"5ee1b8e7d6a24ad4a21caaceb371a46c","title":"Yarn link 链接本地项目","body":"## 场景\r\n\r\n作为 JavaScript SDK 的开发者一定都知道，想要在未发布前进行测试整个包可谓是困难重重。而 `yarn link` 这个命令便是为了解决这个需求而产生的，它能让包引用并测试自身，即便包并未发布或不包含在 `package.json` 中亦然。\r\n\r\n## 操作\r\n\r\n> [官网链接](https://www.notion.so/rxliuli/Yarn-link-45007161bbfd43b2beffac88a0bc69b0#396f98a450c445f29e6fff69202654f0)\r\n\r\n### 链接包\r\n\r\n在命令行运行即可将当前包链接安装到这个包中，即便你在 `package.json` 并不会找到显式的依赖。\r\n\r\n```sh\r\nyarn link && yarn link \"<package.json 中的 name 字段>\"\r\n```\r\n\r\n> 注：如果当前包是 `cli`，即 `package.json` 中包含 `bin` 字段，则还会被链接到 yarn 的全局脚本目录中。\r\n> yarn 的全局脚本目录可以通过执行 `yarn global bin` 进行查看，如果要在全局执行，则需要将该目录设置到环境变量 `Path` 中，然后就可以全局运行命令了。\r\n\r\n然后，便可以在项目中使用了（测试）\r\n\r\n```sh\r\nimport <pkgName> from 'pkgName'\r\n```\r\n\r\n### 取消链接\r\n\r\n如果不需要了，则也可以轻易通过 `unlink` 移除。\r\n\r\n```sh\r\nyarn unlink \"<package.json 中的 name 字段>\" && yarn unlink\r\n```\r\n\r\n> 注：同样的，如果当前包是 `cli`，则 yarn 全局 `bin` 目录中也会进行删除\r\n\r\n### 通用 script\r\n\r\n每个项目都这样太麻烦了，可否添加一个通用 `script` 脚本呢？\r\n\r\n当然是可以的，通过 `%npm_package_name%` 我们便能在 `srcipt` 中访问到项目名\r\n\r\n```json\r\n\"scripts\": {\r\n  \"link:add\": \"yarn link && yarn link %npm_package_name%\",\r\n  \"link:remove\": \"yarn unlink %npm_package_name% && yarn unlink\"\r\n},\r\n```\r\n\r\n> 参考：[https://docs.npmjs.com/misc/scripts#packagejson-vars](https://docs.npmjs.com/misc/scripts#packagejson-vars)\r\n\r\n以后便可以直接将命令复制到 `script` 即可直接使用了。\r\n\r\n> 注：使用 `%%` 包裹便能在 `script` 中使用，该方式在 Windows 下生效，Linux 下似乎需要添加前缀 `$`，不过吾辈并未测试（懒得折腾 Linux 桌面了）。\r\n> 然而，问题并非不存在了，例如本地使用 Windows 构建，然而远程 CI 使用 Linux，那这个脚本就要炸了。。。所以，如果你需要上 CI 的话，还是老实改名字吧。\r\n> 或者也可以使用 **VSCode + WSL**？#笑\r\n","createdTime":1580652937887,"updatedTime":1609303410280,"resources":[],"tags":[{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"7616be55a2234a6a8faf3922411ccd2b","title":"局域网内 Windows/Android 传输文件","body":"## 场景\r\n\r\n在写杂谈 [手游-ウチの姫-回坑感想](:/d6cb150792f94929af671bc6b685657f) 时，吾辈在手机上进行了多次截图，但苦于数量太多不方便使用 Telegram/QQ 之类的 IM 进行传输。在尝试了包括 FTP、Infinit、Feem、飞鸽传书这些软件之后，最终发现吾辈还是一如既往的绕远路 -- Windows 本身就包含这个功能。\r\n\r\n## 步骤\r\n\r\n## Windows 设置共享文件夹\r\n\r\nWindows 在 _文件管理器 => 在文件夹上右键 => 属性_ 中可以看到共享，接下来，设置该文件夹为共享文件夹，那么手机便能下载/上传文件到该目录中了。\r\n\r\n1. 点击共享\r\n2. 选择共享的用户\r\n3. 确认共享\r\n\r\n![GIF 示意图](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229233129.gif)\r\n\r\n## 手机上访问局域网\r\n\r\n这里使用 [ES 文件浏览器](https://www.coolapk.com/apk/com.estrongs.android.pop) 作为客户端 App 访问 Windows 的共享文件夹。\r\n\r\n1. 找到 _网络 => 局域网_\r\n2. 点击 **扫描**\r\n   ![扫描到的目录](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229232158.png)\r\n3. 点击扫描到的共享计算机\r\n4. 输入上面选择的共享用户的 `Username/Password`\r\n5. 然后就能看到共享文件夹，并且能够复制/粘贴文件了\r\n   ![目录](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229232200.png)\r\n   ![粘贴](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191229232159.png)\r\n\r\n## 总结\r\n\r\nWindows 真的有很多相当好用的功能，只是由于功能太多导致吾辈未曾发现呢\r\n","createdTime":1580652938058,"updatedTime":1609303292942,"resources":[],"tags":[{"id":"4e00e5550c864473a3f16e4b0698f1c3","title":"windows","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"37d3c50950c24c5e940412df559c401d","title":"偶遇 HTML 中的奇妙字符","body":"虽然名字听起来就像是**一本正经的胡说八道**，但吾辈确实遇到了一个奇怪的问题，于此分享给大家。\n\n事情的起始如下\n\n_下班回家 => 想要看动画 => 去动漫花园下载 BT 种子 => 动漫花园一片空白 => Why？_\n\n![默认 uBlock 屏蔽页面](https://raw.githubusercontent.com/rxliuli/img-bed/master/20200429010151.png)\n\n于是吾辈**偷偷的**的打开了控制台看了一下，发现是页面中的内容元素不见了。经过深思熟虑（好吧其实也就是稍微想了一下）首先把 uBlock 禁用，毕竟这个最容易被网站检测出来并且**对抗**嘛！果不其然，页面恢复了正常，但。。。同时广告也出现在了页面上。\n\n![默认 uBlock 不屏蔽页面](https://img.rxliuli.com/20200429010420.png)\n\n这可不行，重新启用了 uBlock 看了一下分析，很显然，内容不存在大概率是被 uBlock 的**元素过滤**功能隐藏掉了，查看被隐藏的内容元素，发现 id 为 `1280_adv`，但同时又包含了广告与主体内容，所以只要关掉 uBlock 的**元素过滤**就可以避免正常内容被误杀了。\n\n> 之所以不在该网站整个禁用掉 uBlock 的原因在于 uBlock 并不只有**元素过滤**，它还阻止了一些广告资源的加载，仅在动漫花园就包括但不限于 _baidu.com, bebi.com, histats.com_。显而易见，禁用它们还能提高加载速度。\n\n![uBlock 屏蔽的脚本](https://img.rxliuli.com/20200429010547.png)\n\n既然无法使用 uBlock 的元素屏蔽了，那么吾辈便需要使用一个新的方式去阻止广告了，幸运的是吾辈安装了 Stylus 和 Tampermonkey 插件。\n\n> Stylus 能够使用被称为 `user.css` 的技术，能够在本地修改任意网站的样式 -- 即自定义 UI 显示。\n> 而 Tampermonkey 则更强大，支持 `user.js` -- 可以在本地打开任意网站时载入自定义的 JavaScript 脚本，不再局限于修改 UI，几乎与插件无异（事实上它也确实被认为是更轻量的插件）。\n\n原以为就几句 css 的事情，找到了广告的 id，于是吾辈写下了下面这些 css\n\n```css\n/*屏蔽动漫花园的广告*/\n.ad,\n#1280_adv,\n#1280_ad > a,\n#bebiv3_ad {\n  display: none;\n}\n```\n\n但结果却是。。。只生效了一半！\n\n![屏蔽一半](https://img.rxliuli.com/20200429010717.png)\n\n可以看到，上面两个广告确实被隐藏了，但下面一个却并没有，而且吾辈在控制台直接使用 `document.querySelector('#1280_adv')` 也获取 dom 会抛出错误 `SyntaxError: Document.querySelector: '#1280_adv' is not a valid selector`。吾辈是直接复制的 id，**理论上**来说不会有错才是。\n\n仔细想想，吾辈或许是漏掉了什么。。。于是，吾辈使用 **Copy => Copy Selector** 功能，有趣的东西出现了，复制出来的内容竟然是 `'\\31 280_adv'`，wtf？\n\n嗯，或许吾辈需要冷静一下，尝试使用 `document.querySelector(\"#\\\\31 280_adv\")` 获取一下\n\n> 注意：这里 JS 里面去查询 DOM Selector 的字符串又进行了转义。\n\n![Console 获取](https://img.rxliuli.com/20200429010811.png)\n\nOK，确实能够正常拿到。由于这些奇怪的字符在 css 中存在语法错误，那么接下来便用 `user.js` 去屏蔽掉它们吧！\n\n基本实现如下\n\n```js\n;[\n  document.querySelector('#\\\\31 280_adv'),\n  document.querySelector('.ad'),\n  document.querySelector('#\\\\31 280_ad > a'),\n].forEach((ad) => ad.remove())\n```\n\n甚至吾辈都发到了 [GitHub](https://github.com/rxliuli/userjs/tree/master/src/dmhy) 与 [GreasyFork](https://greasyfork.org/zh-CN/scripts/402206) 上了。\n\n然后，有个（万能的）网友就提出，可以转换思路，既然 `#\\\\31 280_adv` 在 css 中存在语法错误，那么使用属性选择器过滤 id 将值包裹在 `''` 之中不就好了么？此话真是九言劝醒迷途仕，一语惊醒梦中人，吾辈瞬间 GET 到了这个点。\n\n于是吾辈编写出了下面这段 `user.css` 样式\n\n```css\n/*屏蔽动漫花园的广告*/\n.ad,\ndiv[id='\\31 280_adv'],\ndiv[id='\\31 280_ad'] > a,\ndiv[id='bebiv3_ad'] {\n  display: none;\n}\n```\n\n使用后效果如下\n\n![屏蔽后干净的网页](https://img.rxliuli.com/20200429010852.png)\n\n现在，初始目的达成了，吾辈开始有点好奇它是怎么实现这个功能，于是下载了它的源码，id 那里并未发现什么奇怪的东西，但吾辈却也无法复现一个 demo！\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n  </head>\n  <body>\n    <div id=\"test\">2</div>\n    <script>\n      window.addEventListener('load', () => {\n        document.querySelector('#test').setAttribute('id', '\\\\31 280_adv')\n      })\n    </script>\n  </body>\n</html>\n```\n\ndemo 效果\n\n![demo 效果](https://img.rxliuli.com/20200429011004.png)\n\n如果有人知道原因的话，请务必不吝赐教！\n\n> 参考：[ASCII Wiki](https://zh.wikipedia.org/wiki/ASCII)\n\n---\n\n> 后续，万能的网友 [NiaMori](https://disqus.com/by/niamori/) 又来说明啦，实际上是 id 以数字开头的原因，具体问题参考：\n> 是 id 以数字开头的原因，简单的 `<div id=\"1\">test<div>` 就能复现这个效果。\n> `document.getElementById('1')` 能够选中，但 `document.querySelector('#1')` 不能，因为 HTML5 允许 id 以数字开头而 CSS 不允许\n> 0x31 是 '1' 的 Unicode 编码值，Copy selector 的时候 Chrome 做了一个智能的 escape\n> 参考：\n>\n> - [Using querySelector with IDs that are numbers](https://disq.us/url?url=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F20306204%2Fusing-queryselector-with-ids-that-are-numbers%3Aywx_Ldt8DYLp36vWCEZDC-CT6pM&cuid=5534903)\n> - [Css Spec](https://disq.us/url?url=https%3A%2F%2Fwww.w3.org%2FTR%2FCSS21%2Fsyndata.html%23characters%3AYR69gjoR28vxgXneZXGYH3k8gFM&cuid=5534903)\n> - [CSS.escape](https://disq.us/url?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FCSS%2Fescape%3A5uLuEmiEmKi4BAwjvTU8OFFY6OQ&cuid=5534903)\n","createdTime":1609302998934,"updatedTime":1609303005528,"resources":[],"tags":[{"id":"8f339224ff5c4b5aa4103e407b04ed0e","title":"css","parent_id":""},{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"eb8ad60e7a4d4fe186a56343790cf524","title":"FireFox [附加组件管理器] 标签页使用 Chrome 的 favIconUrl","body":"## 场景\n\n吾辈最近开发了一个 [标签页快速切换插件](https://github.com/rxliuli/tabs_panel)，原本准备在 Chrome Store 先行上架的，不过由于 Chrome 的 [开发者注册](https://chrome.google.com/webstore/devconsole/register?hl=zh-CN) 需要 Visa 信用卡付费，所以不得已暂缓了下来。\n于是，去看了一下 Firefox 的插件开发者中心，发现其并不需要收费，所以便想要兼容一下 Firefox，但吾辈却由此发现了奇怪的事情。\n\n首先是 firefox 报的一个错误\n\n```js\n安全错误：位于 moz-extension://b0d38f9f-eca1-4163-870e-64aedabf5f20/popup.html 的内容不可以载入或者链接至 chrome://mozapps/skin/extensions/extension.svg。\n```\n\n当然，吾辈看到这个错误的第一时间是很懵逼的，因为吾辈未曾引用过 _chrome://mozapps/skin/extensions/extension.svg_ 这个 svg 图片啊，为什么会提示不可以载入呢？\n\n## 原因\n\n于是吾辈去看了 `browser.tabs.query` 所查询到的数据，结果。。。\n\n```js\narr = await browser.tabs.query({})\narr.find(\n  (tab) => (tab.favIconUrl = 'chrome://mozapps/skin/extensions/extension.svg'),\n)\n```\n\n![查询到的 tab](https://img.rxliuli.com/20200508234243.png)\n\n为什么 Firefox 的**附加组件管理器**标签页会使用 Chrome 的图标啊？难道是 Firefox 的开发团队复制 Chrome 源码的时候忘记替换了么？\n抱着好玩的想法，吾辈将这个错误分享到了某个 Telegram 前端群中，有人提出了完全不同的解释：这是 Firefox 历史的遗产 -- 遠古的 XUL 留下來的 scheme，甚至在 Chrome 浏览器出现之前就已经存在了。\n\n> 参考:\n>\n> - [遠古的 XUL 留下來的 scheme](https://developer.mozilla.org/en-US/docs/Archive/Mozilla/XUL/Tutorial/The_Chrome_URL)\n> - [2004 年 Firefox 1.0 的介面層就叫做 chrome 惹](https://developer.mozilla.org/zh-TW/docs/Mozilla/Chrome_Registration)\n> - [XUL 教学](https://developer.mozilla.org/zh-TW/docs/XUL_%E6%95%99%E5%AD%B8)\n\n## 复现步骤\n\n如果有人想要复现这个问题玩一下的话，具体流程如下：\n\n```mermaid\ngraph TB;\n打开附加组件管理器 --> 调试附加组件 --> 选择一个扩展点击检查按钮 --> 输入上面的代码\n```\n\n![流程示意图](https://img.rxliuli.com/20200509001909.gif)\n\n## 总结\n\n真相只有一个：Firefox 58 之后虽然号称重构了这个浏览器，但 UI 层并未抛弃掉老旧的 XUL，同时 Firefox 主要推动的 web extension api 则并未注意到这个问题（这里或许能从侧面说明 Firefox 的插件生态并不繁荣，这种问题都没有人遇到过。。。），导致了这种 **自相冲突** 的奇葩问题。\n","createdTime":1609302946208,"updatedTime":1609302952393,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"2e44be75fb034cbf8e6bf10edb1c66a6","title":"博客已添加离线支持","body":"博客已使用 [service-worker](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers) 技术对网站添加离线支持功能，具体实现不过是使用了 [hexo-offline](https://github.com/JLHwung/hexo-offline) 插件，之后所有第一次访问过的页面之后便离线可用了，同时即便在线浏览仍然能更快的展示页面。\n想要使用它的主要原因是吾辈的博客是静态的，意味着几乎所有的资源都可以通过 service-worker 缓存，以此提高网站的可用性。\n\n> 注: [Vue 官网](https://vuejs.org/) 使用 hexo 构建，同时使用了该插件实现离线支持。\n\n![ServiceWorker](https://img.rxliuli.com/20200517111759.png)\n","createdTime":1609302877818,"updatedTime":1609302883287,"resources":[],"tags":[{"id":"8d84caf3b0e54ff4af6527928064146b","title":"宣告","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"68a7cedb0c1f49f08c8d8942e905d885","title":"使用插件还是油猴脚本","body":"## 场景\n\n最近吾辈写了一个 chrome 插件，之前也有写过许多 user.js 脚本，所以便想在此谈一下它们的区别，以及如何选择。\n\n- [吾辈写过的 user.js 脚本](https://greasyfork.org/zh-CN/users/84714)\n- [吾辈写过的 chrome 插件](https://chrome.google.com/webstore/search/rxliuli)\n\n## 简介\n\n> [user.js wiki](https://zh.wikipedia.org/zh-hk/Greasemonkey), [chrome plugin dev doc](https://developer.chrome.com/extensions/devguide)\n\nuser.js 是一个开放的的标准，最早由 Firefox 的一个插件提出，后来在 chrome 得到原生支持。实际上，user.js 只是在用户的浏览器上访问一些网站时，向网站注入一些 JavaScript 脚本，除了顶部的声明信息以及一些 `GM_*` 的特殊 api 之外，它与普通的 JavaScript 没有什么不同。同时，目前支持 user.js 的浏览器插件很多，最流行的大概就是 [TamperMonkey](https://www.tampermonkey.net/)，同时支持非常多的浏览器，在不同浏览器之间实现了 **跨平台**。当然，为网页注入一段 JavaScript 脚本可以改变网页本身，但普通 JavaScript 做不到的事情，user.js 也基本没法实现。例如 **获取所有的浏览器标签页** 这种涉及到浏览器本身的操作。\n\n而插件则不同，它是浏览器提供的一种附加功能，借用官方介绍：**扩展程序是可定制浏览体验的小型软件程序。它们使用户可以根据个人需要或偏好来定制 Chrome 功能和行为。它们基于 Web 技术（例如 HTML，JavaScript 和 CSS）构建。**，它们能访问浏览器众多的扩展 API，实现对浏览器级别的功能定制 -- 而非仅限于网站。例如上面 user.js 做不到的事情 **获取所有的浏览器标签页** 浏览器插件可以轻易实现。\n\n## 能力/API\n\n相关 API 链接如下，此处就不贴了（太多了）\n\n- [user.js api](https://www.tampermonkey.net/documentation.php)\n- [chrome plugin api](https://developer.chrome.com/extensions/devguide)\n\n## 工程化\n\n在工程化上，user.js 几乎没有工程化的最佳实践，直到目前为止，仍然没有简单可用的打包工具对 user.js 进行专门支持，例如通过 react 编写一些 UI 相关的内容并最终打包成一个 `*.user.js` 脚本文件是比较困难的。\n看看目前的主流打包工具吧\n\n- rollup: JavaScript SDK 打包工具\n- Webpack: 最强大的打包工具\n- parcel: 开箱可用的打包工具\n\n是的，打包工具有不少，但这三者都对 user.js 没有太好的支持，主要有两点\n\n1. 保证打包后顶部信息说明注释仍然在最顶部\n2. 支持多入口打包\n3. 支持 TypeScript\n4. 支持 vue/react 现代前端框架\n\n目前最合适的是 parcel，但仍然没有默认解决第一个问题。\n\n与之相比，chrome 插件的工程化就要好上不少，parcel 甚至官方支持了 `WebManifest` 类型的资源，这对浏览器插件的开发有着极大的方便 -- 可以使用现代前端的一切！\n\n## 发布\n\nuser.js 可以发布在任何静态托管服务里，一般可以放在 [GreasyFork](https://greasyfork.org/) 上，供需要的用户通过脚本管理其安装。GreasyFork 甚至可以直接导入 GitHub 上的源码和 README 发布一个脚本，同时在后续过程中自动更新。\n而 chrome 插件则只能通过 [chrome web store](https://chrome.google.com/webstore) 进行分发，而且每次更新或上架都需要被审核，这其实是比较花时间的，并非是即时性的。同时 web store 也有注册费用，必须使用 Visa 等国外信用卡支付 \\$5，而这对于国内开发者而言是一件比较麻烦的事情。\n\n> 吾辈知道可以使用开发者模式打开解压缩的插件，但这终究不是一个好的分发策略，不能要求每个用户都执行这种麻烦的操作，同时，每次重新打开浏览器都会进行提示也不厌其烦。\n\n## 对于使用者\n\n- 安装难度：chrome 插件安装事实上只能从 chrome store 就意味着国内用户几乎用不了，嗯，这点是一个相当的减分项。而油猴脚本则不太相同，只要支持 user.js 的插件即可添加任意多的 user.js 脚本，事实上，插件只是一个管理工具，chrome 原生支持它！\n- 需求： 如果只是为网站诸如一段脚本修改一些网站的内容，则优先考虑使用 user.js，如果涉及到操作浏览器相关功能，则只能选择插件，本质上 user.js 在插件中就是 [content script](https://developer.chrome.com/extensions/content_scripts) 功能。\n- 性能：对于一般用户而言，安装一个 chrome 插件会一直在后台开启一个线程，而脚本不会 -- 只会在需要生效的网站上应用。\n","createdTime":1609302802172,"updatedTime":1609302809423,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"ecdf1211dd6044a9959e2f3ecf5727d2","title":"近期博客变化","body":"近期吾辈的博客会发生一些变化，可能会出现一些奇怪的问题\n\n重要的变更只有以下两点\n\n- hexo 主题由 [matery](https://github.com/blinkfox/hexo-theme-matery/) 迁移至 [fluid](https://github.com/fluid-dev/hexo-theme-fluid)\n- 评论系统由 [disqus](https://blog.disqus.com/) 迁移至 [utterances](https://utteranc.es/)\n\n以下是细节变动\n\n- 更简洁的 material design 风格\n- 评论系统以更新为以 github 为基础 utterances\n- 代码高亮插件 `highlight.js` 更新以支持 `jsx/tsx`\n- 更新 hexo 至最新版 `4.2.1`\n- 更新封面由东方 Project 系列图片为穹妹\n- 清理了一些无用的 hexo 插件\n- 使用 git submodule 的形式管理主题\n","createdTime":1609302503547,"updatedTime":1609302508868,"resources":[],"tags":[{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""},{"id":"f5172282f275485bab67f712ba1b1bcf","title":"个人","parent_id":""}]},{"id":"d101451820354652a932ffe820d9d1c5","title":"TypeScript 类型编程","body":"## 前言\n\n> TypeScript 改变了吾辈对于类型系统的认知，它强大的类型系统使得类型本身也是可编程的。\n\n最近 TypeScript 更新了一个大版本 v4，新增了一些非常强大的特性，让之前难以做到的事情也能够实现了。\n\n- 模板字符串类型\n- 递归类型\n\n## 简介\n\n> 参考：[TypeScript 4.1](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html)\n\n### 模板字符串类型\n\n尤其适合在 CSS Properties 相关的类型定义中使用，例如 css 的 `width`，就可以使用模板字符串进行检查避免低级错误。\n\n之前\n\n```ts\ntype Width = number | string\nconst i: Width = '1px'\nconst i2: Width = '1px2' // 不会报错\n```\n\n现在\n\n```ts\ntype Unit = 'px' | '%' | 'em' | 'rem'\ntype Width = number | `${number}${Unit}`\nconst i: Width = '1px'\nconst i2: Width = '1px2' // TS2322: Type '\"1px2\"' is not assignable to type 'Width'.\n```\n\n> 该特性在 Grid 组件进行了实用，能够避免一些低级错误。\n\n### 递归类型\n\n事实上，递归类型的需求由来已久。例如典型的 `Array.prototype.flat` 函数的类型定义，或是函数式中部分应用函数的类型定义。\n\n下面是一个将嵌套数组亚平的函数的类型定义示例（来自 TypeScript 官网）\n\n```ts\ntype ElementType<T> = T extends ReadonlyArray<infer U> ? ElementType<U> : T\n\nfunction deepFlatten<T extends readonly unknown[]>(x: T): ElementType<T>[] {\n  throw 'not implemented'\n}\n\n// All of these return the type 'number[]':\ndeepFlatten([1, 2, 3])\ndeepFlatten([[1], [2, 3]])\ndeepFlatten([[1], [[2]], [[[3]]]])\n```\n\n## 实际的使用场景\n\n### 在 i18next 中根据 key 获取翻译字符串\n\n> [i18next 的类型定义](https://stackoverflow.com/a/58308279/8409380)\n\n最近遇到了通过 i18n 框架获取翻译文本的需求，其中翻译文本通过一个对象的形式定义，所以吾辈就需要一种能够根据 key 获取到类型的方法。\n\n需要支持以下情况\n\n- 根据 key 获取对应的文本\n- 根据 key 深层获取文本\n- 根据 key 获取文本并进行参数注入\n\n下面是吾辈对 i18next 的封装\n\n```ts\nimport zhCN from '../i18n/zhCN'\nimport en from '../i18n/en'\nimport i18next, { TOptions } from 'i18next'\n\n//region 类型定义\n\n// returns the same string literal T, if props match, else never\ntype CheckDictString<T extends string, O> = T extends `${infer A}.${infer B}`\n  ? A extends keyof O\n    ? `${A}.${Extract<CheckDictString<B, O[A]>, string>}`\n    : never\n  : T extends keyof O\n  ? T\n  : never\n\n// returns the property value from object O given property path T\ntype GetDictValue<T extends string, O> = T extends `${infer A}.${infer B}`\n  ? A extends keyof O\n    ? GetDictValue<B, O[A]>\n    : never\n  : T extends keyof O\n  ? O[T]\n  : never\n\n// retrieves all variable placeholder names as tuple\ntype Keys<S extends string> = S extends ''\n  ? []\n  : S extends `${infer _}{{${infer B}}}${infer C}`\n  ? [B, ...Keys<C>]\n  : never\n\n// substitutes placeholder variables with input values\ntype Interpolate<\n  S extends string,\n  I extends Record<Keys<S>[number], string>\n> = S extends ''\n  ? ''\n  : S extends `${infer A}{{${infer B}}}${infer C}`\n  ? `${A}${I[Extract<B, keyof I>]}${Interpolate<C, I>}`\n  : never\n\n//endregion\n\ntype Dict = typeof zhCN | typeof en\n\nexport enum LanguageEnum {\n  ZhCN = 'zhCN',\n  En = 'en',\n}\n\nexport class I18nLoader {\n  constructor() {}\n\n  /**\n   * 加载国际化\n   */\n\n  async load(language: LanguageEnum) {\n    await i18next.init({\n      lng: language,\n      resources: {\n        en: {\n          translation: en,\n        },\n        zhCN: {\n          translation: zhCN,\n        },\n      },\n    })\n  }\n\n  /**\n   * 根据 key 获取翻译的文本\n   * @param key\n   */\n  getText<K extends string>(\n    key: keyof Dict | (K & CheckDictString<K, Dict>),\n  ): GetDictValue<K, Dict>\n  getText<\n    D extends Dict & Record<string, string>,\n    K extends keyof D,\n    I extends Record<Keys<D[K]>[number], string>\n  >(k: K, args: I): Interpolate<D[K], I>\n  getText<K extends string>(\n    key: keyof Dict | (K & CheckDictString<K, Dict>),\n    args?: TOptions,\n  ): GetDictValue<K, Dict> {\n    return i18next.t(key, args)\n  }\n}\n```\n\n使用起来很简单\n\n```ts\nconst i18nLoader = new I18nLoader()\nawait i18nLoader.load(LanguageEnum.ZhCN)\nconsole.log(i18nLoader.getText('hello')) // 你好\n```\n\n接下来，我们分析以下 `CheckDictString`\n\n```ts\ntype CheckDictString<T extends string, O> = T extends `${infer A}.${infer B}`\n  ? A extends keyof O\n    ? `${A}.${Extract<CheckDictString<B, O[A]>, string>}`\n    : never\n  : T extends keyof O\n  ? T\n  : never\n```\n\n1. 传入泛型参数 `T` 和 `O`，`T` 必须继承自 `string`\n2. 判断 `T` 是否继承自 `${infer A}.${infer B}`，即判断 `T` 是否包含 `.`，并解构得到 `A`（第一个 `.` 之前）,`B`（第一个 `.` 之后，可能还包含 `.`）\n   1. 如果是，则继续判断 `A` 是否为传入对象的字段\n      1. 如果是，则继续递归检查 `B` 是否为 `O[A]` 的一个字段\n      2. 否则，返回 `never`\n   2. 否则，则判断 `T` 是否是 `O` 的字段\n      1. 如果是，则返回 `T`\n      2. 否则，返回 `never`\n\n可以看到，如果检查出现错误，则返回 `never`，但我们传入的 `string` 是不能合并为 `never` 的，这将会导致 ts 类型检查出错（其它的类型基本上也是一样的推导方式）。\n\n---\n\n附录\n\n虽然看起来不错，那么这个类型是否满足我们简化 i18next 使用的需求呢？\n实际上没有。即便有如此强大的类型系统，但它仍然不足以满足特别灵活的需求。实际使用时仍发现以下问题：\n\n- 嵌套对象的参数注入没有进行检查\n- 参数注入的翻译文本没有提示注入参数\n\n解决方案有两个方向\n\n- linter rule\n- code generate\n\n下面是一个简单的对比\n\n| 分类     | typescript             | linter rule              | code generate              |\n| -------- | ---------------------- | ------------------------ | -------------------------- |\n| 使用     | 直接使用               | 通过 eslint 插件         | 通过 cli 命令行            |\n| 复杂度   | 一般（不用了解 `ast`） | 高                       | 较高                       |\n| 适用场景 | 绝大多数场景           | 容易编写的少量代码的检查 | 大量重复可自动化生成的代码 |\n\n### 使用类型系统解析 json 字符串（好玩性质）\n\n[twitter 上](https://twitter.com/buildsghost/status/1301976526603206657) 甚至有人使用 TypeScript 的模板字符串和递归类型解析了 json 字符串。\n\n```ts\ntype ParserError<T extends string> = { error: true } & T\ntype EatWhitespace<State extends string> = string extends State\n  ? ParserError<'EatWhitespace got generic string type'>\n  : State extends ` ${infer State}` | `\\n${infer State}`\n  ? EatWhitespace<State>\n  : State\ntype AddKeyValue<\n  Memo extends Record<string, any>,\n  Key extends string,\n  Value extends any\n> = Memo & { [K in Key]: Value }\ntype ParseJsonObject<\n  State extends string,\n  Memo extends Record<string, any> = {}\n> = string extends State\n  ? ParserError<'ParseJsonObject got generic string type'>\n  : EatWhitespace<State> extends `}${infer State}`\n  ? [Memo, State]\n  : EatWhitespace<State> extends `\"${infer Key}\"${infer State}`\n  ? EatWhitespace<State> extends `:${infer State}`\n    ? ParseJsonValue<State> extends [infer Value, `${infer State}`]\n      ? EatWhitespace<State> extends `,${infer State}`\n        ? ParseJsonObject<State, AddKeyValue<Memo, Key, Value>>\n        : EatWhitespace<State> extends `}${infer State}`\n        ? [AddKeyValue<Memo, Key, Value>, State]\n        : ParserError<`ParseJsonObject received unexpected token: ${State}`>\n      : ParserError<`ParseJsonValue returned unexpected value for: ${State}`>\n    : ParserError<`ParseJsonObject received unexpected token: ${State}`>\n  : ParserError<`ParseJsonObject received unexpected token: ${State}`>\ntype ParseJsonArray<\n  State extends string,\n  Memo extends any[] = []\n> = string extends State\n  ? ParserError<'ParseJsonArray got generic string type'>\n  : EatWhitespace<State> extends `]${infer State}`\n  ? [Memo, State]\n  : ParseJsonValue<State> extends [infer Value, `${infer State}`]\n  ? EatWhitespace<State> extends `,${infer State}`\n    ? ParseJsonArray<EatWhitespace<State>, [...Memo, Value]>\n    : EatWhitespace<State> extends `]${infer State}`\n    ? [[...Memo, Value], State]\n    : ParserError<`ParseJsonArray received unexpected token: ${State}`>\n  : ParserError<`ParseJsonValue returned unexpected value for: ${State}`>\ntype ParseJsonValue<State extends string> = string extends State\n  ? ParserError<'ParseJsonValue got generic string type'>\n  : EatWhitespace<State> extends `null${infer State}`\n  ? [null, State]\n  : EatWhitespace<State> extends `\"${infer Value}\"${infer State}`\n  ? [Value, State]\n  : EatWhitespace<State> extends `[${infer State}`\n  ? ParseJsonArray<State>\n  : EatWhitespace<State> extends `{${infer State}`\n  ? ParseJsonObject<State>\n  : ParserError<`ParseJsonValue received unexpected token: ${State}`>\ntype ParseJson<T extends string> = ParseJsonValue<T> extends infer Result\n  ? Result extends [infer Value, string]\n    ? Value\n    : Result extends ParserError<any>\n    ? Result\n    : ParserError<'ParseJsonValue returned unexpected Result'>\n  : ParserError<'ParseJsonValue returned uninferrable Result'>\n\ntype Json = ParseJson<'{ \"key1\": [\"value1\", null], \"key2\": \"value2\" }'> // type Json = { key1: [\"value1\", null]; } & { key2: \"value2\"; }\n```\n\n> 我想后端语言（Java/GoLang）至今也没有出现如此复杂的类型定义。\n\n## 总结\n\n虽然 TypeScript 的类型系统已经如此强大，但它并非没有局限性，像在上面的 [在 i18next 中根据 key 获取翻译字符串](#在-i18next-中根据-key-获取翻译字符串) 便是一例。\n","createdTime":1609120118636,"updatedTime":1609220172775,"resources":[],"tags":[{"id":"a3f220fe6f2c4c50a1aa91707edb8741","title":"typescript","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"03ee7047ae3c4203b0c4c4ebfd6d7bd9","title":"JavaScript => TypeScript 迁移体验","body":"## 前言\r\n\r\n> 如果你使用 JavaScript 没出现什么问题，那吾辈就不推荐你迁移到 TypeScript！\r\n\r\n- `JavaScript` 不能无缝迁移到 `TypeScript`！\r\n- `JavaScript` 不能无缝迁移到 `TypeScript`！\r\n- `JavaScript` 不能无缝迁移到 `TypeScript`！\r\n\r\n重要的话说三遍，TypeScript 是 JavaScript 的超集，所以有很多人认为（并宣称）JavaScript 可以很容易迁移到 TypeScript，甚至是无缝迁移的！\r\n导致了 JavaScript 开发者满心欢喜的入坑了 TypeScript（包括吾辈），然后掉进了坑里，甚至差点爬不出来。。。\r\n\r\n## 原因\r\n\r\n- 问: 为什么吾辈用 JavaScript 用的好好的，偏偏自找麻烦去入坑了 TypeScript 了呢？\r\n- 答: JavaScript 因为一些固有问题和主流编辑器 VSCode 支持不力，导致代码写起来会感觉很不方便\r\n- 问: 具体谈谈\r\n- 答: 有很多令人不满意的地方，这里只谈几点:\r\n  - JavaScript 没有类型，所以写 JSDoc 感觉很麻烦，但不写又不太好。然而，JavaScript 代码写的太顺利的话就可能忘记加上 JSDoc，之后代码就很难维护。\r\n  - VSCode 支持不好，这点或许才是最重要的: VSCode 使用 TypeScript 编写，并基于 TypeScript 实现的语法提示功能，虽然也支持根据 JSDoc 的注释进行提示，然而当你去做一个开源项目，并将之发布到 npm 之后，情况发生了变化。。。当一个用户使用 npm/yarn 安装了你的项目之后，发现并没有任何代码提示，如此你会怎么做？\r\n  - 复杂的类型很难使用 JSDoc 表达出来并清晰地告诉调用者，例如高阶函数。\r\n  - 等等。。。。\r\n\r\n是的，TypeScript 确实解决了以上的一些问题，却同时带入了另外一些问题。\r\n\r\n- TypeScript 有类型了，然而即便有类型推导，还是要加很多类型，而且有时候 TypeScript 和我们的想法不同的时候还要用 `!`/`(t as unkonwn) as R` 这种 **hack 技巧**。\r\n- VSCode 天生支持 TypeScript，但 TypeScript 的 API Doc 生成工具实在谈不上多好，例如 [typedoc](https://typedoc.org/) 相比于 [ESDoc](https://esdoc.org/) 不过是个半吊子。。。\r\n- 事实上，即便使用 TypeScript 写的项目，只要使用者没有在 `jsconfig.json` 中进行配置的话，提示仍然默认不存在\r\n- TypeScript 的类型系统是把双刃剑，实在太复杂了，当然有理由认为是为了兼容 JavaScript。然而在 TypeScript 想要正确的表达类型也是一件相当困难的事情。\r\n\r\n## 类型系统踩坑\r\n\r\n### 如何声明参数与返回值类型相同？\r\n\r\n例如一个函数接受一个参数，并返回一个完全相同类型的返回值。\r\n\r\n```ts\r\nfunction returnItself(obj: any): any {\r\n  return obj\r\n}\r\n```\r\n\r\n假使这样写的话，类型系统就不会发挥作用了，调用函数的结果将是 `any`，意味着类型系统将没有效果。\r\n\r\n例如下面的代码会被 ts 认为是错误\r\n\r\n```ts\r\n// 这段代码并不会有提示\r\nconsole.log(returnItself('abc').length)\r\n```\r\n\r\n需要写成\r\n\r\n```ts\r\nfunction returnItself<T = any>(obj: T): T {\r\n  return obj\r\n}\r\n```\r\n\r\n这里主要声明了参数和返回值是同一类型，默认为 any，但具体取决于参数的不同而使得返回值也不同，返回值不会丢失类型信息。\r\n\r\n### 如何声明参数与返回值类型有关联？\r\n\r\n例如一个计算函数执行时间的函数 `timing`，接受一个函数参数，有可能是同步/异步的，所以要根据函数的返回值确定 `timing` 的返回值为 `number/Promise<number>`\r\n\r\n```ts\r\nexport function timing(\r\n  fn: (...args: any[]) => any | Promise<any>,\r\n): number | Promise<number> {\r\n  const begin = performance.now()\r\n  const result = fn()\r\n  if (!(result instanceof Promise)) {\r\n    return performance.now() - begin\r\n  }\r\n  return result.then(() => performance.now() - begin)\r\n}\r\n```\r\n\r\n然而在使用时你会发现返回值类型不太对，因为 `timing` 的返回值是 `number | Promise<number>` 这种复合类型\r\n\r\n```ts\r\n// 这里会提示类型错误\r\nconst res: number = timing(() => sleep(100))\r\nexpect(res).toBeGreaterThan(99)\r\n```\r\n\r\n解决方案有二\r\n\r\n1. 使用函数声明重载\r\n2. 使用类型判断\r\n\r\n#### 使用函数声明重载\r\n\r\n```ts\r\nexport function timing(fn: (...args: any[]) => Promise<any>): Promise<number>\r\nexport function timing(fn: (...args: any[]) => any): number\r\nexport function timing(\r\n  fn: (...args: any[]) => any | Promise<any>,\r\n): number | Promise<number> {\r\n  const begin = performance.now()\r\n  const result = fn()\r\n  if (!(result instanceof Promise)) {\r\n    return performance.now() - begin\r\n  }\r\n  return result.then(() => performance.now() - begin)\r\n}\r\n```\r\n\r\n感觉函数声明顺序有点奇怪是因为 `Promise<any>` 属于 `any` 的子类，而函数声明重载必须由具体到宽泛。当然，我们有方法可以在 `any` 中排除掉 `Promise<any>`，这样顺序就对了！\r\n\r\n```ts\r\nexport function timing(\r\n  fn: (...args: any[]) => Exclude<any, Promise<any>>,\r\n): number\r\nexport function timing(fn: (...args: any[]) => Promise<any>): Promise<number>\r\nexport function timing(\r\n  fn: (...args: any[]) => any | Promise<any>,\r\n): number | Promise<number> {\r\n  const begin = performance.now()\r\n  const result = fn()\r\n  if (!(result instanceof Promise)) {\r\n    return performance.now() - begin\r\n  }\r\n  return result.then(() => performance.now() - begin)\r\n}\r\n```\r\n\r\n#### 使用类型判断\r\n\r\n```ts\r\nexport function timing(\r\n  fn: (...args: any[]) => any | Promise<any>,\r\n  // 函数返回类型是 Promise 的话，则返回 Promise<number>，否则返回 number\r\n): R extends Promise<any> ? Promise<number> : number {\r\n  const begin = performance.now()\r\n  const result = fn()\r\n  if (!(result instanceof Promise)) {\r\n    return (performance.now() - begin) as any\r\n  }\r\n  return result.then(() => performance.now() - begin) as any\r\n}\r\n```\r\n\r\n#### 思考\r\n\r\n可以看出来，第一种方式的优点在于可以很精细的控制每个不同参数对应的返回值，并且，可以处理特别复杂的情况，缺点则是如果写 doc 文档的话需要为每个声明都写上，即便，它们有大部分注释是相同的。\r\n而第二种方式，则在代码量上有所减少，而且不必使用函数声明重载。缺点则是无法应对特别复杂的情况，另外一点就是使用了 `any`，可能会造成**重构火葬场**。\r\n\r\n### TypeScript 类型系统就是认为吾辈错了怎么办？\r\n\r\n有时候，明明自己知道是正确的，但 TypeScript 偏偏认为你写错了。思考以下功能如何实现？\r\n\r\n将 Array 转换为 Map，接受三个参数\r\n\r\n1. 需要转换的数组\r\n2. 将数组元素转换为 Map key 的函数\r\n3. 将数组元素转换为 Map value 的函数，可选，默认为数组元素\r\n\r\n```ts\r\nfunction returnItself<T = any>(obj: T): T {\r\n  return obj\r\n}\r\n\r\nexport type ArrayCallback<T, R> = (item: T, index: number, arr: T[]) => R\r\n\r\nexport function arrayToMap<T, K, V>(\r\n  arr: T[],\r\n  kFn: ArrayCallback<T, K>,\r\n  vFn: ArrayCallback<T, V> = returnItself,\r\n): Map<K, V> {\r\n  return arr.reduce(\r\n    (res, item, index, arr) =>\r\n      res.set(kFn(item, index, arr), vFn(item, index, arr)),\r\n    new Map<K, V>(),\r\n  )\r\n}\r\n```\r\n\r\n可能有以上代码，然而实际上 `returnItself` 无法直接赋值给 `ArrayCallback<T, V>`。当然，我们知道，这一定是可以赋值的，但 TypeScript 却无法编译通过！\r\n\r\n```ts\r\nexport function arrayToMap<T, K, V>(\r\n  arr: T[],\r\n  kFn: ArrayCallback<T, K>,\r\n  // 是的，这里添加 as any 就好了\r\n  vFn: ArrayCallback<T, V> = returnItself as any,\r\n): Map<K, V> {\r\n  return arr.reduce(\r\n    (res, item, index, arr) =>\r\n      res.set(kFn(item, index, arr), vFn(item, index, arr)),\r\n    new Map<K, V>(),\r\n  )\r\n}\r\n```\r\n\r\n或者，如果 `returnItself` 用的比较多的话（例如吾辈），可以使用另一种方式\r\n\r\n```ts\r\n// 修改 returnItself 的返回值\r\nfunction returnItself<T, R = T>(obj: T): R {\r\n  return obj as any\r\n}\r\n\r\nexport type ArrayCallback<T, R> = (item: T, index: number, arr: T[]) => R\r\n\r\nexport function arrayToMap<T, K, V>(\r\n  arr: T[],\r\n  kFn: ArrayCallback<T, K>,\r\n  vFn: ArrayCallback<T, V> = returnItself,\r\n): Map<K, V> {\r\n  return arr.reduce(\r\n    (res, item, index, arr) =>\r\n      res.set(kFn(item, index, arr), vFn(item, index, arr)),\r\n    new Map<K, V>(),\r\n  )\r\n}\r\n```\r\n\r\n### 如何强制调用非空时对象上的函数？\r\n\r\n当有时候你得到一个对象可能为空时，无法直接调用其上的函数，会提示函数不存在。\r\n例如下面从数组中查询字符串，然后获取长度，在 TypeScript 中便会报错，因为 str 的类型为 string/undefined。\r\n\r\n```ts\r\nconst arr = ['a', 'b', 'c']\r\nconst str = arr.find(s => s === 'b')\r\n//\r\nconsole.log(str.length)\r\n```\r\n\r\n之前使用 JavaScript 从未遇到过这种事情，事实上确实有可能为空，但 JavaScript 太过于动态，并不会提示错误，而 TypeScript 就会提示这种低级错误，因为类型系统。\r\n但是啊，凡事都有例外，当吾辈确实想调用 string 上的函数时报错真的是有点讨厌，那么有什么办法呢？\r\n\r\n1. 使用 `!` 强制调用\r\n\r\n   ```ts\r\n   const arr = ['a', 'b', 'c']\r\n   const str = arr.find(s => s === 'b')\r\n   console.log(str!.length)\r\n   ```\r\n\r\n2. 使用 `(str as any)` 转换为 any 类型之后再随意调用任何函数\r\n\r\n   ```ts\r\n   const arr = ['a', 'b', 'c']\r\n   const str = arr.find(s => s === 'b')\r\n   console.log((str as any).length)\r\n   ```\r\n\r\n3. 使用注释 `// @ts-ignore` 忽略错误（非常强力，少用）\r\n\r\n   ```ts\r\n   const arr = ['a', 'b', 'c']\r\n   const str = arr.find(s => s === 'b')\r\n   // @ts-ignore\r\n   console.log(str.length)\r\n   ```\r\n\r\n注意: 三种方式推荐程度逐渐降低，因为后两种实际上都会忽略类型系统，导致编写代码没有提示！\r\n\r\n## 总结\r\n\r\n截至目前为止，吾辈已经着手使用 TypeScript 重构工具函数库 [rx-util](https://github.com/rxliuli/rx-util) 两周了，基本上打包配置，文档生成，类型定义基本上算是大致完成，感觉之后的公共项目大概都会用 TypeScript 实现了，毕竟前端主流开发工具 VSCode 对其的支持真的很好，而且 TypeScript 的接口这种概念真的太有用了！\r\n\r\n## 一些吐槽\r\n\r\n使用了有一段时间了，这里不得不再次声明一下，TypeScript 的类型系统复杂度超乎想象，如果你没有准备好在生产系统中使用，那就最好不要使用。缺少关于类型系统（尤其是原生类型，例如 `PromiseLike` 居然没有人讲过）的说明，使得 TypeScript 的类型系统很多时候看起来都只是为了**好玩**而已。而且稍微复杂一点的情况思考如何设计类型的时间将会超过具体的代码实现，使用它请务必再三慎重考虑！\r\n\r\nTypeScript 的类型系统为了兼容 JavaScript 缺陷实在太大了。\r\n\r\n> 参见某个知乎用户的话:\r\n\r\n1. ts 写不出一个合并对象的方法\r\n\r\n   下面是一个 js 合并对象的方法\r\n\r\n   ```js\r\n   function extend(dest, ...sources) {\r\n     return Object.assign(dest, ...sources)\r\n   }\r\n   ```\r\n\r\n   这么一个简单的方法，ts 写不出不丢失类型信息的实现。\r\n\r\n   下面贴的是 typescript 源码中对 Object.assign 的声明，我相信都能看出有多傻：\r\n\r\n   ```ts\r\n   assign<T, U>(target: T, source: U): T & U;\r\n   assign<T, U, V>(target: T, source1: U, source2: V): T & U & V;\r\n   assign<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & & W;\r\n   assign(target: object, ...sources: any[]): any;\r\n   ```\r\n\r\n   按这个实现，多于 4 个参数就直接丢掉类型信息了，建议 ts 至少把 A-Z 都作为泛型量用上...\r\n\r\n2. 一些很明显的类型推断却推断不出来\r\n\r\n   用 assert 方法做参数检查是很常用的做法，一个简单的 assert 方法：\r\n\r\n   ```js\r\n   function assert(condition, msg) {\r\n     if (condition) throw new Error(msg)\r\n   }\r\n   ```\r\n\r\n   然后看这样一段代码：\r\n\r\n   ```ts\r\n   function foo(p: number | string) {\r\n     assert(typeof p === 'number', 'p is a number')\r\n     p.length // 这里报错，ts 竟然不知道到这一步 p 必定是 string 类型\r\n   }\r\n   ```\r\n","createdTime":1580652937861,"updatedTime":1608895598091,"resources":[],"tags":[{"id":"a3f220fe6f2c4c50a1aa91707edb8741","title":"typescript","parent_id":""},{"id":"c459bf7ac6f4490c8fd8074fcb398ede","title":"wiki","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"79d6792728cf46828ea1ce6fbce63974","title":"图床「神器」PicGo v2.0 更新，插件系统终于来了","body":"> 转自 <https://molunerfinn.com/picgo-v2.0-update>，作为一个经常使用 Markdown 写作的人而言，一个好的图床工具是很重要的，所以吾辈才会转载这篇文章呢！\r\n\r\n## 前言\r\n\r\n距离上次更新 (v1.6.2) 已经过去了 5 个月，很抱歉 2.0 版本来得这么晚。本来想着在 18 年 12 月（PicGo 一周年的时候）发布 2.0 版本，但是无奈正值研究生开题期间，需要花费不少时间（不然毕不了业了 T T），所以这个大版本姗姗来迟。不过从这个版本开始，正式支持插件系统，发挥你们的无限想象，PicGo 也能成为一个极致的效率工具。\r\n\r\n除了发布 PicGo 2.0 [本体](https://github.com/Molunerfinn/PicGo/releases/)，一同发布的还有 [PicGo-Core](https://picgo.github.io/PicGo-Core-Doc/)（PicGo 2.0 的底层，支持 CLI 和 API 调用），以及 VSCode 的 PicGo 插件 [vs-picgo](https://github.com/Spades-S/vs-picgo) 等。\r\n\r\n### 插件系统\r\n\r\nPicGo 的底层核心其实是 `PicGo-Core`。这个核心主要就是一个流程系统。(它支持在 Node.js 环境下全局安装，可以通过命令行上传图片文件、也可以接入 Node.js 项目中调用 api 实现上传。)\r\n\r\n`PicGo-Core` 的上传流程如下：  \r\n![PicGo-Core 上传流程](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118212302.png)\r\n\r\n`Input` 一般是文件路径，经过 `Transformer` 读取信息，传入 `Uploader` 进行上传，最后通过 `Output` 输出结果。而插件可以接入三个生命周期（`beforeTransform`、`beforeUpload`、`afterUpload`）以及两种部件（`Transformer` 和 `Uploader`）。\r\n\r\n换句话说，如果你书写了合适的 `Uploader`，那么可以上传到不同的图床。如果你书写了合适的 `Transformer`，你可以通过 URL 先行下载文件再通过 `Uploader` 上传等等。\r\n\r\n另外，如果你不想下载 PicGo 的 electron 版本，也可以通过 npm 安装 picgo 来实现命令行一键上传图片的快速体验。\r\n\r\nPicGo 除了 `PicGo-Core` 提供的核心功能之外，额外给 GUI 插件给予一些自主控制权。\r\n\r\n比如插件可以拥有自己的菜单项：  \r\n![菜单](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118212453.png)\r\n\r\n因此 GUI 插件除了能够接管 `PicGo-Core` 给予的上传流程，还可以通过 PicGo 提供的 guiApi 等接口，在插件页面实现一些以前单纯通过 `上传区` 实现不了的功能：\r\n\r\n比如可以通过打开一个 `InputBox` 获取用户的输入：  \r\n![InputBox](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118212549.png)\r\n\r\n可以通过打开一个路径来执行其他功能（而非只是上传文件）：  \r\n![打开一个路径来执行其他功能](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118212808.gif)\r\n\r\n甚至还可以直接在插件面板通过调用 api 实现上传。\r\n\r\n另外插件可以监听相册里图片删除的事件：  \r\n![远端删除](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118212628.png)\r\n\r\n这个功能就可以写一个插件来实现相册图片和远端存储里的同步删除了。\r\n\r\n通过如上介绍，我现在甚至就已经能想到插件系统能做出哪些有意思的插件了。\r\n\r\n比如：\r\n\r\n1. 结合 GitHub 刚刚开放的免费私人仓库，可以通过插件实现 PicGo 的相册以及配置文件同步。\r\n2. 结合 TinyPng 等工具实现上传前给图片瘦身。（不过可能挺影响上传速度的。）\r\n3. 结合一些 Canvas 工具，可以在上传图片前给图片加水印。\r\n4. 通过指定文件夹，将文件夹内部的 markdown 里的图片地址进行图床迁移。\r\n5. 等等。。\r\n\r\n希望这个插件系统能够给 PicGo 带来更强大的威力，也希望它能够成为你的极致的效率工具。\r\n\r\n**需要注意的是，想要使用 PicGo 2.0 的插件系统，需要先行安装 [Node.js](https://nodejs.org/en/) 环境，因为 PicGo 的插件安装依赖 `npm`。**\r\n\r\n## 2.0 其他更新内容\r\n\r\n除了上面说的插件系统，PicGo 2.0 还更新了如下内容：\r\n\r\n- 底层重构了之后，某些图床上传不通过 `base64` 值的将会提升不少速度。比如 `SM.MS` 图床等。而原本就通过 `base64` 上传的图床速度不变。\r\n- 增加一些配置项，比如打开配置文件（包括了上传的图片列表）、mini 窗口置顶、代理设置等。  \r\n  ![更多配置项](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118212954.png)\r\n- 在相册页可以选择复制的链接格式，不用再跑去上传页改了。  \r\n  ![相册允许复制链接格式](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118213134.png)\r\n- 增加不同页面切换的淡入淡出动画。\r\n- macOS 版本配色小幅更新。（Windows 版本配色更新 Fluent Design 效果预计在 2.1 版本上线）\r\n- 更新 electron 版本从 1.8->4.0，启动速度更快了，性能也更好了。\r\n\r\n## Bug Fixed\r\n\r\n- 修复：macOS 多屏下打开详细窗口时位置错误的[问题](https://github.com/Molunerfinn/PicGo/issues/128)。\r\n- 修复：多图片上传重命名一致的[问题](https://github.com/Molunerfinn/PicGo/issues/136)。\r\n- 修复：拖拽图片到软件会自动在软件内部打开这张图片的 [bug](https://github.com/Molunerfinn/PicGo/issues/140)。\r\n- 修复：重命名窗口只出现在屏幕中央而不是跟随主窗口的 [bug](https://github.com/Molunerfinn/PicGo/issues/145)。\r\n\r\n## VSCode 的 PicGo 插件 vs-picgo\r\n\r\n在 PicGo-Core 发布不久，就有人根据 PicGo-Core 的 API 编写了 VSCode 版的 PicGo 插件。使用起来也非常方便：\r\n\r\n- 截图上传  \r\n  ![截图上传](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118213411.gif)\r\n- 文件浏览器选择文件上传  \r\n  ![文件浏览器选择文件上传](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118213514.gif)\r\n- 输入文件路径上传  \r\n  ![输入文件路径上传](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190118213547.gif)\r\n\r\n配置项与 PicGo 的图床的配置项基本保持一致。在 VSCode 插件栏搜索 PicGo 即可下载安装与体验！\r\n\r\n## 结语\r\n\r\nPicGo 第一个稳定版本是在少数派上发布的，详见 [PicGo：基于 Electron 的图片上传工具](https://sspai.com/post/42310)。支持 macOS、Windows、Linux 三平台，开源免费，界面美观，也得到了很多朋友的认可。如果你对它有什么意见或者建议，也欢迎在 [issues](https://github.com/Molunerfinn/PicGo/issues) 里指出。如果你喜欢它，不妨给它点个 star。如果对你真的很有帮助，不妨请我喝杯咖啡（PicGo 的 GitHub [首页](https://github.com/Molunerfinn/PicGo)有赞助的二维码）？\r\n\r\n> 下载地址：[https://github.com/Molunerfinn/PicGo/releases](https://github.com/Molunerfinn/PicGo/releases)  \r\n> Windows 用户请下载`.exe`文件，macOS 用户请下载`.dmg`文件，Linux 用户请下载`.AppImage`文件。\r\n\r\nHappy uploading！\r\n","createdTime":1580652938041,"updatedTime":1608895553483,"resources":[],"tags":[{"id":"95ddbbd925aa4358a46bfcbce4c3fb46","title":"工具","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"8207c9a6018b4cedbffbd600d373c9e3","title":"作为一名 developer 如何正确地使用 Chrome","body":"- [作为一名 developer 如何正确地使用 Chrome](#作为一名-developer-如何正确地使用-chrome)\r\n  - [场景](#场景)\r\n  - [DevTool](#devtool)\r\n    - [Network](#network)\r\n    - [Element](#element)\r\n    - [Sources](#sources)\r\n  - [使用插件](#使用插件)\r\n    - [日常使用](#日常使用)\r\n    - [Stylus](#stylus)\r\n    - [Tampermonkey](#tampermonkey)\r\n\r\n## 场景\r\n\r\n现如今，[Google Chrome](https://www.google.com/chrome/) 是全世界最流行的浏览器，具体有多流行，可以看看 [浏览器市场份额统计](https://www.netmarketshare.com/browser-market-share.aspx)。然而，有许多人，只是简单的安装了 Chrome，然后直接使用，却并未想过如何才能更好的使用它。\r\n\r\n## DevTool\r\n\r\nChrome 的开发者工具可以说是目前最好的了，然而除了简单的查看 `Network/Element` 之外，你可还使用过其他的功能？下面让我们一起来探讨一下 DevTool 的 **奇淫技巧** 吧！\r\n\r\n### Network\r\n\r\n1. `Copy => Copy as fetch`  \r\n   以 `fetch` 方式复制这个请求，如果你对 `fetch` 还不了解，可以去 [MDN: 使用 Fetch](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch) 上查看它，并尝试使用它。这是一个浏览器原生的接口，用于进行 HTTP 操作。相比于 `XMLHttpRequest`，`fetch` 通常被称为下一代的 Ajax 技术。  \r\n   这也正是吾辈将之单独列出的重要原因，因为它是纯 JavaScript 的，所以我们可以直接在浏览器中对其进行测试/修改/执行，这点对于 `user.js` 和 `nodejs 爬虫` 尤其重要。\r\n\r\n   ![Copy => Copy as fetch](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190104212920.png)\r\n\r\n2. Network 设置\r\n\r\n   - `Disable Cache`：禁用网络缓存，开发阶段必备。如果你不想在开发时使用 `CS-R` 进行硬性重新加载，那最好禁用掉它，避免修改的代码没有及时生效。\r\n   - `Preserve log`：保留日志。一般而言，当你刷新页面后，`Network` 将被清空。然而有时候，我们想知道代码修改前后请求发生了哪些变化（修改之前请求一切正常，修改之后就 GG 了），这是便需要使用该选项保留所有的网络请求，方便对比刷新前后请求的变化。\r\n   - `Group by frame`：根据 frame 对请求进行分组。常见于 Web 后台开发，很多后台项目都使用 frame 实现了标签页的功能，所以按照 frame 进行分组会方便进行查看一点。\r\n\r\n   ![Network 设置](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190104214338.png)\r\n\r\n### Element\r\n\r\n1. `Copy => Copy selector`  \r\n   复制 DOM 元素的选择器，该选择器实际上是供 [Selectors API](https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Locating_DOM_elements_using_selectors) 使用（`querySelector/querySelectorAll`），但 jquery 的选择器应该兼容它。我们复制完选择器后就可以使用 `Selectors API` 或 `jquery` 之类的选择器去获取到元素，然后对之进行操作。这对 `user.js`/`nodejs 爬虫`/`快速获取元素` 有着重要的意义。\r\n\r\n   ![Copy => Copy selector](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190104220838.png)\r\n\r\n2. `Break on`  \r\n   在开发过程中，你是否遇到过这样的问题：“某个元素改变了，但始终不知道是那里的代码改变的”。这时候，DOM 断点就派上用场了，监听某个元素，并根据条件触发并暂停当前 JavaScript 进入 Debug 模式。\r\n\r\n   - `subtree modification`：当子节点发生改变时触发\r\n   - `attribute modification`：当节点属性发生改变时触发\r\n   - `node removal`：当节点移除时触发\r\n\r\n   ![Break on](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190104221816.png)\r\n\r\n3. DOM 元素强制指定状态\r\n   某个元素只有在指定状态下才会有某些效果，当你想让这个元素的状态一直维持不变以仔细观察时，就需要强制指定元素的状态了。\r\n   思考以下场景\r\n   下拉菜单只有在鼠标悬浮时才会展开，但鼠标移到 DOM 元素查看时却收起来了，感觉非常难受.JPG！幸好，浏览器为我们提供了这个功能。\r\n   ![Force state](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190726221706.png)\r\n\r\n### Sources\r\n\r\n1. `Drawer Show Search`  \r\n   显示搜索框，全文搜索当前页面载入的代码，用于快速定位到指定的代码片段。如果你不知道某段代码在什么地方，就可以使用它快速查找。搜索的内容可以使用正则表达式以及区分大小写模式。\r\n\r\n   > 在除了 Console 选项卡之外都可以使用 `CS-F` 直接打开\r\n\r\n   ![Drawer Show Search](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190108222409.png)\r\n\r\n2. Debug\r\n   - 预览表达式结果\r\n     当你选中一个表达式后，鼠标悬浮在选中的代码上，Chrome 就会自动计算出表达式的结果，并在鼠标附近显示出来。\r\n     > 注：\r\n     >\r\n     > - 表达式不是代码片段，所以如果选中多段代码是不会得到结果的\r\n     > - 非纯函数，例如使用了 Ajax 请求\r\n   - `Evaluate in console`  \r\n     想要查看某段代码执行的结果，便可以选中这段代码，然后右键选择在控制台中执行它。该功能与上面的预览表达式结果相辅相成。\r\n   - `Conditional breakpoint`  \r\n     条件断点。允许指定某个断点在指定表达式为 `true` 的情况下才停止，便于在循环中使用断点调试某种特殊情况。\r\n   - `Deactivate breakpoints`  \r\n     停用所有的断点。当我们打了一大堆断点之后，想直接看一下效果，又不想把现有的断点删除，就可以暂时停用现有断点，方便查看效果。\r\n\r\n## 使用插件\r\n\r\n自从 Firefox59 以来，随着大量旧体系的插件大量失效，Firefox 的插件库已经不像以往了。如今，Chrome 的插件库是这个星球上最庞大的浏览器插件库了。如果你还没有使用过插件，那恐怕只能使用 Chrome 的一部分功能罢了。\r\n\r\n### 日常使用\r\n\r\n- [AutoPagerize](https://chrome.google.com/webstore/detail/autopagerize/igiofjhpmpihnifddepnpngfjhkfenbp)：自动翻页插件，浏览很多网站时不需要手动点击下一页了，可以自动加载出来下一页的结果。\r\n- [Checker Plus for Gmail™](https://chrome.google.com/webstore/detail/checker-plus-for-gmail/oeopbcgkkoapgobdbedcemjljbihmemj)：对于日常使用 Gmail 的吾辈而言非常有用\r\n- [crxMouse Chrome™ 手势](https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo)：鼠标手势插件，可以使用手势更简单地完成一些事情\r\n- [Dark Reader](https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh)：为所有网站加上黑色主题，大部分情况下都还不错\r\n- [Enhanced Github](https://chrome.google.com/webstore/detail/anlikcnbgdeidpacdbdljnabclhahhmd)：显示 GitHub Repository 大小，允许单独下载每一个文件\r\n- [Enhancer for YouTube™](https://chrome.google.com/webstore/detail/enhancer-for-youtube/ponfpcnoihfmfllpaingbgckeeldkhle)：怎么说呢，Youtube 已经很好了，但吾辈还是觉得需要这个插件来优化播放体验\r\n- [Fatkun 图片批量下载](https://chrome.google.com/webstore/detail/fatkun-batch-download-ima/nnjjahlikiabnchcpehcpkdeckfgnohf)：批量下载网页上的图片，偶尔用一下吧\r\n- [Free Download Manager](https://chrome.google.com/webstore/detail/free-download-manager/ahmpjcflkgiildlgicmcieglgoilbfdp)：FDM Chrome 集成插件，将 Chrome 下载链接使用 FDM 多线程下载\r\n- [GitHub Hovercard](https://chrome.google.com/webstore/detail/github-hovercard/mmoahbbnojgkclgceahhakhnccimnplk)：GitHub 增强插件，鼠标悬浮在仓库链接上面就可以预览\r\n- [Image Search Options](https://chrome.google.com/webstore/detail/image-search-options/kljmejbpilkadikecejccebmccagifhl)：使用右键以图搜图\r\n- [Isometric Contributions](https://chrome.google.com/webstore/detail/isometric-contributions/mjoedlfflcchnleknnceiplgaeoegien)：GitHub 美化插件，将 GitHub 贡献以 3D 的效果显示出来\r\n- [JetBrains IDE Support](https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji)：使用 Chrome 实时显示 IDEA 的 HTML/CSS/JavaScript 文件，与 IDEA 的插件配合使用\r\n- [LastPass: Free Password Manager](https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd)：跨平台的免费密码管理器，有了这个之后再也不用所有网站都使用同一个密码了\r\n- [Mailto: for Gmail™](https://chrome.google.com/webstore/detail/mailto-for-gmail/dgkkmcknielgdhebimdnfahpipajcpjn)：对于 mailto 协议的链接以 Gmail 网页版打开\r\n- [Markdown Here](https://chrome.google.com/webstore/detail/markdown-here/elifhakcjgalahccnjkneoccemfahfoa)：在线将 Markdown 转换为有格式的文档，例如在一个普通的富文本编辑器（不支持 Markdown）中，可以先用 Markdown 语法写内容，然后转换一下就得到了有样式的内容了。\r\n- [Neat URL](https://chrome.google.com/webstore/detail/neat-url/jchobbjgibcahbheicfocecmhocglkco)：移除网址中的无用段，例如返利链接后面的参数\r\n- [Octotree](https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc)：GitHub 代码树状图插件，方便查看项目文件\r\n- [OwO](https://chrome.google.com/webstore/detail/owo/ckfodameiahfhlainaclajkgfagkpodb)：颜文字插件，多亏了这个让吾辈能够愉快的刷推了\r\n- [Proxy SwitchyOmega](https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif)：科学上网必需\r\n- [Stylus](https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne)：使用自定义网站样式的插件，比 Stylish 的名声好一些\r\n- [Tabliss](https://chrome.google.com/webstore/detail/tabliss-a-beautiful-new-t/hipekcciheckooncpjeljhnekcoolahp)：新标签页插件\r\n- [Tampermonkey](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo)：使用自定义网站脚本的插件，可以使用各种 `user.js` 脚本，相当于小型的插件管理器了\r\n- [The Great Suspender](https://chrome.google.com/webstore/detail/the-great-suspender/klbibkeccnjlkjkiokjodocebajanakg)：自动休眠标签页，避免 Chrome 使用的内存太过庞大\r\n- [uBlock Origin](https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm)：日常上网必须，屏蔽各种广告，比 ADBlock 的名声好一些\r\n- [Vue.js devtools](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)：在 DevTool 中添加 VueJS 选项卡，便于对 VueJS 进行调试\r\n- [WebRTC Network Limiter](https://chrome.google.com/webstore/detail/webrtc-network-limiter/npeicpdbkakmehahjeeohfdhnlpdklia)：阻止浏览器通过 WebRTC 泄露 IP 地址\r\n- [WEB 前端助手(FeHelper)](https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad)：貌似是百度的前端插件，但目前还没有什么流氓行为\r\n- [快翻译](https://chrome.google.com/webstore/detail/%E5%BF%AB%E7%BF%BB%E8%AF%91/chpeaiibggkmaongjphijmielpkokcdg)：这个翻译插件是真心不错，某种意义上讲比 Chrome 自带的翻译都要好（#大雾）\r\n- [扩展管理器（Extension Manager）](https://chrome.google.com/webstore/detail/extension-manager/gjldcdngmdknpinoemndlidpcabkggco)：插件很少的时候还好，一多起来还是需要一个插件进行管理，快速启用和禁用一些插件，根据场景切换启用插件列表\r\n\r\n### Stylus\r\n\r\n为网页自定义 CSS 样式，主要用于网站美化，但也可以用于屏蔽网站内容（现在某些网站会检测用户浏览器是否安装了 uBlock Origin 之类的广告过滤插件）。\r\n\r\n例如吾辈就写了一些 css 来提高使用浏览器的体验\r\n\r\n```css\r\n/* 全局字体设置 */\r\n* {\r\n  font-family: 'RTWS YueGothic Trial Regular';\r\n}\r\n\r\n/*滚动条美化*/\r\n::-webkit-scrollbar {\r\n  width: 6px;\r\n  height: 6px;\r\n}\r\n\r\n::-webkit-scrollbar-track-piece {\r\n  background-color: #cccccc;\r\n  -webkit-border-radius: 6px;\r\n}\r\n\r\n::-webkit-scrollbar-thumb:horizontal {\r\n  width: 5px;\r\n  background-color: #cccccc;\r\n  -webkit-border-radius: 6px;\r\n}\r\n\r\n/*滚动条滑块的宽高*/\r\n::-webkit-scrollbar {\r\n  width: 9px;\r\n  height: 9px;\r\n}\r\n\r\n::-webkit-scrollbar-track-piece {\r\n  background-color: transparent;\r\n}\r\n\r\n::-webkit-scrollbar-track-piece:no-button {\r\n}\r\n\r\n::-webkit-scrollbar-thumb {\r\n  background-color: #3994ef;\r\n  border-radius: 3px;\r\n}\r\n\r\n/*滑块的样式*/\r\n::-webkit-scrollbar-thumb:vertical {\r\n  height: 5px;\r\n  background-color: #4afffe;\r\n  -webkit-border-radius: 6px;\r\n}\r\n\r\n/*鼠标悬浮于滑块上*/\r\n::-webkit-scrollbar-thumb:hover {\r\n  background-color: #39ffff;\r\n}\r\n\r\n/*鼠标按下于滑块上*/\r\n::-webkit-scrollbar-thumb:active {\r\n  background-color: #00fffd;\r\n}\r\n\r\n/*纵向滚动条的宽度*/\r\n::-webkit-scrollbar-button:vertical {\r\n  width: 9px;\r\n}\r\n\r\n/*横向滚动条的宽度*/\r\n::-webkit-scrollbar-button:horizontal {\r\n  width: 9px;\r\n}\r\n\r\n/*纵向滚动条的开始按钮（右上角）*/\r\n::-webkit-scrollbar-button:vertical:start:decrement {\r\n  background-color: #00fffd;\r\n}\r\n\r\n/*纵向滚动条的开始按钮（右下角）*/\r\n::-webkit-scrollbar-button:vertical:end:increment {\r\n  background-color: #00fffd;\r\n}\r\n\r\n/*横向滚动条的开始按钮（左下角）*/\r\n::-webkit-scrollbar-button:horizontal:start:decrement {\r\n  background-color: #00fffd;\r\n}\r\n\r\n/*横向滚动条的结束按钮（右下角）*/\r\n::-webkit-scrollbar-button:horizontal:end:increment {\r\n  background-color: #00fffd;\r\n}\r\n\r\nbody::-webkit-scrollbar-track-piece {\r\n  background-color: white;\r\n}\r\n```\r\n\r\n当然，也安装了一些其他人写好的\r\n\r\n- [GitHub Dark](https://userstyles.org/styles/37035/github-dark)：将 GitHub 页面设置为暗色护眼模式\r\n- [A Better Twitter](https://userstyles.org/styles/155039)：删除了 Twitter 上用不到的内容，例如广告，新闻栏\r\n- [Bilibili 屏蔽广告 & 首页去除 舞蹈、生活、时尚、娱乐…… 分类区块](https://userstyles.org/styles/144506/bilibili)：精简 Bilibili，毕竟，现在 B 站无关的内容实在太多了\r\n\r\n### Tampermonkey\r\n\r\n非常强大的一个插件，如果真要展开说明，恐怕又要写一篇博客了。可以将用户自定义的 js 代码 **注入** 到网页中，而这，其实就代表着，任何只要会 JavaScript 的人，都可以在自己浏览器上任意修改网站内容。\r\n\r\n那么，说的好像很厉害的样子，具体能做些什么呢？下面列出吾辈常用的 user.js 脚本\r\n\r\n- [百度网盘导出数据](https://greasyfork.org/zh-CN/scripts/375701)：百度网盘将文件数据导出出来便于二次分析\r\n- [為什麼你們就是不能加個空格呢？](https://greasyfork.org/scripts/2185)：网站本身不加空格吾辈帮它加咯\r\n- [Google Hit Hider by Domain](https://greasyfork.org/scripts/1682)：Google 搜索结果过滤域名\r\n- [网页限制解除](https://greasyfork.org/scripts/41075)：解除网页不能复制/粘贴/右键的问题\r\n- [bilibili merged flv+mp4+ass+enhance](https://greasyfork.org/zh-CN/scripts/372516)：下载 bilibili 上的视频\r\n- [Ci-Aria2 百度云盘增强版](https://greasyfork.org/scripts/40496)：提取百度网盘下载直链\r\n- [网盘自动填写密码](https://greasyfork.org/scripts/29762)：自动填写百度网盘提取密码\r\n- [Booru Downloader + Viewer](https://greasyfork.org/scripts/34175)：图站抓图之用\r\n- [Youtube Download](https://greasyfork.org/zh-CN/scripts/369418)：下载 Youtube 上的视频\r\n\r\n哦，如果你很懒，也可以先去 [Greasy Fork](https://greasyfork.org) 搜索一下是否有你需要的 user.js 脚本。有的话可以直接安装。\r\n\r\n> Greasy Fork 上的脚本全部都是开源的，如果你不信任其他开发者，可以随意对脚本进行检查。\r\n\r\n---\r\n\r\n那么，有关 Chrome 的使用就到这里啦。如果你也知道什么有趣的操作，可以在下方留言告诉吾辈呢\r\n","createdTime":1580652938037,"updatedTime":1608895526181,"resources":[],"tags":[{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"6394b6d9a2ba4be7a17fec38f274a50c","title":"Notion 使用体验","body":"## 场景\r\n\r\n> [官网](http://notion.so)\r\n\r\nNotion 是一个基于 Web 的跨平台笔记工具，在了解过印象笔记、OneNote、为知笔记和有道云笔记之后，吾辈选择了 Notion。\r\n\r\n之所以没有选择上面列出的几个，都有一些原因\r\n\r\n- 印象笔记\r\n  - 不直接支持 Markdown\r\n  - 编辑器体验并不好\r\n  - 不能以目录分割笔记\r\n- OneNote\r\n  - 完全不支持 Markdown\r\n- 为知笔记\r\n  - 国产软件，肯定会上报数据\r\n- 为知笔记\r\n  - 同上\r\n\r\n吾辈的对笔记工具的要求也很简单\r\n\r\n- [ ] 允许在线/本地编辑\r\n- [ ] 本地编辑器体验必须要好\r\n- [ ] 支持 Markdown 语法\r\n- [ ] 搜索速度要快并且支持中文\r\n\r\n很遗憾，虽然吾辈选择了 Notion，并不代表它满足了所有需求，只是目前存在的选择中，最适合吾辈的罢了（搜索速度和中文支持真的很硬伤）。\r\n\r\n## 快捷键\r\n\r\n- `C-B`：将选定文字加粗，或者结束加粗模式\r\n- `C-I`：将选定文字变成斜体，或者结束斜体模式\r\n- `C-E`：将选定区域为行内代码，或者结束行内代码模式\r\n- `S-鼠标滚轮`：水平滚动\r\n- `CS-L`：切换夜间模式\r\n- `C-V + Link`：选中文字粘贴链接，会直接将文字变成可点击链接\r\n- `CS-Up/Down`：将当前行上移/下移\r\n- `S-Enter`：不完成当前区块的情况下换行。类似于 QQ 的回车发送消息，`Shift-Enter` 换行一样。\r\n- `Tab`：缩进一个 Tab\r\n- `S-Tab`：反向缩进一个 Tab\r\n- `/`：可以搜索并使用命令\r\n\r\n## 快捷 Block 片段\r\n\r\n输入后按空格即可生成的特定 Block 的字符\r\n\r\n- `-`：无序列表\r\n- `Number`：有序列表\r\n- `[]`：待办事项列表\r\n- `>`：可折叠层级列表（和 markdown 语义不同了）\r\n- `\"`：引用（这才是 markdown 中 `>` 在 notion 中的关键字）\r\n- <code>\\`\\`</code>：行内代码块\r\n  - 必须在输入第一个 `之后，输入代码，再输入第二个` 才有效\r\n  - 生成行内代码片段后，必须紧跟一个空格，如果输入之后又删除掉，再次输入就会被当成行内代码，这时候使用 `C-E` 可将下一个字符指定为行内代码之外的文本。\r\n- <code>\\`\\`\\`</code>：区域代码块\r\n  - 无法直接指定语言，必须在选择框内选择语言（鼠标）\r\n\r\n## 夜间模式\r\n\r\n通过 `CS-L` 进行切换，也可以在 `Settings & Members` 中找到 `Dark Mode` 这个切换。\r\n\r\n![Notion 夜间模式](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191201224609.png)\r\n\r\n## 缺点\r\n\r\n- 编辑真的很卡！\r\n- 性能不好\r\n  - 大文件\r\n  - 包含图片\r\n  - 导入 markdown\r\n- 粘贴富文本链接存在问题\r\n- 没有列编辑\r\n- 没有 **标签** 的概念，导致分类只能依赖于目录，不能跨目录进行某种关联。例如 **未完成**\r\n- 就单纯的编辑体验上还说不上非常好，至少比起 VSCode 还有一段距离\r\n- 无法深度导出 PDF（需要企业版），导致想要打印资料会很不方便\r\n- bug\r\n\r\n  - 从编辑器之外点击编辑器，第一次并不会获取到焦点，需要点第二次才行（只出现在 Windows 自动分屏）\r\n  - 代码块中同时存在中文和英文时粘贴后只剩中文部分，英文代码不见了\r\n  - 从 VSCode 的 markdown 预览区复制的区域代码块最后总是会多出空行\r\n  - 代码高亮渲染问题，目前 `TypeScript/HTML` 是存在问题的\r\n\r\n    ```ts\r\n    // 一个用于解构 Promise 中的泛型类\r\n    type PromiseDeconstruct<T extends Promise<any>> = T extends Promise<infer R>\r\n      ? R\r\n      : never\r\n    const res = Promise.resolve(1)\r\n    const i: PromiseDeconstruct<typeof res> = 1\r\n    ```\r\n\r\n## 感受\r\n\r\n笔记适合作为整理资料的方式，而作为写作工具的话体验却是还差了点。\r\n","createdTime":1580652938025,"updatedTime":1608895522238,"resources":[],"tags":[{"id":"95ddbbd925aa4358a46bfcbce4c3fb46","title":"工具","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"027417d00f58478d944cc98ba412d801","title":"JetBrains 1024 程序员节优惠活动","body":"## 简介\r\n\r\n一年一次的 JetBrains 优惠活动，这次是买一赠一！\r\n\r\n> 注: 活动截止 10/31\r\n\r\n![image.png](https://i.loli.net/2019/10/24/b5AgNHKUhFmZ3xz.png)\r\n![image.png](https://i.loli.net/2019/10/24/DVdJPEtZjwpQbiG.png)\r\n\r\n## 说明\r\n\r\n该次活动老用户无法直接输入优惠码购买，必须提交请求后等待销售代表回复专属购买链接。（老用户没人权系列 QAQ）\r\n\r\n![image.png](https://i.loli.net/2019/10/24/gAKEG28p5erO4iM.png)\r\n\r\n然后，果然手动化操作忙不过来了 23333\r\n![官方邮件](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191026114627.png)\r\n\r\n重要的是，这个优惠码貌似可以针对任意产品，包括全家桶那个 \\$249 的那个也能免费 0 折一年！官方也太实诚了吧 emmmmm\r\n![优惠码使用](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191026115028.png)\r\n\r\n## 链接\r\n\r\n> [1024 程序员节 IDE++ 快乐翻倍！](https://www.jetbrains.com/zh-cn/lp/programmers-day/?tdsourcetag=s_pcqq_aiomsg)\r\n","createdTime":1580652938008,"updatedTime":1608895487354,"resources":[],"tags":[{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"5752c36bb78943c595db73065c564f72","title":"IntelliJ 开发者之夜@深圳之行","body":"## 起因\r\n\r\n最早，吾辈是在 [活动行](http://www.huodongxing.com/event/6459475264900) 上面看到这个活动的，然后果断报名参加了。\r\n![参与通知](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181113012304.png)\r\n\r\n即便，吾辈本身并不住在深圳，但还是选择坐高铁赶过去了。  \r\n![好吧，其实这张图是坐车回来的图片](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181113012102.png)\r\n\r\n## 活动\r\n\r\n吾辈去的比较早，接近四点钟左右到了，但那个时候活动并没有开始，也没有看到活动标识。于是，吾辈和朋友便先去咖啡厅坐了一会，然后在大约六点钟的时候到达了活动现场。嗯，还拿到了一些小礼物。  \r\n![小礼物](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181113014204.png)\r\n\r\n> 产品全系列五折优惠真的很良心了！\r\n\r\n![会场演讲](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181113012612.png)\r\n\r\n其实活动只有是三个主题\r\n\r\n- [IntelliJ IDEA](https://www.jetbrains.com/idea/) 的使用技巧及新特性讲解\r\n- [TeamCity](https://www.jetbrains.com/teamcity/) 持续集成工具讲解\r\n- [Kotlin](https://kotlinlang.org/) 语言特性讲解\r\n\r\n在讲完 TeamCity 之后其实有个茶歇时间的，这里吾辈拍了一张会场入口的活动海报  \r\n![幕间休息](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181113012530.png)\r\n\r\n## 感想\r\n\r\n虽然 dalao 们都是用英语进行口语交流，吾辈只能听懂七七八八，但参加活动还是感到很高兴。讲真只有在第一个主题吾辈基本能够听懂/参与的，毕竟 IDEA 用了好久。第二个主题的 TeamCity 表示没用过不明觉厉。Kotlin 虽然吾辈也没有用过，但看起来与 Scala 非常相像（语法糖真的太多了！），感觉还是很不错的！\r\n\r\n嘛，希望以后有更多的机会参加 IDEA 举办的活动就是了呢 o((\\*^▽^\\*))o\r\n","createdTime":1580652938006,"updatedTime":1608895471237,"resources":[],"tags":[{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""},{"id":"f5172282f275485bab67f712ba1b1bcf","title":"个人","parent_id":""}]},{"id":"a0b9c67c7c9c460ea59c12603f390f2d","title":"IDEA 激活","body":"## 使用本地注册码（不需要在线）的方式激活\r\n\r\n> 注: 此方法对 IDEA 2018.01-2018.02 版本无效，但对 IDEA 2018.03 EAP 是有效的\r\n\r\n1. 修改 **hosts** 文件，Windows 系统上的位置是 **C:\\Windows\\System32\\drivers\\etc\\hosts**，将之复制到其他位置并在文件的最末尾添加一句话。\r\n\r\n   ```hosts\r\n   0.0.0.0 account.jetbrains.com\r\n   ```\r\n\r\n   然后将 **hosts** 文件复制到原本的位置覆盖一下就好。\r\n\r\n   > 注：该操作是必要的，因为不修改 **hosts** 文件的话获得的激活码是会直接提示非法的！\r\n\r\n2. 在 <http://idea.iteblog.com/> 获得到一个注册码（用户名和 PC 用户名保持一致），将注册码用于激活 IDEA 即可。\r\n\r\n## 使用本地 Jar 文件\r\n\r\n> 注：该方法适用于 IDEA 2018.01-2018.02，在 IDEA 2018.03 已经失效\r\n\r\n1. 下载破解 Jar：[JetbrainsCrack](https://raw.githubusercontent.com/rxliuli/blog_binary_file/master/JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar)\r\n\r\n   然后放到一个合适的位置（你不会随意删除的位置，推荐直接放到 IDEA 的安装目录下）\r\n\r\n2. 修改 IDEA 的一个配置文件（位置在 `${idea.home}/bin/idea64.exe.vmoptions`），在最后一行添加：`-javaagent:这里是你上面下载的那个 Jar 的绝对路径`\r\n\r\n   然后在激活对话框中选 **Activation code** 随意输入然后点击 OK 即可。\r\n\r\n3. Pass：其实下面还有一步的，不过做不做都可以，运行上面的就已经完成激活了，不过激活信息显示的不是你的名字。当然，我们可以去变成自己的名字，如果我们在 **Activation code** 里填写合适的 `json` 信息的话。\r\n\r\n   1. 首先运行刚才下载的 Jar，然后会得到一个激活信息的 `json` 字符串，大致是下面这样：\r\n\r\n      ```json\r\n      {\r\n        \"licenseId\": \"ThisCrackLicenseId\",\r\n        \"licenseeName\": \"Rover12421\",\r\n        \"assigneeName\": \"Rover12421\",\r\n        \"assigneeEmail\": \"rover12421@163.com\",\r\n        \"licenseRestriction\": \"By Rover12421 Crack, Only Test! Please support genuine!!!\",\r\n        \"checkConcurrentUse\": false,\r\n        \"products\": [\r\n          { \"code\": \"II\", \"paidUpTo\": \"2099-12-31\" },\r\n          { \"code\": \"DM\", \"paidUpTo\": \"2099-12-31\" },\r\n          { \"code\": \"AC\", \"paidUpTo\": \"2099-12-31\" },\r\n          { \"code\": \"RS0\", \"paidUpTo\": \"2099-12-31\" },\r\n          { \"code\": \"WS\", \"paidUpTo\": \"2099-12-31\" },\r\n          { \"code\": \"DPN\", \"paidUpTo\": \"2099-12-31\" },\r\n          { \"code\": \"RC\", \"paidUpTo\": \"2099-12-31\" },\r\n          { \"code\": \"PS\", \"paidUpTo\": \"2099-12-31\" },\r\n          { \"code\": \"DC\", \"paidUpTo\": \"2099-12-31\" },\r\n          { \"code\": \"RM\", \"paidUpTo\": \"2099-12-31\" },\r\n          { \"code\": \"CL\", \"paidUpTo\": \"2099-12-31\" },\r\n          { \"code\": \"PC\", \"paidUpTo\": \"2099-12-31\" },\r\n          { \"code\": \"DB\", \"paidUpTo\": \"2099-12-31\" },\r\n          { \"code\": \"GO\", \"paidUpTo\": \"2099-12-31\" },\r\n          { \"code\": \"RD\", \"paidUpTo\": \"2099-12-31\" }\r\n        ],\r\n        \"hash\": \"2911276/0\",\r\n        \"gracePeriodDays\": 7,\r\n        \"autoProlongated\": false\r\n      }\r\n      ```\r\n\r\n   2. 修改其中的 `licenseeName`, `assigneeName`, `assigneeEmail` 为你的名字和邮箱，然后将修改后的 `json` 字符串丢到 **Activation code** 里面就好啦\r\n\r\n## IDEA 激活服务器\r\n\r\n> 注: 此方法随时可能失效\r\n\r\n- 激活服务器：<http://idea.imsxm.com/>，<http://idea.uri.ci>\r\n- 如果无法激活，请前往 [网站](http://idea.imsxm.com/) 查找方法。如有能力，请支持正版！\r\n\r\n使用方法\r\n\r\n- 在 idea 首次使用时会要求输入注册码，选择第三个选项卡，即 **License Server**,然后填入上面的激活服务器即可。\r\n- 进入 idea 后，选择 Help->Register,就会弹出一个输入注册码的窗口了，以上面那种方法输入就行啦。\r\n","createdTime":1580652937997,"updatedTime":1608895421183,"resources":[],"tags":[{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"7f1dee8cb55d4d578b1e677d2327adec","title":"react 入坑思考","body":"## 场景\r\n\r\n吾辈为什么要学 `react` 呢？难道 `HTML+CSS+JavaScript` 已经满足不了了？是的，传统前端确实满足不了吾辈了，前端在快速发展，而后端手中（甚至眼中）的前端仍然是只有 `HTML+CSS+JavaScript+JQuery` 的世界。吾辈不想就这样下去，所以想要了解、学习、使用现代前端的内容。\r\n谜之音：难道 `vuejs` 还不够么？\r\n`vuejs` 既是国产（阿里），所以文档（中文）相对而言应该是最好的。而且相比于 `react`，`vuejs` 的门槛相对而言还是比较低的。至少，不用一开始就接触 `webpack`（天坑），在不用 `webpack` 的情况下使用 `react` 将是很困难的。\r\n或许有人说，`react` 不是有 `create-react-app` 可以快速创建 `web app` 么？然而使用 `create-react-app` 之后，一大波僵尸（概念）将会袭来。\r\n\r\n## 对白\r\n\r\n让我们先来看一段对白\r\n\r\n问：`react` 好像不推荐在浏览器中直接使用 `<script>` 标签引入呢？\r\n答：是呀，你需要 `npm/yarn` 这类工具呢\r\n问：`npm` 是什么？\r\n答：`npm` 能帮助我们管理依赖的库 只要 `install` 一下就可以啦\r\n问：那么安装的包要怎么引用呢？\r\n答：你需要用 `commonjs/es2016` 之类的方式引入呢？\r\n问：等等，`commonjs`？`es2016`？这都是什么呀？\r\n答：哦，这是一种 js 模块化的规范而已，我们只要知道 `import` 和 `export` 就好啦？\r\n问：嗯，那么我应该在哪里写 `HTML`？\r\n答：不不不，`react` 里面没有 `HTML`，只有 `jsx`。\r\n问：OMG，`jsx` 又是什么？\r\n答：一种 `js + xml` 的 `dsl`，语法上很像 `HTML`，no problem！\r\n问：那写完的的 `jsx` 组件怎么在浏览器中查看啊？\r\n答：你需要使用打包工具，例如 `webpack`，将 `jsx` 打包成 `HTML+JavaScript` 才行\r\n问：额，不是没有 `HTML` 了么？\r\n答：写的时候没有，但浏览器只认识 `HTML/CSS/JavaScript`，所以最终还是要变成这些才行呀\r\n问：嗯，那么 `webpack` 是什么呢？\r\n答：现代前端的一个打包工具\r\n问：好的，那我去看看文档\r\n一段时间后。。。\r\n问：我看了 `webpack` 官网的文档，但还是不明白应该怎么打包\r\n答：额，不行的话就用 `create-react-app` 吧。它会自动帮你生成一个完整配置的项目的，你只要懂得配置的意思并且会修改就好了。\r\n问：于是，我开始了愉快的 `react` 之旅。。。个鬼呀！**idea** 怎么没提示？\r\n答：额，你需要插件，不过更推荐 **vscode**，毕竟已经是事实上的前端标准编辑器了。\r\n问：也就是说，我又要用一个新的 `IDE` 了？\r\n答：不是啦，**vscode** 只是一个编辑器，比 **idea** 轻量太多了。而且，**vscode** 对前端生态支持很好哦\r\n一段时间后。。。\r\n问：我写了几个组件，但不知道应该怎么控制页面跳转？我好像并不能在后端映射到组件呀\r\n答：`react` 需要使用 `react router` 之类的前端路由，现在前端的跳转由前端来控制就好了\r\n问：所以说，不能使用 `java` 来控制么？≥﹏≤\r\n答：额，可能真不行，为什么不用 `react router` 呢？\r\n问：好吧，我先去看看。。。\r\n问：唉，组件之间的交互好麻烦呀，每次都要依赖传递 `props` 啊\r\n答：哦，你可以尝试一下状态管理。例如 `redux`\r\n问：`redux`？那是什么？\r\n答：`react` 中的一个状态管理，可以不用一层层的传递 `props` 了呢\r\n问：听起来很不错，我现在就去看一下！\r\n问：两天后，woc，`redux` 去死吧？就想改个状态怎么这么麻烦，而且异步那里什么鬼？(ノ =Д=) ノ ┻━┻\r\n答：看来你不适合 `react`，或许你可以看看 `vuejs`，更简单一点。国产，中文文档齐全，门槛很低的呢！\r\n\r\n诚然，以上的问题不一定是指 `react` 本身，但依赖于如此之多的工具，本就造成了 `react` 的复杂性。\r\n\r\n## 思考\r\n\r\n看完以上对话，或许吾辈看起来很讨厌 `react` 的样子？\r\n事实上，吾辈第一次学习现代前端的时候，就是从 `react` 开始的，然后基本上就像上面的对话所述，直接败退了，然后滚去学了一段时间的 `vuejs`。\r\n然而，直到最近，吾辈发现 `vuejs` 的生态实在太小了。最开始吾辈就了解过这两个框架，也知道 `vuejs` 的生态很小，然而确实没想到会这么小。。。\r\n深层次来讲，`vuejs` 毕竟是国产，毕竟是阿里，所以还是慎用。想想 **Dubbo 放弃维护** 和 **Ant Design 圣诞彩蛋**，一切皆是不言自明的！\r\n\r\n现在再看 `react`，感觉简单了一些。一方面，由于 `vuejs` 的原因，接触到了 `es6/npm/yarn/webpack/babel/vscode` 这些前端工具链，对现代前端有了基本的概念与认知。不再因为某些代码看不懂而卡住，也不会面对各种工具一脸懵逼了。\r\n","createdTime":1580652937904,"updatedTime":1608895093473,"resources":[],"tags":[{"id":"5a7776c036cf46738cb6a729934a1a7b","title":"react","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"35841f3c9ebe46aa9c589a92ff9558a7","title":"浅谈 Vue SPA 网站 URL 保存数据实践","body":"## 场景\r\n\r\n> 该功能吾辈已经封装成 NPM 库 [vue-url-persist](https://www.npmjs.com/package/vue-url-persist)\r\n\r\n在使用 Vue SPA 开发面向普通用户的网站时，吾辈也遇到了一些之前未被重视，但却实实在在存在的问题，这次便浅谈一下 SPA 网站将所有数据都存储到内存中导致数据很容易丢失以及吾辈思考并尝试的解决方案。\r\n\r\n> 参考：SPA 全称 `single page application`，意为 [单页应用](https://zh.wikipedia.org/wiki/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8)，不是泥萌想的那样！#笑哭\r\n\r\n思维导图\r\n\r\n<iframe id=\"embed_dom\" name=\"embed_dom\" frameborder=\"0\" style=\"display:block;width:525px; height:245px;\" src=\"https://www.processon.com/embed/5e1e5d93e4b0c3908f881d64\"></iframe>\r\n\r\n首先列出为什么遇到这个问题，具体场景及解决的问题是什么？\r\n\r\n想要解决的一些问题\r\n\r\n1. 刷新页面数据不丢失：因为数据都保存在内存中，所以刷新之后自然不存在了\r\n2. URL 复制给其他人数据不丢失：因为数据没有持久化到 URL 上，也没有根据 URL 上的数据进行初始化，所以复制给别人的 URL 当然会丢失数据（搜索条件之类）\r\n3. 页面返回数据不丢失：因为数据都保存在内存中，所以跳转到其他路由再跳转回来数据当然不会存在了\r\n\r\n那么，先谈一下每个问题的解决方案\r\n\r\n1. 刷新页面数据不丢失\r\n   - 将数据序列化到本地，例如 `localStorage` 中，然后在刷新后获取一次\r\n     - 注：这方面已经有先行者了，例如 [vuex-persist](https://www.npmjs.com/package/vuex-persist) 和 [vuex-persistedstate](https://github.com/robinvdvleuten/vuex-persistedstate)\r\n   - 将数据序列化到 URL 上，每次加载都从 URL 上获取数据\r\n2. URL 复制给其他人数据不丢失\r\n   - 只能将数据序列化到 URL 上\r\n3. 页面返回数据不丢失\r\n   - 将数据放到 vuex 中，并且在 URL 上使用 `key` 进行标识\r\n     - 注：这方面已经有先行者了，例如 [vue-navigation](https://www.npmjs.com/package/vue-navigation) 和 [vuex-router-sync](https://github.com/vuejs/vuex-router-sync)\r\n   - 将数据序列化到 URL 上，并且不新增路由记录\r\n   - 使用 vue-router 的缓存 `keep-alive`\r\n\r\n在了解了这么多的解决方案之后，吾辈最终选择了兼容性最好的 URL 保存数据，它能同时解决 3 个问题。然而，很遗憾的是，这似乎并没有很多人讨论这个问题，或许，这个问题本应该是默认就需要解决的，亦或是 SPA 网站真的很少关心这些了。\r\n\r\n> 虽说如此，吾辈还是找到了一些讨论的 [StackOverflow: How to hold URL query params in Vue with Vue-Router](https://stackoverflow.com/questions/42226479)\r\n\r\n## 思路\r\n\r\n一个基本的思路是能够确定的\r\n\r\n1. 在组件创建时，从 URL 获取数据并为需要的数据进行初始化\r\n2. 在这些数据变化时，及时将数据序列化到 URL 上\r\n\r\n![思路图](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200105012847.png)\r\n\r\n然后，再次出现了一个分歧点，到底要不要绑定 Vue？\r\n\r\n1. 不绑定 vue 手动监听对象变化并将对象的变化响应到 URL 上\r\n   ![不绑定 vue](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200105012848.png)\r\n2. 绑定 vue 并使用它的生命周期 `created, beforeRouteUpdate` 与监听器 `watch`\r\n   ![绑定 vue](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200105012846.png)\r\n\r\n那么，两者有什么区别呢？\r\n\r\n| 思路 | 不绑定 vue                                                          | 绑定 vue                                                                       |\r\n| ---- | ------------------------------------------------------------------- | ------------------------------------------------------------------------------ |\r\n| 优点 | 非框架强相关，理论上可以通用 `Vue/React`                            | 不需要手动实现 URL 的几种序列化模式，可以预见至少有两种：`HTML 5 History/Hash` |\r\n|      | 没有 vue/vue-router 的历史包袱                                      | 不需要手动实现数据监听/响应（虽然现在已然不算难了）                            |\r\n|      | 可以不管 vue-router 实现 URL 动态设置，可以自动优雅降级             | 灵活性很强，实现比较好的封装之后使用成本很低                                   |\r\n| 缺点 | 没有包袱，但同时没有基础，序列化/数据监听都需要手动实现             | 存在历史包袱，vue/vue-router 的怪癖一点都绕不过去                              |\r\n|      | 灵活性不足，只能初始化一次，需要/不需要序列化的数据分割也相当有挑战 | 依赖 vue/vue-router，在其更新之时也必须跟着更新                                |\r\n|      | 不绑定 vue 意味着与 vue 不可能完美契合                              | 无法通用，在任何一个其他框架（React）上还要再写一套                            |\r\n\r\n最终，在这个十字路口反复踌躇之后，吾辈选择了更加灵活、成本更低的第二种解决方案。\r\n\r\n## 问题\r\n\r\n### 已解决\r\n\r\n- 序列化数据到 URL 上导致路由记录会随着改变增加\r\n- 即时序列化数据到 URL 上不现实\r\n  > 这里吾辈对 [yarn](https://yarnpkg.com/) 进行了考察发现其也是异步更新 URL\r\n- 序列化到 URL 上时导致的死循环，`序列化数据到 URL 上 => 路由更新触发 => 初始化数据到 URL 上 => 触发数据改变 => 序列化数据到 URL 上。。。`\r\n- 同一个路由携带不同的查询参数的 URL 直接在地址栏输入回车一次不会触发页面数据更新\r\n- URL 最大保存数据 IE 最多支持 `2083` 长度的 URL，换算为中文即为 `231` 个，所以不能作为一种通用方式进行\r\n- Vue 插件不能动态混入，而是在各个生命周期中判断是否要处理的\r\n\r\n### 仍遗留\r\n\r\n- JSON 序列化的数据长度较 query param 更大\r\n\r\n> 下面是具体实现及代码，不喜欢的话可以直接跳到最下面的 [总结](#总结)。\r\n\r\n## 实现\r\n\r\n> [GitHub](https://github.com/rxliuli/example/tree/linter_vue_example/vue_url_persist_vue_example)\r\n\r\n### 基本尝试\r\n\r\n首先，尝试不使用任何封装，直接在 `created` 生命周期中初始化并绑定 `$watch`\r\n\r\n```js\r\n<template>\r\n  <div class=\"form1\">\r\n    <div>\r\n      <label for=\"keyword\">搜索名:</label>\r\n      <input type=\"text\" v-model=\"form.keyword\" id=\"keyword\" />\r\n    </div>\r\n    <div>\r\n      <input\r\n        type=\"checkbox\"\r\n        v-model=\"form.hobbyList\"\r\n        id=\"anime\"\r\n        value=\"anime\"\r\n      />\r\n      <label for=\"anime\">动画</label>\r\n      <input type=\"checkbox\" v-model=\"form.hobbyList\" id=\"game\" value=\"game\" />\r\n      <label for=\"game\">游戏</label>\r\n      <input\r\n        type=\"checkbox\"\r\n        v-model=\"form.hobbyList\"\r\n        id=\"movie\"\r\n        value=\"movie\"\r\n      />\r\n      <label for=\"movie\">电影</label>\r\n    </div>\r\n    <p>\r\n      {{ form }}\r\n    </p>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'Form1',\r\n  data() {\r\n    return {\r\n      form: {\r\n        keyword: '',\r\n        hobbyList: [],\r\n      },\r\n    }\r\n  },\r\n  created() {\r\n    const key = 'qb'\r\n    const urlData = JSON.parse(this.$route.query[key] || '{}')\r\n    Object.assign(this.form, urlData.form)\r\n    this.$watch(\r\n      'form',\r\n      function(val) {\r\n        urlData.form = val\r\n        this.$router.replace({\r\n          query: {\r\n            ...this.$route.query,\r\n            [key]: JSON.stringify(urlData),\r\n          },\r\n        })\r\n      },\r\n      {\r\n        deep: true,\r\n      },\r\n    )\r\n  },\r\n}\r\n</script>\r\n```\r\n\r\n### 分离通用性函数\r\n\r\n然后，便是将之分离为单独的函数，方便在所有组件中进行复用\r\n\r\n```js\r\n/**\r\n * 初始化一些数据需要序列化/反序列化到 url data 上\r\n * @param exps 监视的数据的表达式数组\r\n */\r\nfunction initUrlData(exps) {\r\n  const key = 'qb'\r\n  const urlData = JSON.parse(this.$route.query[key] || '{}')\r\n  exps.forEach((exp) => {\r\n    Object.assign(this[exp], urlData[exp])\r\n    this.$watch(\r\n      exp,\r\n      function (val) {\r\n        urlData[exp] = val\r\n        this.$router.replace({\r\n          query: {\r\n            ...this.$route.query,\r\n            [key]: JSON.stringify(urlData),\r\n          },\r\n        })\r\n      },\r\n      {\r\n        deep: true,\r\n      },\r\n    )\r\n  })\r\n}\r\n```\r\n\r\n使用起来需要在 `created` 生命中调用\r\n\r\n```js\r\nexport default {\r\n  created() {\r\n    initUrlData.call(this, ['form'])\r\n  },\r\n}\r\n```\r\n\r\n### 处理深层监听\r\n\r\n如果需要监听的值不是 data 下的顶级字段，而是深层字段的话，便不能直接使用 `[]` 进行取值和赋值了，而是需要实现支持深层取值/赋值的 `get/set`。而且，深层监听也意味着一般不会是对象，所以也不能采用 `Object.assign` 进行合并。\r\n\r\n例如需要监听 `page` 对象中的 `offset, size` 两字段\r\n\r\n首先，需要编写通用的 `get/set` 函数\r\n\r\n```js\r\n/**\r\n * 解析字段字符串为数组\r\n * @param str 字段字符串\r\n * @returns 字符串数组，数组的 `[]` 取法会被解析为数组的一个元素\r\n */\r\nfunction parseFieldStr(str) {\r\n  return str\r\n    .split(/[\\\\.\\\\[]/)\r\n    .map((k) => (/\\]$/.test(k) ? k.slice(0, k.length - 1) : k))\r\n}\r\n\r\n/**\r\n * 安全的深度获取对象的字段\r\n * 注: 只要获取字段的值为 {@type null|undefined}，就会直接返回 {@param defVal}\r\n * 类似于 ES2019 的可选调用链特性: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/%E5%8F%AF%E9%80%89%E9%93%BE\r\n * @param obj 获取的对象\r\n * @param fields 字段字符串或数组\r\n * @param [defVal] 取不到值时的默认值，默认为 null\r\n */\r\nexport function get(obj, fields, defVal = null) {\r\n  if (typeof fields === 'string') {\r\n    fields = parseFieldStr(fields)\r\n  }\r\n  let res = obj\r\n  for (const field of fields) {\r\n    try {\r\n      res = Reflect.get(res, field)\r\n      if (res === undefined || res === null) {\r\n        return defVal\r\n      }\r\n    } catch (e) {\r\n      return defVal\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\n/**\r\n * 安全的深度设置对象的字段\r\n * 注: 只要设置字段的值为 {@type null|undefined}，就会直接返回 {@param defVal}\r\n * 类似于 ES2019 的可选调用链特性: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/%E5%8F%AF%E9%80%89%E9%93%BE\r\n * @param obj 设置的对象\r\n * @param fields 字段字符串或数组\r\n * @param [val] 设置字段的值\r\n */\r\nexport function set(obj, fields, val) {\r\n  if (typeof fields === 'string') {\r\n    fields = parseFieldStr(fields)\r\n  }\r\n  let res = obj\r\n  for (let i = 0, len = fields.length; i < len; i++) {\r\n    const field = fields[i]\r\n    console.log(i, res, field, res[field])\r\n    if (i === len - 1) {\r\n      res[field] = val\r\n      return true\r\n    }\r\n    res = res[field]\r\n    console.log('res: ', res)\r\n    if (typeof res !== 'object') {\r\n      return false\r\n    }\r\n  }\r\n  return false\r\n}\r\n```\r\n\r\n然后，是替换赋值操作，将之修改为一个专门的函数\r\n\r\n```js\r\n/**\r\n * 为 vue 实例上的字段进行深度赋值\r\n */\r\nfunction setInitData(vm, exp, urlData) {\r\n  const oldVal = get(vm, exp, null)\r\n  const newVal = urlData[exp]\r\n  if (typeof oldVal === 'object' && newVal !== undefined) {\r\n    Object.assign(get(vm, exp), newVal)\r\n  } else {\r\n    set(vm, exp, newVal)\r\n  }\r\n}\r\n\r\n/**\r\n * 初始化一些数据需要序列化/反序列化到 url data 上\r\n * @param exps 监视的数据的表达式数组\r\n */\r\nfunction initUrlData(exps) {\r\n  const key = 'qb'\r\n  const urlData = JSON.parse(this.$route.query[key] || '{}')\r\n  exps.forEach((exp) => {\r\n    setInitData(this, exp, urlData)\r\n    this.$watch(\r\n      exp,\r\n      function (val) {\r\n        urlData[exp] = val\r\n        this.$router.replace({\r\n          query: {\r\n            ...this.$route.query,\r\n            [key]: JSON.stringify(urlData),\r\n          },\r\n        })\r\n      },\r\n      {\r\n        deep: true,\r\n      },\r\n    )\r\n  })\r\n}\r\n```\r\n\r\n这样，便能单独监听对象中的某个字段了。\r\n\r\n```js\r\ninitUrlData.call(this, ['form.keyword'])\r\n```\r\n\r\n> 参考：lodash 的函数 [get](https://lodash.com/docs/4.17.15#get)/[set](https://lodash.com/docs/4.17.15#set)\r\n\r\n### 使用防抖避免触发过快\r\n\r\n但目前而言每次同步都是即时的，在数据量较大时，可能会存在一些问题，所以使用防抖避免每次数据更新都即时同步到 URL 上。\r\n\r\n首先，实现一个简单的防抖函数\r\n\r\n```js\r\n/**\r\n * 函数去抖\r\n * 去抖 (debounce) 去抖就是对于一定时间段的连续的函数调用，只让其执行一次\r\n * 注: 包装后的函数如果两次操作间隔小于 delay 则不会被执行, 如果一直在操作就会一直不执行, 直到操作停止的时间大于 delay 最小间隔时间才会执行一次, 不管任何时间调用都需要停止操作等待最小延迟时间\r\n * 应用场景主要在那些连续的操作, 例如页面滚动监听, 包装后的函数只会执行最后一次\r\n * 注: 该函数第一次调用一定不会执行，第一次一定拿不到缓存值，后面的连续调用都会拿到上一次的缓存值。如果需要在第一次调用获取到的缓存值，则需要传入第三个参数 {@param init}，默认为 {@code undefined} 的可选参数\r\n * 注: 返回函数结果的高阶函数需要使用 {@see Proxy} 实现，以避免原函数原型链上的信息丢失\r\n *\r\n * @param action 真正需要执行的操作\r\n * @param delay 最小延迟时间，单位为 ms\r\n * @param init 初始的缓存值，不填默认为 {@see undefined}\r\n * @return function(...[*]=): Promise<any> {@see action} 是否异步没有太大关联\r\n */\r\nexport function debounce(action, delay, init = null) {\r\n  let flag\r\n  let result = init\r\n  return function (...args) {\r\n    return new Promise((resolve) => {\r\n      if (flag) clearTimeout(flag)\r\n      flag = setTimeout(\r\n        () => resolve((result = action.apply(this, args))),\r\n        delay,\r\n      )\r\n      setTimeout(() => resolve(result), delay)\r\n    })\r\n  }\r\n}\r\n```\r\n\r\n将 `$watch` 中的函数用 `debounce` 进行包装\r\n\r\n```js\r\n/**\r\n * 初始化一些数据需要序列化/反序列化到 url data 上\r\n * @param exps 监视的数据的表达式数组\r\n */\r\nfunction initUrlData(exps) {\r\n  const key = 'qb'\r\n  const urlData = JSON.parse(this.$route.query[key] || '{}')\r\n  exps.forEach((exp) => {\r\n    setInitData(this, exp, urlData)\r\n    this.$watch(\r\n      exp,\r\n      debounce(function (val) {\r\n        urlData[exp] = val\r\n        this.$router.replace({\r\n          query: {\r\n            ...this.$route.query,\r\n            [key]: JSON.stringify(urlData),\r\n          },\r\n        })\r\n      }, 1000),\r\n      {\r\n        deep: true,\r\n      },\r\n    )\r\n  })\r\n}\r\n```\r\n\r\n> 引用：[掘金：7 分钟理解 JS 的节流、防抖及使用场景](https://juejin.im/post/5b8de829f265da43623c4261)\r\n> 参考：lodash 的函数 [debounce](https://lodash.com/docs/4.17.15#debounce)\r\n\r\n### 处理路由不变但 query 修改的问题\r\n\r\n接下来，就需要处理一种小众，但确实存在的场景了。\r\n\r\n- 同一个组件被多个路由复用，这些路由仅仅只是一个 path param 改变了。例如 [标签页](https://ant.design/components/tabs-cn/)\r\n- 用户复制 URL 之后，发现其中的查询关键字错了，于是修改了关键字之后又复制了一次，而粘贴两次路由相同 query param 不同的 URL 是不会重新创建组件的\r\n\r\n首先确定基本的思路：在路由改变但组件没有重新创建时将 URL 上的数据为需要的数据进行初始化\r\n\r\n```js\r\n/**\r\n * 在组件被 vue-router 路由复用时，单独进行初始化数据\r\n * @param exps 监视的数据的表达式数组\r\n * @param route 将要改变的路由对象\r\n */\r\nfunction initUrlDataByRouteUpdate(exps, route) {\r\n  const urlData = JSON.parse(route.query[key] || '{}')\r\n  exps.forEach((exp) => {\r\n    setInitData(this, exp, urlData)\r\n  })\r\n}\r\n```\r\n\r\n在 vue 实例的生命周期 `beforeRouteUpdate, beforeRouteEnter` 重新初始化 `data` 中的数据\r\n\r\n```js\r\nexport default {\r\n  beforeRouteUpdate(to, from, next) {\r\n    initUrlDataByRouteUpdate.call(this, ['form'], to)\r\n    next()\r\n  },\r\n  beforeRouteEnter(to, from, next) {\r\n    next((vm) => initUrlDataByRouteUpdate.call(vm, ['form'], to))\r\n  },\r\n}\r\n```\r\n\r\n真的以为问题都解决了么？并不然，打开控制台你会发现一些 vue router 的警告\r\n\r\n```sh\r\nvue-router.esm.js?8c4f:2051 Uncaught (in promise) NavigationDuplicated {_name: \"NavigationDuplicated\", name: \"NavigationDuplicated\", message: \"Navigating to current location (\"/form1/?qb=%7B%22…,%22movie%22,%22game%22%5D%7D%7D\") is not allowed\", stack: \"Error↵    at new NavigationDuplicated (webpack-int…/views/Form1.vue?vue&type=script&lang=js&:222:40)\"}\r\n```\r\n\r\n其实是因为循环触发导致的：`序列化数据到 URL 上 => 路由更新触发 => 初始化数据到 URL 上 => 触发数据改变 => 序列化数据到 URL 上。。。`，目前可行的解决方案是在 `$watch` 中判断数据是否与原来的相同，相同就不进行赋值，避免再次触发 vue-router 的 `beforeRouteUpdate` 生命周期。\r\n\r\n```js\r\n/**\r\n * 初始化一些数据需要序列化/反序列化到 url data 上\r\n * @param exps 监视的数据的表达式数组\r\n */\r\nfunction initUrlData(exps) {\r\n  const urlData = JSON.parse(this.$route.query[key] || '{}')\r\n  exps.forEach((exp) => {\r\n    setInitData(this, exp, urlData)\r\n    this.$watch(\r\n      exp,\r\n      debounce(function (val) {\r\n        urlData[exp] = val\r\n        if (this.$route.query[key] === JSON.stringify(urlData)) {\r\n          return\r\n        }\r\n        this.$router.replace({\r\n          query: {\r\n            ...this.$route.query,\r\n            [key]: JSON.stringify(urlData),\r\n          },\r\n        })\r\n      }, 1000),\r\n      {\r\n        deep: true,\r\n      },\r\n    )\r\n  })\r\n}\r\n```\r\n\r\n现在，控制台不会再有警告了。\r\n\r\n### 封装起来\r\n\r\n#### 使用 Vue 插件\r\n\r\n```js\r\nimport { debounce, get, set } from './common'\r\n\r\nclass VueUrlPersist {\r\n  /**\r\n   * 一些选项\r\n   */\r\n  constructor() {\r\n    this.expListName = 'exps'\r\n    this.urlPersistName = 'qb'\r\n  }\r\n\r\n  /**\r\n   * 将 URL 上的数据初始化到 data 上\r\n   * 此处存在一个谬误\r\n   * 1. 如果对象不使用合并而是赋值，则处理 [干净] 的 URL 就会很棘手，因为无法感知到初始值是什么\r\n   * 2. 如果对象使用合并，则手动输入的相同路由不同参数的 URL 就无法处理\r\n   *    注：该问题已经通过在 watch 中判断值是否变化而解决，但总感觉还有莫名其妙的坑在前面等着。。。\r\n   * @param vm\r\n   * @param expOrFn\r\n   * @param urlData\r\n   */\r\n  initVueData(vm, expOrFn, urlData) {\r\n    const oldVal = get(vm, expOrFn, null)\r\n    const newVal = urlData[expOrFn]\r\n    if (oldVal === undefined || oldVal === null) {\r\n      set(vm, expOrFn, newVal)\r\n    } else if (typeof oldVal === 'object' && newVal !== undefined) {\r\n      Object.assign(get(vm, expOrFn), newVal)\r\n    }\r\n  }\r\n  /**\r\n   * 在组件被 vue-router 路由复用时，单独进行初始化数据\r\n   * @param vm\r\n   * @param expOrFnList\r\n   * @param route\r\n   */\r\n  initNextUrlData(vm, expOrFnList, route) {\r\n    const urlData = JSON.parse(route.query[this.urlPersistName] || '{}')\r\n    console.log('urlData: ', urlData)\r\n    expOrFnList.forEach((expOrFn) => {\r\n      this.initVueData(vm, expOrFn, urlData)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 在组件被 vue 创建后初始化数据并监听之，在发生变化时自动序列化到 URL 上\r\n   * 注：需要序列化到 URL 上的数据必须能被 JSON.stringfy 序列化\r\n   * @param vm\r\n   * @param expOrFnList\r\n   */\r\n  initUrlData(vm, expOrFnList) {\r\n    const urlData = JSON.parse(vm.$route.query[this.urlPersistName] || '{}')\r\n    expOrFnList.forEach((expOrFn) => {\r\n      this.initVueData(vm, expOrFn, urlData)\r\n\r\n      vm.$watch(\r\n        expOrFn,\r\n        debounce(1000, async (val) => {\r\n          console.log('val 变化了: ', val)\r\n          urlData[expOrFn] = val\r\n\r\n          if (\r\n            vm.$route.query[this.urlPersistName] === JSON.stringify(urlData)\r\n          ) {\r\n            return\r\n          }\r\n\r\n          await vm.$router.replace({\r\n            query: {\r\n              ...vm.$route.query,\r\n              [this.urlPersistName]: JSON.stringify(urlData),\r\n            },\r\n          })\r\n        }),\r\n        {\r\n          deep: true,\r\n        },\r\n      )\r\n    })\r\n  }\r\n  install(Vue, options = {}) {\r\n    const _this = this\r\n    if (options.expListName) {\r\n      this.expListName = options.expListName\r\n    }\r\n    if (options.urlPersistName) {\r\n      this.urlPersistName = options.urlPersistName\r\n    }\r\n    Vue.prototype.$urlPersist = this\r\n\r\n    function initDataByRouteUpdate(to) {\r\n      const expList = this[_this.expListName]\r\n      if (Array.isArray(expList)) {\r\n        this.$urlPersist.initNextUrlData(this, expList, to)\r\n      }\r\n    }\r\n\r\n    Vue.mixin({\r\n      created() {\r\n        const expList = this[_this.expListName]\r\n        if (Array.isArray(expList)) {\r\n          this.$urlPersist.initUrlData(this, expList)\r\n        }\r\n      },\r\n      beforeRouteUpdate(to, from, next) {\r\n        initDataByRouteUpdate.call(this, to)\r\n        next()\r\n      },\r\n      beforeRouteEnter(to, from, next) {\r\n        next((vm) => initDataByRouteUpdate.call(vm, to))\r\n      },\r\n    })\r\n  }\r\n}\r\n\r\nexport default VueUrlPersist\r\n```\r\n\r\n使用起来和其他的插件没什么差别\r\n\r\n```js\r\n// main.js\r\nimport VueUrlPersist from './views/js/VueUrlPersist'\r\n\r\nconst vueUrlPersist = new VueUrlPersist()\r\nVue.use(vueUrlPersist)\r\n```\r\n\r\n在需要使用的组件中只要声明这个属性就好了。\r\n\r\n```js\r\nexport default {\r\n  name: 'Form2Tab',\r\n  data() {\r\n    return {\r\n      form: {\r\n        keyword: '',\r\n        sex: 0,\r\n      },\r\n      exps: ['form'],\r\n    }\r\n  },\r\n}\r\n```\r\n\r\n然而，使用 vue 插件有个致命的缺陷：无论是否需要，都会为每个组件中都混入三个生命周期函数，吾辈没有找到一种可以根据实例中是否包含某个值而决定是否混入的方式。\r\n\r\n#### 使用高阶函数\r\n\r\n所以，我们使用 `高阶函数` + `mixin` 的形式看看。\r\n\r\n```js\r\nimport { debounce, get, set } from './common'\r\n\r\nclass VueUrlPersist {\r\n  /**\r\n   * 一些选项\r\n   */\r\n  constructor({ key = 'qb' } = {}) {\r\n    this.key = key\r\n  }\r\n\r\n  /**\r\n   * 为 vue 实例上的字段进行深度赋值\r\n   */\r\n  setInitData(vm, exp, urlData) {\r\n    const oldVal = get(vm, exp, null)\r\n    const newVal = urlData[exp]\r\n    //如果原值是对象且新值也是对象，则进行浅合并\r\n    if (\r\n      oldVal === undefined ||\r\n      oldVal === null ||\r\n      typeof oldVal === 'string' ||\r\n      typeof oldVal === 'number'\r\n    ) {\r\n      set(vm, exp, newVal)\r\n    } else if (typeof oldVal === 'object' && typeof newVal === 'object') {\r\n      Object.assign(get(vm, exp), newVal)\r\n    }\r\n  }\r\n  /**\r\n   * 初始化一些数据需要序列化/反序列化到 url data 上\r\n   * @param vm vue 实例\r\n   * @param exps 监视的数据的表达式数组\r\n   */\r\n  initUrlDataByCreated(vm, exps) {\r\n    const key = this.key\r\n    const urlData = JSON.parse(vm.$route.query[key] || '{}')\r\n    exps.forEach((exp) => {\r\n      this.setInitData(vm, exp, urlData)\r\n      vm.$watch(\r\n        exp,\r\n        debounce(function (val) {\r\n          urlData[exp] = val\r\n          if (vm.$route.query[key] === JSON.stringify(urlData)) {\r\n            return\r\n          }\r\n          vm.$router.replace({\r\n            query: {\r\n              ...vm.$route.query,\r\n              [key]: JSON.stringify(urlData),\r\n            },\r\n          })\r\n        }, 1000),\r\n        {\r\n          deep: true,\r\n        },\r\n      )\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 在组件被 vue-router 路由复用时，单独进行初始化数据\r\n   * @param vm vue 实例\r\n   * @param exps 监视的数据的表达式数组\r\n   * @param route 将要改变的路由对象\r\n   */\r\n  initUrlDataByRouteUpdate(vm, exps, route) {\r\n    const urlData = JSON.parse(route.query[this.key] || '{}')\r\n    exps.forEach((exp) => this.setInitData(vm, exp, urlData))\r\n  }\r\n\r\n  /**\r\n   * 生成可以 mixin 到 vue 实例的对象\r\n   * @param exps 监视的数据的表达式数组\r\n   * @returns {{created(): void, beforeRouteEnter(*=, *, *): void, beforeRouteUpdate(*=, *, *): void}}\r\n   */\r\n  generateInitUrlData(...exps) {\r\n    const _this = this\r\n    return {\r\n      created() {\r\n        _this.initUrlDataByCreated(this, exps)\r\n      },\r\n      beforeRouteUpdate(to, from, next) {\r\n        _this.initUrlDataByRouteUpdate(this, exps, to)\r\n        next()\r\n      },\r\n      beforeRouteEnter(to, from, next) {\r\n        console.log('beforeRouteEnter')\r\n        next((vm) => _this.initUrlDataByRouteUpdate(vm, exps, to))\r\n      },\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 修改一些配置\r\n   * @param options 配置项\r\n   */\r\n  config(options) {\r\n    Object.assign(this, options)\r\n  }\r\n}\r\nconst vueUrlPersist = new VueUrlPersist()\r\nconst generateInitUrlData = vueUrlPersist.generateInitUrlData.bind(\r\n  vueUrlPersist,\r\n)\r\n\r\nexport { vueUrlPersist, generateInitUrlData, VueUrlPersist }\r\n\r\nexport default vueUrlPersist\r\n```\r\n\r\n使用起来几乎一样简单\r\n\r\n```js\r\nimport { generateInitUrlData } from './js/VueUrlPersist'\r\n\r\nexport default {\r\n  name: 'Form1',\r\n  mixins: [generateInitUrlData('form')],\r\n  data() {\r\n    return {\r\n      form: {\r\n        keyword: '',\r\n        hobbyList: [],\r\n      },\r\n    }\r\n  },\r\n}\r\n```\r\n\r\n看起来，使用高阶函数也没有比 Vue 插件麻烦太多。\r\n\r\n## 总结\r\n\r\n总的来说，虽然路途坎坷，不过这个问题还是很有趣的，而且确实能解决实际的问题，所以还是有研究价值的。\r\n","createdTime":1580652937924,"updatedTime":1608895064848,"resources":[],"tags":[{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"53148ce0792e49b6b18bc68ea4eb6b8e","title":"使用 rollup 打包 JavaScript SDK","body":"> 吾辈已经写了一个 TypeScript/JavaScript Cli 工具 [liuli-cli](https://www.npmjs.com/package/liuli-cli)，如有需要可以使用这个 Cli 直接生成一个开箱即用 SDK 项目，然后就可以直接开始写自己的代码，不需要太过关心下面的内容了 -- 因为，它们都已然集成了。\r\n\r\n## 场景\r\n\r\n### 为什么要使用打包工具\r\n\r\n如果我们想要写一个 `JavaScript SDK`，那么就不太可能将所有的代码都写到同一个 js 文件中。当然了，想做的话的确可以做到，但随着 `JavaScript SDK` 内容的增加，一个 js 文件容易造成开发冲突，以及测试上的困难，这也是现代前端基本上都依赖于打包工具的原因。\r\n\r\n### 为什么打包工具是 rollup\r\n\r\n现今最流行的打包工具是 [webpack](https://webpack.js.org/)，然而事实上对于单纯的打包 JavaScript SDK 而言 webpack 显得有些太重了。webpack 终究是用来整合多种类型的资源而产生的（`ReactJS/VueJS/Babel/TypeScript/Stylus`），对于纯 JavaScript 库而言其实并没有必要使用如此 **强大** 的工具。而 rollup 就显得小巧精致，少许配置就能立刻打包了。\r\n\r\n## 步骤\r\n\r\n> 该记录的代码被吾辈放到了 [GitHub](https://github.com/rxliuli/rollup-example)，有需要的话可以看下。\r\n\r\n### 前置要求\r\n\r\n开始之前，我们必须要对以下内容有所了解\r\n\r\n- [x] JavaScript\r\n- [x] npm\r\n- [ ] babel\r\n- [ ] uglify\r\n- [ ] eslint\r\n\r\n### 需要打包的代码\r\n\r\n```js\r\n// src/wait.js\r\n/**\r\n * 等待指定的时间/等待指定表达式成立\r\n * @param {Number|Function} param 等待时间/等待条件\r\n * @returns {Promise} Promise 对象\r\n */\r\nfunction wait(param) {\r\n  return new Promise((resolve) => {\r\n    if (typeof param === 'number') {\r\n      setTimeout(resolve, param)\r\n    } else if (typeof param === 'function') {\r\n      var timer = setInterval(() => {\r\n        if (param()) {\r\n          clearInterval(timer)\r\n          resolve()\r\n        }\r\n      }, 100)\r\n    } else {\r\n      resolve()\r\n    }\r\n  })\r\n}\r\n\r\nexport default wait\r\n\r\n// src/fetchTimeout.js\r\n/**\r\n * 为 fetch 请求添加超时选项\r\n * 注：超时选项并非真正意义上的超时即取消请求，请求依旧正常执行完成，但会提前返回 reject 结果\r\n * @param {Promise} fetchPromise fetch 请求的 Promise\r\n * @param {Number} timeout 超时时间\r\n * @returns {Promise} 如果超时就提前返回 reject, 否则正常返回 fetch 结果\r\n */\r\nfunction fetchTimeout(fetchPromise, timeout) {\r\n  var abortFn = null\r\n  //这是一个可以被 reject 的 Promise\r\n  var abortPromise = new Promise(function (resolve, reject) {\r\n    abortFn = function () {\r\n      reject('abort promise')\r\n    }\r\n  })\r\n  // 有一个 Promise 完成就立刻结束\r\n  var abortablePromise = Promise.race([fetchPromise, abortPromise])\r\n  setTimeout(function () {\r\n    abortFn()\r\n  }, timeout)\r\n  return abortablePromise\r\n}\r\n\r\nexport default fetchTimeout\r\n\r\n// src/main.js\r\nimport wait from './wait'\r\nimport fetchTimeout from './fetchTimeout'\r\n\r\n/**\r\n * 限制并发请求数量的 fetch 封装\r\n */\r\nclass FetchLimiting {\r\n  constructor({ timeout = 10000, limit = 10 }) {\r\n    this.timeout = timeout\r\n    this.limit = limit\r\n    this.execCount = 0\r\n    // 等待队列\r\n    this.waitArr = []\r\n  }\r\n\r\n  /**\r\n   * 执行一个请求\r\n   * 如果到达最大并发限制时就进行等待\r\n   * 注：该方法的请求顺序是无序的，与代码里的顺序无关\r\n   * @param {RequestInfo} url 请求 url 信息\r\n   * @param {RequestInit} init 请求的其他可选项\r\n   * @returns {Promise} 如果超时就提前返回 reject, 否则正常返回 fetch 结果\r\n   */\r\n  async _fetch(url, init) {\r\n    const _innerFetch = async () => {\r\n      console.log(\r\n        `执行 execCount: ${this.execCount}, waitArr length: ${\r\n          this.waitArr.length\r\n        }, index: ${JSON.stringify(this.waitArr[0])}`,\r\n      )\r\n      this.execCount++\r\n      const args = this.waitArr.shift(0)\r\n      try {\r\n        return await fetchTimeout(fetch(...args), this.timeout)\r\n      } finally {\r\n        this.execCount--\r\n      }\r\n    }\r\n    this.waitArr.push(arguments)\r\n    await wait(() => this.execCount < this.limit)\r\n    // 尝试启动等待队列\r\n    return _innerFetch()\r\n  }\r\n}\r\n\r\nexport default FetchLimiting\r\n```\r\n\r\n### 使用 rollup 直接打包\r\n\r\n安装 `rollup`\r\n\r\n```sh\r\nnpm i rollup -D\r\n```\r\n\r\n在根目录创建一个 `rollup.config.js` 配置文件\r\n\r\n```js\r\nexport default {\r\n  // 入口文件\r\n  input: 'src/main.js',\r\n  output: {\r\n    // 打包名称\r\n    name: 'bundlea',\r\n    // 打包的文件\r\n    file: 'dist/bundle.js',\r\n    // 打包的格式，umd 支持 commonjs/amd/life 三种方式\r\n    format: 'umd',\r\n  },\r\n}\r\n```\r\n\r\n添加一个 `npm script`\r\n\r\n```json\r\n\"scripts\": {\r\n  \"build\": \"rollup -c\"\r\n}\r\n```\r\n\r\n然后运行 `npm run build` 测试打包，可以看到 _dist_ 目录下已经有 `bundle.js` 文件了\r\n\r\n> 好了，到此为止我们已经简单使用 rollup 打包 js 了，下面的内容都是可选项，如果需要可以分节选读。\r\n\r\n### 使用 babel 转换 ES5\r\n\r\n然而，我们虽然已经将 main.js 打包了，然而实际上我们的代码没有发生什么变化。即：原本是 ES6 的代码仍然会是 ES6，而如果我们想要尽可能地支持更多的浏览器，目前而言还是需要兼容到 ES5 才行。\r\n\r\n所以，我们需要 `babel`，它能够帮我们把 ES6 的代码编译成 ES5。\r\n\r\n> 附：babel 被称为现代前端的 jquery。\r\n\r\n首先，安装 babel 需要的包\r\n\r\n```sh\r\nnpm i -D rollup-plugin-babel @babel/core @babel/plugin-external-helpers @babel/preset-env\r\n```\r\n\r\n在 `rollup.config.js` 中添加 `plugins`\r\n\r\n```js\r\nimport babel from 'rollup-plugin-babel'\r\n\r\nexport default {\r\n  plugins: [\r\n    // 引入 babel 插件\r\n    babel({\r\n      exclude: 'node_modules/**',\r\n    }),\r\n  ],\r\n}\r\n```\r\n\r\n添加 babel 的配置文件 `.babelrc`\r\n\r\n```json\r\n{\r\n  \"presets\": [\r\n    [\r\n      \"@babel/preset-env\",\r\n      {\r\n        \"modules\": false\r\n      }\r\n    ]\r\n  ],\r\n  \"plugins\": [\"@babel/plugin-external-helpers\"]\r\n}\r\n```\r\n\r\n再重新运行 `npm run build`，可以看到 `bundle.js` 中的代码已经被编译成 ES5 了。\r\n\r\n### 使用 uglify 压缩生产环境代码\r\n\r\n那么，生产中的代码还需要做什么呢？是的，压缩，减小 js 代码的体积是必要的。接下来，我们还需要使用 `uglify` 压缩我们打包后的 `bundle.js` 代码。\r\n\r\n首先仍然是安装 `uglify` 相关的包\r\n\r\n```sh\r\nnpm i -D rollup-plugin-uglify\r\n```\r\n\r\n然后在 `rollup.config.js` 中引入插件就好了\r\n\r\n```js\r\n// 注意，这里引入需要使用 { uglify } 而非 uglify，因为 uglify 导出自身时使用的是 exports.uglify\r\nimport { uglify } from 'rollup-plugin-uglify'\r\n\r\nexport default {\r\n  plugins: [\r\n    // js 压缩插件，需要在最后引入\r\n    uglify(),\r\n  ],\r\n}\r\n```\r\n\r\n### 使用 ESLint 检查代码\r\n\r\n如果我们想要需要多人协作统一代码风格，那么可以使用 ESLint 来强制规范。\r\n\r\n首先，全局安装 `eslint`\r\n\r\n```sh\r\nnpm i eslint -g\r\n```\r\n\r\n然后使用 `eslint cli` 初始化\r\n\r\n```sh\r\neslint --init\r\n```\r\n\r\n下面的三项问题选择\r\n\r\n1. How would you like to configure ESLint? (Use arrow keys)  \r\n   `Use a popular style guide`\r\n2. Which style guide do you want to follow? (Use arrow keys)  \r\n   `Standard (https://github.com/standard/standard)`\r\n3. What format do you want your config file to be in? (Use arrow keys)  \r\n   `JavaScript`\r\n4. Would you like to install them now with npm?  \r\n   `y`\r\n\r\n然后，我们发现项目根目录下多出了 `.eslintrc.js`，这是 eslit 的配置文件。然而，我们需要对其稍微修改一下，不然如果我们的代码中出现了浏览器中的对象，例如 `document`，eslint 就会傻傻的认为那是个错误！  \r\n修改后的 `.eslintrc.js` 配置\r\n\r\n```js\r\nmodule.exports = {\r\n  extends: 'standard',\r\n  // 添加了运行环境设定，设置 browser 为 true\r\n  env: {\r\n    browser: true,\r\n  },\r\n}\r\n```\r\n\r\n当我们查看打包后的 `bundle.js` 时发现 eslint 给我们报了一堆错误，所以我们需要排除掉 dist 文件夹  \r\n添加 `.eslintignore` 文件\r\n\r\n```ignore\r\ndist\r\n```\r\n\r\n添加 `rollup-plugin-eslint` 插件，在打包之前进行格式校验\r\n\r\n```sh\r\nnpm i -D rollup-plugin-eslint\r\n```\r\n\r\n然后引入它\r\n\r\n```js\r\nimport { eslint } from 'rollup-plugin-eslint'\r\n\r\nexport default {\r\n  plugins: [\r\n    // 引入 eslint 插件\r\n    eslint(),\r\n  ],\r\n}\r\n```\r\n\r\n这个时候，当你运行 `npm run build` 的时候，eslint 可能提示你一堆代码格式错误，难道我们还要一个个的去修复么？不，eslint 早已考虑到了这一点，我们可以添加一个 npm 脚本用于全局修复格式错误。\r\n\r\n```json\r\n\"scripts\": {\r\n  \"lint\": \"eslint --fix src\"\r\n}\r\n```\r\n\r\n然后运行 `npm run lint`，eslint 会尽可能修复格式错误，如果不能修复，会在控制台打印异常文件的路径，然后我们手动修复就好啦\r\n\r\n### 其他 rollup 配置\r\n\r\n#### 添加代码映射文件\r\n\r\n其实很简单，只要在 `rollup.config.js` 启用一个配置就好了\r\n\r\n```js\r\nexport default {\r\n  output: {\r\n    // 启用代码映射，便于调试之用\r\n    sourcemap: true,\r\n  },\r\n}\r\n```\r\n\r\n#### 多环境打包\r\n\r\n首先移除掉根目录下的 `rollup.config.js` 配置文件，然后创建 build 目录并添加下面四个文件\r\n\r\n```js\r\n// build/util.js\r\nimport path from 'path'\r\n\r\n/**\r\n * 根据相对路径计算真是的路径\r\n * 从当前类的文件夹开始计算，这里是 /build\r\n * @param {String} relaPath 相对路径\r\n * @returns {String} 绝对路径\r\n */\r\nexport function calcPath(relaPath) {\r\n  return path.resolve(__dirname, relaPath)\r\n}\r\n```\r\n\r\n```js\r\n// build/rollup.config.dev.js\r\nimport { eslint } from 'rollup-plugin-eslint'\r\nimport { calcPath } from './util'\r\nimport { name } from '../package.json'\r\n\r\nexport default {\r\n  // 入口文件\r\n  input: calcPath('../src/main.js'),\r\n  output: {\r\n    // 打包名称\r\n    name,\r\n    // 打包的文件\r\n    file: calcPath(`../dist/${name}.js`),\r\n    // 打包的格式，umd 支持 commonjs/amd/life 三种方式\r\n    format: 'umd',\r\n    // 启用代码映射，便于调试之用\r\n    sourcemap: true,\r\n  },\r\n  plugins: [\r\n    // 引入 eslint 插件，必须在 babel 之前引入，因为 babel 编译之后的代码未必符合 eslint 规范，eslint 仅针对我们 [原本] 的代码\r\n    eslint(),\r\n  ],\r\n}\r\n```\r\n\r\n```js\r\n// build/rollup.config.prod.js\r\nimport babel from 'rollup-plugin-babel'\r\n// 注意，这里引入需要使用 { uglify } 而非 uglify，因为 uglify 导出自身时使用的是 exports.uglify\r\nimport { uglify } from 'rollup-plugin-uglify'\r\nimport { eslint } from 'rollup-plugin-eslint'\r\nimport { calcPath } from './util'\r\nimport dev from './rollup.config.dev'\r\nimport { name } from '../package.json'\r\n\r\nexport default [\r\n  dev,\r\n  {\r\n    // 入口文件\r\n    input: calcPath('../src/main.js'),\r\n    output: {\r\n      // 打包名称\r\n      name,\r\n      // 打包的文件\r\n      file: calcPath(`../dist/${name}.min.js`),\r\n      // 打包的格式，umd 支持 commonjs/amd/life 三种方式\r\n      format: 'umd',\r\n    },\r\n    plugins: [\r\n      // 引入 eslint 插件，必须在 babel 之前引入，因为 babel 编译之后的代码未必符合 eslint 规范，eslint 仅针对我们 [原本] 的代码\r\n      eslint(),\r\n      // 引入 babel 插件\r\n      babel({\r\n        exclude: calcPath('../node_modules/**'),\r\n      }),\r\n      // js 压缩插件，需要在最后引入\r\n      uglify(),\r\n    ],\r\n  },\r\n]\r\n```\r\n\r\n```js\r\n// build/rollup.config.js\r\nimport dev from './rollup.config.dev'\r\nimport prod from './rollup.config.prod'\r\n\r\n// 如果当前环境时 production，则使用 prod 配置，否则使用 dev 配置\r\nexport default process.env.NODE_ENV === 'production' ? prod : dev\r\n```\r\n\r\n修改 npm 脚本\r\n\r\n```json\r\n\"scripts\": {\r\n  \"build:dev\": \"rollup -c build/rollup.config.js --environment NODE_ENV:development\",\r\n  \"build:prod\": \"rollup -c build/rollup.config.js --environment NODE_ENV:production\",\r\n  \"build\": \"npm run build:dev && npm run build:prod\",\r\n}\r\n```\r\n\r\n---\r\n\r\n那么，关于使用 rollup 打包 JavaScript 的内容就先到这里了，有需要的话后续吾辈还会继续更新的！\r\n","createdTime":1580652937916,"updatedTime":1608894919769,"resources":[],"tags":[{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"50a0376f73294d13af86032050a465b8","title":"JavaScript 善用解构赋值","body":"## 场景\r\n\r\n在今天写 JavaScript 函数时，发现了一个有趣的技巧。\r\n\r\n在此之前，吾辈想知道泥萌需要默认值的时候是如何做的呢？\r\n\r\n例如下面的函数 `print`，吾辈需要在没有给定参数 `user` 的情况下，给出合适的输出\r\n\r\n```js\r\nfunction print(user) {\r\n  if (!user) {\r\n    user = {}\r\n  }\r\n  if (!user.name) {\r\n    user.name = '未设置'\r\n  }\r\n  if (!user.age) {\r\n    user.age = 0\r\n  }\r\n  console.log(`姓名：${user.name}，年龄：${user.age}`)\r\n}\r\n```\r\n\r\n那么，我们应该怎么优化呢？\r\n\r\n- 三元表达式\r\n- `||` / `&&` 赋予默认值\r\n- `Object.assign()` 合并对象\r\n\r\n我们分别来实现一下\r\n\r\n### 三元表达式实现\r\n\r\n```js\r\nfunction print(user) {\r\n  user = user ? user : {}\r\n  console.log(\r\n    `姓名：${user.name ? user.name : '未设置'}，年龄：${\r\n      user.age ? user.age : 0\r\n    }`,\r\n  )\r\n}\r\n```\r\n\r\n### `||` / `&&` 赋予默认值\r\n\r\n```js\r\nfunction print(user) {\r\n  console.log(\r\n    `姓名：${(user || {}).name || '未设置'}，年龄：${(user || {}).age || 0}`,\r\n  )\r\n}\r\n```\r\n\r\n使用 `&&` 也可以\r\n\r\n```js\r\nfunction print(user) {\r\n  console.log(\r\n    `姓名：${(user && user.name) || '未设置'}，年龄：${\r\n      (user && user.age) || 0\r\n    }`,\r\n  )\r\n}\r\n```\r\n\r\n> `||` / `&&` 解释\r\n>\r\n> - `||` 用来取默认值，避免太多的 `if` 判断。例如对于 `a || b` 我们可以认为：如果 `a` 为空，则赋值为 `b`\r\n> - `&&` 用来连续执行，避免深层嵌套的 `if` 判断。例如对于 `a || b`，我们可以认为：如果 `a` 不为空，则赋值为 `b`\r\n>\r\n> 注：||`/`&&` 非常适合简单的默认值赋值，但一旦设置到深层嵌套默认值就不太合适了\r\n\r\n### `Object.assign()` 合并对象\r\n\r\n```js\r\nfunction print(user) {\r\n  _user = {\r\n    name: '未设置',\r\n    age: 0,\r\n  }\r\n  user = Object.assign(_user, user)\r\n  console.log(`姓名：${user.name}，年龄：${user.age}`)\r\n}\r\n```\r\n\r\n---\r\n\r\n可以看出\r\n\r\n1. 三元表达式的方式方式明显有点繁琐\r\n2. `||` / `&&` 很好很强大，缺点是看起来很不直观，而且容易混淆\r\n3. `Object.assign()` 合并对象的方式应该算是最好的了，然而是在方法内部进行的初始化，作为调用者除非查看文档或源码才能知道\r\n\r\n那么，有没有更好的解决方案呢？\r\n\r\n## 解构赋值\r\n\r\n解构赋值是 ES6 的一个新的语法，具体可以查看 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)。\r\n\r\n下面是一些简单的解构赋值操作\r\n\r\n### 数组解构\r\n\r\n```js\r\nvar arr = [1, 2, 3, 4]\r\nvar [first, second, ...remaining] = arr // first: 1, second: 2, remaining: [3, 4]\r\n// 接受一或多个可变参数的函数\r\nfunction join(...arr) {\r\n  return arr.join(', ')\r\n}\r\n// 调用时可以使用 ... 将数组解构\r\njoin(...arr) // 1, 2, 3, 4\r\n// 忽略开始的某些值\r\nvar [, , ...remaining] = arr // remaining: [3, 4]\r\n// 默认值\r\nvar [first = 1, second = 2, ...remaining] = [] // first: 1, second: 2, remaining:\r\nvar a = 1,\r\n  b = 2\r\n// 交换变量\r\n;[a, b] = [b, a] // a: 2, b: 1\r\n```\r\n\r\n### 对象解构\r\n\r\n```js\r\nvar user = {\r\n  id: 1,\r\n  name: '未设置',\r\n  age: 0,\r\n  sex: false,\r\n}\r\n// 排除指定属性\r\nvar { name, age, ...rest } = user // name: '未设置', age: 0, 其他属性: { \"id\": 1,\"sex\": false }\r\n\r\n// 使用新的变量名\r\nvar { name: newName, age: newAge } = user // newName: '未设置', newAge: 0\r\n// 默认值\r\nvar { name = '未设置', age = 0 } = {} // name: '未设置', age: 0\r\n// 同时使用新的变量名和默认值\r\nvar { name: newName = '未设置', age: newAge = 0 } = user // newName: '未设置', newAge: 0\r\n// 计算属性名\r\nvar key = 'name'\r\nvar { [key]: name } = user\r\n\r\n// 数组迭代解构\r\nvar users = [\r\n  {\r\n    name: '琉璃',\r\n    age: 17,\r\n  },\r\n  {\r\n    name: '楚轩',\r\n    age: 23,\r\n  },\r\n]\r\nusers.map(({ name, age }) => `name: ${name}, age: ${age}`).join('\\n')\r\n// 解构函数实参\r\nfunction print({ name = '未设置', age = 0 } = {}) {\r\n  console.log(`姓名：${name}，年龄：${age}`)\r\n}\r\n```\r\n\r\n啊嘞，吾辈好像不知不觉间把解决方案写出来了。。。？\r\n\r\n### 分析\r\n\r\n让我们好好看下这段代码\r\n\r\n```js\r\nfunction print({ name = '未设置', age = 0 } = {}) {\r\n  console.log(`姓名：${name}，年龄：${age}`)\r\n}\r\n```\r\n\r\n一眼看过去，是不是感觉很直观，如果稍微了解一点 ES6 就能瞬间明白这是解构赋值以及默认参数\r\n\r\n我们分析一下具体流程\r\n\r\n1. 调用 `print` 函数\r\n2. 检查参数是否为有值，没有的话设置默认值 `{}`  \r\n   相当于\r\n\r\n   ```js\r\n   if (!user) {\r\n     user = {}\r\n   }\r\n   ```\r\n\r\n3. 解构参数，检查解构的属性是否有值，没有的话设置默认值  \r\n    相当于\r\n\r\n   ```js\r\n   var name\r\n   if (!user.name) {\r\n     name = '未设置'\r\n   } else {\r\n     name = user.name\r\n   }\r\n   var age\r\n   if (!user.age) {\r\n     age = 0\r\n   } else {\r\n     age = user.age\r\n   }\r\n   ```\r\n\r\n4. 进入函数内部\r\n\r\n关键就在于第 2,3 步，[默认参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters) 和 [解构赋值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) 都是 ES6 的新特性，善于使用能大大简化代码的繁琐性。\r\n\r\n---\r\n\r\n希望有更多的人能够学会怎么使用，让我们早日抛弃 babel 吧 (\\*＾ ▽ ＾)／\r\n","createdTime":1580652937866,"updatedTime":1608894724483,"resources":[],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"31f9f3f788794bd38f4d5ba0e9337ff4","title":"JavaScript 加载全部资源后再使用","body":"## 场景\r\n\r\n客户需要一次性将视频全部缓冲完成再进行观看而非看一段缓冲一段，所以就看了一下有没有什么方法能够做到，结果顺便还写了一个通用的加载资源的方法。\r\n\r\n## 实现\r\n\r\n基本思路是使用 `ajax`(`fetch`) 将资源先加载到本地，然后生成一个本地的 url，最后将本地资源链接赋值给需要资源的元素上。\r\n\r\n```js\r\n/**\r\n * 将 url 中的内容加载到元素上\r\n * 注：domSelector 必须有 src 属性用以将加载完成的资源赋值给其，加载默认是异步的\r\n * @param {string} url url 资源\r\n * @param {document} domSelector dom 选择器\r\n * @param {object} init 初始化参数, 实为 fetch() 的参数以及一些自定义的参数\r\n * 关于 fetch 具体可以参考 <https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch>\r\n * 自定义的参数有:\r\n * before: 加载之前的方法，例如可以设置一个弹窗或者遮罩告诉用户资源正在加载中\r\n * after: 加载完成之后的方法，例如可以设置一个加载完成的动画提醒一下用户\r\n * error: 发生异常时的方法，例如可以设置一个错误提示通知用户加载异常需要刷新了\r\n */\r\nfunction loadResource(url, domSelector, init) {\r\n  if (!init) {\r\n    init = {}\r\n  }\r\n  if (init.before && typeof init.before === 'function') {\r\n    init.before()\r\n  }\r\n  // 如果没有自定义缓存的话就设置缓存\r\n  init.cache = init.cache || 'force-cache'\r\n  // 如果没有自定义错误处理就设置一下错误处理\r\n  init.error =\r\n    init.error || ((error) => console.log(`request was wrong: ${error}`))\r\n  fetch(url, init)\r\n    // 判断返回的状态是否正常\r\n    .then((rep) => {\r\n      if (rep.status === 200) {\r\n        return rep\r\n      } else {\r\n        throw new Error(`response status error ${rep.status}`)\r\n      }\r\n    })\r\n    // 转换资源\r\n    .then((data) => data.blob())\r\n    .then((blob) => {\r\n      // 生成一个本地的 url 并赋值给 src 属性\r\n      domSelector.src = window.URL.createObjectURL(blob)\r\n      if (init.after && typeof init.after === 'function') {\r\n        init.after()\r\n      }\r\n    })\r\n    .catch(init.error)\r\n}\r\n```\r\n\r\n## 使用示例\r\n\r\n假如有一个 `video` 元素需要加载视频\r\n\r\n```html\r\n<video id=\"video\" controls></video>\r\n```\r\n\r\n那么使用该方法的 `JavaScript` 代码就是\r\n\r\n```js\r\n// 要加载的 url 资源\r\nvar url = '/html/testVideo.m4'\r\n// 资源的容器，这里是一个视频元素\r\nvar video = document.querySelector('#video')\r\n\r\n// 此处使用第三个参数仅为演示，不需要的话忽略即可。。。\r\nloadResource(url, video, {\r\n  before: () => console.log('video load before'),\r\n  after: () => console.log('video load after'),\r\n  error: (error) => console.log(`video load error: ${error}`),\r\n})\r\n// 即可以：\r\nloadResource(url, video)\r\n```\r\n\r\n> 注：此方法不仅可以加载视频，也可以加载 audio, img 等拥有 src 属性的二进制资源\r\n>\r\n> 这个方法同样也已经丢到了 [GitHub Gist](https://gist.github.com/rxliuli/1bf04abd0e91718a901b97762beb0eb9) 上面啦\r\n","createdTime":1580652937858,"updatedTime":1608894706406,"resources":[],"tags":[{"id":"1de1ff51140a44d5a2c223459dabcc37","title":"异步","parent_id":""},{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"e55a67646bf546b3900ce270a6fbc6ca","title":"Greasemonkey 踩坑之路","body":"- [Greasemonkey 踩坑之路](#greasemonkey-踩坑之路)\r\n  - [场景](#场景)\r\n  - [window 对象不能和外部交换数据](#window-对象不能和外部交换数据)\r\n  - [Greasemonkey API 显示 undefined](#greasemonkey-api-显示-undefined)\r\n  - [内存爆炸](#内存爆炸)\r\n  - [Greasemonkey 加载时机太晚](#greasemonkey-加载时机太晚)\r\n    - [等待一段时间再调用，例如等个几秒 Greasemonkey 脚本可能就加载了](#等待一段时间再调用例如等个几秒-greasemonkey-脚本可能就加载了)\r\n    - [延迟到 Greasemonkey 脚本加载完成再与之交互](#延迟到-greasemonkey-脚本加载完成再与之交互)\r\n    - [暴露出需要交互的函数等到 Greasemonkey 加载完成后进行回调](#暴露出需要交互的函数等到-greasemonkey-加载完成后进行回调)\r\n\r\n## 场景\r\n\r\n最近在玩 Greasemonkey 脚本，遇到了各种奇怪的问题，便于此处统一记录一下。\r\n\r\n## window 对象不能和外部交换数据\r\n\r\n场景\r\n\r\n在写 Greasemonkey 脚本时遇到的一个奇怪的问题，吾辈想要把某些数据添加到 `window` 对象上，方便在 DevTool console 中进行测试。然而却由此印发了一个新的问题，即 `window` 对象不是真正的 `window` 对象的问题。\r\n\r\n```js\r\n// ==UserScript==\r\n// @name         Testing\r\n// @namespace    http://tampermonkey.net/\r\n// @version      0.1\r\n// @description  用来测试的 userjs 脚本\r\n// @author       rxliuli\r\n// @include     http://*\r\n// @include\t\t\thttps://*\r\n// @grant        MIT\r\n// ==/UserScript==\r\n\r\n;(function () {\r\n  'use strict'\r\n  window.onload = function () {\r\n    window.rxliuli = function () {\r\n      console.log('这里是 rxliuli 编写的 user.js 脚本')\r\n    }\r\n    window.rxliuli()\r\n  }\r\n})()\r\n```\r\n\r\n控制台正常输出了一句话。然而，当吾辈在 console 中输入 `window.rxliuli` 的结果却是 `undefined`。\r\n\r\n---\r\n\r\n解决\r\n\r\n吾辈估计又是 Greasemonkey 自身的问题，所以不得不去翻了 [Wiki](https://wiki.greasespot.net) 上查找，直到看到了 [Greasemonkey Manual:Environment](https://wiki.greasespot.net/Greasemonkey_Manual:Environment)。里面有这么一段话\r\n\r\n> Depending on the usage, the special Greasemonkey environment may seem perfectly normal, or excessively limiting.  \r\n> The Greasemonkey environment is a vanilla XPCNativeWrapper of the content window, with only certain extra bits added in to emulate a normal environment, or changed. Specifically:\r\n>\r\n> - window is an XPCNativeWrapper of the content window.\r\n> - document is the document object of the XPCNativeWrapper window object.\r\n> - XPathResult is added so that document.evaluate() works.\r\n> - Unless the @unwrap metadata imperative is present in the user script header, the entire script is wrapped inside an anonymous function, to guarantee the script's identifiers do not collide with identifiers present in the Mozilla JavaScript sandbox. This function wrapper captures any function definitions and var variable declarations made (e.g. var i = 5;) into the function's local scope. Declarations made without var will however end up on the script's this object, which in Greasemonkey is the global object, contrary to in the normal browser object model, where the window object fills this function. In effect, after i = 5;, the values of window['i'] and window.i remain undefined, whereas this['i'] and this.i will be 5. See also: Global object\r\n> - In order to access variables on the page, use the unsafeWindow object. To use values defined in a script, simply reference them by their names.\r\n\r\n大意是 Greasemonkey 为了安全所以 Greasemonkey 脚本是在沙箱中执行的，并且限制了一些内容。其中就包括了 `window` 对象并非浏览器的原生对象，而是 `XPCNativeWrapper`。  \r\n所以，`XPCNativeWrapper` 是什么。。。？（一个 Greasemonkey 的坑太多了吧 #吐血）  \r\n吾辈找到了两篇文章\r\n\r\n- [XPCNat ive Wrapper](https://developer.mozilla.org/zh-TW/docs/XPCNativeWrapper)\r\n- [Use XPCNativeWrapper](http://kb.mozillazine.org/XPCNativeWrapper)\r\n\r\n看完之后表示只知道 `XPCNativeWrapper` 是在扩展中用来保护不受信任的对象，并非浏览器客户端本身的 API。\r\n\r\n好吧，说了这么多解决方案是什么呢？\r\n\r\n答案很简单，其实使用 [unsafeWindow](https://wiki.greasespot.net/UnsafeWindow) 对象就能像使用原生的 `window` 对象行为一致，即便这是不推荐的方法，但有时仍然是必须的！\r\n\r\n## Greasemonkey API 显示 undefined\r\n\r\n场景\r\n\r\n在 [Greasemonkey 手册：API](https://wiki.greasespot.net/Greasemonkey_Manual:API) 写出的 API 有很多都不能正常使用，吾辈打印下来的结果是\r\n\r\n```js\r\n// ==UserScript==\r\n// @name         test\r\n// @namespace    http://tampermonkey.net/\r\n// @version      0.1\r\n// @description  test\r\n// @match        *\r\n// @author       rxliuli\r\n// @grant        MIT\r\n// ==/UserScript==\r\n\r\n;(function () {\r\n  'use strict'\r\n\r\n  console.log(GM)\r\n  console.log(GM.info)\r\n  console.log(GM.deleteValue)\r\n  console.log(GM.getValue)\r\n  console.log(GM.listValues)\r\n  console.log(GM.setValue)\r\n  console.log(GM.getResourceUrl)\r\n  console.log(GM.notification)\r\n  console.log(GM.openInTab)\r\n  console.log(GM.setClipboard)\r\n  console.log(GM.setClipboard)\r\n  console.log(unsafeWindow)\r\n})()\r\n```\r\n\r\n![Greasemonkey API 显示 undefined](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181219225309.png)\r\n\r\n测试环境如下：\r\n\r\n- Windows 10 Ltsc\r\n- Chrome 71\r\n- tampermonkey 4.7.44\r\n\r\n---\r\n\r\n解决\r\n\r\n吾辈在翻 [GitHub Issue](https://github.com/sindresorhus/globals/issues/122) 找到了问题所在，原因是这些 API 必须要手动获取准许才行。\r\n即使用 `// @grant GM.[Function]` 来获取需要的 API，所以吾辈的脚本变成了下面这样：\r\n\r\n```js\r\n// ==UserScript==\r\n// @name         test\r\n// @namespace    http://tampermonkey.net/\r\n// @version      0.1\r\n// @description  test\r\n// @match        *\r\n// @author       rxliuli\r\n// @grant        MIT\r\n// @grant        GM.deleteValue\r\n// @grant        GM.getValue\r\n// @grant        GM.listValues\r\n// @grant        GM.setValue\r\n// @grant        GM.getResourceUrl\r\n// @grant        GM.notification\r\n// @grant        GM.openInTab\r\n// @grant        GM.setClipboard\r\n// ==/UserScript==\r\n\r\n;(function () {\r\n  'use strict'\r\n  console.log(GM)\r\n  console.log(GM.info)\r\n  console.log(GM.deleteValue)\r\n  console.log(GM.getValue)\r\n  console.log(GM.listValues)\r\n  console.log(GM.setValue)\r\n  console.log(GM.getResourceUrl)\r\n  console.log(GM.notification)\r\n  console.log(GM.openInTab)\r\n  console.log(GM.setClipboard)\r\n  console.log(GM.setClipboard)\r\n  console.log(unsafeWindow)\r\n})()\r\n```\r\n\r\n问题解决了，现在，所有的 API 都有值了。\r\n\r\n![GM API 都有值了](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181219225919.png)\r\n\r\n## 内存爆炸\r\n\r\n场景\r\n\r\n使用了 `GM.setValue()/GM.getValue()` 两个 API，结果内存分分钟爆炸。吾辈安装 Chrome 以来第一次碰到加载网页能把内存耗尽的情况，果然 GM 的限制不是没有道理的呢  \r\n![内存爆炸](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181220002112.png)  \r\n![浏览器崩溃](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181220013001.png)\r\n\r\n```js\r\n// ==UserScript==\r\n// @name         Testing\r\n// @namespace    http://tampermonkey.net/\r\n// @match        *\r\n// @version      0.1\r\n// @description  用来测试的 userjs 脚本\r\n// @author       rxliuli\r\n// @grant        GM.getValue\r\n// @grant        GM.setValue\r\n// ==/UserScript==\r\n\r\n;(function () {\r\n  'use strict'\r\n\r\n  var domains = {\r\n    domainsName: 'domains',\r\n    async list() {\r\n      var valueStr = GM.getValue(this.domainsName)\r\n      if (!valueStr) {\r\n        return null\r\n      }\r\n      try {\r\n        return JSON.parse(valueStr)\r\n      } catch (err) {\r\n        var defaultArr = []\r\n        await this.set(defaultArr)\r\n        return defaultArr\r\n      }\r\n    },\r\n    async set(arr) {\r\n      await GM.setValue(this.domainsName, JSON.stringify(arr))\r\n      return this.list()\r\n    },\r\n  }\r\n\r\n  async function init() {\r\n    var arr = new Array(0).fill(0).map((v, i) => i)\r\n    var result = await domains.set(arr)\r\n    console.log(result)\r\n  }\r\n\r\n  init()\r\n})()\r\n```\r\n\r\n---\r\n\r\n解决\r\n\r\nDebug 之后发现是调用 `GM.setValue()` 没有使用 `await` 造成的异步请求数量不断积累最终导致网页崩溃。果然 Promise 什么的还是要小心一点好呀  \r\n当然，不信的话你也可以新建一个 Greasemonkey 脚本尝试一下内存爆炸的感觉咯\r\n\r\n> 递归不是主要问题，吾辈 PC 上的 Chrome 最多到 1.4w+ 次递归就会抛出异常（网页没有崩溃），还没到 1.4w+ 次，所以说递归不是主要问题呀\r\n\r\n## Greasemonkey 加载时机太晚\r\n\r\n场景\r\n\r\nGreasemonkey 的加载是在页面加载完毕时，类似于 `window.onload`，所以造成了一个问题：如果想要在网站的 JavaScript 代码中与 Greasemonkey 脚本交互，那么必须要等到 Greasemonkey 加载完成，而加载完成的时机是不确定的。\r\n\r\n吾辈目前想要的解决方案有三种\r\n\r\n### 等待一段时间再调用，例如等个几秒 Greasemonkey 脚本可能就加载了\r\n\r\n思路\r\n\r\n现在没有人，我等会再来问一次！\r\n\r\n实现\r\n\r\n```js\r\nvar wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms))\r\n```\r\n\r\n使用\r\n\r\n```js\r\n// 实现和调用最为简单，但无法保证等待之后就一定能获得资源了\r\nwait(1000).then(() => console.log(完成))\r\n```\r\n\r\n### 延迟到 Greasemonkey 脚本加载完成再与之交互\r\n\r\n思路\r\n\r\n有人吗? 没有的话我等会再来问！\r\n\r\n实现\r\n\r\n```js\r\n/**\r\n * 轮询等待指定资源加载完毕再执行操作\r\n * 使用 Promises 实现，可以使用 ES7 的 {@async}/{@await} 调用\r\n * @param {Function} resourceFn 判断必须的资源是否存在的方法\r\n * @param {Object} options 选项\r\n * @returns Promise 对象\r\n */\r\nfunction waitResource(resourceFn, options) {\r\n  var optionsRes = Object.assign(\r\n    {\r\n      interval: 1000,\r\n      max: 10,\r\n    },\r\n    options,\r\n  )\r\n  var current = 0\r\n  return new Promise((resolve, reject) => {\r\n    var timer = setInterval(() => {\r\n      if (resourceFn()) {\r\n        clearInterval(timer)\r\n        resolve()\r\n      }\r\n      current++\r\n      if (current >= optionsRes.max) {\r\n        clearInterval(timer)\r\n        reject('等待超时')\r\n      }\r\n    }, optionsRes.interval)\r\n  })\r\n}\r\n```\r\n\r\n使用\r\n\r\n```js\r\nvar resourceFn = ((i) => () => {\r\n  console.log(`第 ${i++} 次调用`)\r\n  return false\r\n})(1)\r\n\r\nwaitResource(resourceFn, {\r\n  interval: 1000,\r\n  max: 3,\r\n})\r\n  .then(() => console.log('完成'))\r\n  .catch((err) => console.log(err))\r\n```\r\n\r\n### 暴露出需要交互的函数等到 Greasemonkey 加载完成后进行回调\r\n\r\n思路\r\n\r\n现在没有人，有人的时候再叫我！\r\n\r\n实现\r\n\r\n```js\r\n/**\r\n * 等待被调用\r\n * @param {Number} ms 超时毫秒数\r\n * @param {String} name 准备被调用的挂载到 window 对象上的方法名\r\n */\r\nfunction waitingToCall(ms, name = 'waiting') {\r\n  return new Promise((resolve, reject) => {\r\n    var timeout = setTimeout(() => {\r\n      reject('等待超时')\r\n    }, ms)\r\n    window[name] = () => {\r\n      clearTimeout(timeout)\r\n      resolve()\r\n    }\r\n  })\r\n}\r\n```\r\n\r\n使用\r\n\r\n```js\r\nwaitingToCall(3000, 'waiting')\r\n  .then(() => console.log('完成'))\r\n  .catch((err) => console.log(err))\r\n```\r\n","createdTime":1580652937856,"updatedTime":1608894662766,"resources":[],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""},{"id":"f93505f3e7994607aec7afec41480af3","title":"经验","parent_id":""}]},{"id":"e7a2212e393e448198da90006d5c21e7","title":"JavaScript 自定义解析字符串为 Date 对象","body":"这两天在 JavaScript 遇到需要根据自定义的格式创建 `Date` 对象的情况，所以就没多想写个了解析方法。\r\n\r\n基本思路是将非标准的日期字符串转换为标准的日期字符串，然后再创建对象。\r\n\r\n具体的步骤如下：\r\n\r\n1. 接收两个字符串参数，分别代表要进行解析的字符串 `dateStr`，以及该字符串需要的自定义日期字符串格式 `fmt`。\r\n2. 先解析 `fmt`，获取其中的代表 `year, method, day, hour, minute, second, milliSecond` 的部分得到一个数组（并且记录不同部分的 `index`）`dateUnits`，对 `fmt` 的代表日期的不同部分进行替换.\r\n3. 使用替换过的 `fmt` 创建正则验证 `dateStr` 是否合法，非法直接返回 `null`。\r\n4. 对 `dateUnits` 根据 `index` 进行排序，得到一个按照原本的 `fmt` 的不同日期部分的顺序的数组。\r\n5. 遍历 `dateUnits` 获取到不同的部分，然后拼接成一个标准的(`yyyy-MM-ddThh:mm:ss.SSS`)日期字符串 `date`。\r\n6. 使用 new Date(date) 并且返回。\r\n\r\n全部代码如下：\r\n\r\n```js\r\n/**\r\n * 解析字符串为 Date 对象\r\n * @param dateStr 日期字符串\r\n * @param fmt 日期字符串的格式\r\n * 目前仅支持使用 y(年),M(月),d(日),h(时),m(分),s(秒),S(毫秒)\r\n */\r\nDate.of = function (dateStr, fmt) {\r\n  if (!dateStr) {\r\n    throw new Error('传入的日期字符串不能为空！')\r\n  }\r\n  if (!fmt) {\r\n    throw new Error('传入的日期字符串的自定义格式不能为空！')\r\n  }\r\n\r\n  /**\r\n   * 日期格式化对象\r\n   * @param name 日期格式的名称\r\n   * @param format 日期的格式值\r\n   * @param value 格式化得到的值\r\n   * @constructor\r\n   */\r\n  function DateFormat(name, format, value, index) {\r\n    this.name = name\r\n    this.format = format\r\n    this.value = value\r\n    this.index = index\r\n  }\r\n\r\n  //日期时间的正则表达式\r\n  const dateFormats = {\r\n    year: 'y{1,4}',\r\n    month: 'M{1,2}',\r\n    day: 'd{1,2}',\r\n    hour: 'h{1,2}',\r\n    minute: 'm{1,2}',\r\n    second: 's{1,2}',\r\n    milliSecond: 'S{1,3}',\r\n  }\r\n  //如果没有格式化某项的话则设置为默认时间\r\n  const defaultDateValues = {\r\n    year: '2001',\r\n    month: '01',\r\n    day: '01',\r\n    hour: '00',\r\n    minute: '00',\r\n    second: '00',\r\n    milliSecond: '000',\r\n  }\r\n  //保存对传入的日期字符串进行格式化的全部信息数组列表\r\n  const dateUnits = []\r\n  for (const fmtName in dateFormats) {\r\n    const regExp = new RegExp(dateFormats[fmtName])\r\n    if (regExp.test(fmt)) {\r\n      const matchStr = regExp.exec(fmt)[0]\r\n      const regexStr = String.fill('`', matchStr.length)\r\n      const index = fmt.indexOf(matchStr)\r\n      fmt = fmt.replaceAll(matchStr, regexStr)\r\n      dateUnits.push(\r\n        new DateFormat(\r\n          fmtName,\r\n          String.fill('\\\\d', matchStr.length),\r\n          null,\r\n          index,\r\n        ),\r\n      )\r\n    } else {\r\n      dateUnits.push(\r\n        new DateFormat(fmtName, null, defaultDateValues[fmtName], -1),\r\n      )\r\n    }\r\n  }\r\n  //进行验证是否真的是符合传入格式的字符串\r\n  fmt = fmt.replaceAll('`', 'd')\r\n  if (!new RegExp(fmt).test(dateStr)) {\r\n    return null\r\n  }\r\n  //进行一次排序, 依次对字符串进行截取\r\n  dateUnits.sort(function (a, b) {\r\n    return a.index - b.index\r\n  })\r\n  for (var i = 0, length = dateUnits.length; i < length; i++) {\r\n    const format = dateUnits[i].format\r\n    if (format == null) {\r\n      continue\r\n    }\r\n    const matchDateUnit = new RegExp(format).exec(dateStr)\r\n    if (matchDateUnit !== null && matchDateUnit.length > 0) {\r\n      dateStr = dateStr.replace(matchDateUnit[0], '')\r\n      dateUnits[i].value = matchDateUnit[0]\r\n    }\r\n  }\r\n  //将截取完成的信息封装成对象并格式化标准的日期字符串\r\n  const obj = dateUnits.toObject(function (item) {\r\n    return {\r\n      key: item.name,\r\n      value: item.value,\r\n    }\r\n  })\r\n  const date = '{year}-{month}-{day}T{hour}:{minute}:{second}.{milliSecond}'.format(\r\n    obj,\r\n  )\r\n  try {\r\n    return new Date(date)\r\n  } catch (e) {\r\n    return null\r\n  }\r\n}\r\n\r\n//下面是上面的 Date.of() 使用的一些辅助方法\r\n\r\n/**\r\n * 替换所有匹配exp的字符串为指定字符串\r\n * @param exp 被替换部分的正则\r\n * @param newStr 替换成的字符串\r\n */\r\nString.prototype.replaceAll = function (exp, newStr) {\r\n  return this.replace(new RegExp(exp, 'gm'), newStr)\r\n}\r\n\r\n/**\r\n * 原型：字符串格式化\r\n * @param args 格式化参数值\r\n */\r\nString.prototype.format = function (args) {\r\n  var result = this\r\n  if (arguments.length < 1) {\r\n    return result\r\n  }\r\n\r\n  var data = arguments // 如果模板参数是数组\r\n  if (arguments.length === 1 && typeof args === 'object') {\r\n    // 如果模板参数是对象\r\n    data = args\r\n  }\r\n  for (var key in data) {\r\n    var value = data[key]\r\n    if (undefined !== value) {\r\n      result = result.replaceAll('\\\\{' + key + '\\\\}', value)\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * 为 js 的 String 添加填充字符串的静态方法\r\n * @param item 填充的元素\r\n * @param length 填充的长度\r\n * @returns {string} 填充得到的字符串\r\n */\r\nString.fill = function (item, length) {\r\n  var result = ''\r\n  for (var i = 0; i < length; i++) {\r\n    result += item\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * js 数组转换为一个 Object 对象\r\n * @param fn 转换方法\r\n * @returns {{}} 得到的 Object 对象\r\n */\r\nArray.prototype.toObject = function (fn) {\r\n  const obj = {}\r\n  this.map(fn).forEach(function (item) {\r\n    obj[item.key] = item.value\r\n  })\r\n  return obj\r\n}\r\n```\r\n\r\nCode Gist：https://gist.github.com/rxliuli/a81f058d03a99cbd08d6ca6095b2c7cb\r\n\r\n那么，关于 `JavaScript` 中的字符串解析为 `Date` 对象就到这里啦，如果有什么错误/更好的建议都可以提出来呢\r\n","createdTime":1580652937860,"updatedTime":1608894648499,"resources":[],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"8067904c808c4b02a99eb2caeb9e7214","title":"JavaScript 使用递归异步的请求","body":"## 场景\r\n\r\n之前写了个 `user.js` 脚本来抓取百度网盘的文件元信息列表，用来进行二级查看和分析,脚本放到了 [GreasyFork](https://greasyfork.org/zh-CN/scripts/375701)。最开始为了简化代码直接使用了 `async/await` 单线程进行异步请求，导致请求的速度十分不理想！  \r\n关键代码如下\r\n\r\n```js\r\n/**\r\n * 文件数据信息类\r\n */\r\nclass File {\r\n  /**\r\n   * 构造函数\r\n   * @param {String} path 全路径\r\n   * @param {String} parent 父级路径\r\n   * @param {String} name 文件名\r\n   * @param {String} size 大小(b)\r\n   * @param {String} isdir 是否为文件\r\n   * @param {String} {origin} 百度云文件信息的源对象\r\n   */\r\n  constructor(path, parent, name, size, isdir, origin) {\r\n    this.path = path\r\n    this.parent = parent\r\n    this.name = name\r\n    this.size = size\r\n    this.isdir = isdir\r\n    this.orgin = origin\r\n  }\r\n}\r\n/**\r\n * 获取指定文件夹下的一级文件/文件夹列表\r\n * @param {String} path 绝对路径\r\n * @returns {Promise} 文件/文件夹列表\r\n */\r\nasync function getDir(path) {\r\n  var baseUrl = 'https://pan.baidu.com/api/list?'\r\n  try {\r\n    var res = await fetch(`${baseUrl}dir=${encodeURIComponent(path)}`)\r\n    var json = await res.json()\r\n    return json.list\r\n  } catch (err) {\r\n    console.log(`读取文件夹 ${path} 发生了错误：`, err)\r\n    return []\r\n  }\r\n}\r\n/**\r\n * 将数组异步压平一层\r\n * @param {Array} arr 数组\r\n * @param {Function} fn 映射方法\r\n */\r\nasync function asyncFlatMap(arr, fn) {\r\n  var res = []\r\n  for (const i in arr) {\r\n    res.push(...(await fn(arr[i])))\r\n  }\r\n  return res\r\n}\r\n/**\r\n * 递归获取到所有的子级文件/文件夹\r\n * @param {String} path 指定获取的文件夹路径\r\n * @returns {Array} 指定文件夹下所有的文件/文件夹列表\r\n */\r\nasync function syncList(path) {\r\n  var fileList = await getDir(path)\r\n  return asyncFlatMap(fileList, async (file) => {\r\n    var res = new File(\r\n      file.path,\r\n      path,\r\n      file.server_filename,\r\n      file.size,\r\n      file.isdir,\r\n      file,\r\n    )\r\n    if (res.isdir !== 1) {\r\n      return [res]\r\n    }\r\n    return [res].concat(await syncList(res.path))\r\n  })\r\n}\r\n```\r\n\r\n可以看到，使用的方式是 `递归 + 单异步`，这就导致了脚本的效率不高，使用体验很差！\r\n\r\n## 解决\r\n\r\n吾辈想要使用多异步模式，需要解决的问题有二：\r\n\r\n- 如何知道现在有多个异步在执行并且在数量过多时等待\r\n- 如何知道所有的请求都执行完成了然后结束\r\n\r\n解决思路\r\n\r\n1. 判断并限定异步的数量\r\n   1. 添加记录正在执行的异步请求的计数器 `execQueue`\r\n   2. 每次请求前先检查 `execQueue` 是否到达限定值\r\n      - 如果没有，`execQueue + 1`\r\n      - 如果有，等待 `execQueue` 减小\r\n   3. 执行请求，请求结束 `execQueue - 1`\r\n2. 判断所有请求都执行完成\r\n   1. 添加记录正在等待的异步请求的计数器 `waitQueue`\r\n   2. 在判断 `execQueue` 是否到达限定值之前 `waitQueue + 1`\r\n   3. 在判断 `execQueue` 是否到达限定值之后（等待之后） `waitQueue - 1`\r\n   4. 请求结束后判断 `waitQueue` 和 `waitQueue` 是否均为 `0`\r\n      - 是：返回结果\r\n      - 否：什么都不做\r\n\r\n具体实现如下\r\n\r\n```js\r\n/**\r\n * 文件数据信息类\r\n */\r\nclass File {\r\n  /**\r\n   * 构造函数\r\n   * @param {String} path 全路径\r\n   * @param {String} parent 父级路径\r\n   * @param {String} name 文件名\r\n   * @param {String} size 大小(b)\r\n   * @param {String} isdir 是否为文件\r\n   * @param {String} {origin} 百度云文件信息的源对象\r\n   */\r\n  constructor(path, parent, name, size, isdir, origin) {\r\n    this.path = path\r\n    this.parent = parent\r\n    this.name = name\r\n    this.size = size\r\n    this.isdir = isdir\r\n    this.orgin = origin\r\n  }\r\n}\r\n/**\r\n * 等待指定的时间/等待指定表达式成立\r\n * @param {Number|Function} param 等待时间/等待条件\r\n * @returns {Promise} Promise 对象\r\n */\r\nfunction wait(param) {\r\n  return new Promise((resolve) => {\r\n    if (typeof param === 'number') {\r\n      setTimeout(resolve, param)\r\n    } else if (typeof param === 'function') {\r\n      var timer = setInterval(() => {\r\n        if (param()) {\r\n          clearInterval(timer)\r\n          resolve()\r\n        }\r\n      }, 100)\r\n    } else {\r\n      resolve()\r\n    }\r\n  })\r\n}\r\n/**\r\n * 获取指定文件夹下的一级文件/文件夹列表\r\n * @param {String} path 绝对路径\r\n * @returns {Promise} 文件/文件夹列表\r\n */\r\nasync function getDir(path) {\r\n  var baseUrl = 'https://pan.baidu.com/api/list?'\r\n  try {\r\n    var res = await fetch(`${baseUrl}dir=${encodeURIComponent(path)}`)\r\n    var json = await res.json()\r\n    return json.list\r\n  } catch (err) {\r\n    console.log(`读取文件夹 ${path} 发生了错误：`, err)\r\n    return []\r\n  }\r\n}\r\n/**\r\n * 递归获取所有文件/文件夹\r\n * 测试获取 34228 条数据\r\n * - 100 线程：156518ms\r\n * - 5   线程：220500ms\r\n * - 1   线程：超过 20min\r\n * 实现：\r\n * 1. 请求文件夹下的所有文件/文件夹\r\n * 2. 如果是文件则直接添加到结果数组中\r\n * 3. 如果是文件夹则递归调用当前方法\r\n * @param {String} [path] 指定文件夹，默认为根路径\r\n * @param {Number} [limit] 指定限定异步数量，默认为 5\r\n * @returns {Promise} 异步对象\r\n */\r\nasync function asyncList(path = '/', limit = 5) {\r\n  return new Promise((resolve) => {\r\n    var count = 1\r\n    var execCount = 0\r\n    var waitQueue = 0\r\n\r\n    // 结果数组\r\n    var result = []\r\n    async function children(path) {\r\n      waitQueue++\r\n      await wait(() => execCount < limit)\r\n      waitQueue--\r\n      execCount++\r\n      getDir(path).then((fileList) => {\r\n        fileList.forEach((file) => {\r\n          var res = new File(\r\n            file.path,\r\n            path,\r\n            file.server_filename,\r\n            file.size,\r\n            file.isdir,\r\n            file,\r\n          )\r\n          result.push(res)\r\n          if (res.isdir === 1) {\r\n            children(res.path)\r\n          }\r\n        })\r\n        if (--execCount === 0 && waitQueue === 0) {\r\n          resolve(result)\r\n        }\r\n      })\r\n    }\r\n    children(path)\r\n  })\r\n}\r\n```\r\n\r\n吾辈使用 `timing` 函数测试了一下\r\n\r\n```js\r\n/**\r\n * 测试函数的执行时间\r\n * 注：如果函数返回 Promise，则该函数也会返回 Promise，否则直接返回执行时间\r\n * @param {Function} 需要测试的函数\r\n * @returns {Number|Promise} 执行的毫秒数\r\n */\r\nfunction timing(fn) {\r\n  var begin = performance.now()\r\n  var result = fn()\r\n  if (!(result instanceof Promise)) {\r\n    return performance.now() - begin\r\n  }\r\n  return result.then(() => performance.now() - begin)\r\n}\r\n```\r\n\r\n请求了 `2028` 次，两个函数的性能比较如下（单位是毫秒）\r\n\r\n- `asyncList`：109858.80000004545\r\n- `syncList`：451904.3000000529\r\n\r\n差距近 4.5 倍，几乎等同于默认的异步倍数了，看起来优化还是很值得呢！\r\n\r\n> 附：其实 `asyncList` 如果使用单异步的话效率反而更低，因为要做一些额外的判断导致单次请求更慢，但因为多个异步请求同时执行的缘故因此缺点被弥补了\r\n\r\n---\r\n\r\n那么，关于 JavaScript 使用递归异步的请求就到这里啦\r\n","createdTime":1580652937865,"updatedTime":1608894632606,"resources":[],"tags":[{"id":"1de1ff51140a44d5a2c223459dabcc37","title":"异步","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"6586ffbb50ac49ceb31397ce58b49f16","title":"JavaScript 避免使用 if-else 的方法","body":"## 场景\r\n\r\n在日常编写 JavaScript 代码的过程中，或许会遇到一个很常见的问题。根据某个状态，进行判断，并执行不同的操作。吾辈并不是说 `if-else` 不好，简单的逻辑判断 `if-else` 毫无疑问是个不错的选择。然而在很多时候似乎我们习惯了使用 `if-else`，导致代码不断庞大的同时复杂度越来越高，所有的 JavaScript 代码都乱作一团，后期维护时越发困难。\r\n\r\n> [GitHub](https://github.com/rxliuli/avoid-if-else-example), [演示地址](https://avoid-if-else.rxliuli.com/)\r\n\r\n例如下面这段代码，点击不同的按钮，显示不同的面板。\r\n\r\n```html\r\n<!-- index.html -->\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\r\n    <title>JavaScript 避免使用 if-else</title>\r\n  </head>\r\n  <body>\r\n    <main>\r\n      <div id=\"tab\">\r\n        <label>\r\n          <input type=\"radio\" data-index=\"1\" name=\"form-tab-radio\" />\r\n          第一个选项卡\r\n        </label>\r\n        <label>\r\n          <input type=\"radio\" data-index=\"2\" name=\"form-tab-radio\" />\r\n          第二个选项卡\r\n        </label>\r\n        <label>\r\n          <input type=\"radio\" data-index=\"3\" name=\"form-tab-radio\" />\r\n          第三个选项卡\r\n        </label>\r\n      </div>\r\n      <form id=\"extends-form\"></form>\r\n    </main>\r\n    <script src=\"./js/if-else.js\"></script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n```js\r\n// js/if-else.js\r\ndocument.querySelectorAll('#tab input[name=\"form-tab-radio\"]').forEach((el) => {\r\n  el.addEventListener('click', () => {\r\n    const index = el.dataset.index\r\n    const header = el.parentElement.innerText.trim()\r\n    // 如果为 1 就添加一个文本表单\r\n    if (index === '1') {\r\n      document.querySelector('#extends-form').innerHTML = `\r\n            <header><h2>${header}</h2></header>\r\n            <div>\r\n              <label for=\"name\">姓名</label>\r\n              <input type=\"text\" name=\"name\" id=\"name\" />\r\n            </div>\r\n            <div>\r\n              <label for=\"age\">年龄</label>\r\n              <input type=\"number\" name=\"age\" id=\"age\" />\r\n            </div>\r\n            <div>\r\n              <button type=\"submit\">提交</button> <button type=\"reset\">重置</button>\r\n            </div>\r\n          `\r\n    } else if (index === '2') {\r\n      document.querySelector('#extends-form').innerHTML = `\r\n        <header><h2>${header}</h2></header>\r\n        <div>\r\n          <label for=\"avatar\">头像</label>\r\n          <input type=\"file\" name=\"avatar\" id=\"avatar\" />\r\n        </div>\r\n        <div><img id=\"avatar-preview\" src=\"\" /></div>\r\n        <div>\r\n          <button type=\"submit\">提交</button> <button type=\"reset\">重置</button>\r\n        </div>\r\n      `\r\n      function readLocalFile(file) {\r\n        return new Promise((resolve, reject) => {\r\n          const fr = new FileReader()\r\n          fr.onload = (event) => {\r\n            resolve(event.target.result)\r\n          }\r\n          fr.onerror = (error) => {\r\n            reject(error)\r\n          }\r\n          fr.readAsDataURL(file)\r\n        })\r\n      }\r\n      document.querySelector('#avatar').addEventListener('change', (evnet) => {\r\n        const file = evnet.target.files[0]\r\n        if (!file) {\r\n          return\r\n        }\r\n        if (!file.type.includes('image')) {\r\n          return\r\n        }\r\n        readLocalFile(file).then((link) => {\r\n          document.querySelector('#avatar-preview').src = link\r\n        })\r\n      })\r\n    } else if (index === '3') {\r\n      const initData = new Array(100).fill(0).map((v, i) => `第 ${i} 项内容`)\r\n      document.querySelector('#extends-form').innerHTML = `\r\n        <header><h2>${header}</h2></header>\r\n        <div>\r\n          <label for=\"search-text\">搜索文本</label>\r\n          <input type=\"text\" name=\"search-text\" id=\"search-text\" />\r\n          <ul id=\"search-result\"></ul>\r\n        </div>\r\n      `\r\n      document\r\n        .querySelector('#search-text')\r\n        .addEventListener('input', (evnet) => {\r\n          const searchText = event.target.value\r\n          document.querySelector('#search-result').innerHTML = initData\r\n            .filter((v) => v.includes(searchText))\r\n            .map((v) => `<li>${v}</li>`)\r\n            .join()\r\n        })\r\n    }\r\n  })\r\n})\r\n```\r\n\r\n那么，我们可以如何优化呢？\r\n\r\n## 抽取函数\r\n\r\n稍有些经验的 developer 都知道，如果一个函数过于冗长，那么就应该将之分离成多个单独的函数。\r\n\r\n所以，我们的代码变成了下面这样\r\n\r\n实现思路\r\n\r\n1. 抽取每个状态对应执行的函数\r\n2. 根据状态使用 `if-else/switch` 判断然后调用不同的函数\r\n\r\n```js\r\n// 抽取函数\r\n\r\nfunction switchFirst(header) {\r\n  document.querySelector('#extends-form').innerHTML = `\r\n          ${header}\r\n          <div>\r\n            <label for=\"name\">姓名</label>\r\n            <input type=\"text\" name=\"name\" id=\"name\" />\r\n          </div>\r\n          <div>\r\n            <label for=\"age\">年龄</label>\r\n            <input type=\"number\" name=\"age\" id=\"age\" />\r\n          </div>\r\n          <div>\r\n            <button type=\"submit\">提交</button> <button type=\"reset\">重置</button>\r\n          </div>\r\n        `\r\n}\r\n\r\nfunction switchSecond(header) {\r\n  document.querySelector('#extends-form').innerHTML = `\r\n      ${header}\r\n      <div>\r\n        <label for=\"avatar\">头像</label>\r\n        <input type=\"file\" name=\"avatar\" id=\"avatar\" />\r\n      </div>\r\n      <div><img id=\"avatar-preview\" src=\"\" /></div>\r\n      <div>\r\n        <button type=\"submit\">提交</button> <button type=\"reset\">重置</button>\r\n      </div>\r\n    `\r\n  function readLocalFile(file) {\r\n    return new Promise((resolve, reject) => {\r\n      const fr = new FileReader()\r\n      fr.onload = (event) => {\r\n        resolve(event.target.result)\r\n      }\r\n      fr.onerror = (error) => {\r\n        reject(error)\r\n      }\r\n      fr.readAsDataURL(file)\r\n    })\r\n  }\r\n  document.querySelector('#avatar').addEventListener('change', (evnet) => {\r\n    const file = evnet.target.files[0]\r\n    if (!file) {\r\n      return\r\n    }\r\n    if (!file.type.includes('image')) {\r\n      return\r\n    }\r\n    readLocalFile(file).then((link) => {\r\n      document.querySelector('#avatar-preview').src = link\r\n    })\r\n  })\r\n}\r\n\r\nfunction switchThree(header) {\r\n  const initData = new Array(100).fill(0).map((v, i) => `第 ${i} 项内容`)\r\n  document.querySelector('#extends-form').innerHTML = `\r\n      ${header}\r\n      <div>\r\n        <label for=\"search-text\">搜索文本</label>\r\n        <input type=\"text\" name=\"search-text\" id=\"search-text\" />\r\n        <ul id=\"search-result\"></ul>\r\n      </div>\r\n    `\r\n  document.querySelector('#search-text').addEventListener('input', (evnet) => {\r\n    const searchText = event.target.value\r\n    document.querySelector('#search-result').innerHTML = initData\r\n      .filter((v) => v.includes(searchText))\r\n      .map((v) => `<li>${v}</li>`)\r\n      .join()\r\n  })\r\n}\r\n\r\nfunction switchTab(el) {\r\n  const index = el.dataset.index\r\n  const header = `<header><h2>${el.parentElement.innerText.trim()}</h2></header>`\r\n  // 如果为 1 就添加一个文本表单\r\n  if (index === '1') {\r\n    switchFirst(header)\r\n  } else if (index === '2') {\r\n    switchSecond(header)\r\n  } else if (index === '3') {\r\n    switchThree(header)\r\n  }\r\n}\r\n\r\ndocument.querySelectorAll('#tab input[name=\"form-tab-radio\"]').forEach((el) => {\r\n  el.addEventListener('click', () => switchTab(el))\r\n})\r\n```\r\n\r\n## ES6 class：有限状态机\r\n\r\n如果你知道 ES6 的 `class` 的话，应该也了解到目前 js 可以使用 `class` 模拟面向对象的继承，以及多态。\r\n\r\n实现思路\r\n\r\n1. 创建一个基类，并在其中声明一个需要被子类重写的方法\r\n2. 根据不同的状态创建不同的子类，并分别实现基类的方法\r\n3. 添加一个 `Builder` 类，用于根据不同的状态判断来创建不同的子类\r\n4. 调用者使用 `Builder` 类构造出来的对象调用父类中声明的方法\r\n\r\n具体实现\r\n\r\n```js\r\n// 有限状态机\r\n\r\nclass Tab {\r\n  // 基类里面的初始化方法放一些通用的操作\r\n  init(header) {\r\n    const html = `\r\n      <header><h2>${header}</h2></header>\r\n      ${this.initHTML()}\r\n    `\r\n    document.querySelector('#extends-form').innerHTML = html\r\n  }\r\n\r\n  // 给出一个方法让子类实现，以获得不同的 HTML 内容\r\n  initHTML() {}\r\n}\r\n\r\nclass Tab1 extends Tab {\r\n  // 实现 initHTML，获得选项卡对应的 HTML\r\n  initHTML() {\r\n    return `\r\n      <div>\r\n        <label for=\"name\">姓名</label>\r\n        <input type=\"text\" name=\"name\" id=\"name\" />\r\n      </div>\r\n      <div>\r\n        <label for=\"age\">年龄</label>\r\n        <input type=\"number\" name=\"age\" id=\"age\" />\r\n      </div>\r\n      <div>\r\n        <button type=\"submit\">提交</button> <button type=\"reset\">重置</button>\r\n      </div>\r\n    `\r\n  }\r\n}\r\n\r\nclass Tab2 extends Tab {\r\n  initHTML() {\r\n    return `\r\n    <div>\r\n      <label for=\"avatar\">头像</label>\r\n      <input type=\"file\" name=\"avatar\" id=\"avatar\" />\r\n    </div>\r\n    <div><img id=\"avatar-preview\" src=\"\" /></div>\r\n    <div>\r\n      <button type=\"submit\">提交</button> <button type=\"reset\">重置</button>\r\n    </div>\r\n    `\r\n  }\r\n  // 重写 init 初始化方法，并首先调用基类通用初始化的方法\r\n  init(header) {\r\n    super.init(header)\r\n    document.querySelector('#avatar').addEventListener('change', (evnet) => {\r\n      const file = evnet.target.files[0]\r\n      if (!file) {\r\n        return\r\n      }\r\n      if (!file.type.includes('image')) {\r\n        return\r\n      }\r\n      this.readLocalFile(file).then((link) => {\r\n        document.querySelector('#avatar-preview').src = link\r\n      })\r\n    })\r\n  }\r\n  // 子类独有方法\r\n  readLocalFile(file) {\r\n    return new Promise((resolve, reject) => {\r\n      const fr = new FileReader()\r\n      fr.onload = (event) => {\r\n        resolve(event.target.result)\r\n      }\r\n      fr.onerror = (error) => {\r\n        reject(error)\r\n      }\r\n      fr.readAsDataURL(file)\r\n    })\r\n  }\r\n}\r\n\r\nclass Tab3 extends Tab {\r\n  initHTML() {\r\n    return `\r\n      <div>\r\n        <label for=\"search-text\">搜索文本</label>\r\n        <input type=\"text\" name=\"search-text\" id=\"search-text\" />\r\n        <ul id=\"search-result\" />\r\n      </div>\r\n    `\r\n  }\r\n  init(header) {\r\n    super.init(header)\r\n    const initData = new Array(100).fill(0).map((v, i) => `第 ${i} 项内容`)\r\n    document\r\n      .querySelector('#search-text')\r\n      .addEventListener('input', (evnet) => {\r\n        const searchText = event.target.value\r\n        document.querySelector('#search-result').innerHTML = initData\r\n          .filter((v) => v.includes(searchText))\r\n          .map((v) => `<li>${v}</li>`)\r\n          .join()\r\n      })\r\n  }\r\n}\r\n\r\nclass TabBuilder {\r\n  /**\r\n   * 获取一个标签子类对象\r\n   * @param {Number} index 索引\r\n   * @returns {Tab} 子类对象\r\n   */\r\n  static getInstance(index) {\r\n    // Tab 构造类，用于根据不同的状态 index 构造不同的 Tab 对象\r\n    const tabMap = new Map(\r\n      Object.entries({\r\n        1: () => new Tab1(),\r\n        2: () => new Tab2(),\r\n        3: () => new Tab3(),\r\n      }),\r\n    )\r\n    return tabMap.get(index)()\r\n  }\r\n}\r\n\r\ndocument.querySelectorAll('#tab input[name=\"form-tab-radio\"]').forEach((el) => {\r\n  el.addEventListener('click', () =>\r\n    // 首先通过 Builder 构造类获取 Tab 子类实例，然后调用初始化方法 init\r\n    TabBuilder.getInstance(el.dataset.index).init(\r\n      el.parentElement.innerText.trim(),\r\n    ),\r\n  )\r\n})\r\n```\r\n\r\n主要优势\r\n\r\n- 分离了状态与执行函数之间的关联，具体执行由具体的子类决定\r\n- 子类允许包含独有的属性/方法\r\n- 可扩展性更好，随时可以扩展任意多个子类\r\n\r\n## ES6 class：无限状态机\r\n\r\n上面使用 class 继承多态实现的状态机虽然很好，但却并不能应对 **不确定** 具体有多少种状态的情况。因为每个子类都与父类有着强关联，直接在 Builder 类中进行了声明。那么，有没有一种方式，可以在添加/删除后不影响基类或者构造类呢？\r\n\r\n1. 创建一个基类，并在其中声明一个需要被子类重写的方法\r\n2. 添加一个 `Builder` 类，具体子类对应的状态由子类的某个属性决定\r\n3. 根据不同的状态创建不同的子类，并分别实现基类的方法，调用 `Builder` 类的方法注册自身\r\n   > 此处因为 js 无法通过反射拿到所有子类，所以子类需要在 `Builder` 类注册自己\r\n4. 使用 `Builder` 构造子类对象，并调用基类声明的方法\r\n\r\n具体实现\r\n\r\n```js\r\n// 无限状态机\r\n\r\nclass Tab {\r\n  // 基类里面的初始化方法放一些通用的操作\r\n  init(header) {\r\n    const html = `\r\n      <header><h2>${header}</h2></header>\r\n      ${this.initHTML()}\r\n    `\r\n    document.querySelector('#extends-form').innerHTML = html\r\n  }\r\n\r\n  // 给出一个方法让子类实现，以获得不同的 HTML 内容\r\n  initHTML() {}\r\n}\r\n\r\n/**\r\n * 状态机\r\n * 用于避免使用 if-else 的一种方式\r\n */\r\nclass StateMachine {\r\n  static getBuilder() {\r\n    const clazzMap = new Map()\r\n    /**\r\n     * 状态注册器\r\n     * 更好的有限状态机，分离子类与构建的关系，无论子类如何增删该都不影响基类及工厂类\r\n     */\r\n    return new (class Builder {\r\n      // noinspection JSMethodCanBeStatic\r\n      /**\r\n       * 注册一个 class，创建子类时调用，用于记录每一个 [状态 => 子类] 对应\r\n       * @param state 作为键的状态\r\n       * @param clazz 对应的子类型\r\n       * @returns {*} 返回 clazz 本身\r\n       */\r\n      register(state, clazz) {\r\n        clazzMap.set(state, clazz)\r\n        return clazz\r\n      }\r\n\r\n      // noinspection JSMethodCanBeStatic\r\n      /**\r\n       * 获取一个标签子类对象\r\n       * @param {Number} state 状态索引\r\n       * @returns {QuestionType} 子类对象\r\n       */\r\n      getInstance(state) {\r\n        const clazz = clazzMap.get(state)\r\n        if (!clazz) {\r\n          return null\r\n        }\r\n        //构造函数的参数\r\n        return new clazz(...Array.from(arguments).slice(1))\r\n      }\r\n    })()\r\n  }\r\n}\r\n/**\r\n * 状态注册器\r\n * 更好的有限状态机，分离子类与构建的关系，无论子类如何增删该都不影响基类及工厂类\r\n */\r\nconst builder = StateMachine.getBuilder()\r\n\r\nconst Tab1 = builder.register(\r\n  1,\r\n  class Tab1 extends Tab {\r\n    // 实现 initHTML，获得选项卡对应的 HTML\r\n    initHTML() {\r\n      return `\r\n        <div>\r\n          <label for=\"name\">姓名</label>\r\n          <input type=\"text\" name=\"name\" id=\"name\" />\r\n        </div>\r\n        <div>\r\n          <label for=\"age\">年龄</label>\r\n          <input type=\"number\" name=\"age\" id=\"age\" />\r\n        </div>\r\n        <div>\r\n          <button type=\"submit\">提交</button> <button type=\"reset\">重置</button>\r\n        </div>\r\n      `\r\n    }\r\n  },\r\n)\r\n\r\nconst Tab2 = builder.register(\r\n  2,\r\n  class Tab2 extends Tab {\r\n    initHTML() {\r\n      return `\r\n      <div>\r\n        <label for=\"avatar\">头像</label>\r\n        <input type=\"file\" name=\"avatar\" id=\"avatar\" />\r\n      </div>\r\n      <div><img id=\"avatar-preview\" src=\"\" /></div>\r\n      <div>\r\n        <button type=\"submit\">提交</button> <button type=\"reset\">重置</button>\r\n      </div>\r\n      `\r\n    }\r\n    // 重写 init 初始化方法，并首先调用基类通用初始化的方法\r\n    init(header) {\r\n      super.init(header)\r\n      document.querySelector('#avatar').addEventListener('change', (evnet) => {\r\n        const file = evnet.target.files[0]\r\n        if (!file) {\r\n          return\r\n        }\r\n        if (!file.type.includes('image')) {\r\n          return\r\n        }\r\n        this.readLocalFile(file).then((link) => {\r\n          document.querySelector('#avatar-preview').src = link\r\n        })\r\n      })\r\n    }\r\n    // 子类独有方法\r\n    readLocalFile(file) {\r\n      return new Promise((resolve, reject) => {\r\n        const fr = new FileReader()\r\n        fr.onload = (event) => {\r\n          resolve(event.target.result)\r\n        }\r\n        fr.onerror = (error) => {\r\n          reject(error)\r\n        }\r\n        fr.readAsDataURL(file)\r\n      })\r\n    }\r\n  },\r\n)\r\n\r\nconst Tab3 = builder.register(\r\n  3,\r\n  class Tab3 extends Tab {\r\n    initHTML() {\r\n      return `\r\n      <div>\r\n        <label for=\"search-text\">搜索文本</label>\r\n        <input type=\"text\" name=\"search-text\" id=\"search-text\" />\r\n        <ul id=\"search-result\" />\r\n      </div>\r\n    `\r\n    }\r\n    init(header) {\r\n      super.init(header)\r\n      const initData = new Array(100).fill(0).map((v, i) => `第 ${i} 项内容`)\r\n      document\r\n        .querySelector('#search-text')\r\n        .addEventListener('input', (evnet) => {\r\n          const searchText = event.target.value\r\n          document.querySelector('#search-result').innerHTML = initData\r\n            .filter((v) => v.includes(searchText))\r\n            .map((v) => `<li>${v}</li>`)\r\n            .join()\r\n        })\r\n    }\r\n  },\r\n)\r\n\r\ndocument.querySelectorAll('#tab input[name=\"form-tab-radio\"]').forEach((el) => {\r\n  el.addEventListener('click', () =>\r\n    // 调用方式不变\r\n    builder\r\n      .getInstance(Number.parseInt(el.dataset.index))\r\n      .init(el.parentElement.innerText.trim()),\r\n  )\r\n})\r\n```\r\n\r\n主要优势\r\n\r\n- 可扩展性最好，添加/修改/删除子类不影响父类及构造类\r\n\r\n---\r\n\r\n那么，关于 JavaScript 中如何避免使用 if-else 到这里就结束啦\r\n","createdTime":1580652937877,"updatedTime":1608894426064,"resources":[],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""},{"id":"f93505f3e7994607aec7afec41480af3","title":"经验","parent_id":""}]},{"id":"5086a3fce1c344cda12d9c9b73804b53","title":"论国内的通货膨胀率","body":"## 前言\r\n\r\n偶然在知乎上面看到的一个长篇评论，对国内的通货膨胀讲解的有理有据，便于此转载一下，供人参考。\r\n\r\n> 原文地址: <https://www.zhihu.com/question/21470072>\r\n\r\n## 正文\r\n\r\n小猫猫\r\n\r\n最近有三个信息正在证明我的一个判断，2017 年通货紧缩周期形成后，2018 年将进入自我加速阶段；\r\n\r\n1，按美元计算，2017 年现金收益率高达 11%\r\n\r\n2，任志强先生透露许多房企开年就没钱了，在拼命找钱\r\n\r\n3，某高官在最近达沃斯论坛表态，中国将致力缩小和平衡外贸顺差\r\n\r\n一，假设你 2017 年初有 100 万现金，投入保守型理财，年收益率约 4%，年初人民币约 6.9 元 = 1 美元，年底升值到约 6.4 元，升值超过 7%，这样，你年收益将高达 11%，\r\n\r\n除个别房价上涨的城市外，这是国内理财的最好收益了，而房子你却无法兑现。。。\r\n\r\n大多数网友都没有留意这个现金收益率的历史意义，因为这是 40 年来从未有过的事，\r\n\r\n想想看，从 1978 年到 1998 年，尽管房价没有上涨多少，但物价不断快速上涨，你的现金收益远远落后于物价涨幅。\r\n\r\n想想看，从 1998 年起，不但物价继续涨，房价更是一路飙升，你手里的现金看着看着就变了水。。。\r\n\r\n然而，2017 年，悄悄地就颠倒了这个持续 40 年的历史，现金为王时代来临。。。而且可以预计的是，2018 年不但将延续，而且可能还会加速。。。\r\n\r\n二，据凤凰台报道，任志强先生最近讲话透露，一些房企一开年就国内外到处融资，甚至在出售资产，许多房企没钱了，在拼命找钱。\r\n\r\n这就怪了，刚刚过去的 2017 年可是中国房地产历史上的最大丰收年，销售额和销售面积双双创新高，千亿级房企已经多达 10 多家，如此大好形势，房地产企业怎么会却缺钱呢，这逻辑不通啊，\r\n\r\n任志强先生可是长期活跃在地产界的大佬，对中国的房地产状况可是了如指掌，所述一定是事实。。。\r\n\r\n这是为什么？\r\n\r\n这就是房地产泡沫即将破裂的明显迹象，是通货紧缩正在自我加速的典型现象。。。\r\n\r\n因为，在过去的一年中，房企收获最丰，但负债增加也最多，著名房企万科的资产负债率在销售额突破 5000 亿的同时，负债率也上升了 2 个百分点。。。\r\n\r\n负债率上升意味着资金流动性更加紧张，此时更需要融资，更需要银行贷款，可银行呢，正在缓缓对房地产企业贷款融资关上大门。。。\r\n\r\n许多网友一定会说，这是房地产调控政策的原因，是银监会管控结果。。。\r\n\r\n是吗，这个问题并不好判断，如果房价泡沫由此开始破裂，到底是政策调控的结果，还是房地产泡沫已经到了不得不破的程度。。。\r\n\r\n接下来我简要介绍一个著名日本电影《穿越泡沫时代》。。。大家就知道为什么难以判断了。。。\r\n\r\n未完，待续\r\n\r\nhnpjcw 2018-01-28 13:25\r\n好吧，继续学习。\r\n尽天事听天人命 2018-01-28 13:32\r\n16，17 年房子都已经去库存了，应该赚得盆满钵满，怎么还缺钱？贪心不足，摊子越铺越大？\r\n剩余 17 条\r\n评论 看全部\r\nx8596t\r\n2018-01-28 15:04\r\n26026 楼\r\n继续 385\r\n\r\n日本电影《穿越泡沫时代》拍摄于 2007 年，就是说，拍摄于中国还没有房价泡沫概念之前，或者说，电影作者完全没有受到今天中国房地产泡沫影响，但描述的现象竟然与今天的中国惊人一致。。。\r\n\r\n镜头一，1990 年 3 月 30 日，日本财政部宣布，一项关于限制银行对不动产贷款的条例生效，财务省发言人说，实施这个条例是为了限制地产投机，土地价格降了，大家就买得起房了。。。\r\n\r\n镜头二，真弓小姐从 2007 年穿越到 1990 年房价泡沫高企的日本经济繁荣时代，见到一位刚毕业的大学生，大学生高兴的说，他找到了著名长银银行工作，真弓告诉他，这个银行将会倒闭，\r\n\r\n这个大学生惊讶的回答，银行怎么会倒闭，不可能。\r\n\r\n镜头三，真弓小姐参加了泡沫时代的一个同学聚会，刚报到就得到了一叠免费乘坐出租车的免费卷，接着还得到了一位初次见面的未来明星大方送给她的一条项链，还幸运抽到了奖金 200 万日元。\r\n\r\n仅仅一天什么都没干，就得到了这么多，真弓小姐禁不住高喊；泡沫经济万岁\r\n\r\n镜头四；一群官员，国内外商人正在密谋出台限制不动产银行贷款条例，也是穿越过来的真弓小姐的母亲告诉与会者，千万不要出台这个条例，否则泡沫破裂，房价下跌，银行破产，经济将进入大萧条。。。\r\n\r\n与会财政省官员说，要的就是这个效果，如是把真弓母亲抓起来，要强行通过条咧。。。\r\n\r\n镜头五，经过一番激烈斗争，新任财政省官员宣布；这个限制房地产投机贷款条例宣布撤销，因为这个条例会对经济产生很大的收紧作用，会有很多银行破产。。。\r\n\r\n然而，非常令人深思的是；有记者提问，那面对高房价，财政省打算什么都不做吗？\r\n\r\n新任财政省官员环顾左右而言它；我们目前的繁荣不可能不付代价的结束，泡沫最终会破裂。。。\r\n\r\n当记者紧紧追问财政省将会做些什么时；财政省官员答复，他要回家了。。。\r\n\r\n网友们看看，这些镜头与当今中国的状况是多么的惊人一致；\r\n\r\n银行绝不可能倒闭\r\n\r\n泡沫时代是多么繁荣，钱是多么容易赚\r\n\r\n精英鼓吹，底线是房价泡沫不能破，房价泡沫破裂是美国阴谋，美国发力就可以刺破中国房价泡沫。。。\r\n\r\n2017 年一连串的限购，限售，禁止贷款流入房地产市场的监管政策，条例出台。。。。\r\n\r\n按日本经验，这一系列限制房地产政策出台是可能刺破房价泡沫的，繁荣将会结束，银行将会破产。。。\r\n\r\n不过从这个日本电影判断，至今在日本有一种质疑的舆论，质疑当时的日本政府一系列限制地产的政策是否正确，如果不刺破，是否日本的经济繁荣就能继续。。。\r\n\r\n我解读这个日本电影，。。。看来刺破泡沫是有政治风险的。。。\r\n\r\n所以，由此我得出结论，恐怕没有任何行政力量会愿意主动刺破泡沫，一定会尽最大努力延续泡沫繁荣经济的。。。\r\n\r\n因为，美联储主席格林斯潘说过；泡沫只有破裂后，才知道是泡沫，换句话就是；\r\n\r\n谁知道，今天中国的房地产到底是不是泡沫呢，不是还有经济精英说，房价还没有泡沫，房价还会永远涨。。。哈哈，网友们，你们说呢？\r\n继续 387\r\n\r\n今天讨论一个重要的经济原理，消费，投资与经济增长的关系。\r\n\r\n近几年，统计局官员总是摇头晃脑的说，消费占 GDP 比重不断提高，这是经济结构改善，是消费逐渐成为推动经济增长主要动力。。。云云。\r\n\r\n例如，2016 年消费占 GDP 比重达到 64.6%，比 2015 年提高了 9.7 个百分点。。。统计局官员总是把这些当好消息告诉我们。。。\r\n\r\n我十分不解这些经济精英的经济学知识是在哪里学来的？\r\n\r\n1，消费是不可能推动经济增长的，只有投资才能推动经济增长。\r\n\r\n2，消费占 GDP 比重提高决不代表经济结构改善。\r\n\r\n为什么？先从第 1 点说起；\r\n\r\n举例 1，某家庭农场年农产品收入 100 万，那这个家庭该如何安排消费与投资呢？理论上有如下几种安排；\r\n\r\n1,100 万全部吃光用光，这样该农场第二年就没法延续生产了，因为第 2 年的生产需要一定的投入，包括种子，化肥，农药，更新和维修农具，水利灌溉设施等等，这些都需要钱，需要投资。\r\n\r\n所以，如果该农场不投资，不要说第 2 年会增产，连再生产都不可能。\r\n\r\n2，80 万用于消费，20 万用于投资，简单再生产得以继续进行。\r\n\r\n所以，没有投资就不会有经济增长，连简单再生产都无法进行。\r\n\r\n再看所谓消费占比提高是经济结构改善，经济原理证明同样不符合逻辑。\r\n\r\n举例 2，该农场全家节衣缩食，50 万用于消费，50 万用于投资，购买了先进农业机械，第 2 年生产率提高，收入增多。不但可以提高生活水平，还可以滚动高效发展。\r\n\r\n比如，该农场节衣缩食拿出 50 万购买先进农具等，收入从 100 万提高到 120 万，即使还是按 50% 比例消费，50% 比例投资，不但实际消费提高了 10 万，投资也提高了 10 万，生活改善，还为下一年的农场发展奠定基础。\r\n\r\n从以上 2 个例子，我们很容易就理解了如下两条经济原理。\r\n\r\n1，没有投资就没有经济发展\r\n\r\n2，勤俭节约，适当减少消费，提高投资比例更有利于经济发展，所谓消费比例提高就是经济结构改善是逻辑不通的。\r\n\r\n难道中国的经济学家这么笨，连这点道理都不明白，网友一定一头雾水，一定抱着深深的怀疑看待我这个观点。。。\r\n\r\n其实，点破了很简单；\r\n\r\n这个所谓消费占 GDP 比重上升是从美国那里学的，因为美国经济消费占 GDP 比重高达 70% 以上，美国是高收入发达国家，我们要成为高收入国家，当然也要提高消费比重。。。\r\n\r\n这真的让人哭笑不得，不禁使我想起了古代著名的削足适履的故事。。。\r\n\r\n未完待续\r\n\r\n老鼠飞上天 2018-01-30 19:22\r\n“勤俭节约，适当减少消费，提高投资比例更有利于经济发展” 的目的是为了将来更好的消费。所以，生产和消费终究是要平衡的。\r\nty_XEN 2018-01-30 19:25\r\n刻舟求剑，呵呵！同意！\r\n剩余 15 条\r\n评论 看全部\r\nx8596t\r\n2018-01-30 20:22\r\n26123 楼\r\n继续 388\r\n\r\n接着 387 聊；为什么学美国提高消费占 GDP 比重是削足适履；\r\n\r\n道理很简单，因为中美两国发展阶段不同。\r\n\r\n美国消费比重高是经济全球化的结果，是美国的无可奈何的选择。\r\n\r\n二战后，美国经济快速发展，生活水平提高，劳动力变得昂贵，于是大量向发展中国家转移制造业，制造业逐渐空心化，消费比重当然不得不提高，否则经济就垮下去了，\r\n\r\n所以美国这 20 多年来，不断鼓励老百姓借贷消费，以维持经济增长，结果仍然是经济增长缓慢，基础设施等得不到更新，。。\r\n\r\n这就是许多中国人跑到美国去，大喊美国落后，中国基础设施先进的原因。。。这就是美国经济消费比例高，投资比例小的原因造成的。。。\r\n\r\n反观中国，我们仍然处于中等收入的发展阶段，这个阶段不但制造业不能丢，还得大力投资，还得加快发展，改变严重的地方贫富差距，完善基础设施等等。。。为中国尽快成为高收入国家奠定基础。。。\r\n\r\n换句话说，中国还没有到要提高消费比重阶段，还不应该提倡消费，反而还应该提倡勤俭节约，积累资本，增加投资。。。\r\n\r\n为什么中国现在就进入了消费比重不断提高的经济状况了呢，这其实不是什么好的经济现象。。。\r\n\r\n原因是什么呢，其实很简单，就是债务太高，因为多年来总是吃光用光，投资全靠借，弄得债台高筑。。。\r\n\r\n俗话说，不听老人言，吃亏在眼前，\r\n\r\n亚当斯密早在 200 多年前的《国富论》中告诫我们说；勤劳不能积累资本，只有节俭才能积累资本。。。\r\n\r\n同时还告诫我们说，不要从银行借贷投资，不要从银行借贷消费，银行的借贷只应该用于解决商人的资金流动性，盘活商人的准备金。。。\r\n\r\n例如，某商人有 100 万流动资金，但他往往不能全部投入，得留一部分作为备用金，以防万一，亚当斯密赞成银行给这位商人借贷流动资金，这样该商人就可以把全部 100 万用于经营了，就提高了资金运用效率。。。\r\n\r\n许多网友一定认为这亚当斯密理论太老化了，不适应今天的经济发展了。。。\r\n\r\n真的吗，我下面举出 2 个实际例子，网友大家评；\r\n\r\n举例 1，前 30 年计划经济时，是没有银行借贷业务的，就是说，不能从银行借贷投资，借贷消费的。。。\r\n\r\n所以，那时要投资就得勤俭节约，积累资金用于投资，发展经济，所以，那时有个广为人知的口号 “为国家建设节约每一分钱”\r\n\r\n这种硬碰硬的经济发展方式，导致 30 年后留下了一个十分良好的发展基础，这就是；既无内债又无外债。。。干干净净，无债一身轻。。。\r\n\r\n有网友一定说，那时经济发展慢，现在虽然欠债，但发展快，是吗？恐怕要打个疑问号。\r\n\r\n我们实事求是的比较一下；\r\n\r\n举例 2，\r\n\r\n假设 1949 年到 1979 年 30 年中国经济从 1000 亿发展到 2000 亿，经济总量提高了 1 倍。但没有 1 分钱债务。\r\n\r\n假设按不变价算，从 1979 年到 2009 年 30 年，经济总量从 2000 亿提高到 8000 亿，经济总量提高了 4 倍，但负债 6000 亿，结果是；去掉这 6000 亿债务还是只增长 2000 亿，不会比前 30 年强。。。\r\n\r\n有网友一定不服气；不对不对，债务虽然很高，但主要是国内债务，是左手与右手，左\r\n\r\n口袋与右口袋的关系。。。\r\n\r\n真的吗，国内债务是左手与右手的关系吗，或者说，还不还无所谓。。。。\r\n\r\n真的吗，我们从今天起，就大手一挥，所有债务一风吹。。。。\r\n\r\n到底是不是无所谓，是不是可以一风吹。。。我们接下来讨论，甚至辩论。。。\r\n\r\n未完，待续\r\n\r\n夏尘埃 2013 2018-01-30 20:33\r\n请教楼主，看新闻开发商竞拍价格第一后继续自己给自己加价拿地是什么意思？\r\nxieyu007007 2018-01-30 21:05\r\n套路，不敢不加价，你懂的\r\n剩余 12 条\r\n评论 看全部\r\nx8596t\r\n2018-01-31 04:38\r\n26137 楼\r\n@第一 MP 2018-01-30 23:02:10\r\n\r\n楼主所言差矣，有空再辩。先指出一点，前 30 年经济增长一倍，后 30 年增长 4 倍，去掉债务和前 30 年一样…… 这犯了最基本的错误，不能用货币量和 Gdp 量对比，因为单位是货币单位，而不是购买力。经济发展的结果不是一个 Gdp 数字，而是物质财富，近 30 年的物质财富是前 30 年的上百倍，只是价格大大降低，最终用货币量衡量差异不明显。这就是所谓的 “百姓福祉”，负作用是污染等…… 大家就想想现在你家里有啥东西，79 年家里有啥东西……......\r\n\r\n---\r\n\r\n你对前 30 年充满了偏见；\r\n\r\n1，按国家统计局数据，年平均 GDP 增速，前 30 年只比后 30 年低一个百分点。何来什么几百倍。\r\n\r\n2，电视机，手机等都是科技发明进步，再落后的非洲国家也在用手机。\r\n\r\n3,1979 年与 1949 年比那也是天翻地覆的变化，\r\n\r\n4，如果你去过印度，你就知道前 30 年是如何伟大了。\r\n\r\n5，前 30 年给中国留下了两弹一星，完整的科研工业体系，基本普及高小，初中教育，医疗卫生体系，获得如此巨大成就却没有给后面的留下一分钱债务。。。\r\n\r\n假设，1979 年留下的是一个债台高筑的经济体，你认为还有可能搞什么改革开放吗？？\r\n\r\n第一 MP 2018-01-31 04:53\r\n我对前 30 年没有偏见，前 30 年和后 30 年的差异是百姓生活的财富差别，这个可以让大家来感觉…… 两弹一星恰恰是你前述所有例子的反证，即没有任何收益的资本投入，只不过是国家资本。抛开安全因素，纯从经济学来说，两弹一星就是你说的货币黑洞，朝鲜仍有这个黑洞\r\n第一 MP 2018-01-31 05:08\r\n1979 如果留下的是一个债务重重的经济体，还会有现在的改革开放吗？…… 没错啊，假设 49 年改革开放，估计 1979 年就债务重重了，不就是改革开放提前了吗？呵呵。最终不就是要进步吗\r\n剩余 19 条\r\n评论 看全部\r\nx8596t\r\n2018-01-31 14:22\r\n26164 楼\r\n继续 389\r\n\r\n今天聊 2 个问题；\r\n\r\n1，国内债务是不是左手与右手，债务可以一风吹\r\n\r\n2，近年消费占 GDP 比重上升，是经济结构改善吗，消费成为推动经济增长主要动力是好现象吗？\r\n\r\n先看第 1 个问题；\r\n\r\n不用说什么深奥的大道理，只需凭生活常识就可以明白。\r\n\r\n2017 年大约有 20 多万亿理财产品，也就是 20 万亿债务，不还了，一风吹了，那就是有无数人的 20 多万亿现金没了，可能吗，你同意吗。\r\n\r\n2017 年全银行系统有贷款余额 120 万亿，如果不还了，一风吹了，结果就是所有银行倒闭无数次，更重要的是 120 万亿货币也没了，也就是现有 170 万亿货币总量只剩下 50 万亿了。。。\r\n\r\n所以说国内债务不要紧的专家就是砖家，普通百姓恐怕是在用骨头想。。。\r\n\r\n相反，外债倒是好办，免掉就免掉了，只会占便宜，例如中国免掉非洲国家那么多债务，欠债国家就占便宜了。。。\r\n\r\n我们再看第 2 个问题；\r\n\r\n我们用数据说话；\r\n\r\n2015 年，M2 净增额 16.4 万亿，居民贷款 3.8 万亿，占货币净增额的比例；23%\r\n\r\n2016 年，M2 净增额 15.8 万亿，居民贷款 6.3 万亿，占货币净增额的比例；40%\r\n\r\n2017 年，M2 净增额 12.6 万亿，居民贷款 7.1 万亿，占货币净增额的比例；56%\r\n\r\n网友看看，居民贷款占比快速上升，一年比一年高，与这几年消费占 GDP 比重不断升高完全一致\r\n\r\n这就道出了一个公开的秘密，即；消费占 GDP 比重是靠普通百姓大幅增加借债取得的。\r\n\r\n也就是说，老百姓用大幅透支自己的未来收入，提高了消费占 GDP 比重，\r\n\r\n这就是经济精英口中的经济结构改善？\r\n\r\n这就是经济精英口中的消费成为经济增长主要推动力？\r\n\r\n这只能说明，中国老百姓很可爱，很善良，很爱国，宁愿用将来的节衣缩食来支持所谓经济结构改善，成为推动经济增长的主要动力。。。。\r\n\r\n天理良心何在。。。\r\n\r\n以上数据可都是来自国家统计局，我可没有加油添醋，只是分析角度不一样，网友们认为这种分析角度对吗。。。\r\n\r\n接下来我们还可以从另一个角度分析 GDP。。。\r\n\r\n未完，待续\r\n\r\nty_133106929 2018-01-31 14:27\r\n这一段不错？？拜读\r\n夏尘埃 2013 2018-01-31 14:42\r\n如楼主所言，贷款投资基建不可以，贷款消费不可以，那经济增长何去何从呢？\r\n剩余 15 条\r\n评论 看全部\r\nx8596t\r\n2018-02-01 13:50\r\n26191 楼\r\n继续 390\r\n\r\n今天我们从另一个角度看 GDP，即；从老百姓的实际生活角度看。。。\r\n\r\n对普通百姓来说，是不会关心 GDP 增速的，老百姓只关心自己的生活水平能否实实在在提高，实际收入能否跑赢物价涨幅，跑赢多少。。。\r\n\r\n从过去 30 多年的实际看，中国 GDP 一直高速增长，总体来说，老百姓收入还是跑赢物价涨幅的，就是说老百姓的生活水平这几十年有了极大提高。。。（请网友注意，我这里说的是收入跑赢物价涨幅，与以前说过的银行利率跑赢物价涨幅是两个不同概念）\r\n\r\n问题是老百姓并不满意，或者说还有相当部分老百姓感到忧虑，或者说有如下三大不良后果；\r\n\r\n1，收入跑赢了 CPI 物价涨幅，但却跑输了房价涨幅，甚至是大幅跑输了房价，\r\n\r\n以北京为例，10 年前 1 个月工资再不济也能买 0.2 个平米房子吧，现在恐怕连 0.1 个平米也买不到了吧。。。\r\n\r\n这就造成了相当数量的高负债房奴几乎生活在还贷压力和房价下跌的恐惧之中。生活一点都不轻松。。。\r\n\r\n2，延迟退休，养老金亏空的忧虑和恐惧，严重损害了普通老百姓的长远利益。。\r\n\r\n别小看养老金不够发的问题，今天绝大部分西方发达国家几乎都深陷不得不动用大量财政资金来弥补养老亏空和福利的黑洞中。。。成为西方国家财政不可持续的关键因素之一。。。\r\n\r\n原因很简单，这就是西方市场经济国家长期运用凯恩斯理论，刻意用温和通货膨胀刺激经济增长的必然结果。因为长期的通货膨胀导致货币价值不断下降，也必然导致积累的巨量的养老金价值下降。。。\r\n\r\n例如，30 年前当你月工资 100 元时，按 28% 比例交 28 元养老金，但 30 年后这 28 元养老金已经贬值到几乎一钱不值，等于白交了。。。\r\n\r\n用凯恩斯理论发展创造 GDP 的后果是非常残酷的，网友们到西方国家去，你们可以看到大量白发苍苍的老头老太太还在工作，而中国的许多中年妇女已经在每天跳广场舞了。。。\r\n\r\n比较起来，中国妇女 50 岁退休是不是太幸福了，然而这个幸福竟然将伴随所谓几十年高速经济发展的赞歌声中而结束。。。真是莫大的讽刺啊。。。。\r\n\r\n3，无论是政府还是普通百姓无一不是债台高筑，特别是西方老百姓，遗憾的是中国老百姓近年也急起直追。。。不说了，说起来那些高负债房奴满眼都是泪。。。\r\n\r\n好了，当我们明白依托凯恩斯理论的 GDP 发展效果和弊病后，再具体分析一下中国 2017 年 GDP。。。看看会给我们带来那些启发。。。\r\n继续 391\r\n\r\n今天紧贴时事，聊一个最时髦话题，为什么这半年来人民币会疯狂升值，这出乎许多人的预料，包括经济精英。。。\r\n\r\n与此同时，美元变得越来越宝贵，资本管制是越来越严格，国外消费 1000 元以上要报央行，一年最高 10 万元限额。。等等。\r\n\r\n我要给这个最新经济现象一个有点难听的名称；美元荒\r\n\r\n这个 “美元荒” 是继 “钱荒” 后的又一个信号，是客观经济规律给中国经济的又一个重要信号，通知中国经济必须放弃行政力量与客观经济规律规律的抗衡了，再不放弃，客观经济规律就会让你按下葫芦浮起瓢，顾得了这头，顾不了那头。。。\r\n\r\n网友们应该记得，仅仅 3 到 4 年前，中国还在嫌美元太多，官员感叹，外汇储备太多，头痛，老百姓在国外买买买，，牛气冲天，转眼之间又变成美元太少，闹起 “美元荒” 了。\r\n\r\n这到底是怎么回事，为什么会这样，下一步会发生什么，让我们从最基本的经济原理谈起。。。\r\n\r\n懂得一些最基本经济原理是非常重要的，为什么古代 “秀才不出门，全知天下事”，就是因为秀才掌握了知识，所以能够根据道听途说得来的信息，判断天下的大趋势。。。\r\n\r\n美元荒是反常经济现象，其根源就在中国经济精英界长期坚持的对外贸易错误观点；\r\n\r\n这个错误观点就是；出口多好。出口顺差好，以至于行政力量长期只关注 GDP，而不重视对外贸易均衡和人民币汇率对国家经济的决定性作用。。。\r\n\r\n我们还是以举例的方式来说明一些基本经济原理；\r\n\r\n举例 1，在黄金白银作货币时代，大清朝对英帝国大量出口丝绸，茶叶等，大量白银源源不断流于入中国。。。\r\n\r\n与此同时，大清朝闭关锁国，制造种种障碍禁止英国的先进商品进口，从而造成中英贸易不平衡。。。\r\n\r\n英帝国只好来邪的，默许英国商人出口鸦片来实现中英贸易平衡。。。结果导致了著名的鸦片战争。。。\r\n\r\n请网友注意，鸦片战争签订不平等条约中最重要条款就是开放中国沿海 10 多个城市港口，与外国自由贸易。。。\r\n\r\n在今天的人看来，不就是开放对外贸易吗，咋看都不像是不平等条约啊。。。\r\n\r\n这个例子充分说明，两国之间的贸易一定要平衡，如果一国对另一国长期贸易顺差，那对逆差国是不公平的，如果长期逆差，会遭到逆差国反抗，甚至战争的。。。\r\n\r\n以上例子说的是黄金白银为货币的时代，那么今天的纸币体系时代呢？\r\n\r\n未完，待续\r\n\r\nhnpjcw 2018-02-02 14:27\r\n学习了。\r\nty_XEN 2018-02-02 14:59\r\n太好了，期待下文！\r\n剩余 11 条\r\n评论 看全部\r\nx8596t\r\n2018-02-02 15:38\r\n26219 楼\r\n继续 382\r\n\r\n接着聊 “美元荒”\r\n\r\n在纸币体系时代，对外贸易有个很大不同特点；\r\n\r\n在黄金白银时代，你出口越多，顺差越大，你获取的黄金白银就越多，你就越占便宜，因为你得到的是有价值的真金白银，而不是纸币，而纸币的价值是由该国政府决定的，多印刷，该国纸币价值就降低。。。\r\n\r\n所以，在纸币时代，就更要讲究进出口平衡了，否则你多出口，得到的是人家的纸币，是没有多大意义的，实际是吃亏的、、、\r\n\r\n以中美贸易为例，中国对美国贸易长期顺差，多年来，每年对美贸易顺差少则 1 到 2 千亿，多则 3 到 4 千亿美元，这其实都是美元纸币，对中国经济是没有多大实际意义的，\r\n\r\n可，中国经济精英像着了迷一样，喜欢美元纸币，。。\r\n\r\n2005 年，美国贸易代表来到中国，试图强迫人民币升值，甚至建议人民币一次性升值 25%，相关官员连连摆手，不可能，那怎么得了，那会有多少血汗工厂关闭，多少工人失业啊。。。\r\n\r\n结果达成妥协，人民币缓慢升值。。。由于升值力度不够，对美贸易顺差仍然高居不下，外汇储备继续飙升，到 2014 年，外汇储备达到创纪录的约 4 万亿美元。。。\r\n\r\n然而，这 4 万亿美元哪里来的呢，事实证明大部分是从美联储印钞机来的。。。不信，请看下列数据；\r\n\r\n2008 年中国外汇储备突破 1 万亿美元，达到 10600 亿美元。到 2014 年增加到 4 万亿美元，净增约 3 万亿美元。\r\n\r\n2008 年美联储开动印钞机救市，美联储资产负债表中的美元基础货币从约 9000 亿美元上升到 2014 年的约 4.5 万亿美元，净增约 3.6 万亿美元。\r\n\r\n这是偶然的巧合吗，事实是；美联储印刷的 3.5 万亿美元纸币确实大部分到了中国。。。\r\n\r\n想想看，中国这 3 万亿美元外汇储备可是无数打工者的血汗劳动换来的，是无数个集装箱，装载着无数中国产实体商品，浩浩荡荡运到美国换来的。。。\r\n\r\n而美国呢，美联储仅仅开动印钞机，印了 3 万亿美元给中国，轻轻松松换来中国巨额实物商品，美国人占大便宜了。。。。\r\n\r\n可，遗憾的是，美国占了便宜还卖乖，年年指责中国操纵汇率，要求中国开放市场，特别是中国农业深受其害，作为大豆之乡的中国，大豆首先沦陷。。。\r\n\r\n说起中美贸易，真是满眼都是泪啊，。。。\r\n\r\n然而事情还远未就此结束，特朗普政府上台后，变本加厉。。。。\r\n\r\n未完，待续\r\n\r\n碧海蓝天已被使用 2018-02-02 16:43\r\n同意楼主观点，楼主知识渊博，佩服佩服。\r\nty\\_终于白首 872 2018-02-02 17:12\r\n这回不是马上超美了！看看血月今年注定是不平凡的一年，满朝文武拿绿卡！老百姓苦了\r\n剩余 13 条\r\n评论 看全部\r\nx8596t\r\n2018-02-03 13:13\r\n26252 楼\r\n继续 393\r\n\r\n前面聊 “美元荒” 的 392 错成了 382.\r\n\r\n为什么说，与前任美国总统不同，特朗普政府会变本加厉压制中国，会不惜重大代价也要缩小中国对美贸易顺差呢？\r\n\r\n道理不复杂，这就是因为美联储的缩表，也就是美联储不再开动印钞机给美国政府输血了。\r\n\r\n那，为什么缩表就会导致特朗普政府要尽力缩小对外贸易逆差呢，特别是来自中国的逆差，。。\r\n\r\n举例；假设 2018 年美国出口 7000 亿美元，进口 1 万亿美元，逆差 3000 亿美元，\r\n\r\n按照以前的做法，美联储开动印钞机印刷了 3000 亿美元投入市场，意味着这 3000 亿美元间接支付了 3000 亿美元逆差，否则，这 3000 亿美元就得从存量资金中支付，也就是得从老百姓口袋中支付。。。\r\n\r\n这就导致美国老百姓的实际消费会减少 3000 亿美元，直接就拉低美国的 GDP，当然特朗普就不会干了，\r\n\r\n而来自中国的 3000 多亿美元逆差占全美贸易逆差 5000 亿美元的约 70%，理所当然，特朗普政府会盯住中国不放了。。。\r\n\r\n为了美国的 GDP，精明商人特朗普早就拨拉着算盘算好了，一些中国经济精英还在试图用所谓双输，双赢的道理像说服前任美国总统一样，说服特朗普，恐怕只能是一厢情愿了。\r\n\r\n面对超 3 万亿美元的巨额中国外汇储备，已经关闭印钞机的美国不惦念，谁惦念，中国有句老话；这钱啊，不怕贼偷，就怕贼惦念。。。。哈哈。\r\n\r\n现在我们再来看中国。。。\r\n\r\n未完，待续\r\n\r\n评论 看全部\r\nx8596t\r\n2018-02-03 14:41\r\n26256 楼\r\n继续 394\r\n\r\n接着 393 聊，我们来看中国的对美贸易顺差，解释一下为什么今天中国闹 “美元荒” 的真实原因；\r\n\r\n先看下列两组数据；\r\n\r\n第一组；从 2014 年到 2017 年中国对美贸易顺差数据\r\n\r\n2014 年，对美贸易顺差约 2400 亿美元\r\n\r\n2015 年，对美贸易顺差约 3700 亿美元\r\n\r\n2016 年，对美贸易顺差约 3400 亿美元，\r\n\r\n2017 年，估计对美贸易顺差也在 3000 亿美元以上。\r\n\r\n四年合计；对美贸易顺差总额约 1.25 万亿美元。\r\n\r\n众所周知，按 GDP 核算公式；顺差就直接增加了中国 GDP，相反逆差的美国 GDP 就被直接拉低了。。。\r\n\r\n1.25 万亿美元啊，这对中美两国都是巨额，假设某个经济谋士拨拉着算盘，把这个帐算给特朗普看，特朗普岂不勃然大怒，咬牙切齿。。。\r\n\r\n如果换成早几年，美联储 QE 量化宽松，大印美元时，美国还会偷着乐，可美国关闭印钞机已经 2 年多了，现在支付中国的可不是兑了水的美元啊，可是真金白银了啊。。。\r\n\r\n再看第二组数据；2014 年和 2017 年 M2 货币总量与外汇储备的比值\r\n\r\n2014 年中国 M2 总量约 122 万亿，外汇储备约 4 万亿美元，当年平均汇率；1 美元 = 6.14 元\r\n\r\n换算成比值；122 万亿 ÷（4 万亿 X6.14）=4.96 元\r\n\r\n这意味着人民币还有很大的升值压力。因为实际汇率高于比值 1.18 元\r\n\r\n2017 年中国 M2 总量约 167 万亿，外汇储备约 3.1 万亿美元，按当年平均汇率；大约 1 美元 = 6.4 元。\r\n\r\n换算成比值；167 万亿 ÷（3.1 万亿 X6.4）=8.41 元\r\n\r\n这意味着人民币有很大的贬值压力，因为实际汇率低于比值 2.01 元。\r\n\r\n网友们看清楚了，人民币汇率处于一种相互矛盾的状态中。\r\n\r\n从对美贸易顺差看，人民币币值被严重低估，人民币有着巨大的升值潜力。\r\n\r\n相反，从 M2 总额与外汇储备币值看，人民币却是被严重高估，人民币有着巨大的贬值压力。\r\n\r\n这到底信哪一个，问题是，这两个都是真实的，信了这个就信不了那个，反之亦然。。。\r\n\r\n这就导致我们看到了极不正常的人民币汇率波动现象；\r\n\r\n2015 年 811 汇改，人民币从 6.2 元一路贬值到 2017 年初的 6.95 元，央行不得不釜底抽薪，收缩境外人民币，以牺牲人民币国际化进程为代价止住了贬值。\r\n\r\n不料，从 2017 年 5 月起，到 2018 年 1 月，人民币又一路疯狂升值，从 6.95 元一路升值到今天的 6.30 元。。。\r\n\r\n有经济精英一定会说，这很好，很正常吗，央行要的就是汇率双向波动吗。。。\r\n\r\n真的吗？我一句话就要让这些经济精英目瞪口呆，哑口无言。。。。\r\n\r\n很简单，因为这人民币升值和贬值的原因竟然都是同一个；“缺美元” 或叫 “美元荒”\r\n\r\n这就是天下奇闻了，无论升值贬值都是缺美元，这太奇怪了，因为按原理只有贬值才是缺美元啊，怎么升值也会缺美元呢？\r\n\r\n我估计，问遍世界上的经济学家，他们只能感叹，奇迹啊，奇迹啊，这奇迹真的只有中国才能创造。。。\r\n\r\n所以有中国经济学家常常引以为傲，中国经济奇迹是西方经济学不能解释的，这是又一证明。。。哈哈。\r\n\r\n那么到底是什么原因会造成这种经济现象呢？\r\n\r\n我曾经做个形象的比喻，把客观经济规律比作幼小树苗，把行政权力比作大石头，大石头不断压迫树苗，但树苗却一定会顽强抗衡，一定会绕过大石头，顽强地从石头缝隙里弯弯曲曲生长出来，不过虽然生长出来了，但一定是扭扭曲曲的。。。。\r\n\r\nty\\_自留地 66 2018-02-03 15:11\r\n有道理\r\n大狗熊 2018-02-03 15:12\r\n继续\r\n剩余 19 条\r\n评论 看全部\r\nx8596t\r\n2018-02-04 13:51\r\n26278 楼\r\n@atian110 2018-02-04 11:15:19\r\n\r\n在第十六届企业发展高层论坛上的讲话\r\n\r\n楼继伟\r\n\r\n2018 年 1 月 28 日\r\n\r\n谢谢主持人的介绍，各位来宾，女士们，先生们：\r\n\r\n大家下午好！非常高兴参加此次论坛。按照会议安排，围绕新时代宏观经济形势这个主题，我主要从以下三个方面谈谈个人的观点。\r\n\r\n第一，年度经济指标是超预期的，反映出良性变化的趋势。\r\n\r\n2017 年主要经济指标都在可接受的范围，部分指标甚至在上限区。从经济总量看，GDP 达到 82.7 万亿元，增长 6.......\r\n\r\n---\r\n\r\n继续 395\r\n\r\n非常感谢这位 ati110 网友，我正打算就楼先生提供的经济数据聊一下中美日三国经济发展趋势，恰遇网友提供这个资料，真是人多力量大啊。。。\r\n\r\n我们先以楼先生提供的数据，列出中美日三国的最重要宏观经济数据如下；\r\n\r\n日本；拆借利率；0.01%，政府债务；250%/GDP，M2；200%/GDP，总债务；400/GDP\r\n\r\n美国；拆借利率；1.1%， 政府债务；100%/GDP，M2；91%/GDP，总债务；300/GDP\r\n\r\n中国；拆借利率；4.09%，政府债务；50%.GDP，M2；200%/GDP, 总债务；300/GDP\r\n\r\n依据以上数据，我们基本可以判断，中美日三国经济状况都没能跳出凯恩斯理论框框，即；都不同程度的掉入了流动性陷阱。\r\n\r\n让我们一个个看；\r\n\r\n先看日本；\r\n\r\n日本的流动性陷阱特征最为明显和典型，银行拆借利率竟然是负数，-0.01，这在市场经济中是不可想象的，甚至也超越了凯恩斯理论，凯恩斯想到了零利率，却万万没想到还有负利率，由此可见日本掉入流动性陷阱之深。。。\r\n\r\n日本在 20 多年前房价泡沫破裂后，就逐步掉入流动性陷阱，利率逐步降至零，甚至负利率，毫无疑问，零利率就是流动性陷阱的最典型特征，因为零利率下就不会有什么经济增长和物价上涨，经济基本就是死水一潭。。。\r\n\r\n这个道理很简单；资本是逐利的，零利率意味着资本没有利益了，没利益资本就不会投资，就不会活跃，经济发展当然就会停滞。。。\r\n\r\n最近 5 年，安倍政府采用极端的货币宽松手段，但也没能把日本经济拉出流动性陷阱泥潭，这负的拆借利率就是证明。。。\r\n\r\n有网友会说，最近 2 年，日本 GDP 还有了 2% 左右的增速，可网友注意没有，这是以日元贬值为代价的，\r\n\r\n安倍政府这几年大量货币宽松，导致日元从 1 美元 = 80 多日元，贬值到 1 美元 = 约 110 日元，这种以日元贬值为代价的 GDP 增长，导致按美元计算的 GDP 实际没啥增长，最近几年日本人均 GDP 在世界排名是下降的，这就是证明，证明日本经济根本就没有跳出流动性陷阱，依靠货币宽松搞出的 GDP 增长实际只是货币泡沫。。。\r\n\r\n这就是凯恩斯理论的威力，摆在日本面前只有一条出路；将通货紧缩进行到底，消灭债务，消灭货币，经济才能真正恢复健康，否则经济发展就只能停滞。。。\r\n\r\n但是，日本经济并非没有亮点，日本经济唯一的亮点就是；失业率低，几乎处于充分就业状况，这就怪了，经济不好，这就业怎么会好呢。。。\r\n\r\n大家记得，有中国经济精英还煞有介事的计算过，GDP 增长一个百分点，就可以创造就业 150 万，因为中国每年有超过 1000 万人新增就业，所以 GDP 增速要 7% 左右。。。云云。。。\r\n\r\n然而，日本就业率状况证明中国经济精英的这种观点并不正确，我估计也不会有一个中国经济学者能正确解释日本经济低迷，为何还能充分就业。。。\r\n\r\n这个问题先放一边，我会找机会与网友深入探讨。。。\r\n\r\n我们继续看美国。。。\r\n\r\n未完待续\r\n\r\n碧海蓝天已被使用 2018-02-04 17:52\r\n楼主博学，没有比较就没有鉴别，日本有充分的就业是不是人口少的缘故？\r\n晔小生 2018-02-04 23:50\r\n评论 碧海蓝天已被使用：日本的人口数量低，但是日本的人口密度比中国高很多。日本的就业率高，可能是人口老龄化，制造业这些旧产业一直稳步发展，而且一些新兴产业的涌现。日本的就业率很高，但也并非如报道那样全覆盖的，里面有很多就业人员工资很低的\r\n剩余 4 条\r\n评论 看全部\r\nx8596t\r\n2018-02-04 15:56\r\n26282 楼\r\n继续 396\r\n\r\n现在我们来聊美国的经济发展趋势。\r\n\r\n看上去，美国的经济情况比日本要好得多，无论是总债务还是政府债务要少的多，GDP 增速还有 2 到 3%，M2 也只有 GDP 的 91%。。。\r\n\r\n但美国经济有两大软肋；1 是巨大的泡沫股市，2 是已经永远还不清的政府债务，\r\n\r\n美国股市泡沫如同悬在美国经济头上的达摩斯剑，随时都可能掉下来，美国经济就会好日子不再，直接掉入像日本一样的低利率流动性陷阱。。。\r\n\r\n而支撑美国股市泡沫的又是美国的不断增长的财政开支，一旦财政开支停止增长，或者增长慢了，美国股市就可能随时崩盘，上个星期五，道琼斯指数狂跌 700 点，就是客观经济规律给美国经济的一个警告。。。\r\n\r\n与此同时，美国财政开支的增长越来越不可持续，美国中央银行美联储已经对美国政府关闭了印钞机，\r\n\r\n评论 看全部\r\nx8596t\r\n2018-02-04 17:05\r\n26283 楼\r\n继续 396 第二部分；\r\n\r\n刚才不小心点错了键，还没写完就发出来了，网友见谅。。。\r\n\r\n美联储对美国政府关闭印钞机后，美国财政赤字就只能靠全世界老百姓和政府购买美国国债，就是说，美国国债唯一来源就是存量资金了。。。\r\n\r\n这就引发我们必须讨论和学习的一大经济原理，搞明白这一大经济原理后，我们就会明白，美国经济同样无别路可走，只有一条路，将通货紧缩进行到底，或者说，美国股市泡沫必破。。。\r\n\r\n为什么？是什么样的经济原理有这么大的能耐。。。\r\n\r\n其实很简单，这就是以凯恩斯理论为基础的纸币体系的基本特性决定了。。。。\r\n\r\n这个特性就是，现代市场的所谓经济增长必定是货币数量的增长，或者说没有货币数量的增长就没有经济增长。。。\r\n\r\n例如；美国 2017 年有 GDP 总额 19 万亿美元，增长 3% 就是增长净额为；5700 亿美元，这 5700 亿美元必须对应货币数量的增长。。。\r\n\r\n因为这 5700 亿美元 GDP 增长分为三大块；劳动者工资，资本家利润，政府税收，\r\n\r\n例如，工资增长 2000 亿美元，利润增加 2000 亿美元，税收增加 1700 亿美元，这都得体现在货币数量的增长上。。。\r\n\r\n这就冒出一个天大的问题，美国的货币总量一定得比前一年增加 5700 亿美元，否则工人，资本家，政府就无法得到足额的收入增长。。。对不对。\r\n\r\n那么，这货币增量从哪里来呢？\r\n\r\n按纸币体系原理，只有两个来源；1，美联储印钞机，2，美国各个商业银行创造信用货币。\r\n\r\n这要在中国，增长点货币实在小菜一碟，来个 PSL 印个 1 万亿，PPP 项目银行贷款 2 万亿，三万亿货币就增发出来了，也就是发个红头文件就轻易搞定。。。哈哈\r\n\r\n可在美国却没那么容易，因为美联储，商业银行都是私人性质，都是不能亏本，不能庞氏借债的。。。\r\n\r\n例如，美联储之所以对美国政府关闭印钞机，原因就是看你美国政府还不上了，利息都还不起了，那对不起，不借了，要缩表了。。。\r\n\r\n例如，美国地方政府要借新债还旧债，要搞什么债务置换，对不起，美国商业银行打死也不会同意，因为美国商业银行都是私人银行，这消息传出去，引起储户挤兑，那银行是要破产的。。。\r\n\r\n但美元作为世界货币，美国政府还有一大优势，这就是把散落在世界各地的美元收集起来，同时大幅缩减对外贸易逆差，也就是减少美元流失。。。\r\n\r\n这就是为什么美国总统特朗普一面大肆吹牛，要给每个中产家庭减税 4000 亿美元，同时要大幅减税，吸引苹果公司，微软等美国企业的海外资金流入美国的原因。。。\r\n\r\n与此同时，特朗普还盯上了中国的巨额外汇储备和贸易顺差，中美贸易对决不可避免。。。\r\n\r\n不过理想很丰满，现实很骨感，特朗普虽然野心勃勃，但美国财政现实很可能让他碰个满头包。。。\r\n\r\n为什么，道理很简单；\r\n\r\n要美元回流美国，就得减税，就得加息，现在美国政府债务高达 20 万亿，加一个点利息就增加 2000 亿，预计 2018 年美国财政利息开支将暴增到 5000 多亿美元，庞氏借债已经非常明显，\r\n\r\n如果特朗普政府一意孤行的借债借下去，要不了多久就会遭遇国债违约的风险，这时的特朗普政府就只有乞求美国国会提高预算，要求美联储开动印钞机救美国政府了。。\r\n\r\n可美国的经济制度不是中国式的经济制度，只要美国国债违约消息传出，不等国会投票通过预算，美国股市泡沫可能就破裂了。。。\r\n\r\n史上最大美国股市泡沫破裂，美国经济一头掉进日本式的流动性陷阱就是大概率了。。。\r\n\r\n到时，再能干的特朗普总统也只能仰天长叹，生不逢时啊。。。\r\n\r\n以上议论，许多网友一定听得一愣一愣的，半信半疑，将信将疑，这需要我们进一步把纸币体系和金银货币体系推动经济增长的经济原理探讨清楚，网友就明白了。。。\r\n\r\n未完，待续\r\n继续 397\r\n\r\n接着 396 聊，为什么美国经济最终跳不出凯恩斯理论框框，必定掉入日本式的低利率流动性陷阱。。。\r\n\r\n这得从金银货币体系与现代纸币体系推动经济增长的经济原理说起；\r\n\r\n当今世界，老百姓都习惯了货币超发，认为货币面额只能越来越大，从来没有想过，纸币其实也是可以朝面额越来越小方向发行的。。。\r\n\r\n例如人民币，几十年前最大面额是 10 元，后来就增加了 20,50,100 元面额，面额越来越大，似乎天经地义，一些网友甚至还煞有介事的质问；经济越来越发展，商品越来越多，不发行一定货币怎么行，。。。\r\n\r\n有没有网友想过，其实人民币也可以朝小面额方向发行的，例如，发行分币以下的厘，豪之类的更小面额的纸币。。。\r\n\r\n什么叫解放思想，打破纸币只能朝大面额发行的思想框框，树立纸币也可以朝小面额发行的创新思想就是最新的思想解放潮流。。。，现在不是提倡创新吗。。。哈哈\r\n\r\n一些网友一定提出质疑，纸币朝小面额发行怎么发展经济。。。\r\n\r\n其实，货币面值越来越小才是适合人类经济发展规律的，货币面额越来越大，反而是违背人类经济发展客观规律的。。。\r\n\r\n为什么？\r\n\r\n因为商品价值由其所含社会平均必要劳动时间决定，隋着科学技术的发展，劳动生产率不断提高，生产一件商品所耗费的劳动时间就会越来越少，商品价值就越来越低，价格当然就越来越低了。。\r\n\r\n例如，10 年前一个 100 工人鞋厂，年产 10 万双鞋，10 年后，采用先进制鞋设备，同样 100 个工人年产鞋提高到 100 万双，这样每双鞋耗费的劳动时间就只有 10 分之一了，价值降低了，价格也就应该下降了，。。对不对。\r\n\r\n所以，货币面额越来越小才是符合经济发展客观规律的。。。\r\n\r\n那么如果采用朝面额越来越小的方向发行货币，商品价格越来越便宜，那经济又是如何发展的呢？\r\n\r\n未完，待续\r\n\r\n别崩着我 2018-02-05 15:41\r\n楼主你就在这里忽悠吧\r\n滑雪爱好者 2017 2018-02-05 16:13\r\n评论 别崩着我：你别听啊，欠儿的进来一楼楼追完然后嘲讽一句，滚\r\n剩余 4 条\r\n评论 看全部\r\nx8596t\r\n2018-02-05 14:46\r\n26310 楼\r\n继续 398\r\n\r\n接着聊，货币面值越来越小是怎样推动经济发展的；\r\n\r\n举例 1；\r\n\r\n甲猎人擅长捕猎野兔，平均每 2 小时劳动时间可捕获一只，标价 2 元。\r\n\r\n乙猎人擅长捕猎野鸡，平均每 2 小时劳动时间可捕获一只，标价 2 元。\r\n\r\n甲猎人卖出野兔 1 只，获得 2 元，从乙哪里购得野兔 1 只，甲乙猎人各用 2 小时劳动时间获得一只野兔，或一只野鸡。\r\n\r\n举例 2；\r\n\r\n甲猎人改进捕猎工具，劳动生产率提高，平均每 1 个劳动小时可以捕猎 1 只野兔了，标价 1 元，因为甲的劳动生产率提高，捕猎野兔耗费的劳动时间降低，也就是商品价值降低，所以每只野兔降价为 1 元。\r\n\r\n乙猎人也一样提高了劳动生产率，平均每 1 个劳动小时可以捕猎一只野鸡了。野鸡降价，标价 1 元。\r\n\r\n甲卖掉 2 小时捕猎的 2 只野兔，获得 2 元，从乙哪里买来 2 只野鸡，甲用同样 2 小时的劳动时间，却多换得 1 只野鸡，甲的生活水平提高了，也就是经济发展了。\r\n\r\n反之，对乙猎人也是一样，由于劳动生产率提高，尽管野鸡价格降低了，但同样的 2 小时劳动时间却可以换得更多商品了。。。\r\n\r\n这样，甲乙都会努力提高劳动生产率，劳动积极性更高了，经济也就不断发展了。。。\r\n\r\n因为，因为，因为，甲乙猎人发现，只要劳动生产率提高，即使商品价格下跌，照样可以提高生活水平啊。。。\r\n\r\n从以上 2 个例子，我们明白如下科学道理；\r\n\r\n1，经济发展的决定性因素是劳动生产率提高，只要劳动生产率提高，即使商品降价，同样可以促进经济发展。\r\n\r\n2，货币只是商品交易媒介，与经济发展其实没有关系，货币数量增加，价格上涨不一定代表经济发展了，相反，货币总量不变，商品增加，价格下跌，反而更能代表经济发展，甚至是经济发展更为健康的标志。。。\r\n\r\n我们把以上两个例子扩展到现代经济体制下的一个国家，道理也是一样。。。\r\n\r\n即；我们既可以用超发货币的办法发展经济，也可以用通货紧缩的办法发展经济，也就是说，货币面额朝不断增大的方向发行可以发展经济，也可以朝货币面值不断缩小的方向发行来发展经济，\r\n\r\n最为重要的是，这种通货紧缩发展经济的办法更健康，可持续，因为这是符合人类经济发展规律的，而通货膨胀发展经济的办法是违背客观经济规律的。。。\r\n\r\n而凯恩斯理论是依靠通货膨胀办法发展经济的，是违背人类经济发展客观规律的，最终必将把人类经济引入流动性陷阱的死胡同。。。\r\n\r\n特别要提醒网友的是，连凯恩斯本人都承认，按他的理论发展经济，最终难逃流动性陷阱。。。\r\n\r\n所以，我点赞凯恩斯先生，毕竟是个经济科学家，能够实事求是。。。凯恩斯先生对人类经济，特别是对资本主义经济发展贡献是伟大的，无与伦比的。。。\r\n\r\n所以，今天美国经济，无论特朗普多么能干，经济政策刀刀见血，也是无力回天，而且越是折腾，美国股市崩盘还会越快。。。越会加速掉入日本式流动性陷阱。。。\r\n\r\n时势造英雄，时势也可以灭英雄。。。哈哈\r\n\r\n接下来我们再聊中国。。。\r\n\r\n未完，待续\r\n\r\nty_134772404 2018-02-05 14:55\r\n我就想知道中国 2.3.4 线城市的房价何时崩盘\r\nhnpjcw 2018-02-05 15:12\r\n崩盘的定义呢？\r\n剩余 20 条\r\n评论 看全部\r\nx8596t\r\n2018-02-06 04:33\r\n26332 楼\r\n@金陵徒步者 2018-02-05 19:20:39\r\n\r\n我没有经济理论来反驳 LZ 的通缩发展经济的设想，但是我基于常识，提出几个问题：\r\n\r\nLZ 通缩发展经济理论 是按通货膨胀形态进行倒推的。看起来好像没有错误哦，但为什么那么多政府 和 经济学家没有想到呢？ 凯恩斯那么聪明，难道就没有考虑过把事情颠倒过来操作？？？ 为什么世界范围没有实施的案例？？？？\r\n\r\n原因很简单：通缩不可能发展经济！！！！！！ 通缩下，获利最大的行为是存储货币，自然就会降低消费，经......\r\n\r\n---\r\n\r\n人类经济发展科分为三大阶段；\r\n\r\n1，商品 - 货币 - 商品，这个阶段的货币只是交易媒介。\r\n\r\n2，资本 1 - 商品 - 资本 2，这个阶段是资本主义生产阶段，这个阶段货币转化为资本，货币的主要功能转变为谋取利润服务。资本的逐利性成为推动经济发展的第一动力。。。\r\n\r\n3，劳动 - 劳动，这个阶段作为交易媒介的货币也会逐步消失，人们将直接进行劳动的交换。。。\r\n\r\n这个阶段是建立在生产力，科学技术高度发达的基础上，接下来会与网友详细探讨这个经济发展阶段。。。\r\n\r\n网友们长期生活在市场经济中，已经习惯了资本主义生产方式和交换方式，思维已经定格，所以，一时半时是很难理解通货紧缩是如何发展经济的。。。\r\n\r\n你说得没错，探讨这个阶段难免会牵扯到比特币和区块链技术，。。。争议太激烈，慢慢来吧，来日方长，大家共同探讨，共同学习，共同提高。。。\r\n\r\nx8596t 楼主: 2018-02-06 04:38\r\n顺便说一下，你说为什么没有经济学者探讨这个问题，道理很简单，现在的经济学，经济学家都是为资本主义服务的，探讨通货紧缩下如何发展经济的结论只能是否定资本主义，他们当然没法探讨了，凯恩斯主义就是为挽救资本主义而兴起的一门经济学。。。\r\npxlee21cn 2018-02-06 10:46\r\n楼主思想超前 N 年。劳动 - 劳动，比特币和区块链要去中心化，然而政府不会放取手中的利益， 肯定拼命抵制。\r\n剩余 6 条\r\n评论 看全部\r\nx8596t\r\n2018-02-06 14:00\r\n26353 楼\r\n继续 399\r\n\r\n今天聊一个非常重要，事关网友切身利益的大事，这就是失业问题，因为我预计，2 到 3 年后火热的房价话题将不再被大家关注，人们将越来越关注失业。。。\r\n\r\n早几年，有中国经济精英说，GDP 每增加一个百分点，就可以解决约 150 万人失业，中国每年新增就业人口约 1000 多万，所以 GDP 增速要保持在 7% 左右才能解决就业问题。。。云云。\r\n\r\n可美日近年来在 GDP 增速仅为 1 到 2% 左右的情况下，却几乎达到了 4% 左右的失业率，4% 在经济学上已经可以视为充分就业了。。。\r\n\r\n事实证明，中国经济精英的 GDP 与失业关系的理论是不正确的，因为美日的实践证明，低 GDP 增速下也可以实现高就业。。。\r\n\r\n这是什么原因呢，是什么样的经济原理在起作用呢？还没有看到任何一个经济专家学者对此做过解释，我估计他们也解释不出。。。\r\n\r\n今天，我就与网友深入探讨一下，欢迎网友批评指正，加入讨论。。。\r\n\r\n这个经济原理其实很简单，这就是低利率，零利率的经济环境促成的结果。。\r\n\r\n那为什么低利率，零利率环境下可以出现低经济增长，高就业呢？\r\n\r\n我曾经在前面相关帖文中提出过这样的观点，即；造成失业的主要原因是资本的逐利性，逻辑推理如果要提高就业，就需要去除资本的逐利性。。。\r\n\r\n而美国日本多年来执行低利率，零利率，甚至负利率，这就在一定程度上去除了资本的逐利性，或者说，制造了资本难以获取利润，资本生存艰难的经济环境。。。\r\n\r\n1，零利率消除了大量不劳而获的人群，逼迫所有的人都得劳动，只有劳动才能生存。\r\n\r\n例如，中国财政 2017 年支出国债利息 6130 亿元，加上地方政府利息支出。合计总利息支出大约为 2.5 万亿。。。\r\n\r\n2.5 万亿是什么概念，如果工资 2000 元月，那么将有 1 亿人口可以不劳而获的靠利息收入生活。。。\r\n\r\n一亿人啊，这还仅仅只算政府这一块的利息支出，算上全国各行业，那将是天文数字。\r\n\r\n在零利率情况下呢，这 1 亿人就没法靠利息不劳动而生活了，他们就必须靠劳动获得收入生存了。\r\n\r\n2，在零利率环境下，资本也不得不放弃追求高利润，力图以最小的利润率求生存了。\r\n\r\n按资本逐利性原则，市场利率高。资本追求的利润率也就会高，反之资本追求的利润率就低。。。\r\n\r\n例如，当银行利率 5%，企业均利润率 2 时，资本家就会放弃企业，资本就会转而去追求\r\n\r\n银行高利率了。\r\n\r\n反之，当银行利率为零时，资本就只能放弃追求高利润率，转而以保持极低的利润率求生存了。\r\n\r\n未完，待续\r\n\r\n箐箐河边草 2016 2018-02-06 14:12\r\n这意思是日本负利率好处大大的 实现完全就业了 ⊙?⊙！\r\njianpu2015 2018-02-06 14:16\r\n评论 x8596t：同样债台高筑，那国内是否也可以实行低利率？\r\n剩余 5 条\r\n评论 看全部\r\nx8596t\r\n2018-02-06 15:15\r\n26355 楼\r\n继续 400\r\n\r\n前面 399 说到，低利率，零利率经济环境下会出现如下两种情况；\r\n\r\n1，大量靠利息不劳而获的人群被消除，人人都得靠劳动生存。\r\n\r\n2，资本追逐利润率目标降低，资本的逐利性大幅下降，资本将以保持最低利润率求生存。\r\n\r\n所以，在零利率环境下，劳动者和资本家都得为生存而努力，一个要找工作求生存，一个以资本最低利润率求生存，双方抱团取暖。。。\r\n\r\n这样，经过一段时间的磨合，相互结合，经济就稳定了，劳动就业率就会上升。。。\r\n\r\n与此同时，消费也会趋于稳定，因为人人靠劳动获取收入，收入的大部分会用在消费上，进而导致资本的生存空间也稳定下来。。。\r\n\r\n不过零利率环境付出的代价就是低经济增长，因为资本无法追逐到高利润，资本活跃度降低，投资意愿降低，经济死水一潭。。。\r\n\r\n所以，此时要想提高经济增长率，就得抬高利率，抬高通货膨胀，以满足资本的逐利性，。。\r\n\r\n不过自相矛盾的是，此时的美日经济体都是债台高筑，任何提高利率的做法几乎都是不作就不会死。。。\r\n\r\n例如，日本政府负债高达 GDP 的 250%，任何加息几乎都是自杀行为，都是在引爆债务炸弹。\r\n\r\n例如，美国债务总额高达 20 万亿，利率每上升一个点就得增加 2000 亿美元，如果按照特朗普，美联储的计划，真的把利息升到正常利率 3.5% 左右，那美国国债利率将升高到 4.5% 左右，一年美国政府光利息开支就会超过 9000 亿美元。。。\r\n\r\n而现在美国财政赤字一年高达 1.3 万亿美元，增加的债务将大部分被用来偿付利息，结果必然导致美国国会的反对，会不断提高特朗普政府预算批准难度。。。\r\n\r\n当国会议员看到特朗普政府减税，加息必定导致美国政府永远也还不清债务了，美国政府越来越高的财务预算将很难获得国会批准了，最近美国政府因为国会迟迟不通过提高债务上限而关门，就是国会对美国政府的警告。。。\r\n\r\n美国是个多权分立的国家，因为美国政府的庞氏借债，美联储已经关闭印钞机了，很有可能，美国国会也将对特朗普的预算计划说不了。。。\r\n\r\n这可不像中国，几个国会，政府，央行巨头一碰面，那有预算不能通过的，哪有央行敢不开动印钞机的，这大概就是一些经济精英鼓吹的中国模式的优势吧。。。哈哈。\r\n\r\n所以，美日如果不将通货紧缩进行到底，彻底消除债务，消减贫富分化，调整经济结构，就别想真正恢复经济增长。。。\r\n\r\n好，扯远了，现在我们回到失业问题的讨论上来。。。\r\n\r\n毫无疑问，美日低利率环境下，低经济增长，高就业的实践会对中国可能遭到经济危机时，如何应对大规模失业将有十分要的理论和实践意义。。。\r\n\r\n未完，待续\r\n\r\n小龙栖尧 2018-02-06 15:33\r\n没有连续加息，中国的房子估计又要反弹了\r\n无心插柳 oy 2018-02-06 15:41\r\n房价和 m2 有关 加息是为了稳汇率 当然加息了 各种债务会被引爆 ！目前估计谁也解决不了这难题，只有静观其变，实际上就是拖吧\r\n剩余 5 条\r\n评论 看全部\r\nx8596t\r\n2018-02-07 16:24\r\n26394 楼\r\n继续 401\r\n\r\n我觉得可以聊聊比特币和区块链技术了。。。\r\n\r\n一是因为比特币暴跌到 6000 美元，现在谈，一些网友就没那么反感了。。。\r\n\r\n二是因为事关网友的人生发展选择，事关网友，特别是年轻网友的学习，就业。。。\r\n\r\n当今世界和中国正处于一个新的历史潮流拐点，每个人都不得不作出选择，选择正确，人生道路就可能顺风顺水，事半功倍，错了就可能坎坎坷坷，事倍功半了。。。\r\n\r\n例如，1979 年，你考上大学，你是选择马列主义专业，还是选择金融专业，那对你的前途影响就大了。\r\n\r\n例如，大清朝末年，你是选择读四书五经，考秀才，还是选择学习蒸汽动力原理，蒸汽机制造，那你的前途就相差天远地远了。。。\r\n\r\n回到当今现实中；\r\n\r\n学习金融\r\n\r\n学习比特币和区块链技术。\r\n\r\n如果你选择学金融，对不起，你将来可能很难找到对口工作，除了改行，别无选择，\r\n\r\n因为我预测，一旦危机来临，失业大军中最大比例可能就是当今红得发紫的所谓经济金融界\r\n\r\n很明显，是学金融还是学比特币，区块链技术，毫无疑问，我是赞成年轻网友学习比特币和区块链技术的。。。\r\n\r\n为什么？\r\n\r\n未完，待续\r\n\r\n---\r\n\r\n注意: 目前而言比特币，区块链之类的技术泡沫已经破裂了，无事勿扰，有事烧纸！\r\n","createdTime":1580652937804,"updatedTime":1608894174582,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"4851df9b40f6427c8bccf86560d33529","title":"一些烦心事","body":"## 场景\r\n\r\n> 抽刀断水水更流，举杯消愁愁更愁（虽然吾辈并不喝酒就是了）\r\n\r\n明明说过这是一个技术博客的，然而现如今，吾辈却也需要发一些技术之外的内容了呢。。。（经受了[社会的毒打](https://www.zhihu.com/question/282036368)）\r\n\r\n## 公司\r\n\r\n![公司](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191201212832.png)\r\n\r\n最近到了一家新的公司，每天早晨 6-7 点起床，然后晚上 7-8 点回来，忙忙碌碌，再无他事。\r\n\r\n公司项目历史遗留的问题之多，想要改变问题面临的困境之难，都导致吾辈在公司的时间逐渐变多，自己生活的时间逐渐变少，所以最近别说博客都半个月不发一次，连 github 的维护都少有时间，每天都是早晨抽空维护半个小时罢了。\r\n\r\n回到了家里，吃完晚饭，洗完澡，便已然快到了睡觉的时间。想要做点自己的事情，但又感觉没什么时间。\r\n\r\n## 生活\r\n\r\n![生活](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191201212906.png)\r\n\r\n而且，现在吾辈有点控制不了时间了，每天睡觉时间也难以固定。或许因为一时兴起，便去看了一部电影，然后到了凌晨 0 点或 1 点再睡觉，便是在周末刻意进行了补觉，但也不能弥补日常精力不足的事实。\r\n\r\n不曾被在意，不曾被了解，没有目标，没有动力。吾辈曾经把写博客作为目标，但后来知识的增长速度越来越慢，空闲时间越来越多用来咸鱼般的躺在床上，发呆地度过周末的两天。\r\n\r\n## 家庭\r\n\r\n![家庭](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191201212931.png)\r\n\r\n曾经亲密的家人，现在因为一些事情，却也有了现实的矛盾。或许，家家都有难念的经，便是吾辈，也必须经历各种现实中的苦难吧。\r\n\r\n周末有时回到家里，虽然家人现在没有说什么特别的话，但从他们的语气中，对我如今的现状，包含心疼，包含不满。如今也便只是维持现状，小心翼翼的计算每个月回去一次，便不会引起太多的波澜（无论如何亲密的人，只要待在一起的时间够久，便会发现对方的缺陷，而家人，便是能够忍受这种问题的存在）。\r\n\r\n吾辈的妹妹已然让父母伤透了心，吾辈不想再伤害他们一次。然而屁股决定脑袋，吾辈想要的东西和他们想要的并不一致，它们的经验并不适合吾辈。娶妻生子，掌家立业，难道便是人一辈子的追求么？\r\n\r\n## 未来\r\n\r\n![未来](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191201212955.png)\r\n\r\n不知道未来会变成怎样，不知道未来会发生什么。平凡的活着，不断遭受着社会的毒打。当垂垂老矣时，回顾一生，没有任何值得诉说的事迹，或许也是吾辈一种可能的结局吧\r\n\r\n> 卑鄙有卑鄙者的通行证，高尚有高尚者的墓志铭。\r\n","createdTime":1580652937690,"updatedTime":1608894156531,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"692f378d34024996ba25ca9160e0c0cb","title":"为什么吾辈不对百度做 SEO 优化","body":"## 闲言碎语\r\n\r\n任何事情都要有目标，而吾辈个人觉得，任何一位开发者，如果还只会用百度的话，那么终究有所不足。或许有人说这是崇洋媚外？然而事实上百度不仅在搜索质量上远不如 Google，而且还发生过多次不好的事件。正如一句话所言：**谷歌一直在挑战人类智力的上限，百度却在挑战人类道德的下限！**\r\n\r\n> [知乎：百度和 Google 的搜索技术是一个量级吗？](https://www.zhihu.com/question/22447908)\r\n\r\n综上所述，吾辈的目标用户便是能够翻墙（这件事本身并不是特别麻烦），能够使用 Google，使用 GitHub 的开发者。\r\n\r\n## 实名认证\r\n\r\n好吧，其实以上说的都不是真正的原因。对于吾辈而言，别人用什么工具，与吾辈并没有什么关系。根本原因是百度要求的信息实在太多太多了。看看，**手机/邮箱/QQ/微信** 一个不拉，调查户口么？呵呵，吾辈随便了，百度找不到就找不到，宁愿不要这些用户了也不想给你这些信息。\r\n\r\n![提交 sitemap 必填信息](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20191026130601.png)\r\n","createdTime":1580652937691,"updatedTime":1608894143868,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"4c6c836249a446e58d36c87b0c4b9e7a","title":"如何编写一篇好的技术文章","body":"## 场景\r\n\r\n> 人的目标总是追求「优越性」，是要摆脱自卑感以求得到优越感。\r\n\r\n现在网络上已经有很多写作平台了，让我们数数: 静态/动态博客（Hexo/WordPress），SegmentFault 专栏，简书，掘金，CSDN 博客。然而写作平台很多，愿意写作的人也很多，那么是否意味着我们就更容易获取知识了呢？其实并不是，原因在于很多人写作只是跟风，觉得很**酷**，所以用 `hexo/hugo + github pages` 建了静态站点发了一篇 **hello world** 之后就没有下文了。这种暂且按下不表，吾辈主要想说的是另一种：为了写作（~~积分~~）而写作，完全不用心，只是简单的把概念复制了一下，甚至直接**抄袭**别人的文章，不注明来源，而且没有尝试过文章做法的人。\r\n\r\n> 这里强烈批评一下 CSDN 博客，虽然也有一些优质的博客，但更多的是直接**抄袭**的文章，而且大多数都存在问题，实在令人深痛恶绝。甚至于，有人专门写了油猴脚本 [google 百度搜索屏蔽 CSDN](https://greasyfork.org/zh-CN/scripts/375279) 用来屏蔽它，糟糕程度可见一斑。\r\n\r\n## 思考\r\n\r\n那么，真的想要开始写作，想要把自己的知识、感触和经验分享给其他人的话，有没有什么写作的技巧，或者说遵循的规则呢？下面是吾辈写作至今以来的一些经验，希望能帮到真心想要写作的人。\r\n\r\n重点\r\n\r\n- 是什么？\r\n- 怎么做？\r\n- 在哪里用？\r\n\r\n细节\r\n\r\n- 排版样式\r\n- 插图\r\n- 错别字\r\n- 转发文章\r\n\r\n## 重点\r\n\r\n如果要写一个技术文档，那么有三点是必须要注意的。\r\n\r\n- 是什么？\r\n  可以是技术的一些简单介绍，或是在什么场景下会遇到这种问题，也可以是为什么要写这篇文章。就像吾辈，基本上每篇文章的正文都会有一个**场景**段落，用来介绍吾辈为什么写这篇文章，以及对涉及问题的介绍（吐槽 #打）。\r\n- 怎么做？\r\n  正确的描述具体如何使用，或是如何使用代码**实现功能/修复错误**。例如介绍 JavaScript Array 的文章，那就需要告诉读者如何使用常见的 API，例如 `forEach, filter, map, reduce` 这些函数，如何的使用它们，给出一些具体可运行的示例，如果有你觉得读者会难以理解的部分，更应该详细解释，并配上代码示例。\r\n- 在哪里用？\r\n  写作最有可能漏掉的部分，但却是最重要的。如果文章只是单纯罗列了一堆概念和代码，却不告诉读者在什么场景下才会用到，那么这只会是相当糟糕的文章，还不如去看官方文档（大部分文档都是告诉怎么做而不告诉在哪里用，尤其是某些 HTML/CSS 书籍，简直是把 MDN 的文档抄了一遍），至少还准确一些。\r\n\r\n## 细节\r\n\r\n- 排版样式\r\n  读者进入网页之后，第一眼看到的绝对不是具体的内容，而是网页的排版大致是什么样子的，这点在读者阅读时能够清晰的感受出来。就像人的外貌，在开口前读者便能藉此看出大概（所谓以貌取人）。即便可能在读者继续阅读内容而扭转形象，但更有可能是读者直接点 X 关闭网页，并且留下了不好的印象。\r\n  所以排版真的很重要，下面提供吾辈的几条经验:\r\n  - 不要是纯 TXT 文本格式（**大忌**）\r\n  - 使用代码块包裹代码片段，不要直接和普通文本一样，没有语法高亮看代码会死人的。\r\n  - 合理使用标题。标题应该是逐级减小，而不应该出现一级标题，然后立刻就是三级标题，中间一定且必须有一个二级标题。\r\n  - 文章中的链接应该是可点击的，并且最好引用一些比较官方的内容（MDN，Wiki）。\r\n  - 错误示例: <https://blog.csdn.net/xlxxcc/article/details/52083543>\r\n- 插图\r\n  如果说排版样式是外貌，那图片就像人的衣服一样，能为文章锦上添花。更何况还有 [一图胜千言](https://zh.wikipedia.org/wiki/%E4%B8%80%E7%95%AB%E5%8B%9D%E5%8D%83%E8%A8%80) 的说法，可以避免读者在阅读时感到无聊。像是如果有流程图/原理图/时序图这些，将会显著的提高文章的层次。\r\n  > 附: 画图真的很花时间，如果有图片的话，说明作者是真的用心在写文章。（一般是大佬才会做，吾辈不是大佬，所以一般不会画图 #笑哭）\r\n- 错别字\r\n  但凡写作，如果有人说自己没写过错别字，吾辈是第一个不信的。人非圣贤，孰能无过。写作时出现错别字是很正常的，但由于人类本身的原因（参考 [查出自己的错别字，为什么这么难？](https://www.guokr.com/article/439010/)），所以想要检查是比较困难的 -- 但并不是毫无办法，我们在文章发布后，在网络上再次查看文章，会比在编辑器中更容易察觉到文章中的问题，这其中当然包含错别字。\r\n- 转发文章\r\n  当我们在网络上看到别人的文章，觉得写得很好，于是转发了文章想让更多人看到。但在转发之前，最好先询问一下原作者的意愿（一般是允许署名转载的），而且必须要在显眼的位置（文章顶部或尾部，一般最好是顶部）放置原文的链接，以使读者能够找到原作者。\r\n\r\n## 总结\r\n\r\n上面说了这么多，还有最后一句话要送给大家: **保持作者这个称呼的基本水平和对读者的基本尊重**。\r\n","createdTime":1580652937717,"updatedTime":1608894076102,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"fef54f3887c34c83b33e1e0903249116","title":"程序员对 996 的反抗引来全球关注，它是如何以程序员自己的方式建立起来？","body":"> 转自: <https://m.douban.com/note/712945658/?dt_dapp=1>，原文应该来自 [好奇心日报](https://www.qdaily.com/)，但目前已被删除。\r\n> 国内的各大互联网公司争相屏蔽 [996.ICU](https://996.icu/) 及其 [GitHub](https://github.com/996icu/996.ICU)，甚至在 [GitHub Issues](https://github.com/996icu/996.ICU/issues) 大肆雇佣水军发布乱七八糟的东西导致 Issues 被关闭。\r\n> 包括百度上无法搜索到官网，中文搜索结果中甚至搜索不到 GitHub。QQ/360/百度/UC 这些常见的国内浏览器直接添加本地规则禁止访问，但 Chrome/Firefox 则安然无恙（所以真的无法理解程序员为什么会用 360？）\r\n\r\n一场关于劳工权益的抗议在过去一周里爆发，让中国互联网公司习惯的 996（早九点、晚九点、一周六天）加班时间成为中国乃至全球关注的焦点。\r\n\r\n有程序员发起了一个抵制 996 工作制的项目 [996.ICU](https://996.icu/)。讨论从技术社区开始，在互联网公司的微信群流传开来，蔓延到豆瓣、知乎，很快上了微博热搜，在百度的搜索热度达到平日的十倍。《中国青年报》、《南方日报》的报道被项目发起人标注进了项目的说明页面。\r\n\r\n一周下来，事件的影响在海外逐渐升温。最早跟进报道的英文媒体是关注中国的《南华早报》，它在 3 月 29 日对此事的报道被 Python 之父 [Guido van Rossum](https://twitter.com/gvanrossum) 转发并附上一句评论：“**996 工作制是不人道的。**”\r\n\r\n全球程序员聚集讨论区 Hacker News 和相应 Reddit 论坛，996 也成了一个热门话题。The Verge、Financial Times 分别在 4 月 2 日和 4 月 3 日跟进，《连线》等媒体也已经在采访参与者。\r\n\r\n和前两年以悲剧方式获得全球关注的中国制造业从业者不同，程序员看起来是最不容易为工作环境走向对抗的一个群体。外界对他们的印象主要是收入高、习惯天天加班、办公室放着行军床、生活简单就想着买房结婚。一个典型的中产阶级行业，而中产阶级往往被认为是革命中重要但同时也是阻力最大的阶层。\r\n\r\n但不同于其它也要日常加班，强度更大收入更少的行业，程序员有一个说话的渠道。\r\n\r\n## 1\r\n\r\n996.icu 网站的域名最早由一个年轻的程序员注册。\r\n\r\n在技术论坛 V2EX 上，这位用户曾在一个关于工作薪酬讨论的帖子里提到自己毕业于北京一所 211 大学，在一家与百度、阿里、腾讯同级的大型互联网公司工作，刚转正没多久，每月薪酬在一万多元。\r\n\r\n之前，他都在论坛里发帖讨论技术，讨论同一个公司不同的团队之间为什么薪资会有差别。但最近，他所在的公司开始实行 996 工作制。\r\n\r\n3 月 20 日，他在论坛的域名推广版宣布注册了一个域名 <http://996.icu>，口号是：“工作 996，生病 ICU。”\r\n\r\n3 月 26 日后，他在一个职场话题下回复道：“我才感到 996 多么毁人，除了工作就是休息，跟家人沟通都少了。”在那个回帖里，他再次推荐了 996.ICU 网站。\r\n\r\n[996.ICU](http://996.icu) 就是一个网站，自上而下分成 996 介绍、十七条劳动权益相关法规和相关事件报道三个部分。这三部分自第一天就在，虽然内容在过去一周日渐丰富起来。\r\n\r\n[![996 icu](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190407205931.png)](http://996.icu)\r\n\r\n网站作者还在介绍后面加上了一句“Developers’ Lives Matter”（开发者的命也是命），模仿美国对抗种族不平等运动的“Black Lives Matter”（黑人的命也是命）。\r\n\r\n它的影响力并不来自这个网页。而是来自同样在 3 月 26 日上线的 [GitHub](https://github.com/996icu/996.ICU) 项目。\r\n\r\n项目由一个叫 996icu 的匿名 ID 发起，和域名持有者的关系不得而知。但从每天对最多 260 个建议的快速处理来看，这个账号即便是那位年轻程序员创建，现在很可能也不是他一个人在用。\r\n\r\n今天，软件开发已经不需要凡事都重新发明一个轮子，用开源的代码可以快速完成一个功能。\r\n\r\n而 GitHub 就是存放这些代码的最大平台。程序员们在 GitHub 上管理自己的项目，发起讨论、提交修改建议。\r\n\r\n目前 GitHub 有[三千万程序员用户](http://www.sohu.com/a/276484595_671058)，托管了大约 8000 万个代码仓库，平均每秒创建的存储库就有 1.6 个。2018 年，[微软宣布 75 亿美元收购 GitHub](https://techcrunch.com/2012/07/14/what-exactly-is-github-anyway/)。\r\n\r\nGitHub 上之前也有关于中国互联网公司加班问题的项目，两个月前一个主题是 [“程序员找工作黑名单”](https://github.com/shengxinjing/programmer-job-blacklist) 的项目上线，这个黑名单在两个月内获得了超过 18000 次“加星点赞”（Star）。\r\n\r\n但这看起来更像是程序员在找工作时的一份操作指南。而 996.ICU 则更直接、更简单，从一开始就是一份反 996 工作制的宣言。\r\n\r\n这让它迅速引起共鸣。\r\n\r\n996 一直没有好名声。最早可以追溯到 [2014 阿里巴巴怀孕员工加班回家后大出血去世](http://it.sohu.com/20140405/n397797427.shtml) 的新闻报道。2016 年，[58 同城就因为对 2 万多员工强制 996](http://finance.cnr.cn/gs/20160901/t20160901_523105136.shtml) 遭到不少抵制。\r\n\r\n今年 1 月，[杭州有赞 CEO](http://www.linkshop.com.cn/web/archives/2019/418163.shtml) 在公司年会上突然宣布全公司强制执行 996，有赞高管表示如果工作家庭不好平衡，可以选择离婚。\r\n\r\n更近的，京东 3 月初开始执行 995 工作制度。面对质疑，[京东公关总监刘力回应不会强制要求，但鼓励员工全情投入](http://tech.163.com/19/0312/13/EA2QGIOK00097U7R.html)。\r\n\r\n中国互联网公司加班不被认为是特例，但以往有高回报盼头。2017 年，软件业平均薪资 13.3 万，连续两年超过金融业成为全国最赚钱的行业。阿里巴巴纽交所挂牌上市，一夜之间产生了 1 万多名千万富翁。\r\n\r\n2018 年开始的上市潮没能重现另一个阿里巴巴。小米 2014 年估值达到 450 亿美元，2018 年上市前预期公司市值能有 800 - 1000 亿美元，四年老员工手中股票价值有望翻倍。但等到 2019 年年初员工可以卖股票的时候，小米市值缩水至 315 亿美元，股票价值也比 2014 年缩水 30%。\r\n\r\n而小米已经是过去一年上市公司里表现很好的。[蘑菇街直接以稀释员工股权的手段将员工持股价值缩水为 1/25](https://www.jiemian.com/article/2703824.html)。蘑菇街挂牌价为 14 美元，1 万股理应价值 96.6 万元，但稀释 25 倍后只有 4 万元。\r\n\r\n甚至工作也不一定能保证。互联网行业早几年处于风口，大量风险投资涌入。创业公司不在乎利润，可以开更高薪水来挖人。\r\n\r\n但现在形势变了。2018 年，中国 VC/PE 募资规模 341.12 亿美元，[同比骤降 74.59%](https://36kr.com/p/5150552)。靠烧钱做大规模的互联网公司上市后也面对盈利问题。缺乏资金来源，为了减少亏损，裁员成为一个普遍的做法。\r\n\r\n去年 8 月，美图、拉勾网各裁员 20%。10 月，锤子科技解散成都分公司，为它从北京搬去成都的程序员也失去工作。11 月，趣店裁员 200 人，不从北京搬去杭州也得走，同月斗鱼裁员 70 人。12 月，知乎裁员 20%，300 人被要求当天离开公司；科大讯飞裁员 20%，回应为末位淘汰；摩拜裁员 30%，称为正常调整。今年 2 月，滴滴裁员 15%，2000 人离职；京东先裁员 20% 员工，2 月又裁员 10% 副总裁级别高管。3 月，腾讯中层裁去 20%，[腾讯总裁刘炽平称](http://m.kanshangjie.com/Index/Show?id=161549) 为年轻化主动革新。\r\n\r\n高强度的工作变得强度更高、曾经可以指望的上市故事愈加渺茫，甚至能工作多少年也在大裁员背景下变得难以确定。\r\n\r\n在这样的背景之下，996.ICU 项目上线一小时内就收获了超过 2000 颗星星，一天内加星数超过一万，登上了 GitHub 实时热门榜。\r\n\r\n更多人注意到了。\r\n\r\n## 2\r\n\r\nAnony 就是在 3 月 26 日 996.ICU 上线一小时的时候开始关注的。他自称是一个普通的码农，平时喜欢逛 GitHub。他说自己平时逛 GitHub 就“类似于你们刷微博”。\r\n\r\n尽管 Anony 所在公司没有实行 996 工作制，他还是持续对这个项目的进展保持关注，也参与了修改措辞的工作。\r\n\r\n在 996.ICU 的讨论区（Issues 区）里，加星即将破十万前，有人留言说，没想到以这种方式参与了大型开源项目。\r\n\r\n在社交网络上人们分享自己关于 996 工作的经历、见解以及解决方案。但在程序员社区里，一切都按照程序员们开发开源软件的方式推进着。\r\n\r\n想象一栋充满无数会议室的大楼，每间会议室里的白板上写着一项软件的所有代码。GitHub 可以让程序员走入其中开放的会议室，观看白板上的代码（Watch），点赞（Star），并按自己的想法进行修改。\r\n\r\n但随意修改会扰乱白板上的代码，Github 方便用户将白板上的代码库整体复制到自己账户下，修改不影响项目代码。修改完成后，程序员可以提交“拉回请求”（Pull Request）给项目维护者进行合并，将自己的修改加入项目。\r\n\r\n这是目前开源软件在线协作的工作方法，而 996.ICU 的进化过程完全遵照此方法进行。\r\n\r\nGitHub 上最初的 996.ICU 项目很简单：一段 26 行的 Markdown 格式网页文档。\r\n\r\n一段段劳动法摘录、五一国际劳动节的由来、国际歌歌词、英文版本是最早的一批更新。\r\n\r\n996.ICU 项目的补充、完善，都是由参与者以提交“拉回”请求的方式推进，逐渐成为今天的样子。\r\n\r\n这和在论坛留言不一样，如果一个人看到代码就产生不适感，那就无法在这里提出修改请求。\r\n\r\n各种细节被快速完善。有人提交请求，称主页面上的案例之一京东的英文版本如果直译 JINGDONG 无法让外国投资者理解，要改成 [JD.COM](jd.com)。\r\n\r\n大小写、空格、错误链接、全角半角符号错用等问题都被更新，放进 Markdown 格式的文档里，还有人上传了自制的 Logo。\r\n\r\n法语、德语、意大利语、日语、韩语、葡萄牙语、巴西葡萄牙语、泰语、繁体中文、越南语、俄语、希腊语等主要语言版本翻译都在项目上线第二天提交。还有人写了[颇正式的文言文版本](https://github.com/996icu/996.ICU/pull/16430/files%E3%80%81)：“996”事制，即日早九至岗，直至晚九点事，每周工作六日。2016 年九初起，续有网爆料称，58 同城行全员 996 事制，且周末加班无文……\r\n\r\n3 月 28 日是进展飞快第一天，项目有了两个关联项目：[996 公司黑名单](https://github.com/fengT-T/996_list) 和 [955 公司白名单](https://github.com/formulahendry/955.WLB)。\r\n\r\n黑名单上都是实行了 996 或过度加班的公司，国内的大互联网公司基本在列，京东以超过 1200 票遥遥领先。作者还提出建议，希望在提名的时候加上部门、省区、工资范围，总之给出的信息越详细越好。\r\n\r\n黑名单的作者原先将投票设置在一个论坛上，并没有考虑到会有那么多人参与投票，以至于网站太卡，人们只关注到了排名在前面的大公司。目前，这位作者正在建设新的网站，他在项目说明里写道：“因为太卡大家都只关注到了前面的大公司，希望大家能够注意到 996 的群体实际上很大，不仅仅有 BAT ，还有很多小公司。”\r\n\r\n而白名单上的公司更多是外企。\r\n\r\n955 公司白名单作者 formulahendry 在上海一家大外企做程序员，他的 GitHub 页面有超过 600 个关注者，还坚持用英文写过一段时间技术博客。\r\n\r\n像几乎所有外企一样，formulahendry 并不需要 996。他对《好奇心日报》称，996 就完全没有个人的生活时间，最近这个现象越来越普遍，并不是一个好的趋势，他反对 996 的理由与许多人类似：比起一周工作 40 小时，一周工作 72 小时的 996 单位时间的产出不高。\r\n\r\n注意到 996.ICU 之后，他觉得与其吐槽 996，不如看看有哪些公司实行 955（一周工作五天，朝九晚五） 的公司。\r\n\r\n项目上线第二天，他创建白名单投票，项目的名字 WLB 是他自创的缩写，意思是 Work Life balance，即生活与工作的平衡。WLB 一天内加星数超过了 1000，上线第二天上了 GitHub 实时热门榜。\r\n\r\n投票的雏形是基于 formulahendry 对上海 IT 公司的了解，在接下来的几天里，他利用下班在班车上的时间以及周末的时间维护着项目更新。\r\n\r\n虽然 formulahendry 建了白名单，但是项目被创建出来之后就不再是他一个人能决定的事：一切都得按照 GitHub 的方式来。\r\n\r\n996 公司黑名单则吸引了更多的参与：一个公司被添加到黑名单的方式与开源项目代码审核没什么太大区别，每个人都可以提交论据，只是提交论据的方式对非程序员来说有一定门槛。论据包括媒体报道、知乎讨论、公司官网公告等。\r\n\r\n华为 和 [字节跳动等公司](https://github.com/formulahendry/955.WLB) 是否能够上榜都引发了众多讨论。在要求“删除黑名单字节跳动”的请求下有 51 组对话，要求删除的人和不同意删除的人各自举证。\r\n\r\n发起删除请求的用户给出了两点理由：\r\n\r\n1. 公司虽然下班晚，上班也晚，算上午饭、晚饭后的休息时间，实际工作时长并没有一天 12 小时；公司实行大小周，但是小周周日加班给加班费；\r\n2. 猝死事件的程序员是刚从腾讯跳槽到字节跳动不久，不能武断归咎于字节跳动加班。\r\n\r\n反驳方指出“说的好像 955 的公司不午休不吃饭一样。”接着还有反驳者给出加班费计算方法的猫腻，比如周日加班按 1.2 倍工资而不是 2 倍工资计算。\r\n\r\n一个请求能否通过，实际上是以一种简单的投票实现的。删除字节跳动的请求有 8 人支持，269 人反对。最后 996.ICU 项目负责人拒绝了删除字节跳动的请求。\r\n\r\n虽然项目负责账号可以对请求作出判断，但由于开源项目的可复制性，如果项目发起人背离社区大多数人的诉求，程序员们可以很容易转而支持另一个在这个基础上分出来的项目。\r\n\r\n从一个个人项目，演变为社区项目之后，决定项目发展的就不再是发起人，而是所有参与贡献的人共同决定的结果。这些都是开源软件开发的基本方式。\r\n\r\n就像比如 Linux 系统最早是 Linus 一个人的作品。但随着全球开发者的加入，有 1.5 万开发者和超过 1400 家公司添砖加瓦。现在 Linux 远不是 Linus 所能控制的，它的管理由一个专门的基金会所负责。\r\n\r\n996.ICU 也没什么区别。不论是谁启动了这个项目，现在它已经不再是一个人决定的事。\r\n\r\n## 3\r\n\r\n讨论变得敏感，是从 3 月 29 日项目的 issues 被关闭开始。\r\n\r\n仓库下的讨论区（Issues）突然被关闭，也引发了不少讨论，比如 issues 太多（过了十万）、太多广告，还有人贴出白宫请愿的号召截图怀疑是政治原因。几小时后，作者贴出解释称是主动选择关闭。\r\n\r\n不过这对讨论没有太大影响。项目上线之初，有人发出各地微信群的二维码，与此同时就有人回应说程序员应该用程序员的工具，而不是用 QQ、微信来沟通。于是程序员常用的即时通信工具 Slack、游戏即时通信工具 Discord 都被用起来、国内不能直接访问的通讯工具 Telegram 上也出现了 996.ICU 讨论组。\r\n\r\n996.ICU 的 Slack 讨论频道在五天内吸引了 1000 多名成员，成员自发将 Slack 群组划分成了公告、招聘、讨论、中文、英文、城市等数个频道。在 Slack 频道里讨论最多的，是劳动权益受到侵害之后如何维权。\r\n\r\n[一名拥有二十年经验的程序员陈皓](https://www.zhihu.com/question/317847010/answer/636013957) 在知乎回答了问题：“如果想抵制 996，除了利用 GitHub 发起抗议，还有哪些巧妙的方案？”，提出通过法律手段、政府信访、集体抗议等途径。\r\n\r\n在 Slack 群组讨论中，他的解决方案遇到了不少阻力，一些成员质疑劳动仲裁的效率，还有一些成员则担忧信访手段可能招致政府机关的强制手段。\r\n\r\n在完善了措辞、不同语言版本和黑名单、白名单之后。996.ICU 从上周末开始的最大进展是“反 996 软件授权协议”从想法到落地。\r\n\r\n3 月 27 日，[一个想法被热切讨论后采用](https://github.com/996icu/996.ICU/pull/15642)：设计一种关于劳动保护的软件授权协议——996ICU 协议，如果这个协议被兼容进各个开源项目的授权协议，实行 996 工作制的公司不得使用该开源项目，就可能给公司带来实际的约束作用。\r\n\r\n劳动法一直在，但执行是问题。大互联网公司往往为一个城市解决数万就业，有些还提供数十甚至上百亿利税。理论上地方法院，比如深圳当地法院应该公平对待腾讯、华为和它们的员工，但这是理论上。\r\n\r\n而软件授权协议是软件行业内的一个约束。简单来说，软件授权协议就像是一本书的版权声明。在项目开发中开源软件的使用不可避免，使用开源软软件不需要付费，但是需要遵守作者写在授权协议中的条款，如果公司或个人使用了开源代码，但是没有遵守条款，作者可以据此提起诉讼，要求赔偿、停止使用代码。\r\n\r\n这个想法被上千人点赞，400 多人参与了该协议的讨论。\r\n\r\n但协议怎么写还没人想好，一开始只有这样三行：\r\n\r\nThe 996ICU License (996ICU)Copyright © 2019 3 月 30 日晚间，伊利诺伊大学厄巴纳 - 香槟分校法学博士 Katt Gu 花了一夜时间起草了授权协议。这个版本在常用的 [MIT 开源授权协议基础之上](https://github.com/kattgu7/Anti-996-License/wiki) 改编。协议一共三条，在所有协议都会有的惯例版权声明条款，Katt Gu 增加了两条内容：\r\n\r\n- 个人或法人实体必须严格遵守与个人实际所在地或个人出生地或归化地、或法人实体注册地或经营地（以较严格者为准）的司法管辖区所有适用的与劳动和就业相关法律、法规、规则和标准。如果该司法管辖区没有此类法律、法规、规章和标准或其法律、法规、规章和标准不可执行，则个人或法人实体必须遵守国际劳工标准的核心公约。\r\n\r\n- 个人或法人不得以任何方式诱导或强迫其全职或兼职员工或其独立承包人以口头或书面形式同意直接或间接限制、削弱或放弃其所拥有的，受相关与劳动和就业有关的法律、法规、规则和标准保护的权利或补救措施，无论该等书面或口头协议是否被该司法管辖区的法律所承认，该等个人或法人实体也不得以任何方法限制其雇员或独立承包人向版权持有人或监督许可证合规情况的有关当局报告或投诉上述违反许可证的行为的权利。\r\n\r\nKatt Gu 关注新技术立法，也著有关于 [中国特定领域法律与实践鸿沟](https://scholar.google.com/citations?user=PTcpQwcAAAAJ&hl=en&oi=ao) 的论文。\r\n\r\n3 月 29 日晚上，Katt Gu 的丈夫，一直关注软件版权演进的创业者 Suji Yan 在看到 996.ICU 之后催促她起草一份协议。Gu 回忆说最初她并不愿意。\r\n\r\n“因为我本人是一个工作狂，但是仔细想想这是一个关乎自愿选择的事。”Gu 对《好奇心日报》表示，她的顾虑还来源于专业，这份协议起草涉及 IP 法、劳动法以及国际公约等领域的研究，她从未有过相关经验。\r\n\r\n起草协议之前，一位律师告诉她，要做好这份协议，得先研究十年劳动法、再研究十年 IP 法，或者在几个涉及的领域各找十个专家来讨论、研究，再拟定草稿。\r\n\r\n但是 Katt Gu 觉得协议的实用效果远小于宣传效果，今天最重要的那些开源协议一开始也不是以那样的立法方式做出来的。\r\n\r\n经过一夜研究，她决定以最简单的通用法（Common Law）为基础，草拟一份协议草案。而起草的模版则是简单且应用广泛的 MIT 开源协议。\r\n\r\n这份协议以及协议期待产生的效果，都是相当理想化的。\r\n\r\n根据 Suji Yan 所设想的最理想状态，协议可以对中国互联网公司有一个约束。他的逻辑是今天软件开发基本上已经不可能不用开源代码——微软一度都是开源软件的最大贡献者。当足够多的开源项目用了 996ICU 协议，企业强制 996 就等于自己的产品违反协议，开源代码拥有者就可以起诉该公司。哪怕在中国大陆起诉艰难，这些公司基本都在香港或美国上市，也可以在其它地区发起诉讼。\r\n\r\n不过解释完之后，他自己也说“这当然是一个极其理想化的设想”。\r\n\r\n“本来觉得我们不做会有别人做，但是现在觉得还是需要更多人关注。”Katt Gu 说协议公布之后收到一封感谢邮件，“感觉就像看医生收到那种‘妙手回春’的锦旗。”\r\n\r\n对协议约束力持怀疑态度的人很普遍，而反对者也不少。比如目前 GitHub 上第三大项目的创作者尤雨溪在微博上表示自己个人反对和谴责 996，但是也反对在开源项目许可证中包含 Discriminatory Clause（禁止部分用户使用的条款），或是利用开源项目做任何形式的政治博弈。\r\n\r\n“我个人有个人的看法，但项目是中立的。Vue 的许可证不会禁止任何人使用，现在不会，以后也不会。”他在微博上写道。Vue.js 是一个开发网页用户界面的框架。\r\n\r\n但添加反 996 许可证的项目 [在不断增多](https://github.com/996icu/996.ICU/blob/master/awesomelist/projects.md)。目前已经有 75 个开源项目添加了许可证，其中大部分是个人开发者维护的项目，但也有多个点赞数在四五千以上，有一定规模、被很多公司使用的开源软件项目加入。而和 Vue 相关的数个插件项目也加入了反 996 许可协议——任何项目开源扩大之后，就不再是作者一个人决定的了。\r\n\r\nKatt Gu 称接下来自己的协议修改要它与更多的主流开源软件协议兼容，这样才有希望被更多开源项目所接纳。\r\n\r\n“我自己只想把这个协议写好，写好估计就没有我啥事了，如果要写细，可能要花两三年。”Katt Gu 说做完这个应该就不会管了。Suji Yan 则补充了一句：“还给社区。”\r\n\r\n社区有一个大目标。4 月 1 日，有人号召把反 996 协议加入 GitHub [官方收录协议](http://choosealicense.com/) 当中，这样新开源项目就可以很容易把协议加入项目。\r\n\r\n更长远的目标是让它被 GitHub 高亮显示，这样任何项目在创建选择协议时都有机会看到它。\r\n\r\n这些都不容易，尤其是在主页高亮，需要超过 1000 个公开项目使用该协议，3 个明星项目使用、OSI 和 GNU 批准。\r\n\r\n作为开源软件的推动力量，理查德·斯托曼（ Richard Stallman）在 1985 年发表《GNU 宣言》，提出所有软件都应该贯彻自由软件的精神——运行、复制、发布、研究、修改和改进该软件的自由。\r\n\r\n但从一开始，这个运动就没有停留在技术或者免费用软件的层面，发起者认为大众都能接触到的应用都应完全掌控在用户自己手中。如果 996.ICU 的贡献者们计划成功，这将是开源软件届第一个被认可的约定劳动权益的协议。\r\n\r\n一周不到，对 996.ICU 的反击已经来了。\r\n\r\n没有公司敢直接攻击 GitHub。2015 年的持续攻击 [没有成功](http://choosealicense.com/)。现在它是微软的财产，商业公司攻击它就更不明智。\r\n\r\n攻击者们用了自己最习惯的手段，屏蔽。\r\n\r\n3 月 30 日开始，Slack 讨论群组中开始有人报错：北京地区微信内无法打开 996.ICU 的 GitHub 页面，更多的测试显示，这不是孤例。\r\n\r\nQQ 浏览器称这个唯一公开诉求就是让公司遵守劳动法的网站包含欺诈信息。微信显示的理由则是“该网页包含违法或违规内容，为维护绿色上网环境，已停止访问”。阿里巴巴旗下的 UC 浏览器和 360 浏览器都将该页面认定为包含违法信息的网站。最独特的猎豹浏览器打开这个页面会弹出提示称“网站含有大量淫秽色情信息”。\r\n\r\n使用百度搜索 996，中文版搜索结果里找不到 996.icu 网站和对应 GitHub 页面的链接。\r\n\r\n和以往不同的是，这一次它们并不能直接封杀 996.ICU 的存在，也没法让讨论它的渠道消失。\r\n","createdTime":1580652937800,"updatedTime":1608894033335,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"d574d7de00434d869972201a262124c8","title":"转载","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"e8e351cf90c049e589ce6044613a62ec","title":"如何编写无法维护的代码","body":"> 屁股决定脑袋\r\n\r\n## 让自己稳拿铁饭碗；-)\r\n\r\n> 转自 <https://coderlmn.github.io/frontEndCourse/unmaintainable.html?hmsr=toutiao.io>，这里仅修复了部分错别字，优化了代码显示。\r\n> **--Roedy Green**（老码农翻译，略有删节）\r\n\r\n## 简介\r\n\r\n> 永远不要（把自己遇到的问题）归因于（他人的）恶意，这恰恰说明了（你自己的）无能。-- 拿破仑\r\n\r\n为了造福大众，在 Java 编程领域创造就业机会，兄弟我在此传授大师们的秘籍。这些大师写的代码极其难以维护，后继者就是想对它做最简单的修改都需要花上数年时间。而且，如果你能对照秘籍潜心修炼，你甚至可以给自己弄个铁饭碗，因为除了你之外，没人能维护你写的代码。再而且，如果你能练就秘籍中的**全部**招式，那么连你自己都无法维护你的代码了！\r\n\r\n你不想练功过度走火入魔吧。那就不要让你的代码**一眼看去**就完全无法维护，只要它**实质上是**那样就行了。否则，你的代码就有被重写或重构的风险！\r\n\r\n## 总体原则\r\n\r\n> _Quidquid latine dictum sit, altum sonatur._\r\n> (随便用拉丁文写点啥都会显得高大上。)\r\n\r\n想挫败维护代码的程序员，你必须先明白他的思维方式。他接手了你的庞大程序，没有时间把它全部读一遍，更别说理解它了。他无非是想快速找到修改代码的位置、改代码、编译，然后就能交差，并希望他的修改不会出现意外的副作用。\r\n\r\n他查看你的代码不过是管中窥豹，一次只能看到一小段而已。你要确保他永远看不到全貌。要尽量和让他难以找到他想找的代码。但更重要的是，要让他不能有把握**忽略**任何东西。\r\n\r\n程序员都被编程惯例洗脑了，还为此自鸣得意。每一次你处心积虑地违背编程惯例，都会迫使他必须用放大镜去仔细阅读你的每一行代码。\r\n\r\n你可能会觉得每个语言特性都可以用来让代码难以维护，其实不然。你必须精心地误用它们才行。\r\n\r\n## 命名\r\n\r\n> \"当我使用一个单词的时候\" Humpty Dumpty 曾经用一种轻蔑的口气说，\" 它就是我想表达的意思，不多也不少。“\r\n> \\- Lewis Carroll -- 《爱丽丝魔镜之旅》， 第 6 章\r\n\r\n编写无法维护代码的技巧的重中之重是变量和方法命名的艺术。如何命名是和编译器无关的。这就让你有巨大的自由度去利用它们迷惑维护代码的程序员。\r\n\r\n### 妙用宝宝起名大全\r\n\r\n买本宝宝起名大全，你就永远不缺变量名了。比如 `Fred` 就是个好名字，而且键盘输入它也省事。如果你就想找一些容易输入的变量名，可以试试 `adsf` 或者 `aoeu` 之类。\r\n\r\n### 单字母变量名\r\n\r\n如果你给变量起名为 a,b,c，用简单的文本编辑器就没法搜索它们的引用。而且，没人能猜到它们的含义。\r\n\r\n### 创造性的拼写错误\r\n\r\n如果你必须使用描述性的变量和函数名，那就把它们都拼错。还可以把某些函数和变量名拼错，再把其他的拼对 (例如 SetPintleOpening 和 SetPintalClosing) ，我们就能有效地将 grep 或 IDE 搜索技术玩弄于股掌之上。这招超级管用。还可以混淆不同语言（比如 colour -- 英国英语，和 color -- 美国英语)。\r\n\r\n### 抽象\r\n\r\n在命名函数和变量的时候，充分利用抽象单词，例如 it, everything, data, handle, stuff, do, routine, perform 和数字，例如 e.g. `routineX48`, `PerformDataFunction`, `DoIt`, `HandleStuff` 还有 `do_args_method。`\r\n\r\n### 首字母大写的缩写\r\n\r\n用首字母大写缩写（比如 GNU 代表 GNU's Not Unix) 使代码简洁难懂。真正的汉子 (无论男女) 从来不说明这种缩写的含义，他们生下来就懂。\r\n\r\n### 辞典大轮换\r\n\r\n为了打破沉闷的编程气氛，你可以用一本辞典来查找尽量多的同义词。例如 display, show, present。在注释里含糊其辞地暗示这些命名之间有细微的差别，其实根本没有。不过，如果有两个命名相似的函数真的有重大差别，那倒是一定要确保它们用相同的单词来命名 (例如，对于 \"写入文件\", \"在纸上书写\" 和 \"屏幕显示\" 都用 print 来命名)。 在任何情况下都不要屈服于编写明确的项目词汇表这种无理要求。你可以辩解说，这种要求是一种不专业的行为，它违反了结构化设计的 _信息隐藏原则_。\r\n\r\n### 首字母大写\r\n\r\n随机地把单词中间某个音节的首字母大写。例如 `ComputeReSult()`。\r\n\r\n### 重用命名\r\n\r\n在语言规则允许的地方，尽量把类、构造器、方法、成员变量、参数和局部变量都命名成一样。更高级的技巧是在 {} 块中重用局部变量。这样做的目的是迫使维护代码的程序员认真检查每个示例的范围。特别是在 Java 代码中，可以把普通方法伪装成构造器。\r\n\r\n### 使用非英语字母\r\n\r\n在命名中偷偷使用不易察觉的非英语字母，例如\r\n\r\n```c#\r\ntypedef struct { int i; } ínt;\r\n```\r\n\r\n看上去没啥不对是吧？嘿嘿嘿... 这里的第二个 ínt 的 `í` 实际上是东北欧字母，并不是英语中的 `i`。在简单的文本编辑器里，想看出这一点点区别几乎是不可能的。\r\n\r\n### 巧妙利用编译器对于命名长度的限制\r\n\r\n如果编译器只区分命名的前几位，比如前 8 位，那么就把后面的字母写得不一样。比如，其实是同一个变量，有时候写成 `var_unit_update()`，有时候又写成 `var_unit_setup()`，看起来是两个不同的函数调用。而在编译的时候，它们其实是同一个变量 `var_unit`。\r\n\r\n### 下划线，一位真正的朋友\r\n\r\n可以拿 \\_ 和 \\_\\_ 作为标示符。\r\n\r\n### 混合多语言\r\n\r\n随机地混用两种语言（人类语言或计算机语言都行）。如果老板要求使用他指定的语言，你就告诉他你用自己的语言更有利于组织你的思路，万一这招不管用，就去控诉这是语言歧视，并威胁起诉老板要求巨额精神损失赔偿。\r\n\r\n### 扩展 ASCII 字符\r\n\r\n扩展 ASCII 字符用于变量命名是完全合法的，包括 ß, Ð, 和 ñ 等。在简单的文本编辑器里，除了拷贝/粘贴，基本上没法输入。\r\n\r\n### 其他语言的命名\r\n\r\n使用外语字典作为变量名的来源。例如，可以用德语单词 _punkt_ 代替 _point_。除非维护代码的程序员也像你一样熟练掌握了德语。不然他就只能尽情地在代码中享受异域风情了。\r\n\r\n### 数学命名\r\n\r\n用数学操作符的单词来命名变量。例如：\r\n\r\n```js\r\nopenParen = (slash + asterix) / equals;\r\n(左圆括号 = (斜杠 + 星号)/ 等号；)\r\n```\r\n\r\n### 令人眩晕的命名\r\n\r\n用带有完全不相关的感情色彩的单词来命名变量。例如：\r\n\r\n```js\r\nmarypoppins = (superman + starship) / god;\r\n(欢乐满人间 = (超人 + 星河战队)/ 上帝；)\r\n```\r\n\r\n这一招可以让阅读代码的人陷入迷惑之中，因为他们在试图想清楚这些命名的逻辑时，会不自觉地联系到不同的感情场景里而无法自拔。\r\n\r\n### 何时使用 i\r\n\r\n永远不要把 `i` 用作最内层的循环变量。 用什么命名都行，就是别用 `i`。把 `i` 用在其他地方就随便了，用作非整数变量尤其好。\r\n\r\n### 惯例 -- 明修栈道，暗度陈仓\r\n\r\n忽视 [Java 编码惯例](http://java.sun.com/docs/codeconv/)，Sun 就是这样做的。幸运的是，你违反了它编译器也不会打小报告。这一招的目的是搞出一些在某些特殊情况下有细微差别的名字来。如果你被强迫遵循驼峰法命名，你还是可以在某些模棱两可的情况下颠覆它。例如， _inputFilename_ 和 _inputfileName_ 两个命名都可以合法使用。在此基础上自己发明一套复杂到变态的命名惯例，然后就可以痛扁其他人，说他们违反了惯例。\r\n\r\n### 小写的 l 看上去很像数字 1\r\n\r\n用小写字母 l 标识 long 常数。例如 10l 更容易被误认为是 101 而不是 10L 。 禁用所有能让人准确区分 uvw wW gq9 2z 5s il17|!j oO08 `'\" ;,. m nn rn {[()]} 的字体。要做个有创造力的人。\r\n\r\n### 把全局命名重用为私有\r\n\r\n在 A 模块里声明一个全局数组，然后在 B 模块的头文件里在声明一个同名的私有数组，这样看起来你在 B 模块里引用的是那个全局数组，其实却不是。不要在注释里提到这个重复的情况。\r\n\r\n### 误导性的命名\r\n\r\n让每个方法都和它的名字蕴含的功能有一些差异。例如，一个叫 `isValid(x)` 的方法在判断完参数 x 的合法性之后，还顺带着把它转换成二进制并保存到数据库里。\r\n\r\n## 伪装\r\n\r\n> 当一个 bug 需要越长的时间才会暴露，它就越难被发现。\r\n> \\- Roedy Green（本文作者）\r\n\r\n编写无法维护代码的另一大秘诀就是伪装的艺术，即隐藏它或者让它看起来像其他东西。很多招式有赖于这样一个事实：编译器比肉眼或文本编辑器更有分辨能力。下面是一些伪装的最佳招式。\r\n\r\n### 把代码伪装成注释，反之亦然\r\n\r\n下面包括了一些被注释掉的代码，但是一眼看去却像是正常代码。\r\n\r\n```js\r\nfor(j=0; j<array_len; j+ =8)\r\n  {\r\n  total += array[j+0 ];\r\n  total += array[j+1 ];\r\n  total += array[j+2 ]; /* Main body of\r\n  total += array[j+3]; * loop is unrolled\r\n  total += array[j+4]; * for greater speed.\r\n  total += array[j+5]; */\r\n  total += array[j+6 ];\r\n  total += array[j+7 ];\r\n  }\r\n```\r\n\r\n如果不是用绿色标出来，你能注意到这三行代码被注释掉了么？\r\n\r\n### 用连接符隐藏变量\r\n\r\n对于下面的定义\r\n\r\n```c\r\n#define local_var xy_z\r\n```\r\n\r\n可以把 \"xy_z\" 打散到两行里：\r\n\r\n```c\r\n#define local_var xy\\\r\n_z // local_var OK\r\n```\r\n\r\n这样全局搜索 xy_z 的操作在这个文件里就一无所获了。 对于 C 预处理器来说，第一行最后的 \"\\\" 表示继续拼接下一行的内容。\r\n\r\n## 文档\r\n\r\n> 任何傻瓜都能说真话，而要把谎编圆则需要相当的智慧。\r\n> \\- Samuel Butler (1835 - 1902)\r\n>\r\n> 不正确的文档往往比没有文档还糟糕。\r\n> \\- Bertrand Meyer\r\n\r\n既然计算机是忽略注释和文档的，你就可以在里边堂而皇之地编织弥天大谎，让可怜的维护代码的程序员彻底迷失。\r\n\r\n### 在注释中撒谎\r\n\r\n实际上你不需要主动地撒谎，只要没有及时保持注释和代码更新的一致性就可以了。\r\n\r\n### 只记录显而易见的东西\r\n\r\n往代码里掺进去类似于 `/* 给 i 加 1 */` 这样的注释，但是永远不要记录包或者方法的整体设计这样的干货。\r\n\r\n### 记录 How 而不是 Why\r\n\r\n只解释一个程序功能的细节，而不是它要完成的任务是什么。这样的话，如果出现了一个 bug，修复者就搞不清这里的代码应有的功能。\r\n\r\n### 该写的别写\r\n\r\n比如你在开发一套航班预定系统，那就要精心设计，让它在增加另一个航空公司的时候至少有 25 处代码需要修改。永远不要在文档里说明要修改的位置。后来的开发人员要想修改你的代码门都没有，除非他们能把每一行代码都读懂。\r\n\r\n### 计量单位\r\n\r\n永远不要在文档中说明任何变量、输入、输出或参数的计量单位，如英尺、米、加仑等。计量单位对数豆子不是太重要，但在工程领域就相当重要了。同理，永远不要说明任何转换常量的计量单位，或者是它的取值如何获得。要想让代码更乱的话，你还可以在注释里写上错误的计量单位，这是赤裸裸的欺骗，但是非常有效。如果你想做一个恶贯满盈的人，不妨自己发明一套计量单位，用自己或某个小人物的名字命名这套计量单位，但不要给出定义。万一有人挑刺儿，你就告诉他们，你这么做是为了把浮点数运算凑成整数运算而进行的转换。\r\n\r\n### 坑\r\n\r\n永远不要记录代码中的坑。如果你怀疑某个类里可能有 bug，天知地知你知就好。如果你想到了重构或重写代码的思路，看在老天爷的份上，千万别写出来。切记电影《小鹿斑比》里那句台词 \"如果你不能说好听的话，那就什么也不要说。\"。万一这段代码的原作者看到你的注释怎么办？万一老板看到了怎么办？万一客户看到了怎么办？搞不好最后你自己被解雇了。一句” 这里需要修改 “的匿名注释就好多了，尤其是当看不清这句注释指的是哪里需要修改的情况下。切记难得糊涂四个字，这样大家都不会感觉受到了批评。\r\n\r\n### 说明变量\r\n\r\n永远不要 对变量声明加注释。有关变量使用的方式、边界值、合法值、小数点后的位数、计量单位、显示格式、数据录入规则等等，后继者完全可以自己从程序代码中去理解和整理嘛。如果老板强迫你写注释，就把方法体代码混进去，但绝对不要对变量声明写注释，即使是临时变量！\r\n\r\n### 在注释里挑拨离间\r\n\r\n为了阻挠任何雇佣外部维护承包商的倾向，可以在代码中散布针对其他同行软件公司的攻击和抹黑，特别是可能接替你工作的其中任何一家。例如：\r\n\r\n```java\r\n/* 优化后的内层循环\r\n这套技巧对于 SSI 软件服务公司的那帮蠢材来说太高深了，他们只会\r\n用 <math.h> 里的笨例程，消耗 50 倍的内存和处理时间。\r\n*/\r\nclass clever_SSInc\r\n    {\r\n    ...\r\n    }\r\n```\r\n\r\n可能的话，除了注释之外，这些攻击抹黑的内容也要掺到代码里的重要部分，这样如果管理层想清理掉这些攻击性的言论然后发给外部承包商去维护，就会破坏代码结构。\r\n\r\n## 程序设计\r\n\r\n> 编写无法维护代码的基本规则就是：在尽可能多的地方，以尽可能多的方式表述每一个事实。\r\n> \\- Roedy Green\r\n> 编写可维护代码的关键因素是只在一个地方表述应用里的一个事实。如果你的想法变了，你也只在一个地方修改，这样就能保证整个程序正常工作。所以，编写无法维护代码的关键因素就是反复地表述同一个事实，在尽可能多的地方，以尽可能多的方式进行。令人高兴的是，像 Java 这样的语言让编写这种无法维护代码变得非常容易。例如，改变一个被引用很多的变量的类型几乎是不可能的，因为所有造型和转换功能都会出错，而且关联的临时变量的类型也不合适了。而且，如果变量值要在屏幕上显示，那么所有相关的显示和数据录入代码都必须一一找到并手工进行修改。类似的还有很多，比如由 C 和 Java 组成的 Algol 语言系列，Abundance 甚至 Smalltalk 对于数组等结构的处理，都是大有可为的。\r\n\r\n### Java 类型\r\n\r\nJava 的类型机制是上帝的礼物。你可以问心无愧地使用它，因为 Java 语言本身就需要它。每次你从一个 Collection 里获取一个对象，你都必须把它造型为原始类型。这样这个变量的类型就必须在无数地方表述。如果后来类型变了，所有的造型都要修改才能匹配。如果倒霉的维护代码的程序员没有找全（或者修改太多），编译器能不能检测到也不好说。类似的，如果变量类型从 `short` 变成 `int`，所有匹配的造型也都要从 `(short)`改成 `(int)`。\r\n\r\n### 利用 Java 的冗余\r\n\r\nJava 要求你给每个变量的类型写两次表述。 Java 程序员已经习惯了这种冗余，他们不会注意到你的两次表述有细微的差别，例如\r\n\r\n```java\r\nBubblegum b = new Bubblegom();\r\n```\r\n\r\n不幸的是 ++ 操作符的盛行让下面这种伪冗余代码得手的难度变大了：\r\n\r\n```java\r\nswimmer = swimner + 1;\r\n```\r\n\r\n### 永远不做校验\r\n\r\n永远不要对输入数据做任何的正确性或差异性检查。这样能表现你对公司设备的绝对信任，以及你是一位信任所有项目伙伴和系统管理员的团队合作者。总是返回合理的值，即使数据输入有问题或者错误。\r\n\r\n### 有礼貌，无断言\r\n\r\n避免使用 assert() 机制，因为它可能把三天的 debug 盛宴变成 10 分钟的快餐。\r\n\r\n### 避免封装\r\n\r\n为了提高效率，不要使用封装。方法的调用者需要所有能得到的外部信息，以便了解方法的内部是如何工作的。\r\n\r\n### 复制粘贴修改\r\n\r\n以效率的名义，使用 复制 + 粘贴 + 修改。这样比写成小型可复用模块效率高得多。在用代码行数衡量你的进度的小作坊里，这招尤其管用。\r\n\r\n### 使用静态数组\r\n\r\n如果一个库里的模块需要一个数组来存放图片，就定义一个静态数组。没人会有比 512 X 512 更大的图片，所以固定大小的数组就可以了。为了最佳精度，就把它定义成 double 类型的数组。\r\n\r\n### 傻瓜接口\r\n\r\n编写一个名为 \"WrittenByMe\" 之类的空接口，然后让你的所有类都实现它。然后给所有你用到的 Java 内置类编写包装类。这里的思想是确保你程序里的每个对象都实现这个接口。最后，编写所有的方法，让它们的参数和返回类型都是这个 WrittenByMe。这样就几乎不可能搞清楚某个方法的功能是什么，并且所有类型都需要好玩的造型方法。更出格的玩法是，让每个团队成员编写它们自己的接口 (例如 WrittenByJoe)，程序员用到的任何类都要实现他自己的接口。这样你就可以在大量无意义接口中随便找一个来引用对象了。\r\n\r\n### 巨型监听器\r\n\r\n永远不要为每个组件创建分开的监听器。对所有按钮总是用同一个监听器，只要用大量的 if...else 来判断是哪一个按钮被点击就行了。\r\n\r\n好事成堆 TM\r\n狂野地使用封装和 OO 思想。例如\r\n\r\n```java\r\nmyPanel.add( getMyButton() );\r\nprivate JButton getMyButton()\r\n    {\r\n    return myButton;\r\n    }\r\n```\r\n\r\n这段很可能看起来不怎么好笑。别担心，只是时候未到而已。\r\n\r\n### 友好的朋友\r\n\r\n在 C++ 里尽量多使用 friend 声明。再把创建类的指针传递给已创建类。现在你不用浪费时间去考虑接口了。另外，你应该用上关键字 private 和 protected 来表明你的类封装得很好。\r\n\r\n### 使用三维数组\r\n\r\n大量使用它们。用扭曲的方式在数组之间移动数据，比如，用 arrayA 里的行去填充 arrayB 的列。这么做的时候，不管三七二十一再加上 1 的偏移值，这样很灵。让维护代码的程序员抓狂去吧。\r\n\r\n### 混合与匹配\r\n\r\n存取方法和公共变量神马的都要给他用上。这样的话，你无需调用存取器的开销就可以修改一个对象的变量，还能宣称这个类是个 \"Java Bean\"。对于那些试图添加日志函数来找出改变值的源头的维护代码的程序员，用这一招来迷惑他尤其有效。\r\n\r\n### 没有秘密\r\n\r\n把每个方法和变量都声明为 public。毕竟某个人某天可能会需要用到它。一旦方法被声明为 public 了，就很难缩回去。对不？这样任何它覆盖到的代码都很难修改了。它还有个令人愉快的副作用，就是让你看不清类的作用是什么。如果老板质问你是不是疯了，你就告诉他你遵循的是经典的透明接口原则。\r\n\r\n### 全堆一块\r\n\r\n把你所有的没用的和过时的方法和变量都留在代码里。毕竟说起来，既然你在 1976 年用过一次，谁知道你啥时候会需要再用到呢？当然程序是改了，但它也可能会改回来嘛，你 \"不想要重新发明轮子\"（领导们都会喜欢这样的口气）。如果你还原封不动地留着这些方法和变量的注释，而且注释写得又高深莫测，甭管维护代码的是谁，恐怕都不敢对它轻举妄动。\r\n\r\n### 就是 Final\r\n\r\n把你所有的叶子类都声明为 final。毕竟说起来，你在项目里的活儿都干完了，显然不会有其他人会通过扩展你的类来改进你的代码。这种情况甚至可能有安全漏洞。 java.lang.String 被定义成 final 也许就是这个原因吧？如果项目组其他程序员有意见，告诉他们这样做能够提高运行速度。\r\n\r\n### 避免布局\r\n\r\n永远不要用到布局。当维护代码的程序员想增加一个字段，他必须手工调整屏幕上显示所有内容的绝对坐标值。如果老板强迫你使用布局，那就写一个巨型的 GridBagLayout 并在里面用绝对坐标进行硬编码。\r\n\r\n### 全局变量，怎么强调都不过分\r\n\r\n如果上帝不愿意我们使用全局变量，他就不会发明出这个东西。不要让上帝失望，尽量多使用全局变量。每个函数最起码都要使用和设置其中的两个，即使没有理由也要这么做。毕竟，任何优秀的维护代码的程序员都会很快搞清楚这是一种侦探工作测试，有利于让他们从笨蛋中脱颖而出。\r\n\r\n### 再一次说说全局变量\r\n\r\n全局变量让你可以省去在函数里描述参数的麻烦。充分利用这一点。在全局变量中选那么几个来表示对其他全局变量进行操作的类型。\r\n\r\n### 局部变量\r\n\r\n永远不要用局部变量。在你感觉想要用的时候，把它改成一个实例或者静态变量，并无私地和其他方法分享它。这样做的好处是，你以后在其他方法里写类似声明的时候会节省时间。C++ 程序员可以百尺竿头更进一步，把所有变量都弄成全局的。\r\n\r\n### 配置文件\r\n\r\n配置文件通常是以 关键字 = 值 的形式出现。在加载时这些值被放入 Java 变量中。最明显的迷惑技术就是把有细微差别的名字用于关键字和 Java 变量。甚至可以在配置文件里定义运行时根本不会改变的常量。参数文件变量和简单变量比，维护它的代码量起码是后者的 5 倍。\r\n\r\n### 子类\r\n\r\n对于编写无法维护代码的任务来说，面向对象编程的思想简直是天赐之宝。如果你有一个类，里边有 10 个属性（成员 / 方法），可以考虑写一个基类，里面只有一个属性，然后产生 9 层的子类，每层增加一个属性。等你访问到最终的子类时，你才能得到全部 10 个属性。如果可能，把每个类的声明都放在不同的文件里。\r\n\r\n## 编码迷局\r\n\r\n### 迷惑 C\r\n\r\n从互联网上的各种混乱 C 语言竞赛中学习，追随大师们的脚步。\r\n\r\n### 追求极致\r\n\r\n总是追求用最迷惑的方式来做普通的任务。例如，要用数组来把整数转换为相应的字符串，可以这么做：\r\n\r\n```java\r\nchar *p;\r\nswitch (n)\r\n{\r\ncase 1:\r\n    p = \"one\";\r\n    if (0)\r\ncase 2:\r\n    p = \"two\";\r\n    if (0)\r\ncase 3:\r\n    p = \"three\";\r\n    printf(\"%s\", p);\r\n    break;\r\n}\r\n```\r\n\r\n### 一致性的小淘气\r\n\r\n当你需要一个字符常量的时候，可以用多种不同格式： ' ', 32, 0x20, 040。在 C 或 Java 里 10 和 010 是不同的数（0 开头的表示 16 进制），你也可以充分利用这个特性。\r\n\r\n### 造型\r\n\r\n把所有数据都以 void \\* 形式传递，然后再造型为合适的结构。不用结构而是通过位移字节数来造型也很好玩。\r\n\r\n### 嵌套 Switch\r\n\r\nSwitch 里边还有 Switch，这种嵌套方式是人类大脑难以破解的。\r\n\r\n### 利用隐式转化\r\n\r\n牢记编程语言中所有的隐式转化细节。充分利用它们。数组的索引要用浮点变量，循环计数器用字符，对数字执行字符串函数调用。不管怎么说，所有这些操作都是合法的，它们无非是让源代码更简洁而已。任何尝试理解它们的维护者都会对你感激不尽，因为他们必须阅读和学习整个关于隐式数据类型转化的章节，而这个章节很可能是他们来维护你的代码之前完全忽略了的。\r\n\r\n### 分号\r\n\r\n在所有语法允许的地方都加上分号，例如：\r\n\r\n```java\r\nif(a);\r\nelse;\r\n    {\r\n    int d;\r\n    d = c;\r\n    }\r\n    ;\r\n```\r\n\r\n### 使用八进制数\r\n\r\n把八进制数混到十进制数列表里，就像这样：\r\n\r\n```java\r\narray = new int []\r\n    {\r\n    111,\r\n    120,\r\n    013,\r\n    121,\r\n    };\r\n```\r\n\r\n### 嵌套\r\n\r\n尽可能深地嵌套。优秀的程序员能在一行代码里写 10 层 ()，在一个方法里写 20 层 {}。\r\n\r\n### C 数组\r\n\r\nC 编译器会把 `myArray[i]` 转换成 `_(myArray + i)`，它等同于 `_(i + myArray)` 也等同于 `i[myArray]`。 高手都知道怎么用好这个招。可以用下面的函数来产生索引，这样就把代码搞乱了：\r\n\r\n```c\r\nint myfunc(int q, int p) { return p%q; }\r\n...\r\nmyfunc(6291, 8)[Array];\r\n```\r\n\r\n遗憾的是，这一招只能在本地 C 类里用，Java 还不行。\r\n\r\n### 放长线钓大鱼\r\n\r\n一行代码里堆的东西越多越好。这样可以省下临时变量的开销，去掉换行和空格还可以缩短源文件大小。记住，要去掉运算符两边的空格。优秀的程序员总是能突破某些编辑器对于 255 个字符行宽的限制。\r\n\r\n### 异常\r\n\r\n我这里要向你传授一个编程中鲜为人知的秘诀。异常是个讨厌的东西。良好的代码永远不会出错，所以异常实际上是不必要的。不要把时间浪费在这上面。子类异常是给那些知道自己代码会出错的低能儿用的。在整个应用里，你只用在 main () 里放一个 try/catch，里边直接调用 System.exit() 就行了。在每个方法头要贴上标准的抛出集合定义，到底会不会抛出异常你就不用管了。\r\n\r\n### 使用异常的时机\r\n\r\n在非异常条件下才要使用异常。比如终止循环就可以用 `ArrayIndexOutOfBoundsException`。还可以从异常里的方法返回标准的结果。\r\n\r\n### 狂热奔放地使用线程\r\n\r\n如题。\r\n\r\n## 测试\r\n\r\n在程序里留些 bug，让后继的维护代码的程序员能做点有意思的事。精心设计的 bug 是无迹可寻的，而且谁也不知道它啥时候会冒出来。要做到这一点，最简单的办法的就是不要测试代码。\r\n\r\n### 永不测试\r\n\r\n永远不要测试负责处理错误、当机或操作系故障的任何代码。反正这些代码永远也不会执行，只会拖累你的测试。还有，你怎么可能测试处理磁盘错误、文件读取错误、操作系统崩溃这些类型的事件呢？为啥你要用特别不稳定的计算机或者用测试脚手架来模拟这样的环境？现代化的硬件永远不会崩溃，谁还愿意写一些仅仅用于测试的代码？这一点也不好玩。如果用户抱怨，你就怪到操作系统或者硬件头上。他们永远不会知道真相的。\r\n\r\n### 永远不要做性能测试\r\n\r\n嘿，如果软件运行不够快，只要告诉客户买个更快的机器就行了。如果你真的做了性能测试，你可能会发现一个瓶颈，这会导致修改算法，然后导致整个产品要重新设计。谁想要这种结果？而且，在客户那边发现性能问题意味着你可以免费到外地旅游。你只要备好护照和最新照片就行了。\r\n\r\n### 永远不要写任何测试用例\r\n\r\n永远不要做代码覆盖率或路径覆盖率测试。自动化测试是给那些窝囊废用的。搞清楚哪些特性占到你的例程使用率的 90%，然后把 90% 的测试用在这些路径上。毕竟说起来，这种方法可能只测试到了大约你代码的 60%，这样你就节省了 40% 的测试工作。这能帮助你赶上项目后端的进度。等到有人发现所有这些漂亮的 “市场特性” 不能正常工作的时候，你早就跑路了。一些有名的大软件公司就是这样测试代码的，所以你也应该这样做。如果因为某种原因你还没走，那就接着看下一节。\r\n\r\n### 测试是给懦夫用的\r\n\r\n勇敢的程序员会跳过这个步骤。太多程序员害怕他们的老板，害怕丢掉工作，害怕客户的投诉邮件，害怕遭到起诉。这种恐惧心理麻痹了行动，降低了生产率。有科学研究成果表明，取消测试阶段意味着经理有把握能提前确定交付时间，这对于规划流程显然是有利的。消除了恐惧心理，创新和实验之花就随之绽放。程序员的角色是生产代码，调试工作完全可以由技术支持和遗留代码维护组通力合作来进行。\r\n\r\n如果我们对自己的编程能力有充分信心，那么测试就没有必要了。如果我们逻辑地看待这个问题，随便一个傻瓜都能认识到测试根本都不是为了解决技术问题，相反，它是一种感性的信心问题。针对这种缺乏信心的问题，更有效的解决办法就是完全取消测试，送我们的程序员去参加自信心培训课程。毕竟说起来，如果我们选择做测试，那么我们就要测试每个程序的变更，但其实我们只需要送程序员去一次建立自信的培训课就行了。很显然这么做的成本收益是相当可观的。\r\n\r\n## 编程语言的选择\r\n\r\n计算机语言正在逐步进化，变得更加傻瓜化。使用最新的语言是不人性的。尽可能坚持使用你会用的最老的语言，先考虑用穿孔纸带，不行就用汇编，再不行用 FORTRAN 或者 COBOL，再不行就用 C 还有 BASIC，实在不行再用 C++。\r\n\r\n### FØRTRAN\r\n\r\n用 FORTRAN 写所有的代码。如果老板问你为啥，你可以回答说有很多它非常有用的库，你用了可以节约时间。不过，用 FORTRAN 写出可维护代码的概率是 0，所以，要达到不可维护代码编程指南里的要求就容易多了。\r\n\r\n### 用 ASM\r\n\r\n把所有的通用工具函数都转成汇编程序。\r\n\r\n### 用 QBASIC\r\n\r\n所有重要的库函数都要用 QBASIC 写，然后再写个汇编的封包程序来处理 large 到 medium 的内存模型映射。\r\n\r\n### 内联汇编\r\n\r\n在你的代码里混杂一些内联的汇编程序，这样很好玩。这年头几乎没人懂汇编程序了。只要放几行汇编代码就能让维护代码的程序员望而却步。\r\n\r\n### 宏汇编调用 C\r\n\r\n如果你有个汇编模块被 C 调用，那就尽可能经常从汇编模块再去调用 C，即使只是出于微不足道的用途，另外要充分利用 goto, bcc 和其他炫目的汇编秘籍。\r\n\r\n## 与他人共事之道\r\n\r\n### 老板才是真行家\r\n\r\n如果你的老板认为他 20 年的 FORTRAN 编程经验对于现代软件开发具有很高的指导价值，你务必严格采纳他的所有建议。投桃报李，你的老板也会信任你。这会对你的职业发展有利。你还会从他那里学到很多搞乱程序代码的新方法。\r\n\r\n### 颠覆技术支持\r\n\r\n确保代码中到处是 bug 的有效方法是永远不要让维护代码的程序员知道它们。这需要颠覆技术支持工作。永远不接电话。使用自动语音答复 “感谢拨打技术支持热线。需要人工服务请按 1，或在嘀声后留言。”，请求帮助的电子邮件必须忽略，不要给它分配服务追踪号。对任何问题的标准答复是 “我估计你的账户被锁定了，有权限帮你恢复的人现在不在。”\r\n\r\n### 沉默是金\r\n\r\n永远不要对下一个危机保持警觉。如果你预见到某个问题可能会在一个固定时间爆发，摧毁西半球的全部生命，不要公开讨论它。不要告诉朋友、同事或其他你认识的有本事的人。在任何情况下都不要发表任何可能暗示到这种新的威胁的内容。只发送一篇正常优先级的、语焉不详的备忘录给管理层，保护自己免遭秋后算账。如果可能的话，把这篇稀里糊涂的信息作为另外一个更紧急的业务问题的附件。这样就可以心安理得地休息了，你知道将来你被强制提前退休之后一段时间，他们又会求着你回来，并给你对数级增长的时薪！\r\n\r\n### 每月一书俱乐部\r\n\r\n加入一个计算机每月一书俱乐部。选择那些看上去忙着写书不可能有时间真的去写代码的作者。去书店里找一些有很多图表但是没有代码例子的书。浏览一下这些书，从中学会一些迂腐拗口的术语，用它们就能唬住那些自以为是的维护代码的程序员。你的代码肯定会给他留下深刻印象。如果人们连你写的术语都理解不了，他们一定会认为你非常聪明，你的算法非常深奥。不要在你的算法说明里作任何朴素的类比。\r\n\r\n## 自立门户\r\n\r\n你一直想写系统级的代码。现在机会来了。忽略标准库， [编写你自己的标准](http://www.roll-your-own.com)，这将会是你简历中的一个亮点。\r\n\r\n### 推出你自己的 BNF 范式\r\n\r\n总是用你自创的、独一无二的、无文档的 BNF 范式记录你的命令语法。永远不要提供一套带注解的例子（合法命令和非法命令之类）来解释你的语法体系。那样会显得完全缺乏学术严谨性。确保没有明显的方式来区分终结符和中间符号。永远不要用字体、颜色、大小写和其他任何视觉提示帮助读者分辨它们。在你的 BNF 范式用和命令语言本身完全一样的标点符号，这样读者就永远无法分清一段 (...), [...], {...} 或 \"...\" 到底是你在命令行里真正输入的，还是想提示在你的 BNF 范式里哪个语法元素是必需的、可重复的、或可选的。不管怎么样，如果他们太笨，搞不清你的 BNF 范式的变化，就没资格使用你的程序。\r\n\r\n### 推出你自己的内存分配\r\n\r\n地球人儿都知道，调试动态存储是复杂和费时的。与其逐个类去确认它没有内存溢出，还不如自创一套存储分配机制呢。其实它无非是从一大片内存中 malloc 一块空间而已。用不着释放内存，让用户定期重启动系统，这样不就清除了堆么。重启之后系统需要追踪的就那么一点东西，比起解决所有的内存泄露简单得不知道到哪里去了！而且，只要用户记得定期重启系统，他们也永远不会遇到堆空间不足的问题。一旦系统被部署，你很难想象他们还能改变这个策略。\r\n\r\n## 其他杂七杂八的招\r\n\r\n> _如果你给某人一段程序，你会让他困惑一天；如果你教他们如何编程，你会让他困惑一辈子。_-- Anonymous\r\n\r\n### 1. 不要重编译\r\n\r\n让我们从一条可能是有史以来最友好的技巧开始：把代码编译成可执行文件。如果它能用，就在源代码里做一两个微小的改动 -- 每个模块都照此办理。**但是不要费劲巴拉地再编译一次了。** 你可以留着等以后有空而且需要调试的时候再说。多年以后，等可怜的维护代码的程序员更改了代码之后发现出错了，他会有一种错觉，觉得这些肯定是他自己最近修改的。这样你就能让他毫无头绪地忙碌很长时间。\r\n\r\n### 2. 挫败调试工具\r\n\r\n对于试图用行调试工具追踪来看懂你的代码的人，简单的一招就能让他狼狈不堪，那就是把每一行代码都写得很长。特别要把 then 语句 和 if 语句放在同一行里。他们无法设置断点。他们也无法分清在看的分支是哪个 if 里的。\r\n\r\n### 3. 公制和美制\r\n\r\n在工程方面有两种编码方式。一种是把所有输入都转换为公制（米制）计量单位，然后在输出的时候自己换算回各种民用计量单位。另一种是从头到尾都保持各种计量单位混合在一起。总是选择第二种方式，这就是美国之道！\r\n\r\n### 4. 持续改进\r\n\r\n要持续不懈地改进。要常常对你的代码做出 “改进”，并强迫用户经常升级 -- 毕竟没人愿意用一个过时的版本嘛。即便他们觉得他们对现有的程序满意了，想想看，如果他们看到你又 “完善 “了它，他们会多么开心啊！不要告诉任何人版本之间的差别，除非你被逼无奈 -- 毕竟，为什么要告诉他们本来永远也不会注意到的一些 bug 呢？\r\n\r\n### 5. ” 关于 “\r\n\r\n” 关于 “一栏应该只包含程序名、程序员姓名和一份用法律用语写的版权声明。理想情况下，它还应该链接到几 MB 的代码，产生有趣的动画效果。但是，里边永远不要包含程序用途的描述、它的版本号、或最新代码修改日期、或获取更新的网站地址、或作者的 email 地址等。这样，所有的用户很快就会运行在不同的版本上，在安装 N+1 版之前就试图安装 N+2 版。\r\n\r\n### 6. 变更\r\n\r\n在两个版本之间，你能做的变更自然是多多益善。你不会希望用户年复一年地面对同一套老的接口或用户界面，这样会很无聊。最后，如果你能在用户不注意的情况下做出这些变更，那就更好了 -- 这会让他们保持警惕，戒骄戒躁。\r\n\r\n### 7. 无需技能\r\n\r\n写无法维护代码不需要多高的技能。喊破嗓子不如甩开膀子，不管三七二十一开始写代码就行了。记住，管理层还在按代码行数考核生产率，即使以后这些代码里的大部分都得删掉。\r\n\r\n### 8. 只带一把锤子\r\n\r\n一招鲜吃遍天，轻装前进。如果你手头只有一把锤子，那么所有的问题都是钉子。\r\n\r\n### 9. 规范体系\r\n\r\n有可能的话，忽略当前你的项目所用语言和环境中被普罗大众所接受的编程规范。比如，编写基于 MFC 的应用时，就坚持使用 STL 编码风格。\r\n\r\n### 10. 翻转通常的 True False 惯例\r\n\r\n把常用的 true 和 false 的定义反过来用。这一招听起来平淡无奇，但是往往收获奇效。你可以先藏好下面的定义：\r\n\r\n```d\r\n#define TRUE 0\r\n#define FALSE 1\r\n```\r\n\r\n把这个定义深深地藏在代码中某个没人会再去看的文件里不易被发现的地方，然后让程序做下面这样的比较\r\n\r\n```c\r\nif (var == TRUE)\r\nif (var != FALSE)\r\n```\r\n\r\n某些人肯定会迫不及待地跳出来 “修正” 这种明显的冗余，并且在其他地方照着常规去使用变量 var：\r\n\r\n```c\r\nif (var)\r\n```\r\n\r\n还有一招是为 `TRUE` 和 `FALSE` 赋予相同的值，虽然大部分人可能会看穿这种骗局。给它们分别赋值 1 和 2 或者 -1 和 0 是让他们瞎忙乎的方式里更精巧的，而且这样做看起来也不失对他们的尊重。你在 Java 里也可以用这一招，定义一个叫 `TRUE` 的静态常量。在这种情况下，其他程序员更有可能怀疑你干的不是好事，因为 Java 里已经有了内建的标识符 `true`。\r\n\r\n### 11. 第三方库\r\n\r\n在你的项目里引入功能强大的第三方库，然后不要用它们。潜规则就是这样，虽然你对这些好的工具仍然一无所知，却还是可以在你简历的 “其他工具” 一节中写上这些没用过的库。\r\n\r\n### 12. 不要用库\r\n\r\n假装不知道有些库已经直接在你的开发工具中引入了。如果你用 VC++ 编程，忽略 MFC 或 STL 的存在，手工编写所有字符串和数组的实现；这样有助于保持你的指针技术，并自动阻止任何扩展代码功能的企图。\r\n\r\n### 13. 创建一套 Build 顺序\r\n\r\n把这套顺序规则做得非常晦涩，让维护者根本无法编译任何他的修改代码。秘密保留 SmartJ ，它会让 `make` 脚本形同废物。类似地，偷偷地定义一个 `javac` 类，让它和编译程序同名。说到大招，那就是编写和维护一个定制的小程序，在程序里找到需要编译的文件，然后通过直接调用 `sun.tools.javac.Main` 编译类来进行编译。\r\n\r\n### 14. Make 的更多玩法\r\n\r\n用一个 makefile-generated-batch-file 批处理文件从多个目录复制源文件，文件之间的覆盖规则在文档中是没有的。这样，无需任何炫酷的源代码控制系统，就能实现代码分支，并阻止你的后继者弄清哪个版本的 DoUsefulWork () 才是他需要修改的那个。\r\n\r\n### 15. 搜集编码规范\r\n\r\n尽可能搜集所有关于编写可维护代码的建议，例如 [SquareBox 的建议](http://www.squarebox.co.uk/javatips.html) ，然后明目张胆地违反它们。\r\n\r\n### 16. 规避公司的编码规则\r\n\r\n某些公司有严格的规定，不允许使用数字标识符，你必须使用预先命名的常量。要挫败这种规定背后的意图太容易了。比如，一位聪明的 C++ 程序员是这么写的：\r\n\r\n```c++\r\n#define K_ONE 1\r\n#define K_TWO 2\r\n#define K_THOUSAND 999\r\n```\r\n\r\n### 17. 编译器警告\r\n\r\n一定要保留一些编译器警告。在 make 里使用 “-” 前缀强制执行，忽视任何编译器报告的错误。这样，即使维护代码的程序员不小心在你的源代码里造成了一个语法错误，make 工具还是会重新把整个包 build 一遍，甚至可能会成功！而任何程序员要是手工编译你的代码，看到屏幕上冒出一堆其实无关紧要的警告，他们肯定会觉得是自己搞坏了代码。同样，他们一定会感谢你让他们有找错的机会。学有余力的同学可以做点手脚让编译器在打开编译错误诊断工具时就没法编译你的程序。当然了，编译器也许能做一些脚本边界检查，但是真正的程序员是不用这些特性的，所以你也不该用。既然你用自己的宝贵时间就能找到这些精巧的 bug，何必还多此一举让编译器来检查错误呢？\r\n\r\n### 18. 把 bug 修复和升级混在一起\r\n\r\n永远不要推出什么 “bug 修复 \" 版本。一定要把 bug 修复和数据库结构变更、复杂的用户界面修改，还有管理界面重写等混在一起。那样的话，升级就变成一件非常困难的事情，人们会慢慢习惯 bug 的存在并开始称他们为特性。那些真心希望改变这些” 特性 “的人们就会有动力升级到新版本。这样从长期来说可以节省你的维护工作量，并从你的客户那里获得更多收入。\r\n\r\n### 19. 在你的产品发布每个新版本的时候都改变文件结构\r\n\r\n没错，你的客户会要求向上兼容，那就去做吧。不过一定要确保向下是不兼容的。这样可以阻止客户从新版本回退，再配合一套合理的 bug 修复规则（见上一条），就可以确保每次新版本发布后，客户都会留在新版本。学有余力的话，还可以想办法让旧版本压根无法识别新版本产生的文件。那样的话，老版本系统不但无法读取新文件，甚至会否认这些文件是自己的应用系统产生的！温馨提示：PC 上的 Word 文字处理软件就典型地精于此道。\r\n\r\n### 20. 抵消 Bug\r\n\r\n不用费劲去代码里找 bug 的根源。只要在更高级的例程里加入一些抵销它的代码就行了。这是一种很棒的智力测验，类似于玩 3D 棋，而且能让将来的代码维护者忙乎很长时间都想不明白问题到底出在哪里：是产生数据的低层例程，还是莫名其妙改了一堆东西的高层代码。这一招对天生需要多回合执行的编译器也很好用。你可以在较早的回合完全避免修复问题，让较晚的回合变得更加复杂。如果运气好，你永远都不用和编译器前端打交道。学有余力的话，在后端做点手脚，一旦前端产生的是正确的数据，就让后端报错。\r\n\r\n### 21. 使用旋转锁\r\n\r\n不要用真正的同步原语，多种多样的旋转锁更好 -- 反复休眠然后测试一个 (non-volatile 的) 全局变量，直到它符合你的条件为止。相比系统对象，旋转锁使用简便，” 通用 “性强，” 灵活 “多变，实为居家旅行必备。\r\n\r\n### 22. 随意安插 sync 代码\r\n\r\n把某些系统同步原语安插到一些用不着它们的地方。本人曾经在一段不可能会有第二个线程的代码中看到一个临界区（critical section）代码。本人当时就质问写这段代码的程序员，他居然理直气壮地说这么写是为了表明这段代码是很” 关键 “（也是 critical）的！\r\n\r\n### 23. 优雅降级\r\n\r\n如果你的系统包含了一套 NT 设备驱动，就让应用程序负责给驱动分配 I/O 缓冲区，然后在任何交易过程中对内存中的驱动加锁，并在交易完成后释放或解锁。这样一旦应用非正常终止，I/O 缓存又没有被解锁，NT 服务器就会当机。但是在客户现场不太可能会有人知道怎么弄好设备驱动，所以他们就没有选择（只能请你去免费旅游了）。\r\n\r\n### 24. 定制脚本语言\r\n\r\n在你的 C/S 应用里嵌入一个在运行时按字节编译的脚本命令语言。\r\n\r\n### 25. 依赖于编译器的代码\r\n\r\n如果你发现在你的编译器或解释器里有个 bug，一定要确保这个 bug 的存在对于你的代码正常工作是至关重要的。毕竟你又不会使用其他的编译器，其他任何人也不允许！\r\n\r\n### 26. 一个货真价实的例子\r\n\r\n下面是一位大师编写的真实例子。让我们来瞻仰一下他在这样短短几行 C 函数里展示的高超技巧。\r\n\r\n```c\r\nvoid* Realocate(void*buf, int os, int ns)\r\n{\r\n    void*temp;\r\n    temp = malloc(os);\r\n    memcpy((void*)temp, (void*)buf, os);\r\n    free(buf);\r\n    buf = malloc(ns);\r\n    memset(buf, 0, ns);\r\n    memcpy((void*)buf, (void*)temp, ns);\r\n    return buf;\r\n}\r\n```\r\n\r\n- 重新发明了标准库里已有的简单函数。\r\n- _Realocate_ 这个单词拼写错误。所以说，永远不要低估创造性拼写的威力。\r\n- 无缘无故地给输入缓冲区产生一个临时的副本。\r\n- 无缘无故地造型。 memcpy () 里有 (void*)，这样即使我们的指针已经(void*) 了也要再造型一次。另外这样可以传递任何东西作为参数，加 10 分。\r\n- 永远不必费力去释放临时内存空间。这样会导致缓慢的内存泄露，一开始看来，要程序运行一段时间才行。\r\n- 把用不着的东西也从缓冲区里拷贝出来，以防万一。这样只会在 Unix 上产 core dump，Windows 就不会。\r\n- 很显然，os 和 ns 的含义分别是”old size\"和\"new size\"。\r\n- 给 buf 分配内存之后，memset 初始化它为 0。不要使用 calloc ()，因为某些人会重写 ANSI 规范，这样将来保不齐 calloc () 往 buf 里填的就不是 0 了。（虽然我们复制过去的数据量和 buf 的大小是一样的，不需要初始化，不过这也无所谓啦）\r\n\r\n### 27. 如何修复 \"unused variable\" 错误\r\n\r\n如果你的编译器冒出了 \"unused local variable\" 警告，不要去掉那个变量。相反，要找个聪明的办法把它用起来。我最喜欢的方法是：\r\n\r\n```c\r\ni = i;\r\n```\r\n\r\n### 28. 大小很关键\r\n\r\n差点忘了说了，函数是越大越好。跳转和 GOTO 语句越多越好。那样的话，想做任何修改都需要分析很多场景。这会让维护代码的程序员陷入千头万绪之中。如果函数真的体型庞大的话，对于维护代码的程序员就是哥斯拉怪兽了，它会在他搞清楚情况之前就残酷无情地将他们踩翻在地。\r\n\r\n### 29. 一张图片顶 1000 句话，一个函数就是 1000 行\r\n\r\n把每个方法体写的尽可能的长 -- 最好是你写的任何方法或函数都没有少于 1000 行代码的，而且里边深度嵌套，这是必须的。\r\n\r\n### 30. 少个文件\r\n\r\n一定要保证一个或多个关键文件是找不到的。利用 includes 里边再 includes 就能做到这一点。例如，在你的 main 模块里，你写上：\r\n\r\n```c\r\n#include <stdcode.h>\r\n```\r\n\r\nStdcode.h 是有的。但是在 stdcode.h 里，还有个引用：\r\n\r\n```c\r\n#include \"a:\\\\refcode.h\"\r\n```\r\n\r\n然后，refcode.h 就没地方能找到了。\r\n\r\n### 31. 到处可写，无处可读\r\n\r\n至少要把一个变量弄成这样：到处被设置，但是几乎没有哪里用到它。不幸的是，现代编译器通常会阻止你做相反的事：到处读，没处写。不过你在 C 或 C++ 里还是可以这样做的。\r\n\r\n> **原始博文发布于：** [Roedy Green's Mindproducts](http://mindprod.com/unmain.html)。\r\n","createdTime":1580652937720,"updatedTime":1608894015132,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"d574d7de00434d869972201a262124c8","title":"转载","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"fc656f9cd3da4811988c9063307e0de9","title":"如何超过大多数人","body":"> 转自 <https://coolshell.cn/articles/19464.html>\r\n> 对国内互联网的批判真的是相当尖锐啊 (ノ￣ ω ￣)ノ\r\n\r\n当你看到这篇文章的标题，你一定对这篇文章产生了巨大的兴趣，因为你的潜意识在告诉你，这是一本人生的 “武林秘籍”，而且还是左耳朵写的，一定有干货满满，只要读完，一定可以练就神功并找到超过大多数人的快车道和捷径…… 然而…… 当你看到我这样开篇时，你一定会觉得我马上就要有个转折，告诉你这是不可能的，一切都需要付出和努力…… 然而，你错了，这篇文章还真就是一篇 “秘籍”，只要你把这些 “秘籍” 用起来，你就一定可以超过大多数人。而且，这篇文章只有我这个 “人生导师” 可以写得好。毕竟，我的生命过到了十六进制 2B 的年纪，踏入这个社会已超过 20 年，舍我其谁呢？！\r\n\r\nP.S. 这篇文章借鉴于《[如何写出无法维护的代码](https://coolshell.cn/articles/4758.html)》一文的风格…… 嘿嘿\r\n\r\n## 相关技巧和最佳实践\r\n\r\n要超过别人其实还是比较简单的，尤其在今天的中国，更是简单。因为，你只看看中国的互联网，你就会发现，他们基本上全部都是在消费大众，让大众变得更为地愚蠢和傻瓜。**所以，在今天的中国，你基本上不用做什么，只需要不使用中国互联网，你就很自然地超过大多数人了**。当然，如果你还想跟他们彻底拉开，甩他们几个身位，把别人打到底层，下面的这些 “技巧” 你要多多了解一下。\r\n\r\n在信息获取上，你要不断地向大众鼓吹下面的这些事：\r\n\r\n- 让大家都用百度搜索引擎查找信息，订阅微信公众号或是到知乎上学习知识…… 要做到这一步，你就需要把 “百度一下” 挂在嘴边，然后要经常在群或朋友圈中转发微信公众号的文章，并且转发知乎里的各种 “如何看待……” 这样的文章，让他们爱上八卦，爱上转发，爱上碎片。\r\n- 让大家到微博或是知识星球上粉一些大咖，密切关注他们的言论和动向…… 是的，告诉大家，大咖的任何想法一言一行都可以在微博、朋友圈或是知识星球上获得，让大家相信，你的成长和大咖的见闻和闲扯非常有关系，你跟牛人在一个圈子里你也会变牛。\r\n- 把今日头条和抖音这样的 APP 推荐给大家…… 你只需要让你有朋友成功地安装这两个 APP，他们就会花大量的时间在上面，而不能自拔，要让他们安装其实还是很容易的，你要不信你就装一个试玩一会看看（嘿嘿嘿）。\r\n- 让大家热爱八卦，八卦并不一定是明星的八卦，还可以是你身边的人，比如，公司的同事，自己的同学，职场见闻，社会热点，争议话题，…… 这些东西总有一些东西会让人心态有很多微妙的变化，甚至花大量的时间去搜索和阅读大量的观点，以及花大量时间与人辩论争论，这个过程会让人上瘾，让人欲罢不能，然而这些事却和自己没有半毛钱关系。你要做的事就是转发其中一些 SB 或是很极端的观点，造成大家的一睦讨论后，就早早离场……\r\n- 利用爱国主义，让大家觉得不用学英文，不要出国，不要翻墙，咱们已经是强国了…… 这点其实还是很容易做到的，因为学习是比较逆人性的，所以，只要你鼓吹那些英文无用论，出国活得更惨，国家和民族都变得很强大，就算自己过得很底层，也有大国人民的感觉。\r\n\r\n然后，在知识学习和技能训练上，让他们不得要领并产生幻觉\r\n\r\n- 让他们混淆认识和知识，以为开阔认知就是学习，让他们有学习和成长的幻觉……\r\n- 培养他们要学会使用碎片时间学习。等他们习惯利用碎片时间吃快餐后，他们就会失去精读一本书的耐性……\r\n- 不断地给他们各种各样 “有价值的学习资料”，让他们抓不住重点，成为一个微信公众号或电子书 “收藏家”……\r\n- 让他们看一些枯燥无味的基础知识和硬核知识，这样让他们只会用 “死记硬背” 的方式来学习，甚至直接让他们失去信心，直接放弃……\r\n- 玩具手枪是易用的，重武器是难以操控的，多给他们一些玩具，这样他们就会对玩具玩地得心应手，觉得玩玩具就是自己的专业……\r\n- 让他们喜欢直接得到答案的工作和学习方式，成为一个伸手党，从此学习再也不思考……\r\n- 告诉他们东西做出来就好了，不要追求做漂亮，做优雅，这样他们就会慢慢地变成劳动密集型……\r\n- 让他们觉得自己已经很努力了，剩下的就是运气，并说服他们去‘及时行乐’，然后再也找不到高阶和高效率学习的感觉……\r\n- 让他们觉得 “读完书”、“读过书” 就行了，不需要对书中的东西进行思考，进行总结，或是实践，只要囫囵吞枣尽快读完就等同于学好了……\r\n\r\n最后，在认知和格局上，彻底打垮他们，让他们变成韭菜。\r\n\r\n- 让他们不要看到大的形势，只看到眼前的一亩三分地，做好一个井底之蛙。其实这很简单，比如，你不要让他们看到整个计算机互联网技术改变人类社会的趋势，你要多让他看到，从事这一行业的人有多苦逼，然后再说一下其它行业或职业有多好……\r\n- 宣扬一夜暴富以及快速挣钱的案例，最好让他们进入 “赌博类” 或是 “传销类” 的地方，比如：股市、数字货币…… 要让他们相信各种财富神话，相信他们就是那个幸运儿，他们也可以成为巴菲特，可以成为马云……\r\n- 告诉他们，一些看上去很难的事都是有捷径的，比如：21 天就能学会机器学习，用区块链就能颠覆以及重构整个世界等等……\r\n- 多跟他们讲一些小人物的励志的故事，这样让他们相信，不需要学习高级知识，不需要掌握高级技能，只需要用低等的知识和低级的技能，再加上持续不断拼命重复现有的工作，终有一天就会成功……\r\n- 多让他们跟别人比较，人比人不会气死人，但是会让人变得浮躁，变得心急，变得焦虑，当一个人没有办法控制自己的情绪，没有办法让自己静下心来，人会失去耐性和坚持，开始好大喜欢功，开始装逼，开始歪门邪道剑走偏锋……\r\n- 让他们到体制内的一些非常稳定的地方工作，这样他们拥有不思进取、怕承担责任、害怕犯错、喜欢偷懒、得过且过的素质……\r\n- 让他们到体制外的那些喜欢拼命喜欢加班的地方工作，告诉他们爱拼才会赢，努力加班是一种福报，青春就是用来拼的，让他们喜欢上使蛮力的感觉……\r\n- 告诉他们你的行业太累太辛苦，干不到 30 岁。让他们早点转行，不要耽误人生和青春……\r\n- 当他们要做决定的时候，一定要让他们更多的关注自己会失去的东西，而不是会得到的东西。培养他们患得患失心态，让他们认识不到事物真正的价值，失去判断能力……（比如：让他们觉得跟对人拍领导的马屁忠于公司比自我的成长更有价值）\r\n- 告诉他们，你现有的技能和知识不用更新，就能过好一辈子，新出来的东西没有生命力的…… 这样他们就会像我们再也不学习的父辈一样很快就会被时代所抛弃……\r\n- 每个人都喜欢在一些自己做不到的事上找理由，这种能力不教就会，比如，事情太多没有时间，因为工作上没有用到，等等，你要做的就是帮他们为他们做不到的事找各种非常合理的理由，比如：没事的，一切都是最好的安排；你得不到的那个事没什么意思；你没有面好主要原因是那个面试官问的问题都是可以上网查得到的知识，而不没有问到你真正的能力上；这些东西学了不用很快会忘了，等有了环境再学也不迟……\r\n\r\n**最后友情提示一下，上述的这些 “最佳实践” 你要小心，是所谓，贩毒的人从来不吸毒，开赌场的人从来不赌博！所以，你要小心别自己也掉进去了！这就是 “欲练神功，必先自宫” 的道理。**\r\n\r\n## 相关原理和思维模型\r\n\r\n对于上面的这些技巧还有很多很多，你自己也可以发明或是找到很多。所以，我来讲讲这其中的一些原理。\r\n\r\n一般来说，超过别人一般来说就是两个维度：\r\n\r\n1. **在认知、知识和技能上**。这是一个人赖以立足社会的能力（参看《[程序员的荒谬之言还是至理名言？](https://coolshell.cn/articles/4235.html)》和《[21 天教你学会 C++](https://coolshell.cn/articles/2250.html)》）\r\n2. **在领导力上**。所谓领导力就是你跑在别人前面，你得要有比别人更好的能力更高的标准（参看《[技术人员发展之路](https://coolshell.cn/articles/17583.html)》）\r\n\r\n首先，我们要明白，人的技能是从认识开始，然后通过学校、培训或是书本把 “零碎的认知” 转换成 “系统的知识”，而有要把知识转换成技能，就需要训练和实践，这样才能完成从：认识 -> 知识 -> 技能 的转换。这个转换过程是需要耗费很多时间和精力的，而且其中还需要有强大的学习能力和动手能力，这条路径上有很多的 “关卡”，每道关卡都会过滤掉一大部分人。比如：对于一些比较枯燥的硬核知识来说，90% 的人基本上就倒下来，不是因为他们没有智商，而是他们没有耐心。\r\n\r\n### 认知\r\n\r\n要在认知上超过别人，就要在下面几个方面上做足功夫：\r\n\r\n1. **信息渠道**。试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人 hack 其中的信息（也就是 “中间人攻击”），而这些找不出信息源的人，只能 “被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。（比如：学习 C 语言，放着原作者 K&amp;R 的不用，硬要用错误百出谭浩强的书，能有什么好呢？）\r\n\r\n2. **信息质量**。信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。\r\n\r\n3. **信息密度**。优质的信息，密度一般都很大，因为这种信息会逼着你去干这么几件事，a）搜索并学习其关联的知识，b）沉思和反省，c）亲手去推理、验证和实践…… 一般来说，经验性的文章会比知识性的文章会更有这样的功效。比如，类似于像 Effiective C++/Java，设计模式，Unix 编程艺术，算法导论等等这样的书就是属于这种密度很大的书，而像 [Netflix 的官方 blog](https://medium.com/netflix-techblog) 和 [AWS CTO 的 blog](https://www.allthingsdistributed.com/) 等等地方也会经常有一些这样的文章。\r\n\r\n### 知识\r\n\r\n要在知识上超过别人，你就需要在下面几个方面上做足功夫：\r\n\r\n1. **知识树（图）**。任何知识，只在点上学习不够的，需要在面上学习，这叫系统地学习，这需要我们去总结并归纳知识树或知识图，一个知识面会有多个知识板块组成，一个板块又有各种知识点，一个知识点会导出另外的知识点，各种知识点又会交叉和依赖起来，学习就是要系统地学习整个知识树（图）。而我们都知道，**对于一棵树来说，“根基” 是非常重要的，所以，学好基础知识也是非常重要的，对于一个陌生的地方，有一份地图是非常重要的，没有地图的你只会乱窜，只会迷路、练路、走冤枉路！**\r\n\r\n2. **知识缘由**。任何知识都是有缘由的，了解一个知识的来龙去脉和前世今生，会让你对这个知识有非常强的掌握，而不再只是靠记忆去学习。靠记忆去学习是一件非常糟糕的事。而对于一些操作性的知识（不需要了解由来的），我把其叫操作知识，就像一些函数库一样，这样的知识只要学会查文档就好了。**能够知其然，知其所以然的人自然会比识知识到表皮的人段位要高很多。**\r\n\r\n3. **方法套路**。学习不是为了找到答案，而是找到方法。就像数学一样，你学的是方法，是解题思路，是套路，会用方程式解题的和不会用方程式解题的在解题效率上不可比较，而在微积分面前，其它的解题方法都变成了渣渣。**你可以看到，掌握高级方法的人比别人的优势有多大，学习的目的就是为了掌握更为高级的方法和解题思路**。\r\n\r\n### 技能\r\n\r\n要在技能上超过别人，你就需要在下面几个方面做足功夫：\r\n\r\n1. **精益求精**。如果你想拥有专业的技能，你要做不仅仅是拼命地重复一遍又一遍的训练，而是在每一次重复训练时你都要找到更好的方法，总结经验，让新的一遍能够更好，更漂亮，更有效率，否则，用相同的方法重复，那你只不过在搬砖罢了。\r\n\r\n2. **让自己犯错**。犯错是有利于成长的，这是因为出错会让人反思，反思更好的方法，反思更完美的方案，总结教训，寻求更好更完美的过程，是技能升级的最好的方式。尤其是当你在出错后，被人鄙视，被人嘲笑后，你会有更大的动力提升自己，这样的动力才是进步的源动力。当然，千万不要同一个错误重复地犯！\r\n\r\n3. **找高手切磋**。下过棋，打个球的人都知道，你要想提升自己的技艺，你必需找高手切磋，在和高手切磋的过程中你会感受到高手的技能和方法，有时候你会情不自禁地哇地一下，我靠，还可以这么玩！\r\n\r\n### 领导力\r\n\r\n最后一个是领导力，要有领导力或是影响力这个事并不容易，这跟你的野心有多大，好胜心有多强 ，你愿意付出多少很有关系，因为一个人的领导力跟他的标准很有关系，因为有领导力的人的标准比绝大多数人都要高。\r\n\r\n1. **识别自己的特长和天赋**。首先，每个人 DNA 都可能或多或少都会有一些比大多数人 NB 的东西（当然，也可能没有），如果你有了，那么在你过去的人生中就一定会表现出来了，就是那种大家遇到这个事会来请教你的寻求你帮助的现象。那种，别人要非常努力，而且毫不费劲的事。一旦你有了这样的特长或天赋，那你就要大力地扩大你的领先优势，千万不要进到那些会限制你优势的地方。你是一条鱼，你就一定要把别人拉到水里来玩，绝对不要去陆地上跟别人拼，不断地在自己的特长和天赋上扩大自己的领先优势，彻底一骑绝尘。\r\n\r\n2. **识别自己的兴趣和事业**。没有天赋也没有问题，还有兴趣点，都说兴趣是最好的老师，当年，Linus 就是在学校里对 minx 着迷了，于是整出个 Linux 来，这就是兴趣驱动出的东西，一般来说，兴趣驱动的事总是会比那些被动驱动的更好。但是，这里我想说明一下什么叫 “真 ∙ 兴趣”，真正的兴趣不是那种三天热度的东西，而是那种，你愿意为之付出一辈子的事，是那种无论有多大困难有多难受你都要死磕的事，这才是 “真 ∙ 兴趣”，这也就是你的 “野心” 和 “好胜心” 所在，其实上升到了你的事业。相信我，绝大多数人只有职业而没有事业的。\r\n\r\n3. **建立高级的习惯和方法**。没有天赋没有野心，也还是可以跟别人拼习惯拼方法的，只要你有一些比较好的习惯和方法，那么你一样可以超过大多数人。对此，在习惯上你要做到比较大多数人更自律，更有计划性，更有目标性，比如，每年学习一门新的语言或技术，并可以参与相关的顶级开源项目，每个月训练一个类算法，掌握一种算法，每周阅读一篇英文论文，并把阅读笔记整理出来…… 自律的是非常可怕的。除此之外，你还需要在方法上超过别人，你需要满世界的找各种高级的方法，其中包括，思考的方法，学习的方法、时间管理的方法、沟通的方法这类软实力的，还有，解决问题的方法（trouble shooting 和 problem solving），设计的方法，工程的方法，代码的方法等等硬实力的，一开始照猫画虎，时间长了就可能会自己发明或推导新的方法。\r\n\r\n4. **勤奋努力执着坚持 **。如果上面三件事你都没有也没有能力，那还有最后一件事了，那就是勤奋努力了，就是所谓的 “一万小时定律” 了（参看《[21 天教你学会 C++](https://coolshell.cn/articles/2250.html)》中的十年学编程一节），我见过很多不聪明的人，悟性也不够（比如我就是一个），别人学一个东西，一个月就好了，而我需要 1 年甚至更长，但是很多东西都是死的，只要肯花时间就有一天你会搞懂的，耐不住我坚持十年二十年，聪明的人发明个飞机飞过去了，笨一点的人愚公移山也过得去，因为更多的人是懒人，我不用拼过聪明人，我只用拼过那些懒人就好了。\r\n\r\n好了，就这么多，如果哪天你变得消极和不自信，你要来读读我的这篇文章，子曰：温故而知新。\r\n\r\n（全文完）\r\n","createdTime":1580652937722,"updatedTime":1608894008058,"resources":[],"tags":[{"id":"185201345d1b4d65a22748663093c624","title":"杂谈","parent_id":""},{"id":"d574d7de00434d869972201a262124c8","title":"转载","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"f263e3042824498597a02b35a7ed4dcd","title":"异步并发调用","body":"## 问题\n\n你觉得下面这段代码会怎么打印？这里使用异步模拟了 10 个 thread，然后从 generator 里面迭代取值\n\n```js\nconst sleep = (sec) =>\n  new Promise((res, rej) => {\n    setTimeout(res, sec * 1000)\n  })\nconst group = (arr, kFn) =>\n  arr.reduce((res, item) => {\n    const i = kFn(item)\n    res[i] = (res[i] || 0) + 1\n    return res\n  }, {})\n\nconst fibGenerator = function* (n) {\n  let [a, b] = [0, 1]\n  for (let i = 0; i < n; i++) {\n    yield a\n    ;[a, b] = [b, a + b]\n  }\n}\nconst fibIterator = fibGenerator(100)\n// 开十个 thread\nconst idxArr = Array(10)\n  .fill(0)\n  .map((_, i) => i)\nconst arr = []\nPromise.all(\n  idxArr.map(async (i) => {\n    for (const num of fibIterator) {\n      arr.push([i, num])\n      // 如果改成 await sleep(0) 呢？\n      await sleep(Math.random())\n    }\n  }),\n).then(() => {\n  console.log(\n    arr.length,\n    arr,\n    group(arr, ([i]) => i),\n  )\n})\n```\n\n## 答案\n\n主要考察并发异步和迭代器的知识\n\n修改前\n\n- 100 个，因为 generator 只能迭代 100 次\n- 没什么规律的数组，因为队列在第一次之后追加的 idx 顺序是不确定的，会是 1,2,3...9 然后后面线程就不能确定了\n- 每个线程运行次数至少为 1\n\n修改后\n\n- 同上\n- 确定的数组，线程是 0,1,2...9 的循环，对应的值则是从 0-99 对应的斐波那契数列递增\n- 确定的对象，每个线程运行次数均为 10\n","createdTime":1594900979372,"updatedTime":1607854812857,"resources":[],"tags":[{"id":"1de1ff51140a44d5a2c223459dabcc37","title":"异步","parent_id":""},{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"62804424f22d417ebfcee5ad5e04b754","title":"使用 vscode + draw.io 轻松绘制流程图","body":"> [vscode 扩展](https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio-insiders-build)\n\n## 场景\n\n## 考察\n\n事实上吾辈也有做过相当的考察，用过几个知名的流程图工具，但最终选择 vscode-drawio 插件。\n\n- `plantuml`: 复杂\n- `mermaid`: 复杂，但通过 js 编写，web 友好\n- `processOn`: 付费，不开放\n- `drawio`: 开源、免费，可独立部署或集成\n","createdTime":1599574396944,"updatedTime":1607854812265,"resources":[],"tags":[{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"fc4a5a2a2e8341c584d6e92060faf01f","title":"使用 rollup 打包 react 库","body":"## 场景\n\n其实一般用 tsc 编译一下就行了，但如果想要更加强大的功能，例如打包成一个单文件、多种格式、或者包含 css 时，就需要使用 rollup 来处理了。\n\n- 打包\n- 处理 ts\n- 处理 css\n- 压缩\n\n## 配置文件\n\npackage.json\n\n```json\n{\n  \"scripts\": {\n    \"pub\": \"yarn build && lerna bootstrap\",\n    \"build\": \"rollup -c rollup.config.js\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"^16.9.48\",\n    \"moment\": \"^2.27.0\",\n    \"rollup\": \"^2.26.9\",\n    \"rollup-plugin-babel\": \"^4.4.0\",\n    \"rollup-plugin-postcss\": \"^3.1.8\",\n    \"rollup-plugin-terser\": \"^7.0.1\",\n    \"rollup-plugin-typescript2\": \"^0.27.2\",\n    \"typescript\": \"3.8.2\"\n  }\n}\n```\n\nrollup.config.js\n\n```js\nimport babel from 'rollup-plugin-babel'\nimport typescript from 'rollup-plugin-typescript2'\nimport pkg from './package.json'\nimport { terser } from 'rollup-plugin-terser'\nimport postcss from 'rollup-plugin-postcss'\nimport { resolve } from 'path'\n\nexport default {\n  // 入口文件\n  input: resolve(__dirname, './src/index.ts'),\n  output: {\n    // 打包名称\n    name: pkg.name,\n    exports: 'named',\n    file: resolve(__dirname, './dist/index.js'),\n    format: 'es',\n  },\n  external: [\n    ...Object.keys(pkg.dependencies || {}),\n    ...Object.keys(pkg.peerDependencies || {}),\n  ],\n  plugins: [\n    babel({\n      exclude: 'node_modules/**',\n    }),\n    typescript({\n      typescript: require('typescript'),\n    }),\n    postcss({\n      sourceMap: true,\n      extract: true,\n      minimize: true,\n    }),\n    terser(), // minifies generated bundles\n  ],\n}\n```\n","createdTime":1599101892110,"updatedTime":1607854812232,"resources":[],"tags":[{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"e653734db29e4b1e8a77f4d18183a3d6","title":"Windows 下 Git 中文乱码","body":"## 场景\r\n\r\n在公司的电脑上碰到了 Git 中文乱码的问题，例如想要查看一下仓库的状态，中文全部变成了 ` umber` 的形式。\r\n\r\n```sh\r\ngit status\r\nOn branch master\r\nYour branch is up to date with 'origin/master'.\r\n\r\nChanges not staged for commit:\r\n  (use \"git add <file>...\" to update what will be committed)\r\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\r\n\r\n        modified:   \"source/_posts/JavaScript/\\345\\234\\250\\344\\274\\240\\347\\273\\237\\351\\241\\271\\347\\233\\256\\344\\270\\255\\344\\275\\277\\347\\224\\250-babel-\\347\\274\\226\\350\\257\\221-ES6.md\"\r\n        modified:   \"source/_posts/Tool/IDEA/IDEA \\344\\275\\277\\347\\224\\250\\346\\212\\200\\345\\267\\247.md\"\r\n        modified:   test/test.html\r\n        modified:   test/test.js\r\n\r\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\r\n```\r\n\r\n## 解决方案\r\n\r\n> 该方案摘抄自 [解决 Git 在 windows 下中文乱码的问题](https://gist.github.com/nightire/5069597)\r\n\r\n配置一下这些内容即可\r\n\r\n```sh\r\ngit config --global core.quotepath false # 显示 status 编码\r\ngit config --global gui.encoding utf-8 # 图形界面编码\r\ngit config --global i18n.commit.encoding utf-8 # 提交信息编码\r\ngit config --global i18n.logoutputencoding utf-8 # 输出 log 编码\r\nexport LESSCHARSET=utf-8 # 最后一条命令是因为 git log 默认使用 less 分页，所以需要 bash 对 less 命令进行 utf-8 编码\r\n```\r\n","createdTime":1580652937992,"updatedTime":1605795936802,"resources":[],"tags":[{"id":"0fe3bdc669564a3494e66bc1693d7f3f","title":"git","parent_id":""},{"id":"4e00e5550c864473a3f16e4b0698f1c3","title":"windows","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"ea4c1bd6f73d4faeadf389d0bb269bd3","title":"Git Push 提示不支持具有 Socks5 方案的代理","body":"## 场景\r\n\r\n使用 `Git Push` 提交代码到远程服务器时提示了一个错误\r\n\r\n```bash\r\nfatal: NotSupportedException encountered.\r\n   ServicePointManager 不支持具有 socks5 方案的代理。\r\n```\r\n\r\n## 问题\r\n\r\n然而之后还是正常提交成功了，实际上问题是：\r\n\r\n1. 配置了本地的 `socks5` 的代理（`Shadowsocks` 之类的代理软件）\r\n2. 配置了远程服务器 `Git` 服务端的 `SSH`\r\n3. 本地提交代码到远程服务器时使用的是 `http/https` 协议\r\n\r\n这三者只要有一个不满足就不会出现这个错误了\r\n\r\n## 解决方案\r\n\r\n1. 取消代理\r\n   使用以下简单命令即可取消代理\r\n\r\n   ```bash\r\n   git config --global --unset http.proxy\r\n   git config --global --unset https.proxy\r\n   ```\r\n\r\n   > 注：取消代理会出现另外一个错误，所以并不能解决实际问题\r\n   >\r\n   > ```bash\r\n   > git config --global --unset http.proxy\r\n   > git config --global --unset https.proxy\r\n   > ```\r\n\r\n2. 取消远程的 `SSH`\r\n   在下面的页面中删除你的 `SSH Keys` 即可\r\n\r\n   > - [GitHub](https://github.com/settings/keys)\r\n   > - [Bitbucket](https://bitbucket.org/account/user/your_username/ssh-keys/)\r\n\r\n3. 提交内容到远程 `Git` 服务器时选择 `SSH` 协议\r\n   设置远程仓库为 `SSH` 协议，例如 `GitHub` 的 `SSH` 链接就是 <git@github.com:rxliuli/rxliuli.github.io.git>\r\n\r\n好了，关于 `Git` 提示错误 _Git Push 提示不支持具有 Socks5 方案的代理_ 就到这里啦\r\n","createdTime":1580652937987,"updatedTime":1589552772527,"resources":[],"tags":[{"id":"0fe3bdc669564a3494e66bc1693d7f3f","title":"git","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"88c96ca913764189a7670c31af966d6e","title":"let 与 var 在 for 循环中的区别","body":"## 场景\r\n\r\n今天遇到的一个很有趣的问题，下面两段 js 代码执行的结果是什么？\r\n\r\n```js\r\nfor (let i = 0; i < 3; i++) {\r\n  setTimeout(() => console.log(i), 0)\r\n}\r\n```\r\n\r\n和\r\n\r\n```js\r\nfor (var i = 0; i < 3; i++) {\r\n  setTimeout(() => console.log(i), 0)\r\n}\r\n```\r\n\r\n嗯，乍看之下好像没什么区别，只有声明方式 `let` 和 `var` 不一样而已。\r\n\r\n## 分析\r\n\r\n这里先说一下吾辈两个关于 js 的认知\r\n\r\n1. js 里 `setTimeout` 如果延迟时间为 0 应该会立刻执行\r\n2. js 里的 for 循环和 java 应该差不多，for 循环内部是单独的作用域\r\n\r\n图解如下\r\n\r\n![js for 循环和 setTimeout 理解](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181227214410.png)\r\n\r\n那么答案只有一个，两段代码执行的结果应该都是 `0 1 2` 才对！Ｏ(≧▽≦)Ｏ\r\n\r\n然而当吾辈执行后的结果却是\r\n\r\n- `let`: `0 1 2`\r\n- `var`: `3 3 3`\r\n\r\n发生了什么？吾辈表示很无语。。。┐(￣ヮ￣)┌\r\n\r\n## 解答\r\n\r\n然而，上面的两个认知全错了！\r\n\r\n### 其一：js 里 `setTimeout` 如果延迟时间为 0 应该会立刻执行\r\n\r\n好吧，异步没有 _立刻执行_ 这个说法，js 中异步函数实际上是被 **事件队列** 所管理的。当使用 `setTimeout` 函数时，即便延迟为 0，函数 `() => console.log(i)` 也不会立刻执行，而是会被放到 **事件队列** 中去，然后等待浏览器空闲之后执行。\r\n\r\n在 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#%E9%9B%B6%E5%BB%B6%E8%BF%9F) 上有一段关于零延迟的描述\r\n\r\n> 零延迟\r\n>\r\n> 零延迟并不意味着回调会立即执行。以 0 为第二参数调用 `setTimeout` 并不表示在 `0` 毫秒后就立即调用回调函数。  \r\n> 其等待的时间取决于队列里待处理的消息数量。在下面的例子中，\"this is just a message\" 将会在回调获得处理之前输出到控制台，这是因为延迟参数是运行时处理请求所需的最小等待时间，但并不保证是准确的等待时间。  \r\n> 基本上，`setTimeout` 需要等待当前队列中所有的消息都处理完毕之后才能执行，即使已经超出了由第二参数所指定的时间。\r\n\r\n所以 `setTimeout` 实际上并没有立刻执行，而是等到整个 `for` 循环结束之后才执行的。\r\n\r\n### 其二：js 里的 for 循环和 java 应该差不多，for 循环内部是单独的作用域\r\n\r\n好吧，这个认知更是错的一塌糊涂，for 循环居然没有块级作用域？i 和 k 都是可以直接访问的，犹如直接声明到 for 循环外一样。\r\n\r\n```js\r\nfor (var i = 0; i < 3; i++) {\r\n  var k = 10 - i\r\n}\r\nconsole.log(`i: ${i}, k: ${k}`)\r\n\r\n// 结果：\r\n// i: 3, k: 8\r\n```\r\n\r\n相当于\r\n\r\n```js\r\nvar i = 0\r\nvar k\r\nfor (; i < 3; ) {\r\n  k = 10 - i\r\n  i++\r\n}\r\n```\r\n\r\n如果换成 let 则两者都无法访问\r\n\r\n```js\r\nfor (let i = 0; i < 3; i++) {\r\n  let k = 10 - i\r\n}\r\nconsole.log(`i: ${i}, k: ${k}`)\r\n\r\n// 结果：\r\n// Uncaught ReferenceError: i is not defined\r\n```\r\n\r\n甚至还有一个更有趣的情况，在 for 的表达式和块中可以声明相同的变量，这只说明了一件事，let 声明的变量和循环内部声明的变量不在同一个作用域中！\r\n\r\n```js\r\nfor (var i = 0; i < 3; console.log('in for expression', i), i++) {\r\n  let i\r\n  console.log('in for block', i)\r\n}\r\n\r\n// 结果：\r\n// in for block undefined\r\n// in for expression 0\r\n// in for block undefined\r\n// in for expression 1\r\n// in for block undefined\r\n// in for expression 2\r\n```\r\n\r\n或许，i 只是加了新的作用域，就像下面这样，如此，循环外面就访问不到内部的值，循环内部和 for 的表达式也同样不在一个作用域了，每次循环结束就更新这个值\r\n\r\n```js\r\nfor (var i = 0; i < 3; i++) {\r\n  ;(i => {\r\n    setTimeout(() => console.log(i), 0)\r\n  })(i)\r\n}\r\n```\r\n\r\n> 附：这里吾辈是根据 babel 编译的结果修改而来。而且 babel 真的很聪明，当迭代变量 i 没有更新时，就不会使用 `_i` 进行区分呢！\r\n\r\n## 解决\r\n\r\n重新建立了自己的认知之后，可以再对 `let/var` 在 for 循环进行分析了。\r\n\r\n首先是 `let + for`\r\n\r\n### let + for\r\n\r\n再看下面这段代码，可以对其进行分解\r\n\r\n```js\r\nfor (let i = 0; i < 3; i++) {\r\n  setTimeout(() => console.log(i), 0)\r\n}\r\n```\r\n\r\n1. 创建 for 循环，表达式中存在 let 变量，for 将会创建一个块级作用域（ES6 let 专用）\r\n2. 每次迭代时，会创建一个子块级作用域，迭代变量 i 也会重新生成\r\n3. 对 i 的任何操作，都会被记住并赋值给下一次的迭代\r\n\r\n> 块级作用域只对 let 有效，var 声明的变量仍然能在 for 循环外使用，证明 for 循环并不是像函数作用域那样是连 var 都能封闭的作用域。\r\n\r\n图解如下\r\n\r\n![let + for 图解](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181227212650.png)\r\n\r\n### var + for\r\n\r\n分析一下\r\n\r\n```js\r\nfor (var i = 0; i < 3; i++) {\r\n  setTimeout(() => console.log(i), 0)\r\n}\r\n```\r\n\r\n1. 进入 for 循环\r\n2. 在这里创建了迭代变量 i，因为是函数作用域变量所以在 for 循环外可以访问，被提升到了函数作用域顶部声明\r\n3. setTimeout 函数执行，闭包绑定函数作用域外部变量 i，在循环结束输出 i 的值 3\r\n4. 继续迭代\r\n\r\n![var + for 图解](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20181227213014.png)\r\n\r\n---\r\n\r\n所以以后如果可能，还是要拥抱这些新特性呢！那么，关于 `let/var` 在 `for` 循环中的区别就到这里啦\r\n","createdTime":1580652937894,"updatedTime":1589007446297,"resources":[],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"452eb79b3bd74cbbbc95636b450b52f3","title":"JavaScript 禁止用户保存图片","body":"## 场景\n\n在业务需求中不希望用户保存图片，因为是一些供内部使用的图片。\n\n## 思路\n\n- 添加事件禁止选择、拖拽、右键（简单的禁止用户保存图片，但无法阻止用户打开控制台查看，或是直接抓包）\n- 将之转换为 canvas（让浏览器认为不是图片以此禁止用户对之进行图片的操作，但无法阻止抓包）\n- 禁止用户使用控制台查看源码（阻止浏览器打开控制台，但无法阻止抓包）\n- 传输图片使用自定义格式（可以阻止抓包，但需要后台配合）\n\n> 注：以下内容使用 react+ts 实现\n\n## 添加事件禁止选择、拖拽、右键\n\n简而言之，这是一种简单有效的方式，能够在用户不打开控制台的情况下阻止用户保存图片。\n\n```jsx\nexport function preventDefaultListener(e: any) {\n  e.preventDefault()\n}\n\n;<img\n  src={props.url}\n  alt=\"\"\n  style={{\n    //禁止用户选择\n    userSelect: 'none',\n    //禁止所有鼠标事件，过于强大，图片仅用于展示可用\n    // pointerEvents: 'none',\n  }}\n  onTouchStart={preventDefaultListener}\n  onContextMenu={preventDefaultListener}\n  onDragStart={preventDefaultListener}\n/>\n```\n\n> 参考：<https://www.cnblogs.com/dxzg/p/9930559.html>\n\n## 将之转换为 canvas\n\n另一种思路是将图片转换为 canvas 避免用户使用 `img` 相关的操作。\n\n1. 将图片转成 canvas\n\n   ```ts\n   export async function imageToCanvas(url: string, canvas: HTMLCanvasElement) {\n     return new Promise((resolve, reject) => {\n       //新建Image对象，引入当前目录下的图片\n       const img = new Image()\n       img.src = url\n       const c = canvas.getContext('2d')!\n\n       //图片初始化完成后调用\n       img.onload = function () {\n         //将canvas的宽高设置为图像的宽高\n         canvas.width = img.width\n         canvas.height = img.height\n\n         //canvas画图片\n         c.drawImage(img, 0, 0, img.width, img.height)\n         resolve()\n       }\n       img.addEventListener('error', (e) => {\n         reject(e)\n       })\n     })\n   }\n   ```\n\n2. 禁用 canvas 事件\n\n   ```jsx\n   const throwFn = () => {\n     throw new Error(\n       \"Uncaught DOMException: Failed to execute 'toDataURL' on 'HTMLCanvasElement': Tainted canvases may not be exported.\",\n     )\n   }\n\n   const $canvasRef = useRef<HTMLCanvasElement>(null)\n    useEffect(() => {\n        ;(async () => {\n            await imageToCanvas(props.url, $canvasRef.current!)\n            $canvasRef.current!.toBlob = throwFn\n            $canvasRef.current!.toDataURL = throwFn\n        })()\n    }, [])\n    return (\n        <canvas\n            ref={$canvasRef}\n            onTouchStart={preventDefaultListener}\n            onContextMenu={preventDefaultListener}\n        />\n    )\n   ```\n\n## 禁止用户使用控制台查看源码\n\n如果能禁止用户操作控制台，那么自然能够避免用户查看源码了，下面是一个简单的实现。\n\n```ts\n/**\n * 兼容异步函数的返回值\n * @param res 返回值\n * @param callback 同步/异步结果的回调函数\n * @typeparam T 处理参数的类型，如果是 Promise 类型，则取出其泛型类型\n * @typeparam Param 处理参数具体的类型，如果是 Promise 类型，则指定为原类型\n * @typeparam R 返回值具体的类型，如果是 Promise 类型，则指定为 Promise 类型，否则为原类型\n * @returns 处理后的结果，如果是同步的，则返回结果是同步的，否则为异步的\n */\nexport function compatibleAsync<T = any, Param = T | Promise<T>, R = T>(\n  res: Param,\n  callback: (r: T) => R,\n): Param extends Promise<T> ? Promise<R> : R {\n  return (res instanceof Promise\n    ? res.then(callback)\n    : callback(res as any)) as any\n}\n\n/**\n * 测试函数的执行时间\n * 注：如果函数返回 Promise，则该函数也会返回 Promise，否则直接返回执行时间\n * @param fn 需要测试的函数\n * @returns 执行的毫秒数\n */\nexport function timing<R>(\n  fn: (...args: any[]) => R,\n  // 函数返回类型是 Promise 的话，则返回 Promise<number>，否则返回 number\n): R extends Promise<any> ? Promise<number> : number {\n  const begin = performance.now()\n  const res = fn()\n  return compatibleAsync(res, () => performance.now() - begin)\n}\n/**\n * 禁止他人调试网站相关方法的集合对象\n */\nexport class AntiDebug {\n  /**\n   * 不停循环 debugger 防止有人调试代码\n   * @returns 取消函数\n   */\n  public static cyclingDebugger(): Function {\n    const res = setInterval(() => {\n      debugger\n    }, 100)\n    return () => clearInterval(res)\n  }\n  /**\n   * 检查是否正在 debugger 并调用回调函数\n   * @param fn 回调函数，默认为重载页面\n   * @returns 取消函数\n   */\n  public static checkDebug(\n    fn: Function = () => window.location.reload(),\n  ): Function {\n    const res = setInterval(() => {\n      const diff = timing(() => {\n        debugger\n      })\n      if (diff > 500) {\n        console.log(diff)\n        fn()\n      }\n    }, 1000)\n    return () => clearInterval(res)\n  }\n}\n```\n\n```jsx\nuseEffect(() => {\n  const cancel1 = AntiDebug.cyclingDebugger() as any\n  const cancel2 = AntiDebug.checkDebug(() =>\n    console.log('请不要打开调试'),\n  ) as any\n  return () => {\n    cancel1()\n    cancel2()\n  }\n}, [])\n\nreturn <img src={url} alt=\"\" />\n```\n\n## 传输图片使用自定义格式\n\n该功能需要服务端配合，故而此处赞不实现，可以参考 [微信读书](https://weread.qq.com/)，就是将文本转为 canvas，数据传输也进行了加密，可以在很大程度上防止普通用户想要复制/下载的行为了。\n\n## 总结\n\n如同所有的前端限制用户的技术一样，这是一个没有终点的斗争。。。\n\n> 参考广告屏蔽和屏蔽复制粘贴的发展。。。\n","createdTime":1587958663270,"updatedTime":1588002087312,"resources":[],"tags":[{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"2d9be16aabe14b50abff58cf979b9ec3","title":"TypeScript 函数根据第一个参数推导后面参数的类型","body":"## 问题\n\n在编写一个重载函数时，吾辈发现了 ts 的方法签名问题。\n\n```ts\nenum TypeEnum {\n  A,\n  B,\n}\n\ntype A = {\n  a: string\n}\ntype B = {\n  b: number\n}\n\n//region 普通参数\n\nfunction fn1(type: TypeEnum.A, obj: A): void\nfunction fn1(type: TypeEnum.B, obj: B): void\nfunction fn1(type: TypeEnum, obj: A | B) {}\n\n//endregion\n```\n\n上面是一个简单的重载函数，吾辈希望在输入第一个参数 `type` 之后，ts 就能匹配到正确的参数，然而事实上，ts 并没能完全做到。\n\n![ts 类型提示](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200402140820.png)\n\n当然，如果真的这样写 ts 的类型检查仍然能正确地抛出错误消息，然而未能推导终究是有点问题的。\n\n```ts\n// TS2769: No overload matches this call.   Overload 1 of 2, '(type: TypeEnum.A, obj: A): void', gave the following error.     Argument of type '{ a: string; b: number; }' is not assignable to parameter of type 'A'.       Object literal may only specify known properties, and 'b' does not exist in type 'A'.   Overload 2 of 2, '(type: TypeEnum.B, obj: B): void', gave the following error.     Argument of type 'TypeEnum.A' is not assignable to parameter of type 'TypeEnum.B'\nfn1(TypeEnum.A, {\n  a: '',\n  b: 1,\n})\n```\n\n然后，吾辈想到了几种方式可以尝试解决。\n\n## 解决\n\n### 继承\n\n尝试使用继承限制字段的类型。\n\n```ts\n//region 对象参数\n\nfunction fn2(arg: { type: TypeEnum.A; obj: A }): void\nfunction fn2(arg: { type: TypeEnum.B; obj: B }): void\nfunction fn2(arg: { type: TypeEnum; obj: A | B }) {}\n\nfn2({\n  type: TypeEnum.A,\n  obj: {\n    a: '',\n  },\n})\n\n//endregion\n```\n\n很遗憾的是，这是行不通的，即便是下面的这种变体，仍然是不可行的。\n\n![继承](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200402145908.png)\n\n```ts\ninterface Base<T extends TypeEnum> {\n  type: T\n}\n\ninterface IA extends Base<TypeEnum.A> {\n  obj: A\n}\ninterface IB extends Base<TypeEnum.B> {\n  obj: B\n}\n\nfunction fn2(arg: IA | IB) {}\n```\n\n### 泛型\n\n事实上，使用泛型确实可以做到让 ts 的类型更加 **正确**。\n\n![泛型](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200402145745.png)\n\n缺点：\n\n- 不能使用 ts 的重载\n- 需要函数的作者改变思维\n\n```ts\n//region 泛型\n\ntype EnumTypeMapGen<T extends string[], M extends { [P in TypeEnum]: any }> = []\ntype TypeMap = {\n  [TypeEnum.A]: A\n  [TypeEnum.B]: B\n}\n\nfunction fn3<T extends TypeEnum, Arg extends TypeMap[T]>(type: T, obj: Arg) {}\n\nfn3(TypeEnum.A, {\n  a: '',\n})\n\n//endregion\n```\n\n### 高阶函数\n\n最后，高阶函数可以简单的解决这个问题，它将一次调用更改为两次调用，第一次调用返回的函数便已经确认了类型。\n\n![高阶函数](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20200402145633.png)\n\n缺点：\n\n- 需要使用者接收这种 **函数式** 的调用方式\n\n```ts\n//region 高阶函数\n\nfunction fn4(type: TypeEnum.A): (obj: A) => void\nfunction fn4(type: TypeEnum.B): (obj: B) => void\nfunction fn4(type: TypeEnum): any {}\n\nfn4(TypeEnum.A)({\n  a: '',\n})\n\n//endregion\n```\n\n## 总结\n\n总的而言，泛型和高阶函数都能解决这个问题，吾辈个人倾向于泛型，因为它并未改变调用者的使用方式，而是让作者去改变，避免改变函数的接口本身。\n","createdTime":1585791059335,"updatedTime":1585810857420,"resources":[],"tags":[{"id":"a3f220fe6f2c4c50a1aa91707edb8741","title":"typescript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"1ef7bf384128465b97493cda9b839b2f","title":"JavaScript 微任务/宏任务踩坑","body":"## 场景\r\n\r\n> [SegmentFault](https://segmentfault.com/q/1010000019181961)\r\n\r\n在使用 `async-await` 时，吾辈总是习惯把它们当作同步，终于，现在踩到坑里去了。\r\n使用 `setTimeout` 和 `setInterval` 实现的基于 `Promise` 的 `wait` 函数，然而测试边界情况的时候却发现了一些问题！\r\n\r\n实现代码\r\n\r\n```js\r\n/**\r\n * 等待指定的时间/等待指定表达式成立\r\n * 如果未指定等待条件则立刻执行\r\n * @param {Number|Function} [param] 等待时间/等待条件\r\n * @returns {Promise} Promise 对象\r\n */\r\nexport const wait = param => {\r\n  return new Promise(resolve => {\r\n    if (typeof param === 'number') {\r\n      setTimeout(resolve, param)\r\n    } else if (typeof param === 'function') {\r\n      const timer = setInterval(() => {\r\n        if (param()) {\r\n          clearInterval(timer)\r\n          resolve()\r\n        }\r\n      }, 100)\r\n    } else {\r\n      resolve()\r\n    }\r\n  })\r\n}\r\n```\r\n\r\n测试代码\r\n\r\n```js\r\n;(async () => {\r\n  // 标识当前是否有异步函数 add 在运行了\r\n  let taskIsRun = false\r\n  const add = async (_v, i) => {\r\n    // 如果已经有运行的 add 函数，则等待\r\n    if (taskIsRun) {\r\n      console.log(i + ' 判断前: ')\r\n      await wait(() => {\r\n        return !taskIsRun\r\n      })\r\n      console.log(i + ' 判断后: ' + taskIsRun)\r\n    }\r\n    try {\r\n      taskIsRun = true\r\n      console.log(i + ' 执行前: ' + taskIsRun)\r\n      await wait(100)\r\n    } finally {\r\n      console.log(i + ' 执行后: ')\r\n      taskIsRun = false\r\n    }\r\n  }\r\n\r\n  const start = Date.now()\r\n  await Promise.all(\r\n    Array(10)\r\n      .fill(0)\r\n      .map(add),\r\n  )\r\n  console.log(Date.now() - start)\r\n})()\r\n```\r\n\r\n那么，先不要往下看，猜一下最后打印的大概会是多少呢？\r\n\r\n实际执行结果\r\n\r\n```sh\r\n0 执行前: true ​​​​​at ​​​i + ' 执行前: ' + taskIsRun​​​ ​src/module/function/wait.js:37:6​\r\n\r\n1 判断前:  ​​​​​at ​​​i + ' 判断前: '​​​ ​src/module/function/wait.js:29:6​\r\n\r\n2 判断前:  ​​​​​at ​​​i + ' 判断前: '​​​ ​src/module/function/wait.js:29:6​\r\n\r\n3 判断前:  ​​​​​at ​​​i + ' 判断前: '​​​ ​src/module/function/wait.js:29:6​\r\n\r\n4 判断前:  ​​​​​at ​​​i + ' 判断前: '​​​ ​src/module/function/wait.js:29:6​\r\n\r\n5 判断前:  ​​​​​at ​​​i + ' 判断前: '​​​ ​src/module/function/wait.js:29:6​\r\n\r\n6 判断前:  ​​​​​at ​​​i + ' 判断前: '​​​ ​src/module/function/wait.js:29:6​\r\n\r\n7 判断前:  ​​​​​at ​​​i + ' 判断前: '​​​ ​src/module/function/wait.js:29:6​\r\n\r\n8 判断前:  ​​​​​at ​​​i + ' 判断前: '​​​ ​src/module/function/wait.js:29:6​\r\n\r\n9 判断前:  ​​​​​at ​​​i + ' 判断前: '​​​ ​src/module/function/wait.js:29:6​\r\n\r\n0 执行后:  ​​​​​at ​​​i + ' 执行后: '​​​ ​src/module/function/wait.js:40:6​\r\n\r\n1 判断后: false ​​​​​at ​​​i + ' 判断后: ' + taskIsRun​​​ ​src/module/function/wait.js:33:6​\r\n\r\n1 执行前: true ​​​​​at ​​​i + ' 执行前: ' + taskIsRun​​​ ​src/module/function/wait.js:37:6​\r\n\r\n// 这儿的 1 执行前，结果 2 就已经判断通过并准备执行了？？？发生了什么？\r\n\r\n2 判断后: true ​​​​​at ​​​i + ' 判断后: ' + taskIsRun​​​ ​src/module/function/wait.js:33:6​\r\n\r\n2 执行前: true ​​​​​at ​​​i + ' 执行前: ' + taskIsRun​​​ ​src/module/function/wait.js:37:6​\r\n\r\n3 判断后: true ​​​​​at ​​​i + ' 判断后: ' + taskIsRun​​​ ​src/module/function/wait.js:33:6​\r\n\r\n3 执行前: true ​​​​​at ​​​i + ' 执行前: ' + taskIsRun​​​ ​src/module/function/wait.js:37:6​\r\n\r\n4 判断后: true ​​​​​at ​​​i + ' 判断后: ' + taskIsRun​​​ ​src/module/function/wait.js:33:6​\r\n\r\n4 执行前: true ​​​​​at ​​​i + ' 执行前: ' + taskIsRun​​​ ​src/module/function/wait.js:37:6​\r\n\r\n5 判断后: true ​​​​​at ​​​i + ' 判断后: ' + taskIsRun​​​ ​src/module/function/wait.js:33:6​\r\n\r\n5 执行前: true ​​​​​at ​​​i + ' 执行前: ' + taskIsRun​​​ ​src/module/function/wait.js:37:6​\r\n\r\n6 判断后: true ​​​​​at ​​​i + ' 判断后: ' + taskIsRun​​​ ​src/module/function/wait.js:33:6​\r\n\r\n6 执行前: true ​​​​​at ​​​i + ' 执行前: ' + taskIsRun​​​ ​src/module/function/wait.js:37:6​\r\n\r\n7 判断后: true ​​​​​at ​​​i + ' 判断后: ' + taskIsRun​​​ ​src/module/function/wait.js:33:6​\r\n\r\n7 执行前: true ​​​​​at ​​​i + ' 执行前: ' + taskIsRun​​​ ​src/module/function/wait.js:37:6​\r\n\r\n8 判断后: true ​​​​​at ​​​i + ' 判断后: ' + taskIsRun​​​ ​src/module/function/wait.js:33:6​\r\n\r\n8 执行前: true ​​​​​at ​​​i + ' 执行前: ' + taskIsRun​​​ ​src/module/function/wait.js:37:6​\r\n\r\n9 判断后: true ​​​​​at ​​​i + ' 判断后: ' + taskIsRun​​​ ​src/module/function/wait.js:33:6​\r\n\r\n9 执行前: true ​​​​​at ​​​i + ' 执行前: ' + taskIsRun​​​ ​src/module/function/wait.js:37:6​\r\n\r\n1 执行后:  ​​​​​at ​​​i + ' 执行后: '​​​ ​src/module/function/wait.js:40:6​\r\n\r\n2 执行后:  ​​​​​at ​​​i + ' 执行后: '​​​ ​src/module/function/wait.js:40:6​\r\n\r\n3 执行后:  ​​​​​at ​​​i + ' 执行后: '​​​ ​src/module/function/wait.js:40:6​\r\n\r\n4 执行后:  ​​​​​at ​​​i + ' 执行后: '​​​ ​src/module/function/wait.js:40:6​\r\n\r\n5 执行后:  ​​​​​at ​​​i + ' 执行后: '​​​ ​src/module/function/wait.js:40:6​\r\n\r\n6 执行后:  ​​​​​at ​​​i + ' 执行后: '​​​ ​src/module/function/wait.js:40:6​\r\n\r\n7 执行后:  ​​​​​at ​​​i + ' 执行后: '​​​ ​src/module/function/wait.js:40:6​\r\n\r\n8 执行后:  ​​​​​at ​​​i + ' 执行后: '​​​ ​src/module/function/wait.js:40:6​\r\n\r\n9 执行后:  ​​​​​at ​​​i + ' 执行后: '​​​ ​src/module/function/wait.js:40:6​\r\n\r\n307 ​​​​​at ​​​Date.now() - start​​​ ​src/module/function/wait.js:52:2​\r\n```\r\n\r\n可以看到，很神奇的是 _判断后 => 执行前 => 判断后...=> 执行后..._，并不是预想中的 _判断后 => 执行前 => 执行后..._ 的循环，所以，到底发生了什么呢？\r\n\r\n## 思考\r\n\r\n这个问题卡了吾辈两天之久，直到吾辈在 [StackOverflow](https://stackoverflow.com/questions/56126223/js-asynchronous-concurrent-locks-are-not-in-effect?noredirect=1#comment98896413_56126223) 提出的另一个相关的问题被外国友人回答了，瞬间吾辈就想起了 -- **async-await 本质上还是异步**。\r\n\r\n是的，为什么会出现 `wait` 一直在执行而后面的 `taskIsRun = true` 却并没有执行？因为 JavaScript 中的 `async-await` 虽然可以写出来很像同步代码的异步代码，但实际上还是异步的，原理还是基于 `Promise`。\r\n\r\n我们改造一下代码，将之使用原生 `Promise` 实现一下\r\n\r\n```js\r\n/**\r\n * 等待指定的时间/等待指定表达式成立\r\n * 如果未指定等待条件则立刻执行\r\n * @param {Number|Function} [param] 等待时间/等待条件\r\n * @returns {Promise} Promise 对象\r\n */\r\nexport const wait = param => {\r\n  return new Promise(resolve => {\r\n    if (typeof param === 'number') {\r\n      setTimeout(resolve, param)\r\n    } else if (typeof param === 'function') {\r\n      const timer = setInterval(() => {\r\n        if (param()) {\r\n          clearInterval(timer)\r\n          resolve()\r\n        }\r\n      }, 100)\r\n    } else {\r\n      resolve()\r\n    }\r\n  })\r\n}\r\n;(() => {\r\n  // 标识当前是否有异步函数 add 在运行了\r\n  let taskIsRun = false\r\n  const add = (_v, i) => {\r\n    // 如果已经有运行的 add 函数，则等待\r\n    return Promise.resolve()\r\n      .then(() => {\r\n        if (taskIsRun) {\r\n          console.log(i + ' 判断前: ')\r\n          // 关键在于这里，实际上执行完成之后并不会到下一个 then，而是继续另一个 wait 的判断\r\n          return wait(() => !taskIsRun).then(() => {\r\n            console.log(i + ' 判断后: ' + taskIsRun)\r\n          })\r\n        }\r\n      })\r\n      .then(() => {\r\n        taskIsRun = true\r\n        console.log(i + ' 执行前: ' + taskIsRun)\r\n        return wait(100)\r\n      })\r\n      .catch(() => {})\r\n      .then(() => {\r\n        console.log(i + ' 执行后: ')\r\n        taskIsRun = false\r\n      })\r\n  }\r\n\r\n  const start = Date.now()\r\n  Promise.all(\r\n    Array(10)\r\n      .fill(0)\r\n      .map(add),\r\n  ).then(() => console.log(Date.now() - start))\r\n})()\r\n```\r\n\r\n这个时候就可以看出来了，判断逻辑是处在一个 `then` 后继里面的。那么，执行完 `console.log(i + ' 判断后: ' + taskIsRun)` 之后，就一定会继续执行下面的 `then` 函数么？并不，这时候 `wait` 函数内部实现中的 `setInterval` 还在运转，实际上 `nodejs` 并不会优先继续 `then` 这种 `microtask`（微任务），而是会继续进行 `setInterval` 这种 `macrotask`（宏任务）。这是 nodejs 与浏览器实现不一致的地方，吾辈将这些代码复制到浏览器上，确实可以正常执行并得到预期的结果。\r\n\r\n> [微任务与宏任务参考](https://juejin.im/entry/58d4df3b5c497d0057eb99ff)\r\n\r\n```js\r\nif (taskIsRun) {\r\n  console.log(i + ' 判断前: ')\r\n  return wait(() => !taskIsRun).then(() => {\r\n    console.log(i + ' 判断后: ' + taskIsRun)\r\n  })\r\n}\r\n```\r\n\r\n> 当然，nodejs 11 修复了这个问题，参考 <https://github.com/nodejs/node/pull/22842>。然而目前 NodeJS LTS 为 10，最新版本为 12，这个问题可能还要持续一段时间。\r\n\r\n## 解决\r\n\r\n那么，难道吾辈就必须等到 NodeJS LTS 最新版之后才能用 wait 么？或者说，吾辈就必须依赖于浏览器的 `microtask/macrotask` 么？并不，吾辈对之手动进行了处理即可！\r\n\r\n```js\r\n/**\r\n * 等待指定的时间/等待指定表达式成立\r\n * 如果未指定等待条件则立刻执行\r\n * @param {Number|Function} [param] 等待时间/等待条件\r\n * @returns {Promise} Promise 对象\r\n */\r\nexport const wait = param => {\r\n  return new Promise(resolve => {\r\n    if (typeof param === 'number') {\r\n      setTimeout(resolve, param)\r\n    } else if (typeof param === 'function') {\r\n      const timer = setInterval(() => {\r\n        if (param()) {\r\n          clearInterval(timer)\r\n          resolve()\r\n        }\r\n      }, 100)\r\n    } else {\r\n      resolve()\r\n    }\r\n  })\r\n}\r\n;(async () => {\r\n  // 标识当前是否有异步函数 add 在运行了\r\n  let taskIsRun = false\r\n  const add = async (_v, i) => {\r\n    // 如果已经有运行的 add 函数，则等待\r\n    if (taskIsRun) {\r\n      console.log(i + ' 判断前: ')\r\n      await wait(() => {\r\n        const result = !taskIsRun\r\n        // 关键在于这里\r\n        if (result) {\r\n          taskIsRun = true\r\n        }\r\n        return result\r\n      })\r\n      console.log(i + ' 判断后: ' + taskIsRun)\r\n    }\r\n    try {\r\n      taskIsRun = true\r\n      console.log(i + ' 执行前: ' + taskIsRun)\r\n      await wait(100)\r\n    } finally {\r\n      console.log(i + ' 执行后: ')\r\n      taskIsRun = false\r\n    }\r\n  }\r\n\r\n  const start = Date.now()\r\n  await Promise.all(\r\n    Array(10)\r\n      .fill(0)\r\n      .map(add),\r\n  )\r\n  console.log(Date.now() - start)\r\n})()\r\n```\r\n\r\n吾辈在 `wait` 函数中，即 `setInterval` 循环调用的函数中对 `taskIsRun` 进行了修改，而不是在 `wait` 后面，即 `then` 之后的 `microtask` 中进行修改，结果便一切如同吾辈所期待的一样了！\r\n","createdTime":1580652937873,"updatedTime":1583924716505,"resources":[],"tags":[{"id":"1de1ff51140a44d5a2c223459dabcc37","title":"异步","parent_id":""},{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"f308ebf560c94282807032feccb94586","title":"JavaScript 防抖和节流","body":"## 场景\r\n\r\n网络上已经存在了大量的有关 **防抖** 和 **节流** 的文章，为何吾辈还要再写一篇呢？事实上，防抖和节流，吾辈在使用中发现了一些奇怪的问题，并经过了数次的修改，这里主要分享一下吾辈遇到的问题以及是如何解决的。\r\n\r\n### 为什么要用防抖和节流？\r\n\r\n因为某些函数触发/调用的频率过快，吾辈需要手动去限制其执行的频率。例如常见的监听滚动条的事件，如果没有防抖处理的话，并且，每次函数执行花费的时间超过了触发的间隔时间的话 -- 页面就会卡顿。\r\n\r\n## 演进\r\n\r\n### 初始实现\r\n\r\n我们先实现一个简单的去抖函数\r\n\r\n```js\r\nfunction debounce(delay, action) {\r\n  let tId\r\n  return function(...args) {\r\n    if (tId) clearTimeout(tId)\r\n    tId = setTimeout(() => {\r\n      action(...args)\r\n    }, delay)\r\n  }\r\n}\r\n```\r\n\r\n测试一下\r\n\r\n```js\r\n// 使用 Promise 简单封装 setTimeout，下同\r\nconst wait = ms => new Promise(resolve => setTimeout(resolve, ms))\r\n;(async () => {\r\n  let num = 0\r\n  const add = () => ++num\r\n\r\n  add()\r\n  add()\r\n  console.log(num) // 2\r\n\r\n  const fn = debounce(10, add)\r\n  fn()\r\n  fn()\r\n  console.log(num) // 2\r\n  await wait(20)\r\n  console.log(num) // 3\r\n})()\r\n```\r\n\r\n好了，看来基本的效果是实现了的。包装过的函数 `fn` 调用了两次，却并没有立刻执行，而是等待时间间隔过去之后才最终执行了一次。\r\n\r\n### this 怎么办？\r\n\r\n然而，上面的实现有一个致命的问题，没有处理 `this`！当你用在原生的事件处理时或许还不觉得，然而，当你使用了 ES6 `class` 这类对 `this` 敏感的代码时，就一定会遇到 `this` 带来的问题。\r\n\r\n例如下面使用 `class` 来声明一个计数器\r\n\r\n```js\r\nclass Counter {\r\n  constructor() {\r\n    this.i = 0\r\n  }\r\n  add() {\r\n    this.i++\r\n  }\r\n}\r\n```\r\n\r\n我们可能想在 `constructor` 中添加新的属性 `fn`\r\n\r\n```js\r\nclass Counter {\r\n  constructor() {\r\n    this.i = 0\r\n    this.fn = debounce(10, this.add)\r\n  }\r\n  add() {\r\n    this.i++\r\n  }\r\n}\r\n```\r\n\r\n但很遗憾，这里的 `this` 绑定是有问题的，执行以下代码试试看\r\n\r\n```js\r\nconst counter = new Counter()\r\ncounter.fn() // Cannot read property 'i' of undefined\r\n```\r\n\r\n会抛出异常 `Cannot read property 'i' of undefined`，究其原因就是 `this` 没有绑定，我们可以手动绑定 this `.bind(this)`\r\n\r\n```js\r\nclass Counter {\r\n  constructor() {\r\n    this.i = 0\r\n    this.fn = debounce(10, this.add.bind(this))\r\n  }\r\n  add() {\r\n    this.i++\r\n  }\r\n}\r\n```\r\n\r\n但更好的方式是修改 `debounce`，使其能够自动绑定 `this`\r\n\r\n```js\r\nfunction debounce(delay, action) {\r\n  let tId\r\n  return function(...args) {\r\n    if (tId) clearTimeout(tId)\r\n    tId = setTimeout(() => {\r\n      action.apply(this, args)\r\n    }, delay)\r\n  }\r\n}\r\n```\r\n\r\n然后，代码将如同预期的运行\r\n\r\n```js\r\n;(async () => {\r\n  class Counter {\r\n    constructor() {\r\n      this.i = 0\r\n      this.fn = debounce(10, this.add)\r\n    }\r\n    add() {\r\n      this.i++\r\n    }\r\n  }\r\n\r\n  const counter = new Counter()\r\n  counter.add()\r\n  counter.add()\r\n  console.log(counter.i) // 2\r\n\r\n  counter.fn()\r\n  counter.fn()\r\n  console.log(counter.i) // 2\r\n  await wait(20)\r\n  console.log(counter.i) // 3\r\n})()\r\n```\r\n\r\n### 返回值呢？\r\n\r\n不知道你有没有发现，现在使用 `debounce` 包装的函数都没有返回值，是完全只有副作用的函数。然而，吾辈还是遇到了需要返回值的场景。\r\n例如：_输入停止后，使用 Ajax 请求后台数据判断是否已存在相同的数据。_\r\n\r\n修改 `debounce` 成会缓存上一次执行结果并且有初始结果参数的实现\r\n\r\n```js\r\nfunction debounce(delay, action, init = undefined) {\r\n  let flag\r\n  let result = init\r\n  return function(...args) {\r\n    if (flag) clearTimeout(flag)\r\n    flag = setTimeout(() => {\r\n      result = action.apply(this, args)\r\n    }, delay)\r\n    return result\r\n  }\r\n}\r\n```\r\n\r\n调用代码变成了\r\n\r\n```js\r\n;(async () => {\r\n  class Counter {\r\n    constructor() {\r\n      this.i = 0\r\n      this.fn = debounce(10, this.add, 0)\r\n    }\r\n    add() {\r\n      return ++this.i\r\n    }\r\n  }\r\n\r\n  const counter = new Counter()\r\n\r\n  console.log(counter.add()) // 1\r\n  console.log(counter.add()) // 2\r\n\r\n  console.log(counter.fn()) // 0\r\n  console.log(counter.fn()) // 0\r\n  await wait(20)\r\n  console.log(counter.fn()) // 3\r\n})()\r\n```\r\n\r\n看起来很完美？然而，没有考虑到异步函数是个大失败！\r\n\r\n尝试以下测试代码\r\n\r\n```js\r\n;(async () => {\r\n  const get = async i => i\r\n\r\n  console.log(await get(1))\r\n  console.log(await get(2))\r\n  const fn = debounce(10, get, 0)\r\n  fn(3).then(i => console.log(i)) // fn(...).then is not a function\r\n  fn(4).then(i => console.log(i))\r\n  await wait(20)\r\n  fn(5).then(i => console.log(i))\r\n})()\r\n```\r\n\r\n会抛出异常 `fn(...).then is not a function`，因为我们包装过后的函数是同步的，第一次返回的值并不是 `Promise` 类型。\r\n\r\n除非我们修改默认值\r\n\r\n```js\r\n;(async () => {\r\n  const get = async i => i\r\n\r\n  console.log(await get(1))\r\n  console.log(await get(2))\r\n  // 注意，修改默认值为 Promise\r\n  const fn = debounce(10, get, new Promise(resolve => resolve(0)))\r\n  fn(3).then(i => console.log(i)) // 0\r\n  fn(4).then(i => console.log(i)) // 0\r\n  await wait(20)\r\n  fn(5).then(i => console.log(i)) // 4\r\n})()\r\n```\r\n\r\n### 支持有返回值的异步函数\r\n\r\n支持异步有两种思路\r\n\r\n1. 将异步函数包装为同步函数\r\n2. 将包装后的函数异步化\r\n\r\n第一种思路实现\r\n\r\n```js\r\nfunction debounce(delay, action, init = undefined) {\r\n  let flag\r\n  let result = init\r\n  return function(...args) {\r\n    if (flag) clearTimeout(flag)\r\n    flag = setTimeout(() => {\r\n      const temp = action.apply(this, args)\r\n      if (temp instanceof Promise) {\r\n        temp.then(res => (result = res))\r\n      } else {\r\n        result = temp\r\n      }\r\n    }, delay)\r\n    return result\r\n  }\r\n}\r\n```\r\n\r\n调用方式和同步函数完全一样，当然，是支持异步函数的\r\n\r\n```js\r\n;(async () => {\r\n  const get = async i => i\r\n\r\n  console.log(await get(1))\r\n  console.log(await get(2))\r\n  // 注意，修改默认值为 Promise\r\n  const fn = debounce(10, get, 0)\r\n  console.log(fn(3)) // 0\r\n  console.log(fn(4)) // 0\r\n  await wait(20)\r\n  console.log(fn(5)) // 4\r\n})()\r\n```\r\n\r\n第二种思路实现\r\n\r\n```js\r\nconst debounce = (delay, action, init = undefined) => {\r\n  let flag\r\n  let result = init\r\n  return function(...args) {\r\n    return new Promise(resolve => {\r\n      if (flag) clearTimeout(flag)\r\n      flag = setTimeout(() => {\r\n        result = action.apply(this, args)\r\n        resolve(result)\r\n      }, delay)\r\n      setTimeout(() => {\r\n        resolve(result)\r\n      }, delay)\r\n    })\r\n  }\r\n}\r\n```\r\n\r\n调用方式支持异步的方式\r\n\r\n```js\r\n;(async () => {\r\n  const get = async i => i\r\n\r\n  console.log(await get(1))\r\n  console.log(await get(2))\r\n  // 注意，修改默认值为 Promise\r\n  const fn = debounce(10, get, 0)\r\n  fn(3).then(i => console.log(i)) // 0\r\n  fn(4).then(i => console.log(i)) // 4\r\n  await wait(20)\r\n  fn(5).then(i => console.log(i)) // 5\r\n})()\r\n```\r\n\r\n可以看到，第一种思路带来的问题是返回值永远会是 **旧的** 返回值，第二种思路主要问题是将同步函数也给包装成了异步。利弊权衡之下，吾辈觉得第二种思路更加正确一些，毕竟使用场景本身不太可能必须是同步的操作。而且，原本 `setTimeout` 也是异步的，只是不需要返回值的时候并未意识到这点。\r\n\r\n### 避免原函数信息丢失\r\n\r\n后来，有人提出了一个问题，如果函数上面携带其他信息，例如类似于 `jQuery` 的 `$`，既是一个函数，但也同时含有其他属性，如果使用 `debounce` 就找不到了呀\r\n\r\n一开始吾辈立刻想到了复制函数上面的所有可遍历属性，然后想起了 ES6 的 `Proxy` 特性 -- 这实在是太**魔法**了。使用 Proxy 解决这个问题将异常的简单 -- 因为除了调用函数，其他的一切操作仍然指向原函数！\r\n\r\n```js\r\nconst debounce = (delay, action, init = undefined) => {\r\n  let flag\r\n  let result = init\r\n  return new Proxy(action, {\r\n    apply(target, thisArg, args) {\r\n      return new Promise(resolve => {\r\n        if (flag) clearTimeout(flag)\r\n        flag = setTimeout(() => {\r\n          resolve((result = Reflect.apply(target, thisArg, args)))\r\n        }, delay)\r\n        setTimeout(() => {\r\n          resolve(result)\r\n        }, delay)\r\n      })\r\n    },\r\n  })\r\n}\r\n```\r\n\r\n测试一下\r\n\r\n```js\r\n;(async () => {\r\n  const get = async i => i\r\n  get.rx = 'rx'\r\n\r\n  console.log(get.rx) // rx\r\n  const fn = debounce(10, get, 0)\r\n  console.log(fn.rx) // rx\r\n})()\r\n```\r\n\r\n### 实现节流\r\n\r\n以这种思路实现一个节流函数 `throttle`\r\n\r\n```js\r\n/**\r\n * 函数节流\r\n * 节流 (throttle) 让一个函数不要执行的太频繁，减少执行过快的调用，叫节流\r\n * 类似于上面而又不同于上面的函数去抖, 包装后函数在上一次操作执行过去了最小间隔时间后会直接执行, 否则会忽略该次操作\r\n * 与上面函数去抖的明显区别在连续操作时会按照最小间隔时间循环执行操作, 而非仅执行最后一次操作\r\n * 注: 该函数第一次调用一定会执行，不需要担心第一次拿不到缓存值，后面的连续调用都会拿到上一次的缓存值\r\n * 注: 返回函数结果的高阶函数需要使用 {@link Proxy} 实现，以避免原函数原型链上的信息丢失\r\n *\r\n * @param {Number} delay 最小间隔时间，单位为 ms\r\n * @param {Function} action 真正需要执行的操作\r\n * @return {Function} 包装后有节流功能的函数。该函数是异步的，与需要包装的函数 {@link action} 是否异步没有太大关联\r\n */\r\nconst throttle = (delay, action) => {\r\n  let last = 0\r\n  let result\r\n  return new Proxy(action, {\r\n    apply(target, thisArg, args) {\r\n      return new Promise(resolve => {\r\n        const curr = Date.now()\r\n        if (curr - last > delay) {\r\n          result = Reflect.apply(target, thisArg, args)\r\n          last = curr\r\n          resolve(result)\r\n          return\r\n        }\r\n        resolve(result)\r\n      })\r\n    },\r\n  })\r\n}\r\n```\r\n\r\n## 总结\r\n\r\n嘛，实际上这里的防抖和节流仍然是简单的实现，其他的像 **取消防抖**/**强制刷新缓存** 等功能尚未实现。当然，对于吾辈而言功能已然足够了，也被放到了公共的函数库 [rx-util](https://rx-util.rxliuli.com/) 中。\r\n","createdTime":1580652937879,"updatedTime":1583924686887,"resources":[],"tags":[{"id":"1de1ff51140a44d5a2c223459dabcc37","title":"异步","parent_id":""},{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"8b71b18494ab45b29106740fe5c9c836","title":"js 处理 url 数组参数","body":"## 场景\r\n\r\n使用 `axios.get` 时遇到的问题，axios 在 get 请求时会将参数转换为 url 上，这本是正常的逻辑，然而 Spring MVC 却无法接收，会抛出错误。\r\n\r\n使用 Axios 发送的请求代码\r\n\r\n```js\r\naxios.get('/api/index/array', {\r\n  params: {\r\n    list: ['1', '2', '3'],\r\n  },\r\n})\r\n```\r\n\r\nSpring MVC 接口代码\r\n\r\n```java\r\n@RestController\r\n@RequestMapping(\"/api/index\")\r\npublic class IndexTestController {\r\n    @GetMapping(\"/array\")\r\n    public IndexVo array(IndexVo indexVo) {\r\n        return indexVo;\r\n    }\r\n\r\n    public static class IndexVo {\r\n        private List<String> list;\r\n\r\n        public List<String> getList() {\r\n            return list;\r\n        }\r\n\r\n        public IndexVo setList(List<String> list) {\r\n            this.list = list;\r\n            return this;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n> 此处为了简单演示使用了内部类\r\n\r\n请求如下\r\n\r\n```http\r\nGET /api/index/array?list[]=1&list[]=2&list[]=3 HTTP/1.1\r\nHost: localhost:8080\r\nConnection: keep-alive\r\nPragma: no-cache\r\nCache-Control: no-cache\r\nAccept: application/json, text/plain, */*\r\nDNT: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36\r\nReferer: http://localhost:8080/\r\nAccept-Encoding: gzip, deflate, br\r\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\nCookie: JSESSIONID=F8E42F1AC8B9CD46A0F6678DFEB3E9F3\r\n```\r\n\r\n抛出的错误\r\n\r\n```java\r\njava.lang.IllegalArgumentException: Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986\r\n```\r\n\r\n说是参数中包含 **RFC 7230 and RFC 3986** 未定义的字符，所以说 **RFC 7230 and RFC 3986** 是个什么东西？\r\n\r\n去 Google 上一搜，好吧，果然吾辈不是第一个被坑的人。没想到不是 Spring 的问题，而是新版 Tomcat(7) 的问题。Tomcat 要求 URL 中的字符必须符合 RFC 3986。\r\n即：只能包含英文字符（`a-zA-Z`），数字（`0-9`），特殊字符（`-_.~`），保留字符（`!*'();:@&=+$,/?#[]`）。\r\n\r\n然后，作为一个 URI 的数据与作为保留字符的分隔符发生冲突了，自然是要使用 % 进行编码的。\r\n\r\n## 解决\r\n\r\n既然 Axios 本身的 get 函数中对参数进行编码有问题，那么吾辈就自己手动将 params 转换到 URL 上好了。\r\n本以为是个很简单的功能，所以最初吾辈直接使用了 [rx-util](https://github.com/rxliuli/rx-util) 中之前写的 [spliceParams](https://rx-util.rxliuli.com/function/index.html#static-function-spliceParams) 函数\r\n\r\n```js\r\n// @ts-check\r\n/**\r\n * 拼接参数字符串\r\n * @param {Object} params 参数对象\r\n * @returns {String} 拼接后的字符串\r\n */\r\nexport function spliceParams(params) {\r\n  if (!params) {\r\n    throw new Error(`参数对象不能为空：${params}`)\r\n  }\r\n  var res = ''\r\n  for (const k in params) {\r\n    if (params.hasOwnProperty(k)) {\r\n      const v = params[k]\r\n      res += `${encodeURIComponent(k)}=${encodeURIComponent(v)}&`\r\n    }\r\n  }\r\n  return res\r\n}\r\n```\r\n\r\n然而之前没有处理的边界情况 Array 和 Date 却出现了问题，修改如下\r\n\r\n> 注: 此处的 [dateFormat](https://rx-util.rxliuli.com/function/index.html#static-function-dateFormat) 亦来自于 [rx-util](https://github.com/rxliuli/rx-util)\r\n\r\n```js\r\n// @ts-check\r\nimport { dateFormat } from './../date/dateFormat'\r\n\r\nconst deteFormatter = 'yyyy-MM-ddThh:mm:ss.SSSZ'\r\nconst encode = (k, v) => encodeURIComponent(k) + '=' + encodeURIComponent(v)\r\n\r\n/**\r\n * 拼接参数字符串\r\n * @param {Object} params 参数对象\r\n * @returns {String} 拼接后的字符串\r\n */\r\nexport function spliceParams(params = {}) {\r\n  if (!(params instanceof Object)) {\r\n    throw new Error(`The parameter type must be Object: ${params}`)\r\n  }\r\n  return Array.from(Object.entries(params)).reduce((res, [k, v]) => {\r\n    if (v === undefined || v === null) {\r\n      return res\r\n    } else if (v instanceof Date) {\r\n      res += encode(k, dateFormat(v, deteFormatter))\r\n    } else if (v instanceof Array) {\r\n      res += v\r\n        .map(item =>\r\n          encode(\r\n            k,\r\n            item instanceof Date ? dateFormat(item, deteFormatter) : item,\r\n          ),\r\n        )\r\n        .join('&')\r\n    } else {\r\n      res += encode(k, v)\r\n    }\r\n    return (res += '&')\r\n  }, '')\r\n}\r\n```\r\n\r\n现在，spliceParams 可以正常使用了，对空值，Date 与 Array 都是友好的了！\r\n\r\n使用的话，直接在将 axios 包装一下即可，类似于下面这样\r\n\r\n```js\r\nconst rxAjax = (axios => {\r\n  return {\r\n    ...axios,\r\n    get(url, params, config) {\r\n      return axios.get(`${url}?${rx.spliceParams(params)}`, config)\r\n    },\r\n  }\r\n})(axios.create())\r\n```\r\n\r\n现在，再次发送请求，参数会被正确的处理\r\n\r\n```js\r\naxios.get('/api/index/array', {\r\n  params: {\r\n    list: ['1', '2', '3'],\r\n  },\r\n})\r\n```\r\n\r\n请求如下\r\n\r\n```http\r\nGET /api/index/array?list=1&list=2&list=3& HTTP/1.1\r\nHost: localhost:8080\r\nConnection: keep-alive\r\nPragma: no-cache\r\nCache-Control: no-cache\r\nAccept: application/json, text/plain, */*\r\nDNT: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36\r\nReferer: http://localhost:8080/\r\nAccept-Encoding: gzip, deflate, br\r\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\r\nCookie: JSESSIONID=F8E42F1AC8B9CD46A0F6678DFEB3E9F3\r\n```\r\n\r\n或许，吾辈应该向 axios 提出这个 bug？\r\n","createdTime":1580652937890,"updatedTime":1583924674472,"resources":[],"tags":[{"id":"e3845091762c40f7beb3397e67cca83e","title":"java","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"7b32334453624c398f4ebf0cadff4293","title":"jsdoc 注释标签一览","body":"## 速览表格\r\n\r\n### 标签列表\r\n\r\n| 标签       | 简介       |\r\n| ---------- | ---------- |\r\n| `param`    | 参数       |\r\n| `returns`  | 返回值     |\r\n| `example`  | 示例       |\r\n| `test`     | 测试代码   |\r\n| `class`    | 类定义     |\r\n| `property` | 类属性定义 |\r\n\r\n### 语法列表\r\n\r\n| 语法            | 简介     |\r\n| --------------- | -------- |\r\n| `{T}`           | 类型     |\r\n| `{T,R}`         | 多个类型 |\r\n| `[]`            | 可选值   |\r\n| `[arg=v]`       | 默认值   |\r\n| `.<T>`          | 泛型     |\r\n| `obj.property`  | 对象参数 |\r\n| `function(T):R` | 函数参数 |\r\n\r\n## 标签\r\n\r\n### `param`\r\n\r\n```js\r\n/**\r\n * 在控制台上打印一个值\r\n * @param obj 需要被打印的值\r\n */\r\nfunction print(obj) {\r\n  console.log(obj)\r\n}\r\n```\r\n\r\n### `returns`\r\n\r\n```js\r\n/**\r\n * 获取一个 0-1 之间的随机数\r\n * @returns 随机数\r\n */\r\nfunction random() {\r\n  return Math.random()\r\n}\r\n```\r\n\r\n### `example`\r\n\r\n```js\r\n/**\r\n * 获取一个 0-1 之间的随机数\r\n * @returns 随机数\r\n * @example\r\n * const i = random()\r\n * console.log(i)\r\n */\r\nfunction random() {\r\n  return Math.random()\r\n}\r\n```\r\n\r\n### `test`\r\n\r\n```js\r\n/**\r\n * @test {random} 测试 random 函数\r\n */\r\ndescribe('测试 random 函数', () => {\r\n  it('测试两次随机数是否相等', () => {\r\n    const i = random()\r\n    const k = random()\r\n    expect(i).not.toBe(k)\r\n  })\r\n})\r\n```\r\n\r\n### `class`\r\n\r\n```js\r\n/**\r\n * 简单模拟 Vue class\r\n * @class Vue\r\n */\r\nclass Vue {}\r\n```\r\n\r\n### `property`\r\n\r\n```js\r\n/**\r\n * 简单模拟 Vue class\r\n * @class Vue\r\n * @property {String|Element} option.el 实例绑定的 DOM 选择器或元素\r\n * @property {Object|Function} [option.data={}] 实例内部绑定的数据，默认为空对象\r\n * @property {Object} [option.methods={}] 实例的方法对象，默认为空对象\r\n * @property {Function} [option.mounted=function() {}] 实例的初始化函数，默认为空函数\r\n */\r\nclass Vue {\r\n  /**\r\n   * 构造函数\r\n   * @param {Object} option 可选项\r\n   * @param {String|Element} option.el 实例绑定的 DOM 选择器或元素\r\n   * @param {Object|Function} [option.data={}] 实例内部绑定的数据，默认为空对象\r\n   * @param {Object} [option.methods={}] 实例的方法对象，默认为空对象\r\n   * @param {Function} [option.mounted=function() {}] 实例的初始化函数，默认为空函数\r\n   */\r\n  constructor({ el, data = {}, methods = {}, mounted = function() {} } = {}) {\r\n    this.el = el\r\n    this.data = data\r\n    this.methods = methods\r\n    this.mounted = mounted\r\n  }\r\n}\r\n```\r\n\r\n## 语法\r\n\r\n### `{}`\r\n\r\n```js\r\n/**\r\n * 计算两个数字之和\r\n * @param {Number} i 第一个数字\r\n * @param {Number} k 第二个数字\r\n * @returns {Number} 两数之和\r\n */\r\nfunction add(i, k) {\r\n  return i + k\r\n}\r\n```\r\n\r\n### `{T,R}`\r\n\r\n```js\r\n/**\r\n * 计算两个数字之和，或者两个字符串之间的连接\r\n * @param {Number|String} i 第一个数字\r\n * @param {Number|String} k 第二个数字\r\n * @returns {Number|String} 两数之和，或者两个字符串之间的连接\r\n */\r\nfunction add(i, k) {\r\n  return i + k\r\n}\r\n```\r\n\r\n### `[]`\r\n\r\n使用场景: 可选参数不需要在函数中所有条件下使用\r\n\r\n例如下面的 `sep` 在不传入时会默认返回 `[str]`，一般优先使用 `[arg=v]` 更好\r\n\r\n```js\r\n/**\r\n * 分割字符串为数组\r\n * @param {String} str 字符串\r\n * @param {String} [sep] 分隔符\r\n * @returns {Array} 分割后的数组\r\n */\r\nfunction split(str, sep) {\r\n  return sep ? str.split(sep) : [str]\r\n}\r\n```\r\n\r\n### `[arg=v]`\r\n\r\n使用场景: 需要为传入的参数赋予默认值\r\n\r\n> 注: 太过冗长的默认值最好使用文件描述而非加到 `[]` 中\r\n\r\n例如下面的函数参数 `sep`，如果想要在不传入的时候默认为 `''`，就需要使用默认值标记。\r\n\r\n```js\r\n/**\r\n * 分割字符串为数组\r\n * @param {String} str 字符串\r\n * @param {String} [sep=''] 分隔符\r\n * @returns {Array} 分割后的数组\r\n */\r\nfunction split(str, sep = '') {\r\n  return str.split(sep)\r\n}\r\n```\r\n\r\n### `.<T>`\r\n\r\n使用场景: `Array, Map, Set, Iterator` 这中集合接口/类限定元素类型，也有 `Promise` 这种内嵌其他类型异步结果的情况\r\n\r\n例如下面的集合就声明元素全部都需要为 `String`，`Object` 的话可能出现 `[object Object]` 这种内容\r\n\r\n```js\r\n/**\r\n * 将 String 类型的数组中的元素都连接起来，并以逗号进行分割\r\n * @param {Array.<String>} arr 字符串数组\r\n * @returns {String} 连接后的字符串\r\n */\r\nfunction join(arr) {\r\n  return arr.join(',')\r\n}\r\n```\r\n\r\n### `obj.property`\r\n\r\n```js\r\n/**\r\n * 简单模拟 Vue API\r\n * @param {Object} option 可选项\r\n * @param {String|Element} option.el 实例绑定的 DOM 选择器或元素\r\n * @param {Object|Function} [option.data={}] 实例内部绑定的数据，默认为空对象\r\n * @param {Object} [option.methods={}] 实例的方法对象，默认为空对象\r\n * @param {Function} [option.mounted=function() {}] 实例的初始化函数，默认为空函数\r\n */\r\nfunction Vue({ el, data = {}, methods = {}, mounted = function() {} } = {}) {\r\n  this.el = el\r\n  this.data = data\r\n  this.methods = methods\r\n  this.mounted = mounted\r\n}\r\n```\r\n\r\n### `function(T):R`\r\n\r\n```js\r\n/**\r\n * 自行实现 flatMap，将数组压平一层\r\n * @param {Array.<Object>} arr 数组\r\n * @param {function(Object):Array} fn 映射方法，将一个元素映射为一个数组\r\n * @returns {Array.<Object>} 压平一层的数组\r\n */\r\nexport function flatMap(arr, fn) {\r\n  return arr.reduce((res, item) => res.concat(fn(item)), [])\r\n}\r\n```\r\n\r\n<!--\r\n## 问题\r\n\r\n### 如何处理对象参数\r\n\r\n### 如何处理函数参数\r\n\r\n### 如何处理自定义类型参数\r\n\r\n### 如何定义类型保证参数及返回值泛型相同\r\n\r\n### 如何标记测试代码\r\n-->\r\n","createdTime":1580652937891,"updatedTime":1583924661221,"resources":[],"tags":[{"id":"a730b7d5d2d24346ad36118f1140c314","title":"工程化","parent_id":""},{"id":"be26be73696b4bb6820918bc99b770be","title":"javascript","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]},{"id":"4188208ce629450bb864606028f72980","title":"FlexBox 布局入门","body":"## 场景\r\n\r\n最近刚看了 flexbox，之前一直用的 UI 框架写前端，吾辈可能是个假的前端开发（好吧，其实之前吾辈前后端都写，写得最多的是 JS/TS 就是了），所以写一篇记录便于复习知识。\r\n\r\n## 简介\r\n\r\n不谈需求讲功能就是扯淡，所以吾辈先来说一下吾辈使用 `flex` 的主要场景吧\r\n\r\n- 水平布局: 导航栏，多栏展示，媒体元素\r\n- 水平垂直居中: 这在 flex 之前使用 CSS 很难实现\r\n- 避免使用浮动，行内块元素，表格进行布局\r\n\r\n## 使用\r\n\r\n### 水平布局\r\n\r\n使用 `flex` 可以轻而易举地实现栅格系统，这里的最下面还实现了一个常见的侧边菜单两栏布局。\r\n\r\n![栅格系统](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190916121534.png)\r\n\r\n实现代码\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\r\n    <title>flex 水平布局</title>\r\n    <style>\r\n      * {\r\n        margin: 0;\r\n        padding: 0;\r\n        box-sizing: border-box;\r\n      }\r\n\r\n      /* #region 12 栅格布局 */\r\n\r\n      .row {\r\n        display: flex;\r\n      }\r\n      .col {\r\n        flex: 1;\r\n      }\r\n      .col-1 {\r\n        flex: 1;\r\n      }\r\n      .col-2 {\r\n        flex: 2;\r\n      }\r\n      .col-3 {\r\n        flex: 3;\r\n      }\r\n      .col-4 {\r\n        flex: 4;\r\n      }\r\n      .col-5 {\r\n        flex: 5;\r\n      }\r\n      .col-6 {\r\n        flex: 6;\r\n      }\r\n      .col-7 {\r\n        flex: 7;\r\n      }\r\n      .col-8 {\r\n        flex: 8;\r\n      }\r\n      .col-9 {\r\n        flex: 9;\r\n      }\r\n      .col-10 {\r\n        flex: 10;\r\n      }\r\n      .col-11 {\r\n        flex: 11;\r\n      }\r\n      .col-12 {\r\n        flex: 12;\r\n      }\r\n\r\n      /* #endregion */\r\n\r\n      .col {\r\n        min-width: 50px;\r\n        background-color: #00ffff;\r\n        border: solid 2px #ffffff;\r\n        text-align: center;\r\n      }\r\n\r\n      .side-menu {\r\n        max-width: 250px;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div class=\"row\">\r\n      <div class=\"col col-1\">col-1</div>\r\n      <div class=\"col col-1\">col-1</div>\r\n      <div class=\"col col-1\">col-1</div>\r\n      <div class=\"col col-1\">col-1</div>\r\n      <div class=\"col col-1\">col-1</div>\r\n      <div class=\"col col-1\">col-1</div>\r\n      <div class=\"col col-1\">col-1</div>\r\n      <div class=\"col col-1\">col-1</div>\r\n      <div class=\"col col-1\">col-1</div>\r\n      <div class=\"col col-1\">col-1</div>\r\n      <div class=\"col col-1\">col-1</div>\r\n      <div class=\"col col-1\">col-1</div>\r\n    </div>\r\n    <div class=\"row\">\r\n      <div class=\"col col-2\">col-2</div>\r\n      <div class=\"col col-2\">col-2</div>\r\n      <div class=\"col col-2\">col-2</div>\r\n      <div class=\"col col-2\">col-2</div>\r\n      <div class=\"col col-2\">col-2</div>\r\n      <div class=\"col col-2\">col-2</div>\r\n    </div>\r\n    <div class=\"row\">\r\n      <div class=\"col col-3\">col-3</div>\r\n      <div class=\"col col-3\">col-3</div>\r\n      <div class=\"col col-3\">col-3</div>\r\n      <div class=\"col col-3\">col-3</div>\r\n    </div>\r\n    <div class=\"row\">\r\n      <div class=\"col col-4\">col-4</div>\r\n      <div class=\"col col-4\">col-4</div>\r\n      <div class=\"col col-4\">col-4</div>\r\n    </div>\r\n    <div class=\"row\">\r\n      <div class=\"col col-6\">col-6</div>\r\n      <div class=\"col col-6\">col-6</div>\r\n    </div>\r\n    <div class=\"row\">\r\n      <div class=\"col col-12\">col-12</div>\r\n    </div>\r\n    <div class=\"row\">\r\n      <!-- 侧边菜单栏 -->\r\n      <div class=\"col col-3 side-menu\">col-3</div>\r\n      <div class=\"col col-9\">col-9</div>\r\n    </div>\r\n  </body>\r\n</html>\r\n```\r\n\r\n## 水平垂直居中\r\n\r\n在此 flex 出现之前，想要盒子水平垂直居中是一件比较困难的一件事，但至此之后，便再也不足为道了。\r\n\r\n![水平垂直居中](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190916121734.png)\r\n\r\n实现代码\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <title>使用 flex 实现水平垂直居中</title>\r\n    <style>\r\n      html,\r\n      body,\r\n      .flex-container {\r\n        height: 100%;\r\n      }\r\n\r\n      .flex-container {\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n        background-color: #2c3e50;\r\n      }\r\n\r\n      .flex-item {\r\n        width: 40rem;\r\n\r\n        background-color: #ffffff;\r\n        padding: 2rem;\r\n        box-shadow: 0 0 0.5rem #ffffff;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div class=\"flex-container\">\r\n      <div class=\"flex-item\">\r\n        <h2>内境逾宽、外延逾窄</h2>\r\n        <p>\r\n          我和麻省理工学院的一些博士生谈论过各种浏览器的好坏，他们不和你谈微软的\r\n          IE 或者 Mozilla 的火狐，而是 Unix 用户更常用的字处理器 Emacs\r\n          下一个很小的浏览网页的功能，这个东西不仅不好用，而且在全世界用它的网民连万分之一都不到。他们和你谈的是里面技术上谁实现的好。这些人以后可以是很好的科学家和工程师，但是很难创业。\r\n        </p>\r\n      </div>\r\n    </div>\r\n  </body>\r\n</html>\r\n```\r\n\r\n## 对比浮动、行内盒子、表格布局\r\n\r\n- 浮动布局: 浏览器很早就实现的一种布局方式，但浮动之后的元素脱离了标准文档流，必须特别注意清除浮动。并且，浮动也无法提供足够的布局能力，常常需要一些 hack 技巧。最后，浮动布局本身也不是为了布局而设计，浮动最适合的场景莫过于实现媒体元素的文字环绕。\r\n- 行内盒子: 基本没有提供布局能力\r\n- 表格布局: 实现的非常早的二维布局方式，在 Web 早期很多网站喜欢使用它进行布局，正是因为它的二维布局可以简单实现一些常规布局。但终究它的布局能力还是不足的，CSS3 中实现了更好的 `Grid Layout` 作为二维布局方式。\r\n- `Grid Layout`: 理论上来说，能够进行二维布局的 Grid 肯定比只能一维布局的 Flex 更适合整体布局，但现实因素往往使之并不能理想化。就目前而言，Grid 的实现并不完整，当然，最新版的 Chrome/Firefox 肯定是可以的了，但 Safari/Edge 肯定还是有坑的！\r\n\r\n下面实现一个标签列表，以此便可以看出 Flex 的强大功用\r\n\r\n![标签列表](https://cdn.jsdelivr.net/gh/rxliuli/img-bed/20190916122712.png)\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <title>使用 flex 实现标签组</title>\r\n    <style>\r\n      .tags {\r\n        border: 1px solid #c9e1f4;\r\n        padding: 1rem;\r\n        display: flex;\r\n        flex-wrap: wrap;\r\n        /*min-height: 500px;*/\r\n        /*align-content: space-around;*/\r\n      }\r\n\r\n      .tags li {\r\n        display: inline-block;\r\n        margin: 0.5rem;\r\n        flex: 1 0 auto;\r\n        max-width: 10rem;\r\n      }\r\n\r\n      .tags li a {\r\n        position: relative;\r\n        display: block;\r\n        padding: 0.25rem 0.5rem 0.25rem 0.5rem;\r\n        background-color: #c9e1f4;\r\n        color: #28448f;\r\n        border-radius: 0 0.25rem 0.25rem 0;\r\n        line-height: 1.5;\r\n        text-decoration: none;\r\n        text-align: center;\r\n      }\r\n\r\n      .tags li a::before {\r\n        content: ' ';\r\n        position: absolute;\r\n        width: 0;\r\n        height: 0;\r\n        border: 1rem solid transparent;\r\n        border-right-width: 0.5rem;\r\n        border-right-color: #c9e1f4;\r\n        left: -1.5rem;\r\n        top: 0;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <ul class=\"tags\">\r\n      <li><a href=\"#\">Android</a></li>\r\n      <li><a href=\"#\">Chrome</a></li>\r\n      <li><a href=\"#\">Cmder</a></li>\r\n      <li><a href=\"#\">DB</a></li>\r\n      <li><a href=\"#\">FTP</a></li>\r\n      <li><a href=\"#\">FreeNetwork</a></li>\r\n      <li><a href=\"#\">Git</a></li>\r\n      <li><a href=\"#\">Gradle</a></li>\r\n      <li><a href=\"#\">Greasemonkey</a></li>\r\n      <li><a href=\"#\">HTML</a></li>\r\n      <li><a href=\"#\">IDEA</a></li>\r\n      <li><a href=\"#\">Java</a></li>\r\n      <li><a href=\"#\">JavaScript</a></li>\r\n      <li><a href=\"#\">Linux</a></li>\r\n      <li><a href=\"#\">Markdown</a></li>\r\n      <li><a href=\"#\">Maven</a></li>\r\n      <li><a href=\"#\">MongoDB</a></li>\r\n      <li><a href=\"#\">MonngoDB</a></li>\r\n      <li><a href=\"#\">MySQL</a></li>\r\n      <li><a href=\"#\">Mybatis</a></li>\r\n      <li><a href=\"#\">NodeJS</a></li>\r\n      <li><a href=\"#\">Prettier</a></li>\r\n      <li><a href=\"#\">Promise</a></li>\r\n      <li><a href=\"#\">React</a></li>\r\n      <li><a href=\"#\">Spring</a></li>\r\n      <li><a href=\"#\">Tool</a></li>\r\n      <li><a href=\"#\">TypeScript</a></li>\r\n      <li><a href=\"#\">VSCode</a></li>\r\n      <li><a href=\"#\">VueJS</a></li>\r\n      <li><a href=\"#\">Vuetify</a></li>\r\n      <li><a href=\"#\">Web</a></li>\r\n      <li><a href=\"#\">Windows</a></li>\r\n      <li><a href=\"#\">blog</a></li>\r\n      <li><a href=\"#\">jsdoc</a></li>\r\n      <li><a href=\"#\">mobile</a></li>\r\n      <li><a href=\"#\">npm</a></li>\r\n      <li><a href=\"#\">yarn</a></li>\r\n      <li><a href=\"#\">工具</a></li>\r\n      <li><a href=\"#\">教程</a></li>\r\n      <li><a href=\"#\">文章</a></li>\r\n      <li><a href=\"#\">杂谈</a></li>\r\n      <li><a href=\"#\">记录</a></li>\r\n      <li><a href=\"#\">读书</a></li>\r\n      <li><a href=\"#\">随笔</a></li>\r\n    </ul>\r\n  </body>\r\n</html>\r\n```\r\n","createdTime":1580652937888,"updatedTime":1583899123635,"resources":[],"tags":[{"id":"8f339224ff5c4b5aa4103e407b04ed0e","title":"css","parent_id":""},{"id":"e74aed9d3b2d4471b9f34abbc381dce0","title":"blog","parent_id":""}]}],"resource":[{"id":"94972af176de4e67ab763bdc7862aa26","title":"1634797302936","file_extension":"png","user_updated_time":1634797303360},{"id":"9ba85a775b4e4bfea70f3da8def2f8e5","title":"JavaScript 沙箱示意图.drawio.svg","file_extension":"svg","user_updated_time":1634657477395},{"id":"f4568d723eb942838d7a068d46f721a1","title":"基于 quickjs 实现 setTimeout 与 clearTimeout.drawio.svg","file_extension":"svg","user_updated_time":1635069054595},{"id":"ff279700bc3646e68b53ba833dce9a5f","title":"沙箱与系统之间的通信.drawio.svg","file_extension":"svg","user_updated_time":1635075679794},{"id":"35276870c5974ef78bf55004376104af","title":"1613708879214","file_extension":"png","user_updated_time":1613708880316},{"id":"50811848a3f34cd1ad44173be01b88c6","title":"1614431308200","file_extension":"png","user_updated_time":1614431308609},{"id":"90ab8d5fa24a4612a40d73807bec8cb1","title":"1614431297462","file_extension":"png","user_updated_time":1614431297884},{"id":"92e8be89f8a14afd9cce7f0649477f0d","title":"1627228955245","file_extension":"png","user_updated_time":1627228955580},{"id":"9903efe2e94d4063a381c2683f28d066","title":"1627228947517","file_extension":"png","user_updated_time":1627228947865},{"id":"ac037581e08947959ef7db5bb593f4ba","title":"1615473034848","file_extension":"png","user_updated_time":1615473035685},{"id":"dfd78dc3e0ef4bb0a5068d3895f1802e","title":"1627228922113","file_extension":"png","user_updated_time":1627228922664},{"id":"ea2e178e791b47209a58598acdc11995","title":"1633086403949","file_extension":"png","user_updated_time":1633086404978},{"id":"d073b1ca7427427991328887419f5b57","title":"选择支.drawio.svg","file_extension":"svg","user_updated_time":1622200012004},{"id":"080d96fdedc54c358cf6f1f73e75d8de","title":"配置Proxifer","file_extension":"gif","user_updated_time":1632817963715},{"id":"30d25e553fed4f06b250d4670b32d04f","title":"1623386196951","file_extension":"png","user_updated_time":1623386197488},{"id":"4b6cacb250374c37a3ba48f202c26de0","title":"1623122443753","file_extension":"png","user_updated_time":1623122444074},{"id":"d9df37c041034ad3b3feaaf32a8cd67e","title":"1623122585291","file_extension":"png","user_updated_time":1623122585607},{"id":"e596b55573c0428584f92759c9df7ac6","title":"演示配置SSR","file_extension":"gif","user_updated_time":1632817954827},{"id":"f80aec5f992142258ea21003e4b36729","title":"1623122471651","file_extension":"png","user_updated_time":1623122471933},{"id":"2bceea193e1945aeac57b5342eed3fcc","title":"1619968206663","file_extension":"png","user_updated_time":1619968207509},{"id":"468e71461fca48fa9ae306f2da89fc48","title":"1615086542056","file_extension":"png","user_updated_time":1615086542734},{"id":"49e8605f93954313a6f95621d977785b","title":"1632817508056","file_extension":"png","user_updated_time":1632817508858},{"id":"837c6b07d00449dc9f61b083087b516d","title":"1623482286209","file_extension":"png","user_updated_time":1623482286851},{"id":"96fd64b1eae1494698b5aa092574b1e2","title":"1619968548104","file_extension":"png","user_updated_time":1619968548762},{"id":"b3561ab309a6462386c726372f30aeb2","title":"1619969180589","file_extension":"png","user_updated_time":1619969181269},{"id":"4d3552ea84da470f94be5a4265cb37b4","title":"1624672304685","file_extension":"png","user_updated_time":1624672305235},{"id":"e6d42dad38404bb98f6b44003be4d0b6","title":"1624672317484","file_extension":"png","user_updated_time":1624672317776},{"id":"1ef24ee24f444202955ab68dd94c6b1b","title":"1616313126720","file_extension":"png","user_updated_time":1616313127164},{"id":"1481553a70764d679f18841199b9db09","title":"1614158368615","file_extension":"png","user_updated_time":1614158369019},{"id":"de927ddb9b34400fb8ac6d4e675e1b87","title":"1628152139838","file_extension":"png","user_updated_time":1629616830871},{"id":"3114e38d083649efa048f3e5bedf5b59","title":"Snipaste_2020-12-09_22-43-38.png","file_extension":"png","user_updated_time":1607525028126},{"id":"443aea600d2d4b568c26974c4dd57b38","title":"1629475763454","file_extension":"png","user_updated_time":1629475763758},{"id":"553ed7795e714516b8be9be83eab5e6b","title":"针对任意数量的元素水平布局.html","file_extension":"html","user_updated_time":1630307695206},{"id":"66bd831ec3b048ae99926dddc5543d59","title":"1630307731953","file_extension":"png","user_updated_time":1630307732264},{"id":"6d92a3ad621a4f29b3436107764a2fdb","title":"Snipaste_2020-12-09_22-33-08.png","file_extension":"png","user_updated_time":1607524422895},{"id":"822f302b44d74f40a77f5d50bfd19238","title":"Snipaste_2020-12-09_22-12-56.png","file_extension":"png","user_updated_time":1607523300079},{"id":"88680a1d45be472896d73286759e6e3c","title":"Snipaste_2020-12-09_22-24-47.png","file_extension":"png","user_updated_time":1607523965816},{"id":"9a639cd730ad4ecfb13144d183b9ac11","title":"中后台基本布局.html","file_extension":"html","user_updated_time":1607524664280},{"id":"a591f0eb17604196976eebb3e005941c","title":"根据内容自适应贴靠在一边.html","file_extension":"html","user_updated_time":1607523540898},{"id":"b09e5e0cb82e4b95b1710a95124333e9","title":"1629475754345","file_extension":"png","user_updated_time":1629475754703},{"id":"b64b37dd36d8485c8242380d56bd8371","title":"模拟 flex margin-left 或 margin-right.html","file_extension":"html","user_updated_time":1607523394148},{"id":"ed16a3151010453897c2e38a714fe48e","title":"纵向布局.html","file_extension":"html","user_updated_time":1607522468834},{"id":"d61642e05753427d98ad17a468eea52e","title":"布局.drawio.svg","file_extension":"svg","user_updated_time":1606870024033},{"id":"4fc5f8a2c4ff4cfd9257233cc4a8c5ae","title":"状态管理选择树.drawio.svg","file_extension":"svg","user_updated_time":1627979098805},{"id":"86cc0f02cb594abebe57ba79c8d46f72","title":"navigation","file_extension":"gif","user_updated_time":1627229187775},{"id":"990fd29f95134939a6f4bcf1670d20f4","title":"searchAndReplace","file_extension":"gif","user_updated_time":1627229196610},{"id":"e4b7c0ed2d1b445b8309839cd041cf36","title":"prompt","file_extension":"gif","user_updated_time":1627229173390},{"id":"6996b9a2e3f54a919287c7ea7d0027f7","title":"1613744562293","file_extension":"png","user_updated_time":1613744563057},{"id":"1e8dc3a95f054ef3b404bdc39f95e099","title":"1614382963380","file_extension":"png","user_updated_time":1614382963952},{"id":"3654c8048cb14577a2097aa0294fe4f3","title":"1614383397001","file_extension":"png","user_updated_time":1614383397589},{"id":"40a90f19f74143d3a676e7afdec3c658","title":"1614431686700","file_extension":"png","user_updated_time":1614431687126},{"id":"86bcfe6872864bd282703cbb5522ff27","title":"1614383048466","file_extension":"png","user_updated_time":1614383049180},{"id":"a5cc319a00a144349c494b91edb92079","title":"1614383172095","file_extension":"png","user_updated_time":1614383172671},{"id":"6a3af88df8204b888564bfce8d1d9e5c","title":"treeFilter 流程图.drawio.svg","file_extension":"svg","user_updated_time":1616321918963},{"id":"1a7d05ea9c1e4978bcc540c2eb8cca6f","title":"1624018106300","file_extension":"png","user_updated_time":1624018106637},{"id":"1fb8606dac2c487eafca45ecc4e3a9a3","title":"兼容 nodejs 与浏览器的库的技术方案选择.drawio.svg","file_extension":"svg","user_updated_time":1624077829787},{"id":"2085a6a480124ea8b0fdddf4877f75c7","title":"1622828175546","file_extension":"png","user_updated_time":1622828176962},{"id":"a5134edf1c7b4742aed1a0914faa45ad","title":"1624018026889","file_extension":"png","user_updated_time":1624018027494},{"id":"0dd48273156a4cf18ceb7753a004f3b7","title":"使用 drawio 绘制流程图","file_extension":"gif","user_updated_time":1620884740191},{"id":"5ae6c3b90e464d75975cb492a123d98b","title":"1622643314587","file_extension":"png","user_updated_time":1622643315112},{"id":"64440cbe1f2943e2ab20067b09150b0f","title":"1622214639959","file_extension":"png","user_updated_time":1622214640449},{"id":"b4963c306548404b867137d261c19e36","title":"1622211928274","file_extension":"png","user_updated_time":1622211929301},{"id":"b6e75d38e1974b06b1d95a70e6417a30","title":"使用百度脑图绘制思维导图","file_extension":"gif","user_updated_time":1620884935872},{"id":"fa1667ac96664ab195e487221b3244eb","title":"Electron 开发概略.km.svg","file_extension":"svg","user_updated_time":1616321708956},{"id":"a744f749ef6f4652aa82f5dbcb1e22d8","title":"设计图.drawio.svg","file_extension":"svg","user_updated_time":1616321773385},{"id":"3b4cc0d9ba694947bed9aa224cfc5c04","title":"1617220590795","file_extension":"png","user_updated_time":1617220591300},{"id":"02e2a8b1563c494e8799cc6d753ceac2","title":"1617008270263","file_extension":"png","user_updated_time":1617008271063},{"id":"15109e9b841d4a7e862f230907335460","title":"1617008710523","file_extension":"png","user_updated_time":1617008711183},{"id":"234d2e51d52d4547add5852e58769b9f","title":"1617010120241","file_extension":"png","user_updated_time":1617010120920},{"id":"4052bf77bb3e40d88c358d10d759431b","title":"1617003644844","file_extension":"png","user_updated_time":1617003645593},{"id":"498d35a6b71f47fc86fc9fdc6e5d8fd8","title":"1617008523235","file_extension":"png","user_updated_time":1617008523800},{"id":"4b8b5e37ff5b452dba33ffc68d781b3c","title":"1617010201279","file_extension":"png","user_updated_time":1617010202008},{"id":"4d86955cfa7746d79e8cbfe69f30a567","title":"1617010332150","file_extension":"png","user_updated_time":1617010332854},{"id":"4eec707c2eb9407785aa7be74cc85538","title":"1617010044579","file_extension":"png","user_updated_time":1617010045228},{"id":"5e3bf3cc18124c0f963b3fbcaef52d0d","title":"1617010003098","file_extension":"png","user_updated_time":1617010003826},{"id":"86a75805195648188a93c3a69c42c94d","title":"audio_2021-03-29_15-39-24.ogg","file_extension":"ogg","user_updated_time":1617003663525},{"id":"8c25384a4b8d467e8228581a01dfd8ec","title":"1617010153382","file_extension":"png","user_updated_time":1617010154014},{"id":"8f2d8b72748a4d6cbd6ca2002f97b662","title":"1617010072110","file_extension":"png","user_updated_time":1617010072797},{"id":"a99dac276deb4d68ac8bcd2c181215f8","title":"1617010109606","file_extension":"png","user_updated_time":1617010110200},{"id":"be00fdc1e1434359a23b631e7aba3f0a","title":"1617003181100","file_extension":"png","user_updated_time":1617003183038},{"id":"ce0f530357dd4ca3b4a6a3cf06476284","title":"1617010212626","file_extension":"png","user_updated_time":1617010213488},{"id":"f71d62e8084f4288958ece97635aaabd","title":"audio_2021-03-29_15-39-51.ogg","file_extension":"ogg","user_updated_time":1617003686771},{"id":"46116b80afd84b45a11b57ac67e1550e","title":"test (1).gif","file_extension":"gif","user_updated_time":1610339693958},{"id":"8445c03f200d46229abaab35ef6c4ea7","title":"20210111125550.png","file_extension":"png","user_updated_time":1610340951269},{"id":"8c59e5f2be54498cb7953eed337338b5","title":"1615709481022","file_extension":"png","user_updated_time":1615709481629},{"id":"1d7c7c27c4b34f59964dcb5bf964919e","title":"1613873355258","file_extension":"png","user_updated_time":1613873355645},{"id":"a0af65b841d3440b95043d3254928518","title":"1613873317326","file_extension":"png","user_updated_time":1613873317726},{"id":"866c4124afe04289b88972507b3f6743","title":"20210112130522.png","file_extension":"png","user_updated_time":1610427922838},{"id":"9aa685b675a14bf788093f2656ffc4e8","title":"20210106194304.png","file_extension":"png","user_updated_time":1609933384604},{"id":"be9a61a9bb6c466a86f0fe9c1ea499a6","title":"20210106194102.png","file_extension":"png","user_updated_time":1609933263365},{"id":"4bdfd0cdf55c4e098b1f5b3a92fb7947","title":"1610618120779.png","file_extension":"png","user_updated_time":1610618121187},{"id":"d2a07efc8ff24354b49289c2d4210b79","title":"test (2).gif","file_extension":"gif","user_updated_time":1610623410768},{"id":"92f7aa2fcd894107b05056f5c662e051","title":"1611134001681.png","file_extension":"png","user_updated_time":1611134002177},{"id":"6a33797917e34056b95238471ff0c06b","title":"test (3).gif","file_extension":"gif","user_updated_time":1634414451463},{"id":"ab035c3bd9314c17ad6ec4390a6b00b7","title":"1611716016173.png","file_extension":"png","user_updated_time":1634415116032},{"id":"f315fce582304158b1913b4f2c947a84","title":"1611716716541.png","file_extension":"png","user_updated_time":1611716717000}]}
